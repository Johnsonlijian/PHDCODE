{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ef50a237",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:41:43.280019Z",
     "start_time": "2024-02-05T07:41:43.270058Z"
    }
   },
   "source": [
    "# 准备工作"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7c9184d8",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-08-22T15:00:31.092633Z",
     "start_time": "2022-08-22T15:00:31.086648Z"
    }
   },
   "source": [
    "## 基础代码"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7397fff5",
   "metadata": {},
   "source": [
    "### 基础代码GPU工作测试代码，pytorch测试代码"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ca6a4fbe-f9e1-4afe-a92f-5da599378310",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:08.460475Z",
     "start_time": "2024-02-05T07:20:07.520958Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.5.1\n",
      "gpu False\n"
     ]
    }
   ],
   "source": [
    "import torch \n",
    "print(torch.__version__)\n",
    "print(\"gpu\", torch.cuda.is_available())\n",
    "# 显示过程中的所有输出结果（\"last_expr\"改为\"all\"）\n",
    "from IPython.core.interactiveshell import InteractiveShell\n",
    "InteractiveShell.ast_node_interactivity = \"last_expr\"\n",
    "# pd.set_option('display.max_rows', None)\n",
    "# PyTorch Version: 1.12.0\n",
    "# CUDA Available: True\n",
    "# CUDA Version: 11.6\n",
    "# GPU Name: NVIDIA GeForce RTX 3070"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7bc12804",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:10.040222Z",
     "start_time": "2024-02-05T07:20:08.461474Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "错误：未检测到可用GPU，无法执行GPU运算验证\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import time\n",
    "\n",
    "def gpu_operation_demo():\n",
    "    # 1. 检查GPU可用性\n",
    "    if not torch.cuda.is_available():\n",
    "        print(\"错误：未检测到可用GPU，无法执行GPU运算验证\")\n",
    "        return\n",
    "\n",
    "    # 2. 定义设备（优先使用GPU）\n",
    "    device = torch.device(\"cuda:0\")  # 选择第1块GPU（索引从0开始）\n",
    "\n",
    "    # 3. 在GPU上创建张量（确保a和b都在GPU）\n",
    "    a = torch.randn(1000, 2000, device=device)  # 1000x2000随机矩阵（GPU）\n",
    "    b = torch.randn(2000, 3000, device=device)  # 2000x3000随机矩阵（GPU）\n",
    "\n",
    "    # 4. 验证张量设备\n",
    "    print(f\"张量a所在设备：{a.device}\")  # 应输出：cuda:0\n",
    "    print(f\"张量b所在设备：{b.device}\")  # 应输出：cuda:0\n",
    "\n",
    "    # 5. 执行GPU矩阵乘法（初次调用会有初始化开销）\n",
    "    t0 = time.time()\n",
    "    c = torch.matmul(a, b)  # 矩阵乘法（GPU运算）\n",
    "    t1 = time.time()\n",
    "\n",
    "    # 6. 验证结果设备和运算时间\n",
    "    print(f\"运算结果c所在设备：{c.device}\")  # 应输出：cuda:0\n",
    "    print(f\"GPU矩阵乘法耗时：{t1 - t0:.4f}秒\")\n",
    "    print(f\"结果矩阵c的二范数：{c.norm(2):.2f}\")  # 输出数值验证运算完成\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    gpu_operation_demo()\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "449d6aa3",
   "metadata": {},
   "source": [
    "### 库准备-导入各种库"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "baa4ac11",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import pandas as pd\n",
    "from matplotlib.font_manager import FontProperties\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=12)  # 字体设置宋体\n",
    "import matplotlib.pyplot as plt\n",
    "plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "import seaborn as sns"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30d9ee13",
   "metadata": {},
   "source": [
    "## 数据准备"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12493c12",
   "metadata": {},
   "source": [
    "### 分类数据的读取"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "6f4a402b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import os\n",
    "# import pandas as pd\n",
    "\n",
    "# # 指定您要处理的根文件夹路径\n",
    "# root_folder_path = r'R:\\Jupyterdemo'  # 使用原始字符串避免转义字符问题\n",
    "\n",
    "# # 定义用于确定构件的列名\n",
    "# key_columns = ['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
    "#                'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss','F','BoltB','BoltD']\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# # 定义所有需要保留的列名\n",
    "# columns_to_keep = key_columns + ['EigenValue', 'Pcf1f', 'Pcf1ff', 'Pcf2f', 'Pcf2ff', \n",
    "#                                  'Pcf3f', 'Pcf3ff', 'Pucf1f', 'Pucf2f', 'Pucf3f']\n",
    "\n",
    "# # 初始化一个空DataFrame用于存储所有数据\n",
    "# all_data_df = pd.DataFrame(columns=columns_to_keep + ['type', 'file_path'])  # 添加'type'和'file_path'列\n",
    "\n",
    "# # 需要跳过的文件夹名称\n",
    "# skip_folders = {'phdcode', 'AutoModel'}\n",
    "\n",
    "# # 遍历每个文件\n",
    "# for dirpath, dirnames, filenames in os.walk(root_folder_path):\n",
    "#     # 在这里过滤掉不需要遍历的文件夹\n",
    "#     dirnames[:] = [d for d in dirnames if d not in skip_folders]\n",
    "    \n",
    "#     for filename in filenames:\n",
    "#         if filename.endswith('.xlsx'):\n",
    "#             file_path = os.path.join(dirpath, filename)\n",
    "            \n",
    "#             # 初始化type_value为None\n",
    "#             type_value = None\n",
    "            \n",
    "#             # 根据文件夹名称或文件名确定type值\n",
    "#             if \"整体\" in dirpath or \"整体\" in filename:\n",
    "#                 type_value = 0\n",
    "#             elif \"分离截面\" in dirpath or \"分离截面\" in filename:\n",
    "#                 type_value = 1\n",
    "#             elif \"分离螺栓\" in dirpath or \"分离螺栓\" in filename:\n",
    "#                 type_value = 2\n",
    "\n",
    "#             try:\n",
    "#                 # 读取Excel文件\n",
    "#                 df = pd.read_excel(file_path, engine='openpyxl')\n",
    "#                 # 筛选出需要保留的列\n",
    "#                 available_columns = [col for col in columns_to_keep if col in df.columns]\n",
    "#                 df_filtered = df[available_columns].copy()  # 使用.copy()确保创建一个新的DataFrame\n",
    "                \n",
    "#                 # 添加type列和file_path列\n",
    "#                 df_filtered.loc[:, 'type'] = type_value  # 使用.loc来设置值\n",
    "#                 df_filtered.loc[:, 'file_path'] = file_path  # 记录文件路径\n",
    "                \n",
    "#                 # 将过滤后的数据追加到累积的DataFrame中\n",
    "#                 all_data_df = pd.concat([all_data_df, df_filtered], ignore_index=True)\n",
    "\n",
    "#             except Exception as e:\n",
    "#                 print(f\"Error processing {file_path}: {e}\")\n",
    "\n",
    "# # 处理重复值\n",
    "# def handle_duplicates(group):\n",
    "#     if len(group) > 1:\n",
    "#         # 如果组内有多个元素，优先保留EigenValue非零的行\n",
    "#         non_zero_eigen = group[group['EigenValue'] != 0]\n",
    "#         if not non_zero_eigen.empty:\n",
    "#             return non_zero_eigen\n",
    "#         else:\n",
    "#             # 如果所有行的EigenValue都为0，返回第一行\n",
    "#             return group.head(1)\n",
    "#     else:\n",
    "#         return group\n",
    "\n",
    "# # 根据key_columns分组并应用处理函数\n",
    "# all_data_df_cleaned = all_data_df.groupby(key_columns, as_index=False).apply(handle_duplicates).reset_index(drop=True)\n",
    "# # 去除 EigenValue 列为零和为空的行\n",
    "# all_data_df_cleaned = all_data_df_cleaned[\n",
    "#     (all_data_df_cleaned['EigenValue'] != 0) & \n",
    "#     (pd.notna(all_data_df_cleaned['EigenValue']))\n",
    "# ]\n",
    "\n",
    "# # 重置索引\n",
    "# all_data_df_cleaned = all_data_df_cleaned.reset_index(drop=True)\n",
    "# # 打印最终的DataFrame以供检查\n",
    "# print(\"合并后的数据：\")\n",
    "# print(all_data_df_cleaned.head())  # 根据实际情况调整展示的行数\n",
    "\n",
    "# # 查找type为空的行及其来源文件\n",
    "# empty_type_rows = all_data_df_cleaned[all_data_df_cleaned['type'].isna()]\n",
    "# print(\"\\nType为空的行及其来源文件：\")\n",
    "# print(empty_type_rows[['file_path', 'type']])\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "f887be1d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# print(len(all_data_df_cleaned))\n",
    "# df_dd = all_data_df_cleaned.drop_duplicates()\n",
    "# df_dd.to_excel('df_dd.xlsx')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "d4961531",
   "metadata": {},
   "outputs": [],
   "source": [
    "# file_path = r'R:\\Jupyterdemo\\df_dd.xlsx'\n",
    "# file_df = pd.read_excel(file_path)\n",
    "# file_df                   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "c5317a42",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from pandas import read_excel\n",
    "# pd.set_option('display.max_rows', None)#展示所有行\n",
    "# 命名规则\n",
    "# 整体截面\n",
    "file_Total_all=r'R:\\Jupyterdemo\\1整体截面全部数据.xlsx'\n",
    "# # 分离截面\n",
    "file_Sep_all=r'R:\\Jupyterdemo\\2分离截面全部数据.xlsx'\n",
    "# # 分离螺栓\n",
    "file_Bolt_All=r'R:\\Jupyterdemo\\3分离螺栓全部数据.xlsx'\n",
    "# # 代号简称\n",
    "dfTAll=pd.read_excel(file_Total_all)\n",
    "dfSAll=pd.read_excel(file_Sep_all)\n",
    "dfBAll=pd.read_excel(file_Bolt_All)\n",
    "\n",
    "#将所有截面连接在一起，并加注尾标\n",
    "dfTAll['type']=np.full((len(dfTAll),1),0)\n",
    "dfSAll['type']=np.full((len(dfSAll),1),1)\n",
    "dfBAll['type']=np.full((len(dfBAll),1),2)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "da8175ea",
   "metadata": {},
   "source": [
    "#### 读取三种类型的构件"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "0fecd25b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "共有的列: {'H', 'Pcf3ff', 'Pucf1f', 'B', 'EigenValue', 'L', 'cf2f', 'Pucf3f', 'pbol', 'Pcf1f', 'yuss', 'cf3f', 'yusn', 'T2', 'yfsn', 'meshsz', 'Pcf3f', 'Pucf2f', 'n', 'sfricn', 'type', 'cf1f', 'Imperfectfactor', 'Pcf1ff', 'Pcf2f', 'Pcf2ff', 'T1', 'yfss'}\n",
      "dfTAll 独有的列: set()\n",
      "dfSAll 独有的列: set()\n",
      "dfBAll 独有的列: {'BoltD', 'F', 'BoltB'}\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# 假设 dfTAll, dfSAll, dfBAll 已经定义并填充了数据\n",
    "\n",
    "# 获取每个DataFrame的列集合\n",
    "columns_dfTAll = set(dfTAll.columns)\n",
    "columns_dfSAll = set(dfSAll.columns)\n",
    "columns_dfBAll = set(dfBAll.columns)\n",
    "\n",
    "# 找出所有DataFrame中共有的列\n",
    "common_columns = columns_dfTAll.intersection(columns_dfSAll, columns_dfBAll)\n",
    "\n",
    "# 找出每个DataFrame独有的列\n",
    "unique_to_dfTAll = columns_dfTAll - columns_dfSAll - columns_dfBAll\n",
    "unique_to_dfSAll = columns_dfSAll - columns_dfTAll - columns_dfBAll\n",
    "unique_to_dfBAll = columns_dfBAll - columns_dfTAll - columns_dfSAll\n",
    "\n",
    "# 打印结果\n",
    "print(\"共有的列:\", common_columns)\n",
    "print(\"dfTAll 独有的列:\", unique_to_dfTAll)\n",
    "print(\"dfSAll 独有的列:\", unique_to_dfSAll)\n",
    "print(\"dfBAll 独有的列:\", unique_to_dfBAll)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "34b8622a",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:36.250256Z",
     "start_time": "2024-02-05T07:20:10.058174Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>Pucf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>Bcf1f</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Bcf3f</th>\n",
       "      <th>Bcff</th>\n",
       "      <th>BoltB</th>\n",
       "      <th>BoltD</th>\n",
       "      <th>F</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>260481.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>520963.90</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.010</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>44121</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>13951291.52</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>18876400.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>46945900.0</td>\n",
       "      <td>6.549559e+14</td>\n",
       "      <td>46945900.0</td>\n",
       "      <td>56.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>44122</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>18518900.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>47504200.0</td>\n",
       "      <td>3.313725e+14</td>\n",
       "      <td>47504200.0</td>\n",
       "      <td>56.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>44123</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>18524500.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>47519300.0</td>\n",
       "      <td>3.314778e+14</td>\n",
       "      <td>47519300.0</td>\n",
       "      <td>56.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>2.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>44124</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>18991900.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>49051000.0</td>\n",
       "      <td>3.421624e+14</td>\n",
       "      <td>49051000.0</td>\n",
       "      <td>56.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>4.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>44125</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>19003600.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>49328600.0</td>\n",
       "      <td>3.440988e+14</td>\n",
       "      <td>49328600.0</td>\n",
       "      <td>56.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>94350 rows × 29 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           B  cf1f  cf2f         cf3f       H  Imperfectfactor       L  \\\n",
       "0       50.0   0.0   1.0    260481.95   100.0            0.002  3000.0   \n",
       "1       50.0   0.0   1.0    520963.90   100.0            0.002  3000.0   \n",
       "2       50.0   0.0   1.0    602758.95   100.0            0.002  3000.0   \n",
       "3       50.0   0.0   1.0    602758.95   100.0            0.005  3000.0   \n",
       "4       50.0   0.0   1.0    602758.95   100.0            0.010  3000.0   \n",
       "...      ...   ...   ...          ...     ...              ...     ...   \n",
       "44121  300.0   0.0   1.0  13951291.52  1000.0            0.002  3000.0   \n",
       "44122  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "44123  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "44124  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "44125  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "\n",
       "       meshsz    n      pbol  ...      Pucf2f  Pucf3f  type  Bcf1f  \\\n",
       "0        40.0  1.0      90.0  ...         NaN     NaN     0    NaN   \n",
       "1        40.0  2.0      90.0  ...         NaN     NaN     0    NaN   \n",
       "2        40.0  3.0      90.0  ...         NaN     NaN     0    NaN   \n",
       "3        40.0  3.0      90.0  ...         NaN     NaN     0    NaN   \n",
       "4        40.0  3.0      90.0  ...         NaN     NaN     0    NaN   \n",
       "...       ...  ...       ...  ...         ...     ...   ...    ...   \n",
       "44121    20.0  5.0  125000.0  ...  18876400.0     0.0     2    0.0   \n",
       "44122    20.0  5.0  125000.0  ...  18518900.0     0.0     2    0.0   \n",
       "44123    20.0  5.0  125000.0  ...  18524500.0     0.0     2    0.0   \n",
       "44124    20.0  5.0  125000.0  ...  18991900.0     0.0     2    0.0   \n",
       "44125    20.0  5.0  125000.0  ...  19003600.0     0.0     2    0.0   \n",
       "\n",
       "            Bcf2f         Bcf3f        Bcff  BoltB  BoltD    F  \n",
       "0             NaN           NaN         NaN    NaN    NaN  NaN  \n",
       "1             NaN           NaN         NaN    NaN    NaN  NaN  \n",
       "2             NaN           NaN         NaN    NaN    NaN  NaN  \n",
       "3             NaN           NaN         NaN    NaN    NaN  NaN  \n",
       "4             NaN           NaN         NaN    NaN    NaN  NaN  \n",
       "...           ...           ...         ...    ...    ...  ...  \n",
       "44121  46945900.0  6.549559e+14  46945900.0   56.0   20.0  5.0  \n",
       "44122  47504200.0  3.313725e+14  47504200.0   56.0   20.0  1.0  \n",
       "44123  47519300.0  3.314778e+14  47519300.0   56.0   20.0  2.0  \n",
       "44124  49051000.0  3.421624e+14  49051000.0   56.0   20.0  4.0  \n",
       "44125  49328600.0  3.440988e+14  49328600.0   56.0   20.0  5.0  \n",
       "\n",
       "[94350 rows x 29 columns]"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_alltype=pd.concat([dfTAll, dfSAll,dfBAll], axis=0, join='outer')# 纵向连接，\n",
    "# inner连接只保留两个DataFrame都存在的行和列（并集）：这是 pandas.concat 的默认行为。\n",
    "# 它意味着结果会包含所有被连接的数据框中的所有列或行，\n",
    "# 并用缺失值（如 NaN）填充那些在某些数据框中不存在的值。\n",
    "# 因此，使用 'outer' 可以保留尽可能多的信息，但可能会引入很多缺失值。\n",
    "# df_alltype=dfTAll\n",
    "df_alltype_connect=df_alltype.drop(['Pcf1f', 'Pcf1ff', 'Pcf2f', 'Pcf2ff', 'Pcf3f', 'Pcf3ff'],axis=1,inplace=False)\n",
    "df_alltype_connect.dropna(subset=['EigenValue'], inplace=True)\n",
    "df_alltype_connect"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c4a7c8f",
   "metadata": {},
   "source": [
    "#### 去重"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "204a3103",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:36.391849Z",
     "start_time": "2024-02-05T07:20:36.329017Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True 94350\n",
      "删除后,去NaN前 93884\n",
      "原始数据框：\n",
      "93884\n",
      "\n",
      "清理后的数据框：\n",
      "93884\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# 假设 df_alltype_connect 是你的原始数据框\n",
    "# df_alltype=pd.concat([df_alltype, dfBAllo], axis=0, join='outer')# 纵向连接两类截面\n",
    "# df_alltype.columns\n",
    "df_alltype = df_alltype_connect.copy()\n",
    "print(df_alltype.duplicated().any(), len(df_alltype))\n",
    "\n",
    "# 删除重复行\n",
    "df_alltype = df_alltype.drop_duplicates()\n",
    "print('删除后,去NaN前', len(df_alltype))\n",
    "\n",
    "# 删除所有列都为NaN的行\n",
    "df_alltype.dropna(axis=0, how='all', inplace=True)\n",
    "# 显示原始和清理后的数据框\n",
    "print(\"原始数据框：\")\n",
    "print(len(df_alltype))\n",
    "# 指定要检查的列\n",
    "columns_to_check = ['B', 'H', 'T1', 'T2']\n",
    "df_cleaned = df_alltype.dropna(subset=columns_to_check, how='all')\n",
    "df_cleaned['EigenValue'] = df_cleaned['EigenValue'].abs()\n",
    "print(\"\\n清理后的数据框：\")\n",
    "print(len(df_cleaned))\n",
    "\n",
    "# 重置索引\n",
    "df_alltype = df_cleaned.reset_index(drop=True)\n",
    "dfdelpara = df_alltype"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5a4c4b9a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Index(['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
       "       'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
       "       'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', 'type', 'Bcf1f', 'Bcf2f',\n",
       "       'Bcf3f', 'Bcff', 'BoltB', 'BoltD', 'F'],\n",
       "      dtype='object')"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "display(df_alltype.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "8874d52b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# df=dfdelpara.copy()\n",
    "# # 设置条件：当 cf1f 和 cf2f 为特定数值组合时（示例为 cf1f=1 且 cf2f=2 或 cf1f=3 且 cf2f=2）\n",
    "# # 请根据实际需求修改条件中的数值组合\n",
    "# condition = (df['cf3f'] == 0) \n",
    "# # 将满足条件的行的 bfcf 列置为 0\n",
    "# df.loc[condition, 'Bcf3f'] = 0\n",
    "# df.loc[condition, 'Pucf3f'] = 0\n",
    "\n",
    "# condition2 = (df['cf2f'] == 0) \n",
    "# # 将满足条件的行的 bfcf 列置为 0\n",
    "# df.loc[condition2, 'Bcf2f'] = 0\n",
    "# df.loc[condition2, 'Pucf2f'] = 0\n",
    "\n",
    "# condition3 = (df['cf1f'] == 0) \n",
    "# # 将满足条件的行的 bfcf 列置为 0\n",
    "# df.loc[condition3, 'Bcf1f'] = 0\n",
    "# df.loc[condition3, 'Pucf1f'] = 0\n",
    "\n",
    "# dfdelpara=df"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e6923ee8",
   "metadata": {},
   "source": [
    "#### 计算参数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "a7048fa8",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>ratio_eta_GJdivbyDL</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>260481.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>520963.90</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.010</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93879</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>13951291.52</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93880</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93881</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93882</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93883</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>93884 rows × 112 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           B  cf1f  cf2f         cf3f       H  Imperfectfactor       L  \\\n",
       "0       50.0   0.0   1.0    260481.95   100.0            0.002  3000.0   \n",
       "1       50.0   0.0   1.0    520963.90   100.0            0.002  3000.0   \n",
       "2       50.0   0.0   1.0    602758.95   100.0            0.002  3000.0   \n",
       "3       50.0   0.0   1.0    602758.95   100.0            0.005  3000.0   \n",
       "4       50.0   0.0   1.0    602758.95   100.0            0.010  3000.0   \n",
       "...      ...   ...   ...          ...     ...              ...     ...   \n",
       "93879  300.0   0.0   1.0  13951291.52  1000.0            0.002  3000.0   \n",
       "93880  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "93881  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "93882  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "93883  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "\n",
       "       meshsz    n      pbol  ...  ratio_eta_GJdivbyDL             G  \\\n",
       "0        40.0  1.0      90.0  ...             0.519436  79230.769231   \n",
       "1        40.0  2.0      90.0  ...             0.519436  79230.769231   \n",
       "2        40.0  3.0      90.0  ...             0.519436  79230.769231   \n",
       "3        40.0  3.0      90.0  ...             0.519436  79230.769231   \n",
       "4        40.0  3.0      90.0  ...             0.519436  79230.769231   \n",
       "...       ...  ...       ...  ...                  ...           ...   \n",
       "93879    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93880    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93881    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93882    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93883    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "\n",
       "            EI_edge            Dh        EI_mid  gamma_edge   gamma_mid  \\\n",
       "0      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "1      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "2      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "3      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "4      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "...             ...           ...           ...         ...         ...   \n",
       "93879  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93880  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93881  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93882  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93883  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "\n",
       "           beta     beta2     L_to_tw  \n",
       "0      0.686000  1.751391  600.000000  \n",
       "1      0.686000  1.751391  600.000000  \n",
       "2      0.686000  1.751391  600.000000  \n",
       "3      0.686000  1.751391  600.000000  \n",
       "4      0.686000  1.751391  600.000000  \n",
       "...         ...       ...         ...  \n",
       "93879  1.020324  2.640928  157.894737  \n",
       "93880  1.020324  2.640928  157.894737  \n",
       "93881  1.020324  2.640928  157.894737  \n",
       "93882  1.020324  2.640928  157.894737  \n",
       "93883  1.020324  2.640928  157.894737  \n",
       "\n",
       "[93884 rows x 112 columns]"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 对于截面上的x与y的方向确定与单个H型钢截面一致\n",
    "dfdelpara.eval(\"\"\"\n",
    "\n",
    "As1=B*T2*2*n\n",
    "As1_n=(B-T1)*T2*2*n\n",
    "\n",
    "As2=H*T1*n\n",
    "As2_n=((H-T2*2)*T1)\n",
    "As3=((H*T1)+(B-T1)*T2*2)*n\n",
    "\n",
    "Pu_fy_f1_n = As1_n * yfss/(sqrt(3))\n",
    "Pu_fy_f2_n = As2_n * yfss/(sqrt(3))\n",
    "\n",
    "\n",
    "Pu_fy_f1 = As1 * yfss/(sqrt(3))\n",
    "Pu_fy_f2 = As2 * yfss/(sqrt(3))\n",
    "Pu_fy_f3 = As3 * yfss\n",
    "\n",
    "\n",
    "axialratio=cf3f/Pu_fy_f3\n",
    "cf12f=sqrt(cf1f**2+cf2f**2)\n",
    "\n",
    "Pucf12f=sqrt(Pucf1f**2+Pucf2f**2)\n",
    "\n",
    "EigenValue=abs(EigenValue)\n",
    "\n",
    "Bcf1f=abs(EigenValue)*cf1f\n",
    "Bcf2f=abs(EigenValue)*cf2f\n",
    "Bcf3f=abs(EigenValue)*cf3f\n",
    "Bcf12f=abs(EigenValue)*cf12f\n",
    "\n",
    "SLcf1f_n=sqrt(abs(Pu_fy_f1_n)/abs(Bcf1f))\n",
    "SLcf2f_n=sqrt(abs(Pu_fy_f2_n)/abs(Bcf2f))\n",
    "\n",
    "\n",
    "SLcf1f=sqrt(abs(Pu_fy_f1)/abs(Bcf1f))\n",
    "SLcf2f=sqrt(abs(Pu_fy_f2)/abs(Bcf2f))\n",
    "SLcf3f=sqrt(abs(Pu_fy_f3)/abs(Bcf3f))\n",
    "\n",
    "SFcf1f_n=(abs(Pucf1f)/abs(Pu_fy_f1_n))\n",
    "SFcf2f_n=(abs(Pucf2f)/abs(Pu_fy_f2_n))\n",
    "SFcf1f=(abs(Pucf1f)/abs(Pu_fy_f1))\n",
    "SFcf2f=(abs(Pucf2f)/abs(Pu_fy_f2))\n",
    "SFcf3f=(abs(Pucf3f)/abs(Pu_fy_f3))\n",
    "\n",
    "\n",
    "CWcf1f_n=SFcf1f_n/SLcf1f\n",
    "CWcf2f_n=SFcf2f_n/SLcf2f\n",
    "CWcf1f=SFcf1f/SLcf1f\n",
    "CWcf2f=SFcf2f/SLcf2f\n",
    "CWcf3f=SFcf3f/SLcf3f\n",
    "\n",
    "KG_quge_web=(H-T2*2)/L\n",
    "KG_total_web=n*H/L\n",
    "\n",
    "KG_sing_web=H/L\n",
    "\n",
    "KG_consedge_flange=(B-T1)/2/L\n",
    "KG_midstiff_flange=(B-T1)/2/L\n",
    "\n",
    "GH_quge_web=L/T1\n",
    "\n",
    "KH_quge_web_n=(H-T2*2)/T1\n",
    "KH_quge_web=H/T1\n",
    "KH_total_web=n*H/T1\n",
    "KH_consedge_flange=(B-T1)/2/T2\n",
    "KH_midstiff_flange=(B-T1)/2/(T2*2)\n",
    "\n",
    "KH_sing_flange=B/T2\n",
    "\n",
    "\n",
    "I_single_ix=((H-2*T2)**3)*T1/12+2*B*T2**3/12+T2*B*(2*((H/2-T2/2)**2))\n",
    "I_single_iy=((H-2*T2)*T1**3)/12+(2*T2*B**3)/12\n",
    "\n",
    "I_web_quge_ix=(T1*(H-T2*2)**3)/12\n",
    "I_web_quge_iy=((H-T2*2)*T1**3)/12\n",
    "\n",
    "I_flange_consedge_ix=(B*T2**3)/12\n",
    "I_flange_consedge_iy=(T2*B**3)/12\n",
    "\n",
    "I_flange_midstiff_ix=(B*(T2*2)**3)/12\n",
    "I_flange_midstiff_iy=((T2*2)*B**3)/12\n",
    "\n",
    "I_total_webix=T1*(n*H)*(n*H)*(n*H)/12\n",
    "I_total_webiy=(n*H)*T1*T1*T1/12\n",
    "\n",
    "J_web=(H-2*T2)*((T1)**3)*(1/3-0.21*(T1)/(H-2*T2)*(1-(T1)**4/(12*(H-2*T2)**4)))\n",
    "J_consedge_half=((B-T1)/2)*((T2)**3)*(1/3-0.21*(T2)/((B-T1)/2)*(1-(T2)**4/(12*((B-T1)/2)**4)))\n",
    "J_midstiff_half=((B-T1)/2)*((T2*2)**3)*(1/3-0.21*(T2*2)/((B-T1)/2)*(1-(T2*2)**4/(12*((B-T1)/2)**4)))\n",
    "J_consedge=(B)*((T2)**3)*(1/3-0.21*(T2)/(B)*(1-(T2)**4/(12*(B)**4)))\n",
    "J_midstiff=(B)*((T2*2)**3)*(1/3-0.21*(T2*2)/(B)*(1-(T2*2)**4/(12*(B)**4)))\n",
    "\n",
    "ratio_alpha_tflange_to_tweb=T2/T1\n",
    "ratio_alpha_Bflange_to_Hn=B/(H-2*T2)\n",
    "\n",
    "\n",
    "tau_fem1=Bcf1f/As1\n",
    "tau_fem1_n=Bcf1f/As1_n\n",
    "\n",
    "tau_fem2=Bcf2f/As2\n",
    "tau_fem2_n=Bcf2f/As2_n\n",
    "\n",
    "tau_fem3=Bcf3f/As3\n",
    "\n",
    "E=2.06*10**5\n",
    "Pai=3.1415926\n",
    "\n",
    "k_taucr_fem1 =(tau_fem1*12*(1-0.3**2)*(((B)/2)**2))/((Pai**2)*E*(T2**2))\n",
    "k_taucr_fem1_n =(tau_fem1_n*12*(1-0.3**2)*(((B-T1)/2)**2))/((Pai**2)*E*(T2**2))\n",
    "\n",
    "k_taucr_fem2 =(tau_fem2*(12*(1-0.3**2)*((n*(H))**2)))/((Pai**2)*E*(T1**2))\n",
    "k_taucr_fem2_n =(tau_fem2_n*(12*(1-0.3**2)*(((H-T2*2))**2)))/((Pai**2)*E*(T1**2))\n",
    "k_taucr_fem2_beam=k_taucr_fem2*((H/L)**2)\n",
    "\n",
    "\n",
    "k_taucr_fem31 =(tau_fem3*12*(1-0.3**2)*(((B-T1)/2)**2))/((Pai**2)*E*(T2**2))\n",
    "k_taucr_fem32 =(tau_fem3*(12*(1-0.3**2)*((n*(H-T2*2))**2)))/((3.1415926**2)*E*(T1**2))\n",
    "\n",
    "ratio_axial_to_Pu_fy_f13=cf3f/Pu_fy_f3\n",
    "ratio_eta_GJdivbyDL=((E/(2*(1+0.3)))*J_consedge)/(I_web_quge_ix*L)\n",
    "\n",
    "G=E/(2*(1+0.3))\n",
    "\n",
    "EI_edge=E*((T2)*(B**3)/12)\n",
    "Dh=(E*(T1**3)*H)/(12*(1-0.3**2))\n",
    "EI_mid=E*((T2*2)*(B**3)/12)\n",
    "\n",
    "gamma_edge=EI_edge/(Dh)\n",
    "gamma_mid=EI_mid/(Dh)\n",
    "\n",
    "beta=((B/2)*(T2**3))/(H*(T1)**3)\n",
    "beta2=(J_consedge*G)/(Dh)\n",
    "\n",
    "L_to_tw=L/T1\n",
    "\"\"\", inplace=True)\n",
    "dfdelpara\n",
    "# Jv=(8(b'v)*(b'v)*2bv*2bvt*bv*bv)/(2b'vtv+bvtv)\n",
    "# Gv=E/2(1+poissonratio)\n",
    "# qugeKHB = ((H-T2)+L)-220*sqrt(235/yfss)\n",
    "# K=#竖肋的抗扭／抗弯刚度比\n",
    "# D=Ｅ＼２｛＼－ｆｉ２）# 竖肋的弹性模量\n",
    "# K=(Gv*Jv)/(Ev*Iv)#竖肋的抗扭／抗弯刚度比"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d06efcf3",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "c8f8b1f1",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:37.226617Z",
     "start_time": "2024-02-05T07:20:37.182736Z"
    }
   },
   "outputs": [],
   "source": [
    "# 对轴压力进行四舍五入&异常大数值和小数值处理\n",
    "# dfdelpara.to_excel('dfdelpara.xlsx')\n",
    "# dfdelpara['axialratio'] = round(dfdelpara['axialratio'],2)\n",
    "# dfdelpara = dfdelpara[dfdelpara['Pucf12f'] <= 38854353]\n",
    "# dfdelpara\n",
    "dfdelpara1=dfdelpara.copy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "763496b7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "原始样本数: 93884\n",
      "剔除异常样本数: 2129\n",
      "使用阈值: 18222247.73 (均值:1969879.65 ± 2.0σ)\n",
      "93884 dfdelpara1 91755 cleaned_df\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.neighbors import NearestNeighbors\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "def remove_anomalous_results(df, feature_columns, result_columns, n_neighbors=3, std_threshold=2.5):\n",
    "    \"\"\"\n",
    "    基于特征相似性剔除异常结果样本（支持列名指定）\n",
    "    \n",
    "    参数:\n",
    "    df (pd.DataFrame): 原始数据\n",
    "    feature_columns (list): 特征列名列表（如: ['f1','f2',...,'f10']）\n",
    "    result_columns (list): 结果列名列表（如: ['r1','r2']）\n",
    "    n_neighbors (int): 最近邻数量（建议3-5）\n",
    "    std_threshold (float): 异常阈值（均值+X倍标准差）\n",
    "    \n",
    "    返回:\n",
    "    pd.DataFrame: 清洗后的数据集\n",
    "    \"\"\"\n",
    "    # 参数校验\n",
    "    if not set(feature_columns).issubset(df.columns):\n",
    "        raise ValueError(\"特征列名列表包含不存在的列名\")\n",
    "    if not set(result_columns).issubset(df.columns):\n",
    "        raise ValueError(\"结果列名列表包含不存在的列名\")\n",
    "    if len(df) < n_neighbors:\n",
    "        raise ValueError(\"数据量小于最近邻数量，请减少n_neighbors参数\")\n",
    "\n",
    "    # 提取特征和结果数据\n",
    "    X = df[feature_columns].values  # 通过列名提取特征\n",
    "    y = df[result_columns].values   # 通过列名提取结果\n",
    "    \n",
    "    # 特征标准化（消除量纲影响）\n",
    "    scaler = StandardScaler()\n",
    "    X_scaled = scaler.fit_transform(X)\n",
    "    \n",
    "    # 训练最近邻模型（包含自身+N-1个邻居）\n",
    "    nbrs = NearestNeighbors(n_neighbors=n_neighbors).fit(X_scaled)\n",
    "    distances, indices = nbrs.kneighbors(X_scaled)\n",
    "    \n",
    "    # 计算每个样本与邻居的结果差异（排除自身）\n",
    "    diff_scores = []\n",
    "    for i in range(len(df)):\n",
    "        # 获取当前样本的邻居索引（排除第一个自身）\n",
    "        neighbor_indices = indices[i, 1:]\n",
    "        # 计算当前样本与所有邻居的结果差异总和\n",
    "        total_diff = 0\n",
    "        for ni in neighbor_indices:\n",
    "            # 计算结果列的绝对差之和（可根据需求改为RMSE、余弦距离等）\n",
    "            diff = np.abs(y[i] - y[ni]).sum()\n",
    "            total_diff += diff\n",
    "        # 取平均差异作为该样本的异常分数\n",
    "        avg_diff = total_diff / (n_neighbors - 1)\n",
    "        diff_scores.append(avg_diff)\n",
    "    \n",
    "    # 确定异常阈值（均值+X倍标准差）\n",
    "    diff_mean = np.mean(diff_scores)\n",
    "    diff_std = np.std(diff_scores)\n",
    "    threshold = diff_mean + std_threshold * diff_std\n",
    "    \n",
    "    # 标记并剔除异常样本\n",
    "    df['anomaly_score'] = diff_scores\n",
    "    clean_df = df[df['anomaly_score'] <= threshold].copy()\n",
    "    \n",
    "    # 输出统计信息\n",
    "    print(f\"原始样本数: {len(df)}\")\n",
    "    print(f\"剔除异常样本数: {len(df) - len(clean_df)}\")\n",
    "    print(f\"使用阈值: {threshold:.2f} (均值:{diff_mean:.2f} ± {std_threshold}σ)\")\n",
    "    \n",
    "    return clean_df.drop(columns=['anomaly_score'])\n",
    "\n",
    "# --------------------------- 使用示例 ---------------------------\n",
    "if __name__ == \"__main__\":\n",
    "    df = dfdelpara\n",
    "    # 执行清洗（通过列名指定特征和结果）\n",
    "    cleaned_df = remove_anomalous_results(\n",
    "        df,\n",
    "        feature_columns=['n', 'yfsn', 'yusn', 'cf1f', 'cf3f', 'cf2f', 'yuss',  'L', 'H', 'meshsz',  \n",
    "                         'B', 'type', 'yfss', 'pbol', 'T1', 'T2', 'sfricn', 'Imperfectfactor' ],  # 特征列名列表\n",
    "        result_columns=['EigenValue'],                # 结果列名列表\n",
    "        n_neighbors=4,                                           # 调整邻居数量\n",
    "        std_threshold=2.0                                        # 调整阈值灵敏度\n",
    "    )\n",
    "    \n",
    "print(len(dfdelpara1),'dfdelpara1',len(cleaned_df),'cleaned_df')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "316ceb5c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "float64\n",
      "float64\n"
     ]
    }
   ],
   "source": [
    "print(cleaned_df['Pucf1f'].dtypes)\n",
    "\n",
    "cleaned_df = cleaned_df.replace('', np.nan)\n",
    "\n",
    "# 2. 转换所有列至 float 类型\n",
    "cleaned_df = cleaned_df.astype('float')\n",
    "# print(cleaned_df['Pucf1f'].dtypes)\n",
    "print(cleaned_df['Pucf2f'].dtypes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "60733d8a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "float64\n",
      "float64\n",
      "float64\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>ratio_eta_GJdivbyDL</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>260481.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>520963.90</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>602758.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.010</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93879</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>13951291.52</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93880</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93881</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93882</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93883</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>6975645.76</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>91755 rows × 112 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           B  cf1f  cf2f         cf3f       H  Imperfectfactor       L  \\\n",
       "0       50.0   0.0   1.0    260481.95   100.0            0.002  3000.0   \n",
       "1       50.0   0.0   1.0    520963.90   100.0            0.002  3000.0   \n",
       "2       50.0   0.0   1.0    602758.95   100.0            0.002  3000.0   \n",
       "3       50.0   0.0   1.0    602758.95   100.0            0.005  3000.0   \n",
       "4       50.0   0.0   1.0    602758.95   100.0            0.010  3000.0   \n",
       "...      ...   ...   ...          ...     ...              ...     ...   \n",
       "93879  300.0   0.0   1.0  13951291.52  1000.0            0.002  3000.0   \n",
       "93880  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "93881  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "93882  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "93883  300.0   0.0   1.0   6975645.76  1000.0            0.002  3000.0   \n",
       "\n",
       "       meshsz    n      pbol  ...  ratio_eta_GJdivbyDL             G  \\\n",
       "0        40.0  1.0      90.0  ...             0.519436  79230.769231   \n",
       "1        40.0  2.0      90.0  ...             0.519436  79230.769231   \n",
       "2        40.0  3.0      90.0  ...             0.519436  79230.769231   \n",
       "3        40.0  3.0      90.0  ...             0.519436  79230.769231   \n",
       "4        40.0  3.0      90.0  ...             0.519436  79230.769231   \n",
       "...       ...  ...       ...  ...                  ...           ...   \n",
       "93879    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93880    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93881    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93882    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "93883    20.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "\n",
       "            EI_edge            Dh        EI_mid  gamma_edge   gamma_mid  \\\n",
       "0      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "1      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "2      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "3      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "4      1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "...             ...           ...           ...         ...         ...   \n",
       "93879  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93880  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93881  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93882  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "93883  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "\n",
       "           beta     beta2     L_to_tw  \n",
       "0      0.686000  1.751391  600.000000  \n",
       "1      0.686000  1.751391  600.000000  \n",
       "2      0.686000  1.751391  600.000000  \n",
       "3      0.686000  1.751391  600.000000  \n",
       "4      0.686000  1.751391  600.000000  \n",
       "...         ...       ...         ...  \n",
       "93879  1.020324  2.640928  157.894737  \n",
       "93880  1.020324  2.640928  157.894737  \n",
       "93881  1.020324  2.640928  157.894737  \n",
       "93882  1.020324  2.640928  157.894737  \n",
       "93883  1.020324  2.640928  157.894737  \n",
       "\n",
       "[91755 rows x 112 columns]"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 保存清洗后数据（建议放在所有处理完成后）\n",
    "# cleaned_df.to_excel('cleaned_df.xlsx')\n",
    "\n",
    "# 条件1\n",
    "condition1 = (cleaned_df['cf3f'] != 0) & (cleaned_df['Pucf2f'] >= 60571600)\n",
    "print(cleaned_df['Pucf2f'].dtypes)\n",
    "cleaned_df.loc[condition1, 'Pucf2f'] = np.nan\n",
    "print(cleaned_df['Pucf2f'].dtypes)\n",
    "condition15 = (cleaned_df['cf3f'] != 0) & (cleaned_df['Pucf1f'] >= 412128)\n",
    "cleaned_df.loc[condition15, 'Pucf1f'] =np.nan\n",
    "# 条件2\n",
    "print(cleaned_df['Pucf2f'].dtypes)\n",
    "condition2 = (cleaned_df['cf3f'] == 0) & (cleaned_df['Pucf1f'] == 2044920) & (cleaned_df['Pucf2f'] >= 37045.6)\n",
    "cleaned_df.loc[condition2, ['Pucf1f', 'Pucf2f']] = np.nan\n",
    "\n",
    "# 条件3\n",
    "condition3 = (cleaned_df['cf3f'] == 0) & (cleaned_df['cf1f'] == 1) & (cleaned_df['cf2f'] == 0) & (cleaned_df['Pucf1f'] >= 26919300)\n",
    "cleaned_df.loc[condition3, 'Pucf1f'] = np.nan\n",
    "\n",
    "# 条件4\n",
    "condition4 = (cleaned_df['cf3f'] == 0) &(cleaned_df['cf1f'] == 1) & (cleaned_df['cf2f'] == 0) & (cleaned_df['Pucf2f'] >= 57760)\n",
    "cleaned_df.loc[condition4, 'Pucf2f'] =np.nan\n",
    "\n",
    "# 条件5\n",
    "condition5 = (cleaned_df['cf3f'] == 0) &(cleaned_df['cf1f'] == 0.577) & (cleaned_df['cf2f'] == 1) & (cleaned_df['Pucf2f'] >= 24494500)\n",
    "cleaned_df.loc[condition5, 'Pucf2f'] = np.nan\n",
    "\n",
    "# 条件6\n",
    "condition6 = (cleaned_df['cf3f'] == 0) &(cleaned_df['cf1f'] == 0.577) & (cleaned_df['cf2f'] == 1) & (cleaned_df['Pucf1f'] >= 27298600)\n",
    "cleaned_df.loc[condition6, 'Pucf1f'] = np.nan\n",
    "\n",
    "# 条件7\n",
    "condition7 = (cleaned_df['cf3f'] == 0) &(cleaned_df['cf1f'] == 1.732) & (cleaned_df['cf2f'] == 1) & (cleaned_df['Pucf2f'] >= 24818700)\n",
    "cleaned_df.loc[condition7, 'Pucf2f'] = np.nan\n",
    "\n",
    "# 条件8\n",
    "condition8 = (cleaned_df['cf3f'] == 0) &(cleaned_df['cf1f'] == 1.732) & (cleaned_df['cf2f'] == 1) & (cleaned_df['Pucf1f'] >= 25908100)\n",
    "cleaned_df.loc[condition8, 'Pucf1f'] = np.nan\n",
    "\n",
    "# 条件9\n",
    "\n",
    "condition9 = (cleaned_df['Pucf2f'] >29543000)\n",
    "cleaned_df.loc[condition9, 'Pucf2f'] = np.nan\n",
    "\n",
    "condition10 = (cleaned_df['Pucf1f'] > 27959500)\n",
    "cleaned_df.loc[condition10, 'Pucf1f'] = np.nan\n",
    "\n",
    "condition11 = (cleaned_df['Pucf1f'] == 10714100)\n",
    "cleaned_df.loc[condition11, 'Pucf1f'] = np.nan\n",
    "\n",
    "condition12 = (cleaned_df['EigenValue'] == 259314)&(cleaned_df['cf3f'] != 0) \n",
    "cleaned_df.loc[condition12, 'EigenValue'] = np.nan\n",
    "\n",
    "# cleaned_df.to_excel('cleaned_df.xlsx')\n",
    "cleaned_df"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2272f845",
   "metadata": {},
   "source": [
    "#### 异常数值的筛选与处理"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "7e074145",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "==================================================\n",
      "开始处理参数: Imperfectfactor\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss', 'sfricn', 'pbol', 'F']\n",
      "\n",
      "处理完成! 保留 5780/43630 行\n",
      "分组数: 1527/37731\n",
      "\n",
      "Imperfectfactor 处理摘要:\n",
      "\n",
      "==================================================\n",
      "开始处理参数: sfricn\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss', 'Imperfectfactor', 'pbol', 'F']\n",
      "\n",
      "处理完成! 保留 4757/43630 行\n",
      "分组数: 1462/37815\n",
      "\n",
      "sfricn 处理摘要:\n",
      "\n",
      "==================================================\n",
      "开始处理参数: pbol\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss', 'Imperfectfactor', 'sfricn', 'F']\n",
      "\n",
      "处理完成! 保留 7960/43630 行\n",
      "分组数: 1546/35383\n",
      "\n",
      "pbol 处理摘要:\n",
      "\n",
      "==================================================\n",
      "开始处理参数: F\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss', 'Imperfectfactor', 'sfricn', 'pbol']\n",
      "\n",
      "处理完成! 保留 32243/43630 行\n",
      "分组数: 8959/11921\n",
      "\n",
      "F 处理摘要:\n",
      "\n",
      "所有参数分析完成! 正在生成最终合并结果...\n",
      "最终合并结果已保存到: R:\\Jupyterdemo\\phdcode\\最终合并结果2.xlsx\n",
      "\n",
      "最终合并结果统计:\n",
      "总行数: 50740\n",
      "分析参数分布:\n",
      "请先加载数据到cleaned_df\n",
      "示例: cleaned_df = pd.read_excel('your_data.xlsx')\n",
      "\n",
      "==================================================\n",
      "开始处理参数: Imperfectfactor\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss', 'sfricn']\n",
      "\n",
      "处理完成! 保留 1987/19135 行\n",
      "分组数: 547/17362\n",
      "\n",
      "Imperfectfactor 处理摘要:\n",
      "\n",
      "==================================================\n",
      "开始处理参数: sfricn\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss', 'Imperfectfactor']\n",
      "\n",
      "处理完成! 保留 2375/19135 行\n",
      "分组数: 660/17103\n",
      "\n",
      "sfricn 处理摘要:\n",
      "\n",
      "所有参数分析完成! 正在生成最终合并结果...\n",
      "最终合并结果已保存到: R:\\Jupyterdemo\\phdcode\\最终合并结果1.xlsx\n",
      "\n",
      "最终合并结果统计:\n",
      "总行数: 4362\n",
      "分析参数分布:\n",
      "请先加载数据到cleaned_df\n",
      "示例: cleaned_df = pd.read_excel('your_data.xlsx')\n",
      "\n",
      "==================================================\n",
      "开始处理参数: Imperfectfactor\n",
      "==================================================\n",
      "new_group_cols ['cf1f', 'cf2f', 'cf3f', 'H', 'B', 'T1', 'T2', 'L', 'n', 'meshsz', 'yfss']\n",
      "\n",
      "处理完成! 保留 3682/28990 行\n",
      "分组数: 921/26222\n",
      "\n",
      "所有参数分析完成! 正在生成最终合并结果...\n",
      "最终合并结果已保存到: R:\\Jupyterdemo\\phdcode\\最终合并结果0.xlsx\n",
      "\n",
      "最终合并结果统计:\n",
      "总行数: 3682\n",
      "分析参数分布:\n",
      "请先加载数据到cleaned_df\n",
      "示例: cleaned_df = pd.read_excel('your_data.xlsx')\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os\n",
    "from datetime import datetime\n",
    "\n",
    "class GroupBasedDeduplicator:\n",
    "    \"\"\"\n",
    "    增强版分组数据去重器，完整记录处理过程\n",
    "    在原始数据中标记每一步的处理状态并导出详细报告\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, df, group_cols, eigen_col='EigenValue', f_col='F'):\n",
    "        \"\"\"\n",
    "        初始化去重器，添加过程追踪列\n",
    "        \n",
    "        Parameters:\n",
    "        - df: 输入数据框\n",
    "        - group_cols: 分组列列表\n",
    "        - eigen_col: 排序特征列 (默认: 'EigenValue')\n",
    "        - f_col: 序列值列 (默认: 'F')\n",
    "        \"\"\"\n",
    "        self.df = df.copy()\n",
    "        self.group_cols = group_cols\n",
    "        self.eigen_col = eigen_col\n",
    "        self.f_col = f_col\n",
    "        self.result_df = None\n",
    "        \n",
    "        # 添加处理过程追踪列\n",
    "        self.df['Process_Step'] = \"原始数据\"\n",
    "        self.df['Selection_Reason'] = \"\"\n",
    "        self.df['Sequence_Type'] = \"\"\n",
    "        self.df['Group_Status'] = \"\"\n",
    "        self.df['Duplication_Status'] = \"\"\n",
    "    \n",
    "    def find_longest_monotonic_subsequence(self, values, increasing=True):\n",
    "        \"\"\"动态规划寻找最长单调子序列\"\"\"\n",
    "        n = len(values)\n",
    "        if n == 0:\n",
    "            return []\n",
    "        \n",
    "        # dp[i] = length of longest subsequence ending at position i\n",
    "        dp = [1] * n\n",
    "        parent = [-1] * n\n",
    "        \n",
    "        for i in range(1, n):\n",
    "            for j in range(i):\n",
    "                if increasing and values[j] <= values[i]:\n",
    "                    if dp[j] + 1 > dp[i]:\n",
    "                        dp[i] = dp[j] + 1\n",
    "                        parent[i] = j\n",
    "                elif not increasing and values[j] >= values[i]:\n",
    "                    if dp[j] + 1 > dp[i]:\n",
    "                        dp[i] = dp[j] + 1\n",
    "                        parent[i] = j\n",
    "        \n",
    "        # Find the position with maximum length\n",
    "        max_length = max(dp)\n",
    "        max_idx = dp.index(max_length)\n",
    "        \n",
    "        # Reconstruct the subsequence\n",
    "        indices = []\n",
    "        current = max_idx\n",
    "        while current != -1:\n",
    "            indices.append(current)\n",
    "            current = parent[current]\n",
    "        \n",
    "        return indices[::-1]  # Reverse to get correct order\n",
    "    \n",
    "    def find_nearby_values(self, selected_f_values, all_f_values, selected_indices, \n",
    "                          all_indices, threshold_ratio=0.1):\n",
    "        \"\"\"查找序列边界附近的点\"\"\"\n",
    "        if len(selected_f_values) == 0:\n",
    "            return []\n",
    "        \n",
    "        # Get unselected values\n",
    "        selected_set = set(selected_indices)\n",
    "        unselected_mask = [i not in selected_set for i in range(len(all_f_values))]\n",
    "        \n",
    "        # Calculate threshold based on the range of selected values\n",
    "        f_range = max(selected_f_values) - min(selected_f_values)\n",
    "        threshold = f_range * threshold_ratio if f_range > 0 else 1.0\n",
    "        \n",
    "        # Get end values of the sequence\n",
    "        start_value = selected_f_values[0]\n",
    "        end_value = selected_f_values[-1]\n",
    "        \n",
    "        additional_indices = []\n",
    "        \n",
    "        # Check each unselected value\n",
    "        for i, (f_val, is_unselected) in enumerate(zip(all_f_values, unselected_mask)):\n",
    "            if is_unselected:\n",
    "                # Check if close to either end\n",
    "                if abs(f_val - start_value) <= threshold or abs(f_val - end_value) <= threshold:\n",
    "                    # Also check that this F value isn't already in our selected set\n",
    "                    if f_val not in selected_f_values:\n",
    "                        additional_indices.append(i)\n",
    "        \n",
    "        return additional_indices\n",
    "    \n",
    "    def remove_pattern_breaking_duplicates(self, group_df, sequence_type):\n",
    "        \"\"\"移除破坏模式的重复值\"\"\"\n",
    "        # Sort by EigenValue\n",
    "        group_sorted = group_df.sort_values(self.eigen_col)\n",
    "        f_values = group_sorted[self.f_col].values\n",
    "        indices = group_sorted.index.tolist()\n",
    "        \n",
    "        # Find duplicates\n",
    "        f_counts = pd.Series(f_values).value_counts()\n",
    "        duplicate_f_values = f_counts[f_counts > 1].index.tolist()\n",
    "        \n",
    "        if not duplicate_f_values:\n",
    "            return indices  # No duplicates, keep all\n",
    "        \n",
    "        indices_to_keep = []\n",
    "        \n",
    "        for i, (idx, f_val) in enumerate(zip(indices, f_values)):\n",
    "            if f_val not in duplicate_f_values:\n",
    "                # Not a duplicate, keep it\n",
    "                indices_to_keep.append(idx)\n",
    "            else:\n",
    "                # For duplicates, check if this instance fits the pattern\n",
    "                keep_this = True\n",
    "                \n",
    "                # Check local pattern consistency\n",
    "                if i > 0 and i < len(f_values) - 1:\n",
    "                    prev_f = f_values[i-1]\n",
    "                    next_f = f_values[i+1]\n",
    "                    \n",
    "                    if sequence_type == 'increasing':\n",
    "                        # In increasing sequence, current should be between prev and next\n",
    "                        if not (prev_f <= f_val <= next_f):\n",
    "                            keep_this = False\n",
    "                    else:  # decreasing\n",
    "                        # In decreasing sequence, current should be between prev and next\n",
    "                        if not (prev_f >= f_val >= next_f):\n",
    "                            keep_this = False\n",
    "                \n",
    "                # Check if removing this value would create a better pattern\n",
    "                if keep_this and i > 1:\n",
    "                    # Look for \"jump back\" patterns (e.g., 1,2,3,4,5,1)\n",
    "                    if abs(f_values[i-2] - f_val) < abs(f_values[i-1] - f_val):\n",
    "                        keep_this = False\n",
    "                \n",
    "                if keep_this:\n",
    "                    indices_to_keep.append(idx)\n",
    "        \n",
    "        return indices_to_keep\n",
    "    \n",
    "    def remove_all_f_duplicates(self, group_df):\n",
    "        \"\"\"移除所有F值重复项\"\"\"\n",
    "        # Sort by EigenValue to ensure we keep the first occurrence by EigenValue order\n",
    "        group_sorted = group_df.sort_values(self.eigen_col)\n",
    "        \n",
    "        # Keep only the first occurrence of each F value\n",
    "        group_deduped = group_sorted.drop_duplicates(subset=[self.f_col], keep='first')\n",
    "        \n",
    "        return group_deduped\n",
    "    \n",
    "    def process(self, nearby_threshold=0.1, min_group_size=3):\n",
    "        \"\"\"\n",
    "        增强处理流程，记录每一步的状态\n",
    "        \n",
    "        参数:\n",
    "        - nearby_threshold: 边界扩展阈值比例 (默认: 0.1)\n",
    "        - min_group_size: 最小分组保留行数 (默认: 3)\n",
    "        \"\"\"\n",
    "        # 初始化过程追踪\n",
    "        self.df['Process_Step'] = \"初始分组\"\n",
    "        self.df['Selection_Reason'] = \"未处理\"\n",
    "        self.df['Sequence_Type'] = \"\"\n",
    "        self.df['Group_Status'] = \"有效分组\"\n",
    "        self.df['Duplication_Status'] = \"未检查\"\n",
    "        \n",
    "        # 添加分组ID\n",
    "        self.df['GroupID'] = self.df.groupby(self.group_cols).ngroup()\n",
    "        \n",
    "        # 排序\n",
    "        self.df = self.df.sort_values(by=self.group_cols + [self.eigen_col])\n",
    "        \n",
    "        # 记录初始统计\n",
    "        initial_group_count = self.df['GroupID'].nunique()\n",
    "        initial_row_count = len(self.df)\n",
    "        \n",
    "        selected_indices = []\n",
    "        group_sequence_types = {}\n",
    "        process_details = []\n",
    "\n",
    "        # 阶段1: 寻找最长单调序列\n",
    "        for group_id, group_df in self.df.groupby('GroupID'):\n",
    "            group_size = len(group_df)\n",
    "            f_values = group_df[self.f_col].values\n",
    "            group_indices = group_df.index.tolist()\n",
    "            \n",
    "            # 标记当前处理组\n",
    "            self.df.loc[group_indices, 'Process_Step'] = \"序列分析阶段\"\n",
    "            \n",
    "            if group_size <= 1:\n",
    "                # 标记小分组\n",
    "                self.df.loc[group_indices, 'Group_Status'] = f\"无效分组(大小={group_size})\"\n",
    "                process_details.append({\n",
    "                    'GroupID': group_id,\n",
    "                    'Step': \"跳过\",\n",
    "                    'Reason': f\"分组大小={group_size}\",\n",
    "                    'Selected_Count': 0,\n",
    "                    'Total': group_size\n",
    "                })\n",
    "                continue\n",
    "            \n",
    "            # 查找最长序列\n",
    "            inc_indices = self.find_longest_monotonic_subsequence(f_values, increasing=True)\n",
    "            dec_indices = self.find_longest_monotonic_subsequence(f_values, increasing=False)\n",
    "            \n",
    "            if len(inc_indices) >= len(dec_indices):\n",
    "                best_indices = inc_indices\n",
    "                sequence_type = \"递增\"\n",
    "            else:\n",
    "                best_indices = dec_indices\n",
    "                sequence_type = \"递减\"\n",
    "            \n",
    "            group_sequence_types[group_id] = sequence_type\n",
    "            \n",
    "            # 记录序列类型\n",
    "            self.df.loc[group_indices, 'Sequence_Type'] = sequence_type\n",
    "            \n",
    "            # 标记选择的点\n",
    "            selected_group_indices = [group_indices[i] for i in best_indices]\n",
    "            self.df.loc[selected_group_indices, 'Selection_Reason'] = \"核心序列点\"\n",
    "            self.df.loc[selected_group_indices, 'Process_Step'] = \"初始序列选择\"\n",
    "            \n",
    "            # 查找边界点\n",
    "            selected_f = [f_values[i] for i in best_indices]\n",
    "            additional_local_indices = self.find_nearby_values(\n",
    "                selected_f, f_values, best_indices, \n",
    "                list(range(len(f_values))), nearby_threshold\n",
    "            )\n",
    "            additional_indices = [group_indices[i] for i in additional_local_indices]\n",
    "            \n",
    "            # 标记边界点\n",
    "            if additional_indices:\n",
    "                self.df.loc[additional_indices, 'Selection_Reason'] = \"边界扩展点\"\n",
    "                self.df.loc[additional_indices, 'Process_Step'] = \"边界扩展\"\n",
    "            \n",
    "            # 合并选择点\n",
    "            all_selected = selected_group_indices + additional_indices\n",
    "            selected_indices.extend(all_selected)\n",
    "            \n",
    "            # 记录处理详情\n",
    "            process_details.append({\n",
    "                'GroupID': group_id,\n",
    "                'Step': \"序列选择\",\n",
    "                'Reason': f\"序列类型={sequence_type}, 长度={len(best_indices)}\",\n",
    "                'Selected_Count': len(all_selected),\n",
    "                'Total': group_size\n",
    "            })\n",
    "        \n",
    "        # 创建中间结果\n",
    "        intermediate_df = self.df.loc[selected_indices].copy()\n",
    "        intermediate_df['GroupID'] = self.df.loc[selected_indices, 'GroupID']\n",
    "        \n",
    "        # 阶段2: 模式保持去重\n",
    "        final_indices = []\n",
    "        for group_id, group_df in intermediate_df.groupby('GroupID'):\n",
    "            group_indices = group_df.index.tolist()\n",
    "            sequence_type = group_sequence_types.get(group_id, '递增')\n",
    "            \n",
    "            # 标记当前处理组\n",
    "            self.df.loc[group_indices, 'Process_Step'] = \"模式去重阶段\"\n",
    "            \n",
    "            clean_indices = self.remove_pattern_breaking_duplicates(group_df, sequence_type)\n",
    "            removed_indices = list(set(group_indices) - set(clean_indices))\n",
    "            \n",
    "            # 标记移除点\n",
    "            if removed_indices:\n",
    "                self.df.loc[removed_indices, 'Duplication_Status'] = \"模式破坏点\"\n",
    "                self.df.loc[removed_indices, 'Selection_Reason'] = \"模式去重移除\"\n",
    "            \n",
    "            # 标记保留点\n",
    "            self.df.loc[clean_indices, 'Duplication_Status'] = \"模式一致点\"\n",
    "            \n",
    "            final_indices.extend(clean_indices)\n",
    "            \n",
    "            # 记录处理详情\n",
    "            process_details.append({\n",
    "                'GroupID': group_id,\n",
    "                'Step': \"模式去重\",\n",
    "                'Reason': f\"移除{len(removed_indices)}个破坏点\",\n",
    "                'Selected_Count': len(clean_indices),\n",
    "                'Total': len(group_indices)\n",
    "            })\n",
    "        \n",
    "        # 创建结果\n",
    "        self.result_df = self.df.loc[final_indices].copy()\n",
    "        self.result_df['GroupID'] = self.df.loc[final_indices, 'GroupID']\n",
    "        \n",
    "        # 阶段3: 过滤小分组\n",
    "        group_sizes = self.result_df.groupby('GroupID').size()\n",
    "        valid_groups = group_sizes[group_sizes >= min_group_size].index\n",
    "        invalid_groups = set(self.result_df['GroupID'].unique()) - set(valid_groups)\n",
    "        \n",
    "        # 标记无效分组\n",
    "        for group_id in invalid_groups:\n",
    "            group_indices = self.result_df[self.result_df['GroupID'] == group_id].index\n",
    "            self.df.loc[group_indices, 'Group_Status'] = f\"无效分组(大小={len(group_indices)})\"\n",
    "            self.df.loc[group_indices, 'Selection_Reason'] = \"小分组移除\"\n",
    "        \n",
    "        self.result_df = self.result_df[self.result_df['GroupID'].isin(valid_groups)].copy()\n",
    "        \n",
    "        # 记录分组过滤\n",
    "        process_details.append({\n",
    "            'GroupID': \"ALL\",\n",
    "            'Step': \"分组过滤\",\n",
    "            'Reason': f\"最小分组大小={min_group_size}\",\n",
    "            'Selected_Count': len(valid_groups),\n",
    "            'Total': len(group_sizes)\n",
    "        })\n",
    "        \n",
    "        # 阶段4: 重新编号分组\n",
    "        old_to_new_group = {old_id: new_id for new_id, old_id in \n",
    "                           enumerate(sorted(self.result_df['GroupID'].unique()))}\n",
    "        self.result_df['GroupID'] = self.result_df['GroupID'].map(old_to_new_group)\n",
    "        \n",
    "        # 更新原始数据中的分组ID\n",
    "        self.df['New_GroupID'] = self.df['GroupID'].map(old_to_new_group)\n",
    "        self.df.loc[self.df['New_GroupID'].isna(), 'New_GroupID'] = -1\n",
    "        \n",
    "        # 阶段5: 最终去重\n",
    "        final_result_list = []\n",
    "        duplicate_removal_details = []\n",
    "        \n",
    "        for group_id, group_df in self.result_df.groupby('GroupID'):\n",
    "            cleaned_group = self.remove_all_f_duplicates(group_df)\n",
    "            removed_count = len(group_df) - len(cleaned_group)\n",
    "            \n",
    "            # 标记被移除的重复点\n",
    "            removed_indices = list(set(group_df.index) - set(cleaned_group.index))\n",
    "            if removed_indices:\n",
    "                self.df.loc[removed_indices, 'Duplication_Status'] = \"最终重复点\"\n",
    "                self.df.loc[removed_indices, 'Selection_Reason'] = \"最终去重移除\"\n",
    "            \n",
    "            final_result_list.append(cleaned_group)\n",
    "            \n",
    "            # 记录去重详情\n",
    "            duplicate_removal_details.append({\n",
    "                'GroupID': group_id,\n",
    "                'Original_Count': len(group_df),\n",
    "                'Final_Count': len(cleaned_group),\n",
    "                'Duplicates_Removed': removed_count\n",
    "            })\n",
    "        \n",
    "        if final_result_list:\n",
    "            self.result_df = pd.concat(final_result_list, ignore_index=False)\n",
    "        else:\n",
    "            self.result_df = pd.DataFrame()\n",
    "        \n",
    "        # 标记最终选择点\n",
    "        self.df['Selected'] = False\n",
    "        if not self.result_df.empty:\n",
    "            self.df.loc[self.result_df.index, 'Selected'] = True\n",
    "            self.df.loc[self.result_df.index, 'Process_Step'] = \"最终选择\"\n",
    "            self.df.loc[self.result_df.index, 'Selection_Reason'] = \"最终保留点\"\n",
    "        \n",
    "        # 创建详细处理报告\n",
    "        process_report = pd.DataFrame(process_details)\n",
    "        duplicate_report = pd.DataFrame(duplicate_removal_details)\n",
    "        \n",
    "        # 最终统计\n",
    "        final_group_count = self.result_df['GroupID'].nunique() if not self.result_df.empty else 0\n",
    "        final_row_count = len(self.result_df)\n",
    "        \n",
    "        summary = {\n",
    "            '初始分组数': initial_group_count,\n",
    "            '初始行数': initial_row_count,\n",
    "            '最终分组数': final_group_count,\n",
    "            '最终行数': final_row_count,\n",
    "            '行减少百分比': (1 - final_row_count/initial_row_count)*100 if initial_row_count else 0,\n",
    "            '分组减少百分比': (1 - final_group_count/initial_group_count)*100 if initial_group_count else 0,\n",
    "            '平均分组大小': final_row_count/final_group_count if final_group_count else 0,\n",
    "            '处理时间': datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n",
    "            '分析参数': self.f_col\n",
    "        }\n",
    "        \n",
    "        # 添加处理报告到类属性\n",
    "        self.process_report = process_report\n",
    "        self.duplicate_report = duplicate_report\n",
    "        self.summary_report = pd.DataFrame([summary])\n",
    "        \n",
    "        print(f\"\\n处理完成! 保留 {final_row_count}/{initial_row_count} 行\")\n",
    "        print(f\"分组数: {final_group_count}/{initial_group_count}\")\n",
    "        \n",
    "        return self.result_df\n",
    "    \n",
    "    def export_results(self, filename='deduplication_results.xlsx'):\n",
    "        \"\"\"导出详细处理结果到Excel\"\"\"\n",
    "        # 确保目录存在 - 修复空路径问题\n",
    "        dir_path = os.path.dirname(filename)\n",
    "        if dir_path and not os.path.exists(dir_path):\n",
    "            os.makedirs(dir_path, exist_ok=True)\n",
    "        \n",
    "        # 使用绝对路径避免混淆\n",
    "        abs_path = os.path.abspath(filename)\n",
    "        \n",
    "        with pd.ExcelWriter(abs_path) as writer:\n",
    "            # 原始数据（含过程追踪）\n",
    "            # self.df.to_excel(writer, sheet_name='原始数据', index=False)\n",
    "            \n",
    "            # # 处理后的数据\n",
    "            # if not self.result_df.empty:\n",
    "            #     # self.result_df.to_excel(writer, sheet_name='处理后数据', index=False)\n",
    "            \n",
    "            # # 处理过程报告\n",
    "            # if hasattr(self, 'process_report'):\n",
    "            #     # self.process_report.to_excel(writer, sheet_name='处理步骤', index=False)\n",
    "            \n",
    "            # 去重报告\n",
    "            # if hasattr(self, 'duplicate_report'):\n",
    "            #     # self.duplicate_report.to_excel(writer, sheet_name='去重详情', index=False)\n",
    "            \n",
    "            # 汇总统计\n",
    "            # if hasattr(self, 'summary_report'):\n",
    "            #     # self.summary_report.to_excel(writer, sheet_name='汇总统计', index=False)\n",
    "            \n",
    "            # 添加说明页\n",
    "            notes = pd.DataFrame({\n",
    "                '列名': [\n",
    "                    'Process_Step', 'Selection_Reason', 'Sequence_Type', \n",
    "                    'Group_Status', 'Duplication_Status', 'Selected', 'New_GroupID'\n",
    "                ],\n",
    "                '说明': [\n",
    "                    '数据处理步骤（原始数据、序列分析、边界扩展等）',\n",
    "                    '数据点被选择或移除的原因',\n",
    "                    '分组内的序列类型（递增/递减）',\n",
    "                    '分组状态（有效/无效）',\n",
    "                    '重复点状态（模式破坏点、最终重复点等）',\n",
    "                    '最终是否被选择',\n",
    "                    '重新编号后的分组ID'\n",
    "                ]\n",
    "            })\n",
    "            # notes.to_excel(writer, sheet_name='说明', index=False)\n",
    "        \n",
    "        print(f\"结果已导出到: {abs_path}\")\n",
    "        return abs_path\n",
    "\n",
    "    # def get_summary(self):\n",
    "    #     \"\"\"获取处理摘要\"\"\"\n",
    "    #     if hasattr(self, 'summary_report'):\n",
    "    #         return self.summary_report\n",
    "    #     return \"无可用摘要\"\n",
    "\n",
    "\n",
    "# 示例使用\n",
    "# 修改后的示例使用部分\n",
    "if __name__ == \"__main__\":\n",
    "    # 假设 cleaned_df 已加载\n",
    "    try:\n",
    "        # 使用预过滤数据\n",
    "        data = cleaned_df[cleaned_df['type'] == 2].copy()\n",
    "        \n",
    "        # 定义要保留的列\n",
    "        columns_to_keep = [\n",
    "            'B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', \n",
    "            'meshsz', 'n', 'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', \n",
    "            'yusn', 'yuss', 'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', \n",
    "            'type', 'Bcf1f', 'Bcf2f', 'Bcf3f', 'Bcff', 'BoltB', 'BoltD', \n",
    "            'F', 'SFcf2f'\n",
    "        ]\n",
    "        \n",
    "        # 定义分组列和要分析的参数列表\n",
    "        group_columns = ['cf1f','cf2f','cf3f','H','B','T1','T2','L','n',\n",
    "                         'meshsz','yfss']\n",
    "        f_columns = ['Imperfectfactor',  'sfricn','pbol', 'F']  # 要作为f_col分析的列\n",
    "        \n",
    "        # 存储所有参数的结果\n",
    "        all_results = []\n",
    "        \n",
    "        # 为每个参数运行分析\n",
    "        for f_col in f_columns:\n",
    "            print(f\"\\n{'='*50}\")\n",
    "            print(f\"开始处理参数: {f_col}\")\n",
    "            print(f\"{'='*50}\")\n",
    "            \n",
    "            # 动态构造 group_cols：包括 group_columns 和 f_columns 中除当前 f_col 以外的列\n",
    "            new_group_cols = group_columns + [col for col in f_columns if col != f_col]\n",
    "            print('new_group_cols',new_group_cols)\n",
    "            # 初始化增强版去重器\n",
    "            deduplicator = GroupBasedDeduplicator(\n",
    "                df=data.copy(),  # 每次使用原始数据的副本\n",
    "                group_cols=new_group_cols,\n",
    "                eigen_col='EigenValue',\n",
    "                f_col=f_col\n",
    "            )\n",
    "            \n",
    "            # 处理数据\n",
    "            result_df = deduplicator.process(nearby_threshold=0.1, min_group_size=3)\n",
    "            \n",
    "            # 导出详细结果\n",
    "            report_filename = f\"{f_col}_分析报告.xlsx\"\n",
    "            # report_path = deduplicator.export_results(report_filename)\n",
    "            # print(f\"参数 {f_col} 的报告已生成: {report_path}\")\n",
    "            \n",
    "            # 获取统计摘要\n",
    "            print(f\"\\n{f_col} 处理摘要:\")\n",
    "            # print(deduplicator.get_summary())\n",
    "            \n",
    "            # 准备当前参数的结果\n",
    "            if not result_df.empty:\n",
    "                # 只保留指定列\n",
    "                current_result = result_df[columns_to_keep].copy()\n",
    "                # 添加分析参数标记\n",
    "                current_result['Analysis_Parameter'] = f_col\n",
    "                all_results.append(current_result)\n",
    "            \n",
    "            # 清理内存\n",
    "            del deduplicator\n",
    "            import gc\n",
    "            gc.collect()\n",
    "            \n",
    "        # 合并所有参数的结果\n",
    "        if all_results:\n",
    "            final_df2 = pd.concat(all_results, ignore_index=True)\n",
    "            print(\"\\n所有参数分析完成! 正在生成最终合并结果...\")\n",
    "            \n",
    "            # 导出最终结果\n",
    "            final_filename = \"最终合并结果2.xlsx\"\n",
    "            final_path = os.path.abspath(final_filename)\n",
    "            # final_df2.to_excel(final_path, index=False)\n",
    "            print(f\"最终合并结果已保存到: {final_path}\")\n",
    "            \n",
    "            # 打印最终统计\n",
    "            print(\"\\n最终合并结果统计:\")\n",
    "            print(f\"总行数: {len(final_df2)}\")\n",
    "            print(f\"分析参数分布:\")\n",
    "            print(final_df['Analysis_Parameter'].value_counts())\n",
    "        else:\n",
    "            print(\"\\n所有参数分析完成，但未生成有效结果\")\n",
    "        \n",
    "        print(\"\\n处理流程全部完成!\")\n",
    "        \n",
    "    except NameError:\n",
    "        print(\"请先加载数据到cleaned_df\")\n",
    "        print(\"示例: cleaned_df = pd.read_excel('your_data.xlsx')\")\n",
    "result_df = pd.DataFrame()\n",
    "# 示例使用\n",
    "# 修改后的示例使用部分\n",
    "if __name__ == \"__main__\":\n",
    "    # 假设 cleaned_df 已加载\n",
    "    try:\n",
    "        # 使用预过滤数据\n",
    "        data = cleaned_df[cleaned_df['type'] == 1].copy()\n",
    "        \n",
    "        # 定义要保留的列\n",
    "        columns_to_keep = [\n",
    "            'B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', \n",
    "            'meshsz', 'n', 'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', \n",
    "            'yusn', 'yuss', 'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', \n",
    "            'type', 'Bcf1f', 'Bcf2f', 'Bcf3f', 'Bcff', 'BoltB', 'BoltD', \n",
    "            'F', 'SFcf2f'\n",
    "        ]\n",
    "        \n",
    "        # 定义分组列和要分析的参数列表\n",
    "        group_columns = ['cf1f','cf2f','cf3f','H','B','T1','T2','L','n',\n",
    "                         'meshsz','yfss']\n",
    "        f_columns = ['Imperfectfactor',  'sfricn']  # 要作为f_col分析的列\n",
    "        \n",
    "        # 存储所有参数的结果\n",
    "        all_results = []\n",
    "        \n",
    "        # 为每个参数运行分析\n",
    "        for f_col in f_columns:\n",
    "            print(f\"\\n{'='*50}\")\n",
    "            print(f\"开始处理参数: {f_col}\")\n",
    "            print(f\"{'='*50}\")\n",
    "            \n",
    "            # 动态构造 group_cols：包括 group_columns 和 f_columns 中除当前 f_col 以外的列\n",
    "            new_group_cols = group_columns + [col for col in f_columns if col != f_col]\n",
    "            print('new_group_cols',new_group_cols)\n",
    "            # 初始化增强版去重器\n",
    "            deduplicator = GroupBasedDeduplicator(\n",
    "                df=data.copy(),  # 每次使用原始数据的副本\n",
    "                group_cols=new_group_cols,\n",
    "                eigen_col='EigenValue',\n",
    "                f_col=f_col\n",
    "            )\n",
    "            \n",
    "            # 处理数据\n",
    "            result_df = deduplicator.process(nearby_threshold=0.1, min_group_size=3)\n",
    "            \n",
    "            # 导出详细结果\n",
    "            report_filename = f\"{f_col}_分析报告.xlsx\"\n",
    "            # report_path = deduplicator.export_results(report_filename)\n",
    "            # print(f\"参数 {f_col} 的报告已生成: {report_path}\")\n",
    "            \n",
    "            # 获取统计摘要\n",
    "            print(f\"\\n{f_col} 处理摘要:\")\n",
    "            # print(deduplicator.get_summary())\n",
    "            \n",
    "            # 准备当前参数的结果\n",
    "            if not result_df.empty:\n",
    "                # 只保留指定列\n",
    "                current_result = result_df[columns_to_keep].copy()\n",
    "                # 添加分析参数标记\n",
    "                current_result['Analysis_Parameter'] = f_col\n",
    "                all_results.append(current_result)\n",
    "            \n",
    "            # 清理内存\n",
    "            del deduplicator\n",
    "            import gc\n",
    "            gc.collect()\n",
    "            \n",
    "        # 合并所有参数的结果\n",
    "        if all_results:\n",
    "            final_df1 = pd.concat(all_results, ignore_index=True)\n",
    "            print(\"\\n所有参数分析完成! 正在生成最终合并结果...\")\n",
    "            \n",
    "            # 导出最终结果\n",
    "            final_filename = \"最终合并结果1.xlsx\"\n",
    "            final_path = os.path.abspath(final_filename)\n",
    "            # final_df1.to_excel(final_path, index=False)\n",
    "            print(f\"最终合并结果已保存到: {final_path}\")\n",
    "            \n",
    "            # 打印最终统计\n",
    "            print(\"\\n最终合并结果统计:\")\n",
    "            print(f\"总行数: {len(final_df1)}\")\n",
    "            print(f\"分析参数分布:\")\n",
    "            print(final_df['Analysis_Parameter'].value_counts())\n",
    "        else:\n",
    "            print(\"\\n所有参数分析完成，但未生成有效结果\")\n",
    "        \n",
    "        print(\"\\n处理流程全部完成!\")\n",
    "        \n",
    "    except NameError:\n",
    "        print(\"请先加载数据到cleaned_df\")\n",
    "        print(\"示例: cleaned_df = pd.read_excel('your_data.xlsx')\")\n",
    "result_df = pd.DataFrame()\n",
    "# 示例使用\n",
    "# 修改后的示例使用部分\n",
    "if __name__ == \"__main__\":\n",
    "    # 假设 cleaned_df 已加载\n",
    "    try:\n",
    "        # 使用预过滤数据\n",
    "        data = cleaned_df[cleaned_df['type'] == 0].copy()\n",
    "        \n",
    "        # 定义要保留的列\n",
    "        columns_to_keep = [\n",
    "            'B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', \n",
    "            'meshsz', 'n', 'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', \n",
    "            'yusn', 'yuss', 'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', \n",
    "            'type', 'Bcf1f', 'Bcf2f', 'Bcf3f', 'Bcff', 'BoltB', 'BoltD', \n",
    "            'F', 'SFcf2f'\n",
    "        ]\n",
    "        \n",
    "        # 定义分组列和要分析的参数列表\n",
    "        group_columns = ['cf1f','cf2f','cf3f','H','B','T1','T2','L','n',\n",
    "                         'meshsz','yfss']\n",
    "        f_columns = ['Imperfectfactor']  # 要作为f_col分析的列\n",
    "        \n",
    "        # 存储所有参数的结果\n",
    "        all_results = []\n",
    "        \n",
    "        # 为每个参数运行分析\n",
    "        for f_col in f_columns:\n",
    "            print(f\"\\n{'='*50}\")\n",
    "            print(f\"开始处理参数: {f_col}\")\n",
    "            print(f\"{'='*50}\")\n",
    "            \n",
    "            # 动态构造 group_cols：包括 group_columns 和 f_columns 中除当前 f_col 以外的列\n",
    "            new_group_cols = group_columns + [col for col in f_columns if col != f_col]\n",
    "            print('new_group_cols',new_group_cols)\n",
    "            # 初始化增强版去重器\n",
    "            deduplicator = GroupBasedDeduplicator(\n",
    "                df=data.copy(),  # 每次使用原始数据的副本\n",
    "                group_cols=new_group_cols,\n",
    "                eigen_col='EigenValue',\n",
    "                f_col=f_col\n",
    "            )\n",
    "            \n",
    "            # 处理数据\n",
    "            result_df = deduplicator.process(nearby_threshold=0.1, min_group_size=3)\n",
    "            \n",
    "            # 导出详细结果\n",
    "            report_filename = f\"{f_col}_分析报告.xlsx\"\n",
    "            # report_path = deduplicator.export_results(report_filename)\n",
    "            # print(f\"参数 {f_col} 的报告已生成: {report_path}\")\n",
    "            \n",
    "            # 获取统计摘要\n",
    "            # print(f\"\\n{f_col} 处理摘要:\")\n",
    "            # print(deduplicator.get_summary())\n",
    "            \n",
    "            # 准备当前参数的结果\n",
    "            if not result_df.empty:\n",
    "                # 只保留指定列\n",
    "                current_result = result_df[columns_to_keep].copy()\n",
    "                # 添加分析参数标记\n",
    "                current_result['Analysis_Parameter'] = f_col\n",
    "                all_results.append(current_result)\n",
    "            \n",
    "            # 清理内存\n",
    "            del deduplicator\n",
    "            import gc\n",
    "            gc.collect()\n",
    "            \n",
    "        # 合并所有参数的结果\n",
    "        if all_results:\n",
    "            final_df0 = pd.concat(all_results, ignore_index=True)\n",
    "            print(\"\\n所有参数分析完成! 正在生成最终合并结果...\")\n",
    "            \n",
    "            # 导出最终结果\n",
    "            final_filename = \"最终合并结果0.xlsx\"\n",
    "            final_path = os.path.abspath(final_filename)\n",
    "            # final_df0.to_excel(final_path, index=False)\n",
    "            print(f\"最终合并结果已保存到: {final_path}\")\n",
    "            \n",
    "            # 打印最终统计\n",
    "            print(\"\\n最终合并结果统计:\")\n",
    "            print(f\"总行数: {len(final_df0)}\")\n",
    "            print(f\"分析参数分布:\")\n",
    "            print(final_df['Analysis_Parameter'].value_counts())\n",
    "        else:\n",
    "            print(\"\\n所有参数分析完成，但未生成有效结果\")\n",
    "        \n",
    "        print(\"\\n处理流程全部完成!\")\n",
    "        \n",
    "    except NameError:\n",
    "        print(\"请先加载数据到cleaned_df\")\n",
    "        print(\"示例: cleaned_df = pd.read_excel('your_data.xlsx')\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "c022892a-de7a-4eb1-b448-0e8ec62ea7ac",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "final_df0 列: Index(['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
      "       'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
      "       'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', 'type', 'Bcf1f', 'Bcf2f',\n",
      "       'Bcf3f', 'Bcff', 'BoltB', 'BoltD', 'F', 'SFcf2f', 'Analysis_Parameter'],\n",
      "      dtype='object')\n",
      "final_df1 列: Index(['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
      "       'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
      "       'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', 'type', 'Bcf1f', 'Bcf2f',\n",
      "       'Bcf3f', 'Bcff', 'BoltB', 'BoltD', 'F', 'SFcf2f', 'Analysis_Parameter'],\n",
      "      dtype='object')\n",
      "final_df 列: Index(['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
      "       'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
      "       'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', 'type', 'Bcf1f', 'Bcf2f',\n",
      "       'Bcf3f', 'Bcff', 'BoltB', 'BoltD', 'F', 'SFcf2f', 'Analysis_Parameter'],\n",
      "      dtype='object')\n",
      "final_df0 行数: 3682\n",
      "final_df1 行数: 4362\n",
      "final_df2 行数: 50740\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "      <th>Analysis_Parameter</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>260481.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.0</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>520963.90</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.0</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>643654.10</td>\n",
       "      <td>400.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>9.432234e+08</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>40.950000</td>\n",
       "      <td>81.900000</td>\n",
       "      <td>2.916</td>\n",
       "      <td>6.315615</td>\n",
       "      <td>600.0</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>821459.10</td>\n",
       "      <td>600.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>1.414835e+09</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>27.300000</td>\n",
       "      <td>54.600000</td>\n",
       "      <td>1.944</td>\n",
       "      <td>4.210410</td>\n",
       "      <td>600.0</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>906805.50</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>6.437500e+10</td>\n",
       "      <td>1.273352e+10</td>\n",
       "      <td>1.287500e+11</td>\n",
       "      <td>5.055556</td>\n",
       "      <td>10.111111</td>\n",
       "      <td>1.000</td>\n",
       "      <td>1.753031</td>\n",
       "      <td>200.0</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150534</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150535</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150536</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150537</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150538</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>90378 rows × 113 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            B   cf1f  cf2f       cf3f       H  Imperfectfactor       L  \\\n",
       "0        50.0  0.000   1.0  260481.95   100.0            0.002  3000.0   \n",
       "1        50.0  0.000   1.0  520963.90   100.0            0.002  3000.0   \n",
       "6        50.0  0.000   1.0  643654.10   400.0            0.002  3000.0   \n",
       "7        50.0  0.000   1.0  821459.10   600.0            0.002  3000.0   \n",
       "8        50.0  0.000   1.0  906805.50   200.0            0.002  3000.0   \n",
       "...       ...    ...   ...        ...     ...              ...     ...   \n",
       "150534  300.0  1.732   1.0       0.00  1000.0            0.002  3000.0   \n",
       "150535  300.0  1.732   1.0       0.00  1000.0            0.002  3000.0   \n",
       "150536  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0   \n",
       "150537  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0   \n",
       "150538  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0   \n",
       "\n",
       "        meshsz    n      pbol  ...             G       EI_edge            Dh  \\\n",
       "0         40.0  1.0      90.0  ...  79230.769231  1.502083e+10  2.358059e+08   \n",
       "1         40.0  2.0      90.0  ...  79230.769231  1.502083e+10  2.358059e+08   \n",
       "6         20.0  1.0      90.0  ...  79230.769231  3.862500e+10  9.432234e+08   \n",
       "7         20.0  1.0      90.0  ...  79230.769231  3.862500e+10  1.414835e+09   \n",
       "8         20.0  1.0      90.0  ...  79230.769231  6.437500e+10  1.273352e+10   \n",
       "...        ...  ...       ...  ...           ...           ...           ...   \n",
       "150534    40.0  5.0  125000.0  ...           NaN           NaN           NaN   \n",
       "150535    40.0  5.0  125000.0  ...           NaN           NaN           NaN   \n",
       "150536    40.0  5.0  125000.0  ...           NaN           NaN           NaN   \n",
       "150537    40.0  5.0  125000.0  ...           NaN           NaN           NaN   \n",
       "150538    40.0  5.0  125000.0  ...           NaN           NaN           NaN   \n",
       "\n",
       "              EI_mid  gamma_edge   gamma_mid   beta     beta2  L_to_tw  \\\n",
       "0       3.004167e+10   63.700000  127.400000  0.686  1.751391    600.0   \n",
       "1       3.004167e+10   63.700000  127.400000  0.686  1.751391    600.0   \n",
       "6       7.725000e+10   40.950000   81.900000  2.916  6.315615    600.0   \n",
       "7       7.725000e+10   27.300000   54.600000  1.944  4.210410    600.0   \n",
       "8       1.287500e+11    5.055556   10.111111  1.000  1.753031    200.0   \n",
       "...              ...         ...         ...    ...       ...      ...   \n",
       "150534           NaN         NaN         NaN    NaN       NaN      NaN   \n",
       "150535           NaN         NaN         NaN    NaN       NaN      NaN   \n",
       "150536           NaN         NaN         NaN    NaN       NaN      NaN   \n",
       "150537           NaN         NaN         NaN    NaN       NaN      NaN   \n",
       "150538           NaN         NaN         NaN    NaN       NaN      NaN   \n",
       "\n",
       "        Analysis_Parameter  \n",
       "0                      NaN  \n",
       "1                      NaN  \n",
       "6                      NaN  \n",
       "7                      NaN  \n",
       "8                      NaN  \n",
       "...                    ...  \n",
       "150534                   F  \n",
       "150535                   F  \n",
       "150536                   F  \n",
       "150537                   F  \n",
       "150538                   F  \n",
       "\n",
       "[90378 rows x 113 columns]"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# 纵向拼接（默认 axis=0，按行堆叠）\n",
    "combined_df = pd.concat([final_df0, final_df1, final_df2], axis=0)\n",
    "\n",
    "# 重置索引（可选）\n",
    "combined_df = combined_df.reset_index(drop=True)\n",
    "# 检查列名是否一致\n",
    "print(\"final_df0 列:\", final_df0.columns)\n",
    "print(\"final_df1 列:\", final_df1.columns)\n",
    "print(\"final_df 列:\", final_df2.columns)\n",
    "\n",
    "# 检查行数\n",
    "print(\"final_df0 行数:\", len(final_df0))\n",
    "print(\"final_df1 行数:\", len(final_df1))\n",
    "print(\"final_df2 行数:\", len(final_df2))\n",
    "# 导出为 Excel 文件\n",
    "\n",
    "\n",
    "# 定义 group_columns\n",
    "group_columns = [\n",
    "    'cf1f', 'cf2f', 'cf3f', 'type','H', 'B', 'T1', 'T2', 'L', 'n', \n",
    "    'meshsz', 'yfss','Imperfectfactor',  'sfricn','pbol', 'F']  # 要作为f_col分析的列\n",
    "\n",
    "# 合并两个 DataFrame，并添加标识列\n",
    "combined_with_origin = pd.concat([\n",
    "    cleaned_df.assign(origin='cleaneed'),     # 标记为 cleaned_df 来源\n",
    "    combined_df.assign(origin='combined')    # 标记为 combined_df 来源\n",
    "], ignore_index=True)\n",
    "\n",
    "# 按 group_columns 去重，保留 combined_df 的行\n",
    "result = combined_with_origin.drop_duplicates(\n",
    "    subset=group_columns,                     # 按 group_columns 判断重复\n",
    "    keep='last'                              # 保留最后一个出现的行（即 combined_df）\n",
    ").drop(columns='origin')      \n",
    "result\n",
    "# 删除标识列\n",
    "# result.to_excel('result.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39b507f3",
   "metadata": {},
   "source": [
    "#### 二次参数计算"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "d6a3a745",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n",
      "C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_22632\\1329231213.py:6: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  dfdelpara.eval(\"\"\"\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>ratio_eta_GJdivbyDL</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>260481.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>520963.90</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>643654.10</td>\n",
       "      <td>400.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.098813</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>9.432234e+08</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>40.950000</td>\n",
       "      <td>81.900000</td>\n",
       "      <td>2.916000</td>\n",
       "      <td>6.315615</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>821459.10</td>\n",
       "      <td>600.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.026563</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>1.414835e+09</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>27.300000</td>\n",
       "      <td>54.600000</td>\n",
       "      <td>1.944000</td>\n",
       "      <td>4.210410</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>906805.50</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>2.169314</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>6.437500e+10</td>\n",
       "      <td>1.273352e+10</td>\n",
       "      <td>1.287500e+11</td>\n",
       "      <td>5.055556</td>\n",
       "      <td>10.111111</td>\n",
       "      <td>1.000000</td>\n",
       "      <td>1.753031</td>\n",
       "      <td>200.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150534</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150535</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150536</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150537</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150538</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>90378 rows × 112 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            B   cf1f  cf2f       cf3f       H  Imperfectfactor       L  \\\n",
       "0        50.0  0.000   1.0  260481.95   100.0            0.002  3000.0   \n",
       "1        50.0  0.000   1.0  520963.90   100.0            0.002  3000.0   \n",
       "6        50.0  0.000   1.0  643654.10   400.0            0.002  3000.0   \n",
       "7        50.0  0.000   1.0  821459.10   600.0            0.002  3000.0   \n",
       "8        50.0  0.000   1.0  906805.50   200.0            0.002  3000.0   \n",
       "...       ...    ...   ...        ...     ...              ...     ...   \n",
       "150534  300.0  1.732   1.0       0.00  1000.0            0.002  3000.0   \n",
       "150535  300.0  1.732   1.0       0.00  1000.0            0.002  3000.0   \n",
       "150536  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0   \n",
       "150537  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0   \n",
       "150538  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0   \n",
       "\n",
       "        meshsz    n      pbol  ...  ratio_eta_GJdivbyDL             G  \\\n",
       "0         40.0  1.0      90.0  ...             0.519436  79230.769231   \n",
       "1         40.0  2.0      90.0  ...             0.519436  79230.769231   \n",
       "6         20.0  1.0      90.0  ...             0.098813  79230.769231   \n",
       "7         20.0  1.0      90.0  ...             0.026563  79230.769231   \n",
       "8         20.0  1.0      90.0  ...             2.169314  79230.769231   \n",
       "...        ...  ...       ...  ...                  ...           ...   \n",
       "150534    40.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "150535    40.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "150536    40.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "150537    40.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "150538    40.0  5.0  125000.0  ...             0.090017  79230.769231   \n",
       "\n",
       "             EI_edge            Dh        EI_mid  gamma_edge   gamma_mid  \\\n",
       "0       1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "1       1.502083e+10  2.358059e+08  3.004167e+10   63.700000  127.400000   \n",
       "6       3.862500e+10  9.432234e+08  7.725000e+10   40.950000   81.900000   \n",
       "7       3.862500e+10  1.414835e+09  7.725000e+10   27.300000   54.600000   \n",
       "8       6.437500e+10  1.273352e+10  1.287500e+11    5.055556   10.111111   \n",
       "...              ...           ...           ...         ...         ...   \n",
       "150534  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "150535  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "150536  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "150537  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "150538  1.668600e+13  1.293914e+11  3.337200e+13  128.957574  257.915148   \n",
       "\n",
       "            beta     beta2     L_to_tw  \n",
       "0       0.686000  1.751391  600.000000  \n",
       "1       0.686000  1.751391  600.000000  \n",
       "6       2.916000  6.315615  600.000000  \n",
       "7       1.944000  4.210410  600.000000  \n",
       "8       1.000000  1.753031  200.000000  \n",
       "...          ...       ...         ...  \n",
       "150534  1.020324  2.640928  157.894737  \n",
       "150535  1.020324  2.640928  157.894737  \n",
       "150536  1.020324  2.640928  157.894737  \n",
       "150537  1.020324  2.640928  157.894737  \n",
       "150538  1.020324  2.640928  157.894737  \n",
       "\n",
       "[90378 rows x 112 columns]"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 对于截面上的x与y的方向确定与单个H型钢截面一致\n",
    "dfdelpara=result[['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
    "       'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
    "       'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', 'type', 'Bcf1f', 'Bcf2f',\n",
    "       'Bcf3f', 'Bcff', 'BoltB', 'BoltD', 'F']]\n",
    "dfdelpara.eval(\"\"\"\n",
    "\n",
    "As1=B*T2*2*n\n",
    "As1_n=(B-T1)*T2*2*n\n",
    "\n",
    "As2=H*T1*n\n",
    "As2_n=((H-T2*2)*T1)\n",
    "As3=((H*T1)+(B-T1)*T2*2)*n\n",
    "\n",
    "Pu_fy_f1_n = As1_n * yfss/(sqrt(3))\n",
    "Pu_fy_f2_n = As2_n * yfss/(sqrt(3))\n",
    "\n",
    "\n",
    "Pu_fy_f1 = As1 * yfss/(sqrt(3))\n",
    "Pu_fy_f2 = As2 * yfss/(sqrt(3))\n",
    "Pu_fy_f3 = As3 * yfss\n",
    "\n",
    "\n",
    "axialratio=cf3f/Pu_fy_f3\n",
    "cf12f=sqrt(cf1f**2+cf2f**2)\n",
    "\n",
    "Pucf12f=sqrt(Pucf1f**2+Pucf2f**2)\n",
    "\n",
    "EigenValue=abs(EigenValue)\n",
    "\n",
    "Bcf1f=abs(EigenValue)*cf1f\n",
    "Bcf2f=abs(EigenValue)*cf2f\n",
    "Bcf3f=abs(EigenValue)*cf3f\n",
    "Bcf12f=abs(EigenValue)*cf12f\n",
    "\n",
    "SLcf1f_n=sqrt(abs(Pu_fy_f1_n)/abs(Bcf1f))\n",
    "SLcf2f_n=sqrt(abs(Pu_fy_f2_n)/abs(Bcf2f))\n",
    "\n",
    "\n",
    "SLcf1f=sqrt(abs(Pu_fy_f1)/abs(Bcf1f))\n",
    "SLcf2f=sqrt(abs(Pu_fy_f2)/abs(Bcf2f))\n",
    "SLcf3f=sqrt(abs(Pu_fy_f3)/abs(Bcf3f))\n",
    "\n",
    "SFcf1f_n=(abs(Pucf1f)/abs(Pu_fy_f1_n))\n",
    "SFcf2f_n=(abs(Pucf2f)/abs(Pu_fy_f2_n))\n",
    "SFcf1f=(abs(Pucf1f)/abs(Pu_fy_f1))\n",
    "SFcf2f=(abs(Pucf2f)/abs(Pu_fy_f2))\n",
    "SFcf3f=(abs(Pucf3f)/abs(Pu_fy_f3))\n",
    "\n",
    "\n",
    "CWcf1f_n=SFcf1f_n/SLcf1f\n",
    "CWcf2f_n=SFcf2f_n/SLcf2f\n",
    "CWcf1f=SFcf1f/SLcf1f\n",
    "CWcf2f=SFcf2f/SLcf2f\n",
    "CWcf3f=SFcf3f/SLcf3f\n",
    "\n",
    "KG_quge_web=(H-T2*2)/L\n",
    "KG_total_web=n*H/L\n",
    "\n",
    "KG_sing_web=H/L\n",
    "\n",
    "KG_consedge_flange=(B-T1)/2/L\n",
    "KG_midstiff_flange=(B-T1)/2/L\n",
    "\n",
    "GH_quge_web=L/T1\n",
    "\n",
    "KH_quge_web_n=(H-T2*2)/T1\n",
    "KH_quge_web=H/T1\n",
    "KH_total_web=n*H/T1\n",
    "KH_consedge_flange=(B-T1)/2/T2\n",
    "KH_midstiff_flange=(B-T1)/2/(T2*2)\n",
    "\n",
    "KH_sing_flange=B/T2\n",
    "\n",
    "\n",
    "I_single_ix=((H-2*T2)**3)*T1/12+2*B*T2**3/12+T2*B*(2*((H/2-T2/2)**2))\n",
    "I_single_iy=((H-2*T2)*T1**3)/12+(2*T2*B**3)/12\n",
    "\n",
    "I_web_quge_ix=(T1*(H-T2*2)**3)/12\n",
    "I_web_quge_iy=((H-T2*2)*T1**3)/12\n",
    "\n",
    "I_flange_consedge_ix=(B*T2**3)/12\n",
    "I_flange_consedge_iy=(T2*B**3)/12\n",
    "\n",
    "I_flange_midstiff_ix=(B*(T2*2)**3)/12\n",
    "I_flange_midstiff_iy=((T2*2)*B**3)/12\n",
    "\n",
    "I_total_webix=T1*(n*H)*(n*H)*(n*H)/12\n",
    "I_total_webiy=(n*H)*T1*T1*T1/12\n",
    "\n",
    "J_web=(H-2*T2)*((T1)**3)*(1/3-0.21*(T1)/(H-2*T2)*(1-(T1)**4/(12*(H-2*T2)**4)))\n",
    "J_consedge_half=((B-T1)/2)*((T2)**3)*(1/3-0.21*(T2)/((B-T1)/2)*(1-(T2)**4/(12*((B-T1)/2)**4)))\n",
    "J_midstiff_half=((B-T1)/2)*((T2*2)**3)*(1/3-0.21*(T2*2)/((B-T1)/2)*(1-(T2*2)**4/(12*((B-T1)/2)**4)))\n",
    "J_consedge=(B)*((T2)**3)*(1/3-0.21*(T2)/(B)*(1-(T2)**4/(12*(B)**4)))\n",
    "J_midstiff=(B)*((T2*2)**3)*(1/3-0.21*(T2*2)/(B)*(1-(T2*2)**4/(12*(B)**4)))\n",
    "\n",
    "ratio_alpha_tflange_to_tweb=T2/T1\n",
    "ratio_alpha_Bflange_to_Hn=B/(H-2*T2)\n",
    "\n",
    "\n",
    "tau_fem1=Bcf1f/As1\n",
    "tau_fem1_n=Bcf1f/As1_n\n",
    "\n",
    "tau_fem2=Bcf2f/As2\n",
    "tau_fem2_n=Bcf2f/As2_n\n",
    "\n",
    "tau_fem3=Bcf3f/As3\n",
    "\n",
    "E=2.06*10**5\n",
    "Pai=3.1415926\n",
    "\n",
    "k_taucr_fem1 =(tau_fem1*12*(1-0.3**2)*(((B)/2)**2))/((Pai**2)*E*(T2**2))\n",
    "k_taucr_fem1_n =(tau_fem1_n*12*(1-0.3**2)*(((B-T1)/2)**2))/((Pai**2)*E*(T2**2))\n",
    "\n",
    "k_taucr_fem2 =(tau_fem2*(12*(1-0.3**2)*((n*(H))**2)))/((Pai**2)*E*(T1**2))\n",
    "k_taucr_fem2_n =(tau_fem2_n*(12*(1-0.3**2)*(((H-T2*2))**2)))/((Pai**2)*E*(T1**2))\n",
    "k_taucr_fem2_beam=k_taucr_fem2*((H/L)**2)\n",
    "\n",
    "\n",
    "k_taucr_fem31 =(tau_fem3*12*(1-0.3**2)*(((B-T1)/2)**2))/((Pai**2)*E*(T2**2))\n",
    "k_taucr_fem32 =(tau_fem3*(12*(1-0.3**2)*((n*(H-T2*2))**2)))/((3.1415926**2)*E*(T1**2))\n",
    "\n",
    "ratio_axial_to_Pu_fy_f13=cf3f/Pu_fy_f3\n",
    "ratio_eta_GJdivbyDL=((E/(2*(1+0.3)))*J_consedge)/(I_web_quge_ix*L)\n",
    "\n",
    "G=E/(2*(1+0.3))\n",
    "\n",
    "EI_edge=E*((T2)*(B**3)/12)\n",
    "Dh=(E*(T1**3)*H)/(12*(1-0.3**2))\n",
    "EI_mid=E*((T2*2)*(B**3)/12)\n",
    "\n",
    "gamma_edge=EI_edge/(Dh)\n",
    "gamma_mid=EI_mid/(Dh)\n",
    "\n",
    "beta=((B/2)*(T2**3))/(H*(T1)**3)\n",
    "beta2=(J_consedge*G)/(Dh)\n",
    "\n",
    "L_to_tw=L/T1\n",
    "\"\"\", inplace=True)\n",
    "dfdelpara\n",
    "# Jv=(8(b'v)*(b'v)*2bv*2bvt*bv*bv)/(2b'vtv+bvtv)\n",
    "# Gv=E/2(1+poissonratio)\n",
    "# qugeKHB = ((H-T2)+L)-220*sqrt(235/yfss)\n",
    "# K=#竖肋的抗扭／抗弯刚度比\n",
    "# D=Ｅ＼２｛＼－ｆｉ２）# 竖肋的弹性模量\n",
    "# K=(Gv*Jv)/(Ev*Iv)#竖肋的抗扭／抗弯刚度比"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "d5184ba3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "删除后,去NaNq前 90378\n",
      "False 93884\n",
      "删除后,去NaN后 90378\n",
      "原始数据框：\n",
      "90378\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>ratio_eta_GJdivbyDL</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>260481.95</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>520963.90</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.519436</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.502083e+10</td>\n",
       "      <td>2.358059e+08</td>\n",
       "      <td>3.004167e+10</td>\n",
       "      <td>63.700000</td>\n",
       "      <td>127.400000</td>\n",
       "      <td>0.686000</td>\n",
       "      <td>1.751391</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>643654.10</td>\n",
       "      <td>400.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.098813</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>9.432234e+08</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>40.950000</td>\n",
       "      <td>81.900000</td>\n",
       "      <td>2.916000</td>\n",
       "      <td>6.315615</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>821459.10</td>\n",
       "      <td>600.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.026563</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>1.414835e+09</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>27.300000</td>\n",
       "      <td>54.600000</td>\n",
       "      <td>1.944000</td>\n",
       "      <td>4.210410</td>\n",
       "      <td>600.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>906805.50</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>2.169314</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>6.437500e+10</td>\n",
       "      <td>1.273352e+10</td>\n",
       "      <td>1.287500e+11</td>\n",
       "      <td>5.055556</td>\n",
       "      <td>10.111111</td>\n",
       "      <td>1.000000</td>\n",
       "      <td>1.753031</td>\n",
       "      <td>200.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90373</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90374</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90375</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90376</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90377</th>\n",
       "      <td>300.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.005</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>90378 rows × 112 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           B   cf1f  cf2f       cf3f       H  Imperfectfactor       L  meshsz  \\\n",
       "0       50.0  0.000   1.0  260481.95   100.0            0.002  3000.0    40.0   \n",
       "1       50.0  0.000   1.0  520963.90   100.0            0.002  3000.0    40.0   \n",
       "2       50.0  0.000   1.0  643654.10   400.0            0.002  3000.0    20.0   \n",
       "3       50.0  0.000   1.0  821459.10   600.0            0.002  3000.0    20.0   \n",
       "4       50.0  0.000   1.0  906805.50   200.0            0.002  3000.0    20.0   \n",
       "...      ...    ...   ...        ...     ...              ...     ...     ...   \n",
       "90373  300.0  1.732   1.0       0.00  1000.0            0.002  3000.0    40.0   \n",
       "90374  300.0  1.732   1.0       0.00  1000.0            0.002  3000.0    40.0   \n",
       "90375  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0    40.0   \n",
       "90376  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0    40.0   \n",
       "90377  300.0  1.732   1.0       0.00  1000.0            0.005  3000.0    40.0   \n",
       "\n",
       "         n      pbol  ...  ratio_eta_GJdivbyDL             G       EI_edge  \\\n",
       "0      1.0      90.0  ...             0.519436  79230.769231  1.502083e+10   \n",
       "1      2.0      90.0  ...             0.519436  79230.769231  1.502083e+10   \n",
       "2      1.0      90.0  ...             0.098813  79230.769231  3.862500e+10   \n",
       "3      1.0      90.0  ...             0.026563  79230.769231  3.862500e+10   \n",
       "4      1.0      90.0  ...             2.169314  79230.769231  6.437500e+10   \n",
       "...    ...       ...  ...                  ...           ...           ...   \n",
       "90373  5.0  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "90374  5.0  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "90375  5.0  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "90376  5.0  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "90377  5.0  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "\n",
       "                 Dh        EI_mid  gamma_edge   gamma_mid      beta     beta2  \\\n",
       "0      2.358059e+08  3.004167e+10   63.700000  127.400000  0.686000  1.751391   \n",
       "1      2.358059e+08  3.004167e+10   63.700000  127.400000  0.686000  1.751391   \n",
       "2      9.432234e+08  7.725000e+10   40.950000   81.900000  2.916000  6.315615   \n",
       "3      1.414835e+09  7.725000e+10   27.300000   54.600000  1.944000  4.210410   \n",
       "4      1.273352e+10  1.287500e+11    5.055556   10.111111  1.000000  1.753031   \n",
       "...             ...           ...         ...         ...       ...       ...   \n",
       "90373  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "90374  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "90375  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "90376  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "90377  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "\n",
       "          L_to_tw  \n",
       "0      600.000000  \n",
       "1      600.000000  \n",
       "2      600.000000  \n",
       "3      600.000000  \n",
       "4      200.000000  \n",
       "...           ...  \n",
       "90373  157.894737  \n",
       "90374  157.894737  \n",
       "90375  157.894737  \n",
       "90376  157.894737  \n",
       "90377  157.894737  \n",
       "\n",
       "[90378 rows x 112 columns]"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "print('删除后,去NaNq前', len(dfdelpara))\n",
    "print(dfdelpara.duplicated().any(), len(df_alltype))\n",
    "# 删除重复行\n",
    "dfdelpara = dfdelpara.drop_duplicates()\n",
    "print('删除后,去NaN后', len(dfdelpara))\n",
    "\n",
    "# 删除所有列都为NaN的行\n",
    "dfdelpara.dropna(axis=0, how='all', inplace=True)\n",
    "# 显示原始和清理后的数据框\n",
    "print(\"原始数据框：\")\n",
    "print(len(dfdelpara))\n",
    "# 指定要检查的列\n",
    "\n",
    "\n",
    "# 重置索引\n",
    "dfdelpara = dfdelpara.reset_index(drop=True)\n",
    "dfdelpara "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b9d10f76",
   "metadata": {},
   "source": [
    "### 异常值处理"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "04c71679",
   "metadata": {},
   "source": [
    "#### 冗余数据的判断与处理"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a7ba071",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-02-03T11:58:43.208361Z",
     "start_time": "2023-02-03T11:58:43.182430Z"
    }
   },
   "source": [
    "#### 缺失值识别与处理"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "62170f08",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:37.354277Z",
     "start_time": "2024-02-05T07:20:37.307439Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "88786"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 判断各变量中是否存在缺失值\n",
    "dfdelpara.isnull().any(axis = 0)\n",
    "# 各变量中缺失值的数量\n",
    "dfdelpara.isnull().sum(axis = 0)\n",
    "# 各变量中缺失值的比例\n",
    "dfdelpara.isnull().sum(axis = 0)/dfdelpara.shape[0]\n",
    "\n",
    "dfdelpara.dropna(subset=['EigenValue'], inplace=True)\n",
    "len(dfdelpara)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c3a42223",
   "metadata": {},
   "source": [
    "#### 创建单独的三类截面data集合（并在这里去重）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "a56f77ff-ef9b-4654-b41f-9e5f431c3b25",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.096293Z",
     "start_time": "2024-02-05T07:20:37.370235Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "是否有重复值dfdelparapp_pre False\n",
      "原始数据中重复值的个数为: 0\n",
      "是否有重复值data0 False 27392\n",
      "是否有重复值data1 False 19135\n",
      "是否有重复值data2 False 42259\n"
     ]
    }
   ],
   "source": [
    "# 导入相关包\n",
    "import pandas as pd                      #读取数据\n",
    "from sklearn.preprocessing import scale  #数据中心标准化\n",
    "from sklearn.decomposition import PCA    #主成分分析算法\n",
    "\n",
    "\n",
    "print('是否有重复值dfdelparapp_pre',dfdelpara.duplicated().any())\n",
    "# 记录原始数据行数\n",
    "original_rows = len(dfdelpara)\n",
    "# 删除重复行\n",
    "dfdelpara = dfdelpara.drop_duplicates()\n",
    "# 记录去重后数据行数\n",
    "unique_rows = len(dfdelpara)\n",
    "\n",
    "# 计算重复值个数\n",
    "duplicate_count = original_rows - unique_rows\n",
    "print(f\"原始数据中重复值的个数为: {duplicate_count}\")\n",
    "\n",
    "dfdelparapp=dfdelpara\n",
    "# dfdelparapp.to_excel('dfdelparapp.xlsx')\n",
    "data0pp=dfdelparapp[(dfdelparapp[str('type')]==0)]\n",
    "data1pp=dfdelparapp[(dfdelparapp[str('type')]==1)]\n",
    "data2pp=dfdelparapp[(dfdelparapp[str('type')]==2)]\n",
    "\n",
    "data0=data0pp.drop(['F','BoltB','BoltD','sfricn','pbol'],axis=1,inplace=False)\n",
    "data1=data1pp.drop(['F','BoltB','BoltD','pbol'],axis=1,inplace=False)\n",
    "data2=data2pp\n",
    "\n",
    "print('是否有重复值data0',data0.duplicated().any(),len(data0))\n",
    "print('是否有重复值data1',data1.duplicated().any(),len(data1))\n",
    "print('是否有重复值data2',data2.duplicated().any(),len(data2))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ef8e9c55",
   "metadata": {},
   "source": [
    "#### df细筛"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "a96f6cc1",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.555099Z",
     "start_time": "2024-02-05T07:20:38.097291Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>ratio_eta_GJdivbyDL</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>21429</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>500.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.108236</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.072917e+10</td>\n",
       "      <td>4.716117e+08</td>\n",
       "      <td>2.145833e+10</td>\n",
       "      <td>22.750000</td>\n",
       "      <td>45.500000</td>\n",
       "      <td>0.125000</td>\n",
       "      <td>0.327950</td>\n",
       "      <td>100.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21430</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>500.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>6.482461</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>4.716117e+08</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>81.900000</td>\n",
       "      <td>163.800000</td>\n",
       "      <td>5.832000</td>\n",
       "      <td>12.631231</td>\n",
       "      <td>100.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21431</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>500.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>39.047660</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>6.437500e+10</td>\n",
       "      <td>4.716117e+08</td>\n",
       "      <td>1.287500e+11</td>\n",
       "      <td>136.500000</td>\n",
       "      <td>273.000000</td>\n",
       "      <td>27.000000</td>\n",
       "      <td>47.331829</td>\n",
       "      <td>100.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21432</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>500.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.036079</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.072917e+10</td>\n",
       "      <td>1.273352e+10</td>\n",
       "      <td>2.145833e+10</td>\n",
       "      <td>0.842593</td>\n",
       "      <td>1.685185</td>\n",
       "      <td>0.004630</td>\n",
       "      <td>0.012146</td>\n",
       "      <td>33.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21433</th>\n",
       "      <td>50.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>500.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>2.160820</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>3.862500e+10</td>\n",
       "      <td>1.273352e+10</td>\n",
       "      <td>7.725000e+10</td>\n",
       "      <td>3.033333</td>\n",
       "      <td>6.066667</td>\n",
       "      <td>0.216000</td>\n",
       "      <td>0.467823</td>\n",
       "      <td>33.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25297</th>\n",
       "      <td>200.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>800.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>4000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.013032</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>2.472000e+12</td>\n",
       "      <td>5.093407e+10</td>\n",
       "      <td>4.944000e+12</td>\n",
       "      <td>48.533333</td>\n",
       "      <td>97.066667</td>\n",
       "      <td>0.216000</td>\n",
       "      <td>0.570508</td>\n",
       "      <td>266.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25298</th>\n",
       "      <td>200.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>800.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>4000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.063737</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>4.120000e+12</td>\n",
       "      <td>5.093407e+10</td>\n",
       "      <td>8.240000e+12</td>\n",
       "      <td>80.888889</td>\n",
       "      <td>161.777778</td>\n",
       "      <td>1.000000</td>\n",
       "      <td>2.535411</td>\n",
       "      <td>266.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25299</th>\n",
       "      <td>200.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>800.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>4000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.000158</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>6.866667e+11</td>\n",
       "      <td>2.358059e+11</td>\n",
       "      <td>1.373333e+12</td>\n",
       "      <td>2.912000</td>\n",
       "      <td>5.824000</td>\n",
       "      <td>0.001000</td>\n",
       "      <td>0.002756</td>\n",
       "      <td>160.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25300</th>\n",
       "      <td>200.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>800.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>4000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.007819</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>2.472000e+12</td>\n",
       "      <td>2.358059e+11</td>\n",
       "      <td>4.944000e+12</td>\n",
       "      <td>10.483200</td>\n",
       "      <td>20.966400</td>\n",
       "      <td>0.046656</td>\n",
       "      <td>0.123230</td>\n",
       "      <td>160.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25301</th>\n",
       "      <td>200.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>800.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>4000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>90.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.038242</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>4.120000e+12</td>\n",
       "      <td>2.358059e+11</td>\n",
       "      <td>8.240000e+12</td>\n",
       "      <td>17.472000</td>\n",
       "      <td>34.944000</td>\n",
       "      <td>0.216000</td>\n",
       "      <td>0.547649</td>\n",
       "      <td>160.000000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>3724 rows × 112 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           B  cf1f  cf2f  cf3f      H  Imperfectfactor       L  meshsz    n  \\\n",
       "21429   50.0   0.0   1.0   0.0  200.0            0.002   500.0    20.0  1.0   \n",
       "21430   50.0   0.0   1.0   0.0  200.0            0.002   500.0    20.0  1.0   \n",
       "21431   50.0   0.0   1.0   0.0  200.0            0.002   500.0    20.0  1.0   \n",
       "21432   50.0   0.0   1.0   0.0  200.0            0.002   500.0    20.0  1.0   \n",
       "21433   50.0   0.0   1.0   0.0  200.0            0.002   500.0    20.0  1.0   \n",
       "...      ...   ...   ...   ...    ...              ...     ...     ...  ...   \n",
       "25297  200.0   0.0   1.0   0.0  800.0            0.002  4000.0    20.0  5.0   \n",
       "25298  200.0   0.0   1.0   0.0  800.0            0.002  4000.0    20.0  5.0   \n",
       "25299  200.0   0.0   1.0   0.0  800.0            0.002  4000.0    20.0  5.0   \n",
       "25300  200.0   0.0   1.0   0.0  800.0            0.002  4000.0    20.0  5.0   \n",
       "25301  200.0   0.0   1.0   0.0  800.0            0.002  4000.0    20.0  5.0   \n",
       "\n",
       "       pbol  ...  ratio_eta_GJdivbyDL             G       EI_edge  \\\n",
       "21429  90.0  ...             0.108236  79230.769231  1.072917e+10   \n",
       "21430  90.0  ...             6.482461  79230.769231  3.862500e+10   \n",
       "21431  90.0  ...            39.047660  79230.769231  6.437500e+10   \n",
       "21432  90.0  ...             0.036079  79230.769231  1.072917e+10   \n",
       "21433  90.0  ...             2.160820  79230.769231  3.862500e+10   \n",
       "...     ...  ...                  ...           ...           ...   \n",
       "25297  90.0  ...             0.013032  79230.769231  2.472000e+12   \n",
       "25298  90.0  ...             0.063737  79230.769231  4.120000e+12   \n",
       "25299  90.0  ...             0.000158  79230.769231  6.866667e+11   \n",
       "25300  90.0  ...             0.007819  79230.769231  2.472000e+12   \n",
       "25301  90.0  ...             0.038242  79230.769231  4.120000e+12   \n",
       "\n",
       "                 Dh        EI_mid  gamma_edge   gamma_mid       beta  \\\n",
       "21429  4.716117e+08  2.145833e+10   22.750000   45.500000   0.125000   \n",
       "21430  4.716117e+08  7.725000e+10   81.900000  163.800000   5.832000   \n",
       "21431  4.716117e+08  1.287500e+11  136.500000  273.000000  27.000000   \n",
       "21432  1.273352e+10  2.145833e+10    0.842593    1.685185   0.004630   \n",
       "21433  1.273352e+10  7.725000e+10    3.033333    6.066667   0.216000   \n",
       "...             ...           ...         ...         ...        ...   \n",
       "25297  5.093407e+10  4.944000e+12   48.533333   97.066667   0.216000   \n",
       "25298  5.093407e+10  8.240000e+12   80.888889  161.777778   1.000000   \n",
       "25299  2.358059e+11  1.373333e+12    2.912000    5.824000   0.001000   \n",
       "25300  2.358059e+11  4.944000e+12   10.483200   20.966400   0.046656   \n",
       "25301  2.358059e+11  8.240000e+12   17.472000   34.944000   0.216000   \n",
       "\n",
       "           beta2     L_to_tw  \n",
       "21429   0.327950  100.000000  \n",
       "21430  12.631231  100.000000  \n",
       "21431  47.331829  100.000000  \n",
       "21432   0.012146   33.333333  \n",
       "21433   0.467823   33.333333  \n",
       "...          ...         ...  \n",
       "25297   0.570508  266.666667  \n",
       "25298   2.535411  266.666667  \n",
       "25299   0.002756  160.000000  \n",
       "25300   0.123230  160.000000  \n",
       "25301   0.547649  160.000000  \n",
       "\n",
       "[3724 rows x 112 columns]"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df1=dfdelparapp# 如果是整体类型的截面需要去重极少数相，如果是分离和螺栓截面则不需要\n",
    "# ————————去重————————————\n",
    "df1.drop_duplicates(keep='first', inplace=True)# 去除重复值\n",
    "# ————————肯定要处理的参数（弹性）————————————\n",
    "df21=df1[(df1['EigenValue']!=0)]  # 剔除特征值为0的算例，弹性算不出来\n",
    "# ————————保留方向数据————————————\n",
    "df31=df21[(df21[str('cf1f')]==0)] #去除有面外荷载的值\n",
    "df32=df31[(df31[str('cf2f')]==1)] # 只保留面内荷载的数据\n",
    "df33=df32[(df32[str('cf3f')]==0)] #只保留无轴压的数据\n",
    "# ————————通过稳定系数筛选异常值的参数（弹塑性）———————\n",
    "df41=df33[(df33['SFcf2f']>=0.001)] # 去除稳定系数小于0.01的数值，很多最小值都是局部屈曲\n",
    "df42=df41[(df41['SFcf2f']<=2 )] # 去除整体稳定系数大于2的数值，对于轴压正常的话稳定系数最大也就是1，但对于受剪可能有较大的数值不适用\n",
    "# ———————截面类型————————————\n",
    "df43=df42[(df42[str('type')]==0)] # 0整体截面，1分离截面，2螺栓截面\n",
    "# ———————物理参数————————————\n",
    "df51=df43[(df43[str('yfss')]==355.61)] # 只保留传统强度数据\n",
    "df52=df51[(df51[str('Imperfectfactor')]==0.002)] # 只保留传统几何缺陷数据\n",
    "df53=df52[(df52[str('meshsz')]==20)] # 网格密度参数，注意该参数为0意味着是整体截面\n",
    "# df54=df53[(df53[str('pbol')]==0)] # 0没有预紧力，非0有预紧力\n",
    "# ———————几何参数（对于整体截面来说可以不设置本部分）————————————\n",
    "df6=df53\n",
    "# dfTn=df6[df6['n']==1]    # 筛选几何参数n\n",
    "dfTn=df6\n",
    "dfH=dfTn[(dfTn['H']==200 )|( dfTn['H']==400 )|( dfTn['H']==600 )|(dfTn['H']== 800 )] # 筛选几何参数H|(dfTn['H']== 1000 )\n",
    "dfB=dfH[(dfH['B']==50 )|( dfH['B']==125 )|( dfH['B']==200)]                     # 筛选几何参数B\n",
    "dfT1=dfB[(dfB['T1']==5 )|( dfB['T1']==15  )|( dfB['T1']==25)]                   # 筛选几何参数T1\n",
    "dfT2=dfT1[(dfT1['T2']==5 )|( dfT1['T2']==18  )|( dfT1['T2']==30)]               # 筛选几何参数T2\n",
    "# ———————最终确认筛选到哪一步————————————\n",
    "df=dfT2\n",
    "# df=df.sort_values('KG_quge_web')# 筛查EigenValue和Pucff异常值\n",
    "df_T=df\n",
    "df\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# df=df[df['KG_quge_web']==0.14] \n",
    "# df\n",
    "# df=df[df['B']==50 ] \n",
    "# df\n",
    "# pd.options.display.max_columns = None\n",
    "# pd.options.display.max_rows = None"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "41e67fd2",
   "metadata": {},
   "source": [
    "##### 分离界面"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "b1d91175",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2502"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "S_df1=data1# 如果是整体类型的截面需要去重极少数相，如果是分离和螺栓截面则不需要\n",
    "# ————————去重————————————\n",
    "S_df1.drop_duplicates(keep='first', inplace=True)# 去除重复值\n",
    "# ————————肯定要处a理的参数（弹性）————————————\n",
    "S_df21=S_df1[(S_df1['EigenValue']!=0)]  # 剔除特征值为0的算例，弹性算不出来\n",
    "# ————————保留方向数据————————————\n",
    "S_df31=S_df21[(S_df21[str('cf1f')]==0)] #去除有面外荷载的值\n",
    "S_df32=S_df31[(S_df31[str('cf2f')]==1)] # 只保留面内荷载的数据\n",
    "S_df33=S_df32[(S_df32[str('cf3f')]==0)] #只保留无轴压的数据\n",
    "# ————————通过稳定系数筛选异常值的参数（弹塑性）———————\n",
    "S_df41=S_df33[(S_df33['SFcf2f']>=0.001)] # 去除稳定系数小于0.01的数值，很多最小值都是局部屈曲\n",
    "\n",
    "# 去除整体稳定系数大于2的数值，对于轴压正常的话稳定系数最大也就是1，但对于受剪可能有较大的数值不适用\n",
    "\n",
    "S_df42=S_df41[(S_df41['SFcf2f']<=2 )]\n",
    "# ———————物理参数————————————\n",
    "S_df51=S_df42[(S_df42[str('yfss')]==355.61)] # 只保留传统强度数据\n",
    "S_df52=S_df51[(S_df51[str('Imperfectfactor')]==0.002)] # 只保留传统几何缺陷数据\n",
    "S_df53=S_df52[(S_df52[str('meshsz')]==20)] # 网格密度参数，注意该参数为0意味着是整体截面\n",
    "\n",
    "S_df53\n",
    "# S_df53.to_excel('098.xlsx')\n",
    "\n",
    "df_S=S_df53\n",
    "len(df_S)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "49cf9fe4",
   "metadata": {},
   "source": [
    "##### 螺栓截面"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "d307fcfa",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>B</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>H</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>L</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>n</th>\n",
       "      <th>pbol</th>\n",
       "      <th>...</th>\n",
       "      <th>ratio_eta_GJdivbyDL</th>\n",
       "      <th>G</th>\n",
       "      <th>EI_edge</th>\n",
       "      <th>Dh</th>\n",
       "      <th>EI_mid</th>\n",
       "      <th>gamma_edge</th>\n",
       "      <th>gamma_mid</th>\n",
       "      <th>beta</th>\n",
       "      <th>beta2</th>\n",
       "      <th>L_to_tw</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>40549</th>\n",
       "      <td>100.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>4.332868</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.373333e+11</td>\n",
       "      <td>4.074725e+08</td>\n",
       "      <td>2.746667e+11</td>\n",
       "      <td>337.037037</td>\n",
       "      <td>674.074074</td>\n",
       "      <td>1.185185</td>\n",
       "      <td>3.151266</td>\n",
       "      <td>166.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>40550</th>\n",
       "      <td>100.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>4.332868</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.373333e+11</td>\n",
       "      <td>4.074725e+08</td>\n",
       "      <td>2.746667e+11</td>\n",
       "      <td>337.037037</td>\n",
       "      <td>674.074074</td>\n",
       "      <td>1.185185</td>\n",
       "      <td>3.151266</td>\n",
       "      <td>166.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>40551</th>\n",
       "      <td>100.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>4.332868</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.373333e+11</td>\n",
       "      <td>4.074725e+08</td>\n",
       "      <td>2.746667e+11</td>\n",
       "      <td>337.037037</td>\n",
       "      <td>674.074074</td>\n",
       "      <td>1.185185</td>\n",
       "      <td>3.151266</td>\n",
       "      <td>166.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>40552</th>\n",
       "      <td>100.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>4.332868</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.373333e+11</td>\n",
       "      <td>4.074725e+08</td>\n",
       "      <td>2.746667e+11</td>\n",
       "      <td>337.037037</td>\n",
       "      <td>674.074074</td>\n",
       "      <td>1.185185</td>\n",
       "      <td>3.151266</td>\n",
       "      <td>166.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>40558</th>\n",
       "      <td>100.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>4.332868</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.373333e+11</td>\n",
       "      <td>4.074725e+08</td>\n",
       "      <td>2.746667e+11</td>\n",
       "      <td>337.037037</td>\n",
       "      <td>674.074074</td>\n",
       "      <td>1.185185</td>\n",
       "      <td>3.151266</td>\n",
       "      <td>166.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66069</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66070</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66138</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66139</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66140</th>\n",
       "      <td>300.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>0.002</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>20.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.090017</td>\n",
       "      <td>79230.769231</td>\n",
       "      <td>1.668600e+13</td>\n",
       "      <td>1.293914e+11</td>\n",
       "      <td>3.337200e+13</td>\n",
       "      <td>128.957574</td>\n",
       "      <td>257.915148</td>\n",
       "      <td>1.020324</td>\n",
       "      <td>2.640928</td>\n",
       "      <td>157.894737</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>3999 rows × 112 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           B  cf1f  cf2f  cf3f       H  Imperfectfactor       L  meshsz    n  \\\n",
       "40549  100.0   0.0   1.0   0.0   100.0            0.002  1000.0    20.0  5.0   \n",
       "40550  100.0   0.0   1.0   0.0   100.0            0.002  1000.0    20.0  5.0   \n",
       "40551  100.0   0.0   1.0   0.0   100.0            0.002  1000.0    20.0  5.0   \n",
       "40552  100.0   0.0   1.0   0.0   100.0            0.002  1000.0    20.0  5.0   \n",
       "40558  100.0   0.0   1.0   0.0   100.0            0.002  1000.0    20.0  4.0   \n",
       "...      ...   ...   ...   ...     ...              ...     ...     ...  ...   \n",
       "66069  300.0   0.0   1.0   0.0  1000.0            0.002  3000.0    20.0  1.0   \n",
       "66070  300.0   0.0   1.0   0.0  1000.0            0.002  3000.0    20.0  1.0   \n",
       "66138  300.0   0.0   1.0   0.0  1000.0            0.002  3000.0    20.0  2.0   \n",
       "66139  300.0   0.0   1.0   0.0  1000.0            0.002  3000.0    20.0  2.0   \n",
       "66140  300.0   0.0   1.0   0.0  1000.0            0.002  3000.0    20.0  2.0   \n",
       "\n",
       "           pbol  ...  ratio_eta_GJdivbyDL             G       EI_edge  \\\n",
       "40549  125000.0  ...             4.332868  79230.769231  1.373333e+11   \n",
       "40550  125000.0  ...             4.332868  79230.769231  1.373333e+11   \n",
       "40551  125000.0  ...             4.332868  79230.769231  1.373333e+11   \n",
       "40552  125000.0  ...             4.332868  79230.769231  1.373333e+11   \n",
       "40558  125000.0  ...             4.332868  79230.769231  1.373333e+11   \n",
       "...         ...  ...                  ...           ...           ...   \n",
       "66069  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "66070  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "66138  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "66139  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "66140  125000.0  ...             0.090017  79230.769231  1.668600e+13   \n",
       "\n",
       "                 Dh        EI_mid  gamma_edge   gamma_mid      beta     beta2  \\\n",
       "40549  4.074725e+08  2.746667e+11  337.037037  674.074074  1.185185  3.151266   \n",
       "40550  4.074725e+08  2.746667e+11  337.037037  674.074074  1.185185  3.151266   \n",
       "40551  4.074725e+08  2.746667e+11  337.037037  674.074074  1.185185  3.151266   \n",
       "40552  4.074725e+08  2.746667e+11  337.037037  674.074074  1.185185  3.151266   \n",
       "40558  4.074725e+08  2.746667e+11  337.037037  674.074074  1.185185  3.151266   \n",
       "...             ...           ...         ...         ...       ...       ...   \n",
       "66069  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "66070  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "66138  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "66139  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "66140  1.293914e+11  3.337200e+13  128.957574  257.915148  1.020324  2.640928   \n",
       "\n",
       "          L_to_tw  \n",
       "40549  166.666667  \n",
       "40550  166.666667  \n",
       "40551  166.666667  \n",
       "40552  166.666667  \n",
       "40558  166.666667  \n",
       "...           ...  \n",
       "66069  157.894737  \n",
       "66070  157.894737  \n",
       "66138  157.894737  \n",
       "66139  157.894737  \n",
       "66140  157.894737  \n",
       "\n",
       "[3999 rows x 112 columns]"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# 假设 data1 已经定义\n",
    "B_df1 = data2.copy()  # 创建 data1 的副本以避免 SettingWithCopyWarning\n",
    "\n",
    "# ————————去重————————————\n",
    "B_df1.drop_duplicates(keep='first', inplace=True)  # 去除重复值\n",
    "# ————————肯定要处理的参数（弹性）————————————\n",
    "B_df21 = B_df1[B_df1['EigenValue'] != 0].copy()  # 剔除特征值为0的算例，弹性算不出来，并创建副本\n",
    "# ————————保留方向数据————————————\n",
    "B_df31 = B_df21[B_df21['cf1f'] == 0].copy()  # 去除有面外荷载的值，并创建副本\n",
    "B_df32 = B_df31[B_df31['cf2f'] == 1].copy()  # 只保留面内荷载的数据，并创建副本\n",
    "B_df33 = B_df32[B_df32['cf3f'] == 0].copy()  # 只保留无轴压的数据，并创建副本\n",
    "# ————————通过稳定系数筛选异常值的参数（弹塑性）———————\n",
    "B_df41 = B_df33[B_df33['SFcf2f'] >= 0.001].copy()  # 去除稳定系数小于0.01的数值，很多最小值都是局部屈曲，并创建副本\n",
    "B_df42 = B_df41[B_df41['SFcf2f'] <= 2].copy()  # 去除整体稳定系数大于2的数值，对于轴压正常的话稳定系数最大也就是1，但对于受剪可能有较大的数值不适用，并创建副本\n",
    "\n",
    "# ———————物理参数————————————\n",
    "B_df51 = B_df42[B_df42['yfss'] == 355.61].copy()  # 只保留传统强度数据，并创建副本\n",
    "B_df52 = B_df51[B_df51['Imperfectfactor'] == 0.002].copy()  # 只保留传统几何缺陷数据，并创建副本\n",
    "B_df53 = B_df52[B_df52['meshsz'] == 20].copy()  # 网格密度参数，注意该参数为0意味着是整体截面，并创建副本\n",
    "\n",
    "B_df53\n",
    "# B_df53.to_excel('098.xlsx')\n",
    "df_B=B_df53\n",
    "df_B"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72b9e60f",
   "metadata": {},
   "source": [
    "#### df_all_dic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "95dfea1c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>H</th>\n",
       "      <th>B</th>\n",
       "      <th>T1</th>\n",
       "      <th>T2</th>\n",
       "      <th>L</th>\n",
       "      <th>n</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>...</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>F</th>\n",
       "      <th>pbol</th>\n",
       "      <th>sfricn</th>\n",
       "      <th>yfss</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>SFcf2f</th>\n",
       "      <th>KG_sing_web</th>\n",
       "      <th>KH_sing_flange</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>34</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>18.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>931698.2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>66643.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>2.777778</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>63</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>30.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1973635.5</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>288096.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>1.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>70</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>18.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>2329245.5</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>67748.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>2.777778</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>80</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>30.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>2631514.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>350361.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>1.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>94</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>30.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>3289392.5</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>363341.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>1.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90373</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30857300.0</td>\n",
       "      <td>18523900.0</td>\n",
       "      <td>0.949720</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90374</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30923000.0</td>\n",
       "      <td>18527800.0</td>\n",
       "      <td>0.949920</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90375</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30564400.0</td>\n",
       "      <td>18519300.0</td>\n",
       "      <td>0.949484</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90376</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30774900.0</td>\n",
       "      <td>18526300.0</td>\n",
       "      <td>0.949843</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90377</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30857300.0</td>\n",
       "      <td>18513300.0</td>\n",
       "      <td>0.949176</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>88786 rows × 22 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            H      B    T1    T2       L    n   cf1f  cf2f       cf3f  type  \\\n",
       "34      200.0   50.0   5.0  18.0  3000.0  2.0  0.000   1.0   931698.2   0.0   \n",
       "63      200.0   50.0   5.0  30.0  3000.0  3.0  0.000   1.0  1973635.5   0.0   \n",
       "70      200.0   50.0   5.0  18.0  3000.0  5.0  0.000   1.0  2329245.5   0.0   \n",
       "80      200.0   50.0   5.0  30.0  3000.0  4.0  0.000   1.0  2631514.0   0.0   \n",
       "94      200.0   50.0   5.0  30.0  3000.0  5.0  0.000   1.0  3289392.5   0.0   \n",
       "...       ...    ...   ...   ...     ...  ...    ...   ...        ...   ...   \n",
       "90373  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90374  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90375  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90376  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90377  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "\n",
       "       ...  meshsz     F      pbol  sfricn    yfss       Bcf2f      Pucf2f  \\\n",
       "34     ...    20.0   NaN      90.0    0.00  355.61     66643.0         NaN   \n",
       "63     ...    20.0   NaN      90.0    0.00  355.61    288096.0         NaN   \n",
       "70     ...    20.0   NaN      90.0    0.00  355.61     67748.0         NaN   \n",
       "80     ...    20.0   NaN      90.0    0.00  355.61    350361.0         NaN   \n",
       "94     ...    20.0   NaN      90.0    0.00  355.61    363341.0         NaN   \n",
       "...    ...     ...   ...       ...     ...     ...         ...         ...   \n",
       "90373  ...    40.0   5.0  125000.0    0.35  355.61  30857300.0  18523900.0   \n",
       "90374  ...    40.0  10.0  125000.0    0.35  355.61  30923000.0  18527800.0   \n",
       "90375  ...    40.0   1.0  125000.0    0.35  355.61  30564400.0  18519300.0   \n",
       "90376  ...    40.0   3.0  125000.0    0.35  355.61  30774900.0  18526300.0   \n",
       "90377  ...    40.0   5.0  125000.0    0.35  355.61  30857300.0  18513300.0   \n",
       "\n",
       "         SFcf2f  KG_sing_web  KH_sing_flange  \n",
       "34          NaN     0.066667        2.777778  \n",
       "63          NaN     0.066667        1.666667  \n",
       "70          NaN     0.066667        2.777778  \n",
       "80          NaN     0.066667        1.666667  \n",
       "94          NaN     0.066667        1.666667  \n",
       "...         ...          ...             ...  \n",
       "90373  0.949720     0.333333        8.333333  \n",
       "90374  0.949920     0.333333        8.333333  \n",
       "90375  0.949484     0.333333        8.333333  \n",
       "90376  0.949843     0.333333        8.333333  \n",
       "90377  0.949176     0.333333        8.333333  \n",
       "\n",
       "[88786 rows x 22 columns]"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "# df_all=pd.concat([df_T, df_S,df_B], axis=0, join='outer')# 纵向连接，\n",
    "# df_all\n",
    "\n",
    "# KG_sing_web=H/L\n",
    "# KH_sing_flange=B/T2\n",
    "\n",
    "df_all_dic=dfdelpara.copy()# 如果是整体类型的截面需要去重极少数相，如果是分离和螺栓截面则不需要\n",
    "columns_to_keep = ['H', 'B','T1', 'T2',  'L','n', 'cf1f', 'cf2f', 'cf3f', 'type',\n",
    "                   'axialratio','Imperfectfactor', 'meshsz', 'F', 'pbol', \n",
    "                   'sfricn', 'yfss','Bcf2f', 'Pucf2f','SFcf2f','KG_sing_web','KH_sing_flange']\n",
    "\n",
    "# 从现有DataFrame中选择指定列以创建新的DataFrame\n",
    "df_all_dic = df_all_dic[columns_to_keep]\n",
    "df_all_dic\n",
    "\n",
    "# # ————————去重————————————\n",
    "# df_all_dic.drop_duplicates(keep='first', inplace=True)# 去除重复值\n",
    "# # ————————肯定要处理的参数（弹性）————————————\n",
    "# Dic_df21 = df_all_dic[(df_all_dic['EigenValue']!= 0) & (abs(df_all_dic['EigenValue']) > 10)]  # 剔除特征值为0的算例，弹性算不出来\n",
    "# # ———————物理参数————————————\n",
    "# # Dic_df51=Dic_df21[(Dic_df21[str('yfss')]==355.61)] # 只保留传统强度数据\n",
    "# # Dic_df52=Dic_df21[(Dic_df21[str('Imperfectfactor')]==0.002)] # 只保留传统几何缺陷数据\n",
    "# # Dic_df53=Dic_df51[(Dic_df51[str('meshsz')]==20)] # 网格密度参数，注意该参数为0意味着是整体截面\n",
    "\n",
    "# df_all_evdic=Dic_df21\n",
    "# len(df_all_dic)\n",
    "\n",
    "# df_all_dic.to_excel('df_all_dic.xlsx')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "f17f1afd",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>H</th>\n",
       "      <th>B</th>\n",
       "      <th>T1</th>\n",
       "      <th>T2</th>\n",
       "      <th>L</th>\n",
       "      <th>n</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>...</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>F</th>\n",
       "      <th>pbol</th>\n",
       "      <th>sfricn</th>\n",
       "      <th>yfss</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>SFcf2f</th>\n",
       "      <th>KG_sing_web</th>\n",
       "      <th>KH_sing_flange</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>34</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>18.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>931698.2</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>66643.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>2.777778</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>63</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>30.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1973635.5</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>288096.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>1.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>70</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>18.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>2329245.5</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>67748.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>2.777778</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>80</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>30.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>2631514.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>350361.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>1.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>94</th>\n",
       "      <td>200.0</td>\n",
       "      <td>50.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>30.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>3289392.5</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>20.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.00</td>\n",
       "      <td>355.61</td>\n",
       "      <td>363341.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>1.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90373</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30857300.0</td>\n",
       "      <td>18523900.0</td>\n",
       "      <td>0.949720</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90374</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30923000.0</td>\n",
       "      <td>18527800.0</td>\n",
       "      <td>0.949920</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90375</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30564400.0</td>\n",
       "      <td>18519300.0</td>\n",
       "      <td>0.949484</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90376</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30774900.0</td>\n",
       "      <td>18526300.0</td>\n",
       "      <td>0.949843</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>90377</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>1.732</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>30857300.0</td>\n",
       "      <td>18513300.0</td>\n",
       "      <td>0.949176</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>88786 rows × 22 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            H      B    T1    T2       L    n   cf1f  cf2f       cf3f  type  \\\n",
       "34      200.0   50.0   5.0  18.0  3000.0  2.0  0.000   1.0   931698.2   0.0   \n",
       "63      200.0   50.0   5.0  30.0  3000.0  3.0  0.000   1.0  1973635.5   0.0   \n",
       "70      200.0   50.0   5.0  18.0  3000.0  5.0  0.000   1.0  2329245.5   0.0   \n",
       "80      200.0   50.0   5.0  30.0  3000.0  4.0  0.000   1.0  2631514.0   0.0   \n",
       "94      200.0   50.0   5.0  30.0  3000.0  5.0  0.000   1.0  3289392.5   0.0   \n",
       "...       ...    ...   ...   ...     ...  ...    ...   ...        ...   ...   \n",
       "90373  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90374  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90375  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90376  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "90377  1000.0  300.0  19.0  36.0  3000.0  5.0  1.732   1.0        0.0   2.0   \n",
       "\n",
       "       ...  meshsz     F      pbol  sfricn    yfss       Bcf2f      Pucf2f  \\\n",
       "34     ...    20.0   NaN      90.0    0.00  355.61     66643.0         NaN   \n",
       "63     ...    20.0   NaN      90.0    0.00  355.61    288096.0         NaN   \n",
       "70     ...    20.0   NaN      90.0    0.00  355.61     67748.0         NaN   \n",
       "80     ...    20.0   NaN      90.0    0.00  355.61    350361.0         NaN   \n",
       "94     ...    20.0   NaN      90.0    0.00  355.61    363341.0         NaN   \n",
       "...    ...     ...   ...       ...     ...     ...         ...         ...   \n",
       "90373  ...    40.0   5.0  125000.0    0.35  355.61  30857300.0  18523900.0   \n",
       "90374  ...    40.0  10.0  125000.0    0.35  355.61  30923000.0  18527800.0   \n",
       "90375  ...    40.0   1.0  125000.0    0.35  355.61  30564400.0  18519300.0   \n",
       "90376  ...    40.0   3.0  125000.0    0.35  355.61  30774900.0  18526300.0   \n",
       "90377  ...    40.0   5.0  125000.0    0.35  355.61  30857300.0  18513300.0   \n",
       "\n",
       "         SFcf2f  KG_sing_web  KH_sing_flange  \n",
       "34          NaN     0.066667        2.777778  \n",
       "63          NaN     0.066667        1.666667  \n",
       "70          NaN     0.066667        2.777778  \n",
       "80          NaN     0.066667        1.666667  \n",
       "94          NaN     0.066667        1.666667  \n",
       "...         ...          ...             ...  \n",
       "90373  0.949720     0.333333        8.333333  \n",
       "90374  0.949920     0.333333        8.333333  \n",
       "90375  0.949484     0.333333        8.333333  \n",
       "90376  0.949843     0.333333        8.333333  \n",
       "90377  0.949176     0.333333        8.333333  \n",
       "\n",
       "[88786 rows x 22 columns]"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "df_all_dic['axialratio'] = round(dfdelpara['axialratio'],2)\n",
    "df_all_dic['yfss'] = round(dfdelpara['yfss'],2)\n",
    "df_all_dic['pbol'] = round(dfdelpara['pbol'],0)\n",
    "df_all_dic['H'] = round(dfdelpara['H'],0)\n",
    "# df_all_dic['B'] = round(dfdelpara['B'],0).astype(int)\n",
    "df_all_dic['B'] = round(dfdelpara['B'],0)\n",
    "df_all_dic['T1'] = round(dfdelpara['T1'],0)\n",
    "df_all_dic['T2'] = round(dfdelpara['T2'],0)\n",
    "df_all_dic['meshsz'] = round(dfdelpara['meshsz'],0)\n",
    "# df_all_dic['yfss'] = round(dfdelpara['yfss'],0)\n",
    "df_all_dic\n",
    "# df_all_dic.loc[26618]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "9852e545",
   "metadata": {},
   "outputs": [],
   "source": [
    "# df_all_dic\n",
    "# # 统计 meshsz 列中各个数值的数据量\n",
    "# meshsz_counts = df_all_dic['meshsz'].value_counts()\n",
    "# # meshsz_counts\n",
    "# # df_all_dic[df_all_dic['meshsz'] == 40].to_excel('assadfasdf40.xlsx')\n",
    "# display(df_all_dic)\n",
    "# df = df_all_dic[(df_all_dic['meshsz'] == 40) | (df_all_dic['meshsz'] == 20)]\n",
    "# # df.to_excel('assadfasdf40.xlsx')\n",
    "# # display(df)\n",
    "# # df_all_dic=df.copy()\n",
    "# display(df_all_dic)\n",
    "# # # 除 meshsz 外的列名\n",
    "# # cols = [col for col in df.columns if  col not in ['meshsz', 'Bcf12f', 'Pucf12f']]\n",
    "\n",
    "# # # 按除 meshsz 外的列分组\n",
    "# # groups = df.groupby(cols)\n",
    "\n",
    "# # # 筛选出每组中元素数量大于 1 的组\n",
    "# # filtered_groups = groups.filter(lambda x: len(x) > 1)\n",
    "\n",
    "# # print(\"除 meshsz 不同，其他都相同的新 DataFrame：\")\n",
    "# # print(filtered_groups)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "71cd4141",
   "metadata": {},
   "source": [
    "### 敏感性分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "4096d544",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "27392 0\n",
      "75580 1\n",
      "79645 2\n",
      "75580 3\n",
      "85558 4\n",
      "df_no20400 143\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>H</th>\n",
       "      <th>B</th>\n",
       "      <th>T1</th>\n",
       "      <th>T2</th>\n",
       "      <th>L</th>\n",
       "      <th>n</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>...</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>F</th>\n",
       "      <th>pbol</th>\n",
       "      <th>sfricn</th>\n",
       "      <th>yfss</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>KG_sing_web</th>\n",
       "      <th>KH_sing_flange</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>10201</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>160.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>7813480.0</td>\n",
       "      <td>683666.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10202</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>130.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>5629240.0</td>\n",
       "      <td>667969.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10203</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>100.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>4932710.0</td>\n",
       "      <td>653717.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10204</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>80.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>4218300.0</td>\n",
       "      <td>645976.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10205</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>50.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>3291390.0</td>\n",
       "      <td>638202.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22364</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>50.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>3076640.0</td>\n",
       "      <td>872702.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22365</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>30.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2978130.0</td>\n",
       "      <td>865078.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22367</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>15.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2917650.0</td>\n",
       "      <td>859411.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22368</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>10.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2903030.0</td>\n",
       "      <td>857509.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22369</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>5.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2893880.0</td>\n",
       "      <td>858098.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>143 rows × 21 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           H      B    T1    T2       L    n   cf1f  cf2f  cf3f  type  ...  \\\n",
       "10201  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10202  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10203  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10204  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10205  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "...      ...    ...   ...   ...     ...  ...    ...   ...   ...   ...  ...   \n",
       "22364  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22365  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22367  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22368  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22369  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "\n",
       "       Imperfectfactor  meshsz   F  pbol  sfricn    yfss      Bcf2f    Pucf2f  \\\n",
       "10201            0.002   160.0 NaN  90.0     0.0  355.61  7813480.0  683666.0   \n",
       "10202            0.002   130.0 NaN  90.0     0.0  355.61  5629240.0  667969.0   \n",
       "10203            0.002   100.0 NaN  90.0     0.0  355.61  4932710.0  653717.0   \n",
       "10204            0.002    80.0 NaN  90.0     0.0  355.61  4218300.0  645976.0   \n",
       "10205            0.002    50.0 NaN  90.0     0.0  355.61  3291390.0  638202.0   \n",
       "...                ...     ...  ..   ...     ...     ...        ...       ...   \n",
       "22364            0.002    50.0 NaN  90.0     0.0  355.61  3076640.0  872702.0   \n",
       "22365            0.002    30.0 NaN  90.0     0.0  355.61  2978130.0  865078.0   \n",
       "22367            0.002    15.0 NaN  90.0     0.0  355.61  2917650.0  859411.0   \n",
       "22368            0.002    10.0 NaN  90.0     0.0  355.61  2903030.0  857509.0   \n",
       "22369            0.002     5.0 NaN  90.0     0.0  355.61  2893880.0  858098.0   \n",
       "\n",
       "       KG_sing_web  KH_sing_flange  \n",
       "10201         0.20            10.0  \n",
       "10202         0.20            10.0  \n",
       "10203         0.20            10.0  \n",
       "10204         0.20            10.0  \n",
       "10205         0.20            10.0  \n",
       "...            ...             ...  \n",
       "22364         0.15            25.0  \n",
       "22365         0.15            25.0  \n",
       "22367         0.15            25.0  \n",
       "22368         0.15            25.0  \n",
       "22369         0.15            25.0  \n",
       "\n",
       "[143 rows x 21 columns]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "general_list       =['type','cf3f','Imperfectfactor','axialratio','yfss']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[0 , 0   , 0.002 ,0,355.61]# 面内受剪_分离面内\n",
    "\n",
    "\n",
    "df_ori=df_all_dic.copy()\n",
    "# df_ori.to_excel('df_ori.xlsx')\n",
    "# 固定标准参数general list和其值\n",
    "for i in range (0,len(general_list)):\n",
    "    df_basepara=df_ori[df_ori[general_list[i]]==general_list_number[i]].copy()\n",
    "    \n",
    "    print(len(df_basepara),i)\n",
    "df_no2040=df_basepara[(df_basepara['meshsz']!=20)&(df_basepara['meshsz']!=40)]\n",
    "df_no2040=df_no2040[(df_no2040['H']!=200)|(df_no2040['B']!=100)|(df_no2040['meshsz']!=5)|(df_no2040['cf1f']!=0.577)|(df_no2040['L']!=3000)]\n",
    "print('df_no20400',len(df_no2040))\n",
    "\n",
    "\n",
    "# import pandas as pd\n",
    "\n",
    "# # 定义匹配列（不包含 meshsz，meshsz 作为需不同的列）\n",
    "# match_cols = ['H', 'B', 'T1', 'T2', 'L', 'n', 'cf1f', 'cf2f', 'cf3f', \n",
    "#               'type', 'axialratio', 'Imperfectfactor', 'F', 'pbol', 'sfricn', 'yfss']\n",
    "\n",
    "# # 1. 内连接匹配列，保留 meshsz 不同的行\n",
    "# combined = df_no2040.merge(\n",
    "#     dfori, \n",
    "#     on=match_cols,        # 匹配列值相同\n",
    "#     how='inner',          # 仅保留匹配行\n",
    "#     suffixes=('', '_dfori')  # 给右表列加后缀，区分 meshsz\n",
    "# ).query('meshsz != meshsz_dfori')  # 筛选 meshsz 不同的行\n",
    "\n",
    "# # 2. 提取右表（dfori）的列，去掉后缀并调整列顺序\n",
    "# dfori_matched = combined[\n",
    "#     [col for col in combined.columns if not col.endswith('_dfori')]  # 保留左表列和右表非后缀列\n",
    "# ].rename(columns={'meshsz_dfori': 'meshsz'})  # 恢复 meshsz 列名\n",
    "\n",
    "# # 3. 确保 dfori_matched 列与 df_no2040 一致（按顺序排列）\n",
    "# dfori_matched = dfori_matched[df_no2040.columns.tolist()]\n",
    "\n",
    "# # 4. 添加来源标记并合并\n",
    "# df_no2040['来源'] = '原始数据'\n",
    "# dfori_matched['来源'] = '追加数据（meshsz不同）'\n",
    "\n",
    "# final_data = pd.concat(\n",
    "#     [df_no2040, dfori_matched], \n",
    "#     ignore_index=True\n",
    "# # )\n",
    "# # -------------------------- 新增：按业务列（除来源外）检查重复值 --------------------------\n",
    "# # 获取除“来源”外的所有列（业务列）\n",
    "# business_columns = [col for col in final_data.columns if col != '来源']\n",
    "\n",
    "# # 检查业务列是否重复（忽略来源列）\n",
    "# duplicate_mask = final_data.duplicated(subset=business_columns, keep='first')\n",
    "# has_duplicates = duplicate_mask.any()\n",
    "\n",
    "# print(f\"{'='*30} 重复值检查 {'='*30}\")\n",
    "# print(f\"检查列：{business_columns}（忽略『来源』列）\")\n",
    "# print(f\"是否存在重复行（业务列相同）？ {has_duplicates}\")\n",
    "\n",
    "# if has_duplicates:\n",
    "#     # 删除业务列重复的行，保留第一个出现的行\n",
    "#     final_data = final_data.drop_duplicates(\n",
    "#         subset=business_columns,  # 仅根据业务列判断重复\n",
    "#         keep='first',             # 保留第一个出现的行\n",
    "#         ignore_index=True         # 重置索引（可选）\n",
    "#     )\n",
    "#     print(f\"已删除 {sum(duplicate_mask)} 行重复数据，剩余 {len(final_data)} 行。\")\n",
    "# else:\n",
    "#     print(\"业务列无重复行，无需处理。\")\n",
    "from matplotlib.font_manager import FontProperties\n",
    "# 保存结果\n",
    "# final_data.to_excel('合并结果.xlsx', index=False)\n",
    "final_data = df_no2040.copy()\n",
    "# data=final_data.drop(columns='F')\n",
    "display(final_data)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf6e37d3",
   "metadata": {},
   "source": [
    "#### 分层分析（Stratified Analysis）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "8e2bfb7f",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>H</th>\n",
       "      <th>B</th>\n",
       "      <th>T1</th>\n",
       "      <th>T2</th>\n",
       "      <th>L</th>\n",
       "      <th>n</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>...</th>\n",
       "      <th>Imperfectfactor</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>F</th>\n",
       "      <th>pbol</th>\n",
       "      <th>sfricn</th>\n",
       "      <th>yfss</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>KG_sing_web</th>\n",
       "      <th>KH_sing_flange</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>10201</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>160.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>7813480.0</td>\n",
       "      <td>683666.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10202</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>130.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>5629240.0</td>\n",
       "      <td>667969.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10203</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>100.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>4932710.0</td>\n",
       "      <td>653717.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10204</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>80.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>4218300.0</td>\n",
       "      <td>645976.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10205</th>\n",
       "      <td>200.0</td>\n",
       "      <td>100.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>1000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.577</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>50.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>3291390.0</td>\n",
       "      <td>638202.0</td>\n",
       "      <td>0.20</td>\n",
       "      <td>10.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22364</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>50.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>3076640.0</td>\n",
       "      <td>872702.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22365</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>30.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2978130.0</td>\n",
       "      <td>865078.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22367</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>15.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2917650.0</td>\n",
       "      <td>859411.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22368</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>10.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2903030.0</td>\n",
       "      <td>857509.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22369</th>\n",
       "      <td>300.0</td>\n",
       "      <td>250.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>2000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>...</td>\n",
       "      <td>0.002</td>\n",
       "      <td>5.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>90.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2893880.0</td>\n",
       "      <td>858098.0</td>\n",
       "      <td>0.15</td>\n",
       "      <td>25.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>143 rows × 21 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "           H      B    T1    T2       L    n   cf1f  cf2f  cf3f  type  ...  \\\n",
       "10201  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10202  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10203  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10204  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "10205  200.0  100.0  10.0  10.0  1000.0  2.0  0.577   1.0   0.0   0.0  ...   \n",
       "...      ...    ...   ...   ...     ...  ...    ...   ...   ...   ...  ...   \n",
       "22364  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22365  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22367  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22368  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "22369  300.0  250.0  10.0  10.0  2000.0  2.0  0.000   1.0   0.0   0.0  ...   \n",
       "\n",
       "       Imperfectfactor  meshsz   F  pbol  sfricn    yfss      Bcf2f    Pucf2f  \\\n",
       "10201            0.002   160.0 NaN  90.0     0.0  355.61  7813480.0  683666.0   \n",
       "10202            0.002   130.0 NaN  90.0     0.0  355.61  5629240.0  667969.0   \n",
       "10203            0.002   100.0 NaN  90.0     0.0  355.61  4932710.0  653717.0   \n",
       "10204            0.002    80.0 NaN  90.0     0.0  355.61  4218300.0  645976.0   \n",
       "10205            0.002    50.0 NaN  90.0     0.0  355.61  3291390.0  638202.0   \n",
       "...                ...     ...  ..   ...     ...     ...        ...       ...   \n",
       "22364            0.002    50.0 NaN  90.0     0.0  355.61  3076640.0  872702.0   \n",
       "22365            0.002    30.0 NaN  90.0     0.0  355.61  2978130.0  865078.0   \n",
       "22367            0.002    15.0 NaN  90.0     0.0  355.61  2917650.0  859411.0   \n",
       "22368            0.002    10.0 NaN  90.0     0.0  355.61  2903030.0  857509.0   \n",
       "22369            0.002     5.0 NaN  90.0     0.0  355.61  2893880.0  858098.0   \n",
       "\n",
       "       KG_sing_web  KH_sing_flange  \n",
       "10201         0.20            10.0  \n",
       "10202         0.20            10.0  \n",
       "10203         0.20            10.0  \n",
       "10204         0.20            10.0  \n",
       "10205         0.20            10.0  \n",
       "...            ...             ...  \n",
       "22364         0.15            25.0  \n",
       "22365         0.15            25.0  \n",
       "22367         0.15            25.0  \n",
       "22368         0.15            25.0  \n",
       "22369         0.15            25.0  \n",
       "\n",
       "[143 rows x 21 columns]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "ename": "KeyError",
     "evalue": "'Pucf12f'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "File \u001b[1;32mF:\\ProgramData\\anaconda3\\envs\\phddatc\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3812\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m   3811\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m-> 3812\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_engine\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mget_loc\u001b[49m\u001b[43m(\u001b[49m\u001b[43mcasted_key\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m   3813\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m err:\n",
      "File \u001b[1;32mpandas/_libs/index.pyx:167\u001b[0m, in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[1;34m()\u001b[0m\n",
      "File \u001b[1;32mpandas/_libs/index.pyx:196\u001b[0m, in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[1;34m()\u001b[0m\n",
      "File \u001b[1;32mpandas/_libs/hashtable_class_helper.pxi:7088\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[1;34m()\u001b[0m\n",
      "File \u001b[1;32mpandas/_libs/hashtable_class_helper.pxi:7096\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[1;34m()\u001b[0m\n",
      "\u001b[1;31mKeyError\u001b[0m: 'Pucf12f'",
      "\nThe above exception was the direct cause of the following exception:\n",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[31], line 107\u001b[0m\n\u001b[0;32m    104\u001b[0m \u001b[38;5;66;03m# data = data[data['L'] == 2000]\u001b[39;00m\n\u001b[0;32m    105\u001b[0m \u001b[38;5;66;03m# data=data[(data['L']==1000)] \u001b[39;00m\n\u001b[0;32m    106\u001b[0m display(data)\n\u001b[1;32m--> 107\u001b[0m fig, _ \u001b[38;5;241m=\u001b[39m \u001b[43mcreate_flexible_plot_updated\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m    108\u001b[0m \u001b[43m    \u001b[49m\u001b[43mdf\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mdata\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    109\u001b[0m \u001b[43m    \u001b[49m\u001b[43mx_param\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mmeshsz\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m         \u001b[49m\n\u001b[0;32m    110\u001b[0m \u001b[43m    \u001b[49m\u001b[43my_param\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mPucf12f\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m        \u001b[49m\n\u001b[0;32m    111\u001b[0m \u001b[43m    \u001b[49m\u001b[43msubplot_params\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m[\u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mcf1f\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mcf2f\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m  \u001b[49m\u001b[38;5;66;43;03m# 子图按这两个参数的所有组合分组\u001b[39;49;00m\n\u001b[0;32m    112\u001b[0m \u001b[43m    \u001b[49m\u001b[43mline_params\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m[\u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mH\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mB\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mT1\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mT2\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mL\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m  \u001b[49m\u001b[38;5;66;43;03m# 线条标签仅用这四个参数\u001b[39;49;00m\n\u001b[0;32m    113\u001b[0m \u001b[43m    \u001b[49m\u001b[43mplot_type\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mline\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m          \u001b[49m\n\u001b[0;32m    114\u001b[0m \u001b[43m    \u001b[49m\u001b[43mpalette\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mhusl\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m            \u001b[49m\n\u001b[0;32m    115\u001b[0m \u001b[43m    \u001b[49m\u001b[43mmarker_pool\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m[\u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mo\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43ms\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mD\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43m^\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mp\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\n\u001b[0;32m    116\u001b[0m \u001b[43m    \u001b[49m\u001b[43mlegend_cols\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m2\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m             \u001b[49m\n\u001b[0;32m    117\u001b[0m \u001b[43m    \u001b[49m\u001b[43minvert_xaxis\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m,\u001b[49m\u001b[43m         \u001b[49m\n\u001b[0;32m    118\u001b[0m \u001b[43m    \u001b[49m\u001b[43mmanual_nrows\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m3\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m            \u001b[49m\u001b[38;5;66;43;03m# 手动设置3行\u001b[39;49;00m\n\u001b[0;32m    119\u001b[0m \u001b[43m    \u001b[49m\u001b[43mmanual_ncols\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m1\u001b[39;49m\u001b[43m             \u001b[49m\u001b[38;5;66;43;03m# 手动设置2列\u001b[39;49;00m\n\u001b[0;32m    120\u001b[0m \u001b[43m)\u001b[49m\n",
      "Cell \u001b[1;32mIn[31], line 47\u001b[0m, in \u001b[0;36mcreate_flexible_plot_updated\u001b[1;34m(df, x_param, y_param, subplot_params, line_params, plot_type, palette, marker_pool, legend_cols, invert_xaxis, manual_nrows, manual_ncols)\u001b[0m\n\u001b[0;32m     45\u001b[0m \u001b[38;5;66;03m# ------------------- 正确生成百分比偏差列（后缀为_percent_deviation）-------------------\u001b[39;00m\n\u001b[0;32m     46\u001b[0m min_meshsz \u001b[38;5;241m=\u001b[39m line_data[x_param]\u001b[38;5;241m.\u001b[39mmin()\n\u001b[1;32m---> 47\u001b[0m baseline_result \u001b[38;5;241m=\u001b[39m \u001b[43mline_data\u001b[49m\u001b[43m[\u001b[49m\u001b[43mline_data\u001b[49m\u001b[43m[\u001b[49m\u001b[43mx_param\u001b[49m\u001b[43m]\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m==\u001b[39;49m\u001b[43m \u001b[49m\u001b[43mmin_meshsz\u001b[49m\u001b[43m]\u001b[49m\u001b[43m[\u001b[49m\u001b[43my_param\u001b[49m\u001b[43m]\u001b[49m\u001b[38;5;241m.\u001b[39mvalues[\u001b[38;5;241m0\u001b[39m]\n\u001b[0;32m     48\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m baseline_result \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[0;32m     49\u001b[0m     line_data[y_param \u001b[38;5;241m+\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124m_percent_deviation\u001b[39m\u001b[38;5;124m'\u001b[39m] \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m0\u001b[39m  \u001b[38;5;66;03m# 处理零基准值（可根据需求调整）\u001b[39;00m\n",
      "File \u001b[1;32mF:\\ProgramData\\anaconda3\\envs\\phddatc\\lib\\site-packages\\pandas\\core\\frame.py:4107\u001b[0m, in \u001b[0;36mDataFrame.__getitem__\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m   4105\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcolumns\u001b[38;5;241m.\u001b[39mnlevels \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m   4106\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_getitem_multilevel(key)\n\u001b[1;32m-> 4107\u001b[0m indexer \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcolumns\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mget_loc\u001b[49m\u001b[43m(\u001b[49m\u001b[43mkey\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m   4108\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m is_integer(indexer):\n\u001b[0;32m   4109\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m [indexer]\n",
      "File \u001b[1;32mF:\\ProgramData\\anaconda3\\envs\\phddatc\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3819\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m   3814\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(casted_key, \u001b[38;5;28mslice\u001b[39m) \u001b[38;5;129;01mor\u001b[39;00m (\n\u001b[0;32m   3815\u001b[0m         \u001b[38;5;28misinstance\u001b[39m(casted_key, abc\u001b[38;5;241m.\u001b[39mIterable)\n\u001b[0;32m   3816\u001b[0m         \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28many\u001b[39m(\u001b[38;5;28misinstance\u001b[39m(x, \u001b[38;5;28mslice\u001b[39m) \u001b[38;5;28;01mfor\u001b[39;00m x \u001b[38;5;129;01min\u001b[39;00m casted_key)\n\u001b[0;32m   3817\u001b[0m     ):\n\u001b[0;32m   3818\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m InvalidIndexError(key)\n\u001b[1;32m-> 3819\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(key) \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01merr\u001b[39;00m\n\u001b[0;32m   3820\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mTypeError\u001b[39;00m:\n\u001b[0;32m   3821\u001b[0m     \u001b[38;5;66;03m# If we have a listlike key, _check_indexing_error will raise\u001b[39;00m\n\u001b[0;32m   3822\u001b[0m     \u001b[38;5;66;03m#  InvalidIndexError. Otherwise we fall through and re-raise\u001b[39;00m\n\u001b[0;32m   3823\u001b[0m     \u001b[38;5;66;03m#  the TypeError.\u001b[39;00m\n\u001b[0;32m   3824\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_check_indexing_error(key)\n",
      "\u001b[1;31mKeyError\u001b[0m: 'Pucf12f'"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAvYAAAHWCAYAAAAcpc2LAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAK/xJREFUeJzt3X2UVXW9+PEPoMCozDgiAsqTN8okMEWXVD8fSYlSrndpJWRQVqw0M0UuJoYpEdI1wjLKFplWwAU1syihm96QzBADkRRUHoaHASeGmCdBmAHP+f3h8lxHZgbOyDj09fVa66zl3md/z/ly2MJ7Nnvv0yabzWYDAAD4l9a2tScAAAC8fcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOyBQ9Lu3btj/vz5sb/v0JszZ06sXr0679d/5ZVXmjWv9evX11vetm1bTJ06tVmvBQAH02GtPQHg3SubzUZ5eXls3rw5SktLo7S0NEpKSmL58uXx4osvRo8ePeKII46I8847r9HX+NWvfhWdOnWK973vfU2+V2VlZfz2t7+NK664Ig4//PC45ppr4pJLLonLLrss/va3v8Xjjz8e48aNqzfmjjvuiPnz59dbt2LFivjud78bX/rSl3Lrnnnmmfx/8QBwkAl7oNV8/vOfjx07dkRhYWF069Yt3ve+98Wll14aX//612Pv3r2xfPnyJqM+IuK1116L97znPft9r+Li4iguLo5zzjknFi9eHG3bto0PfvCD8dprr8XEiRPjmmuuiWw2G23atMmNue6662LMmDHxqU99Kn7zm9/ExRdfHJWVlRER8dBDD8X27dvj0ksvjbZt35l//Jw3b15s3749XnvttfjrX/8a9957b2Sz2ZgzZ0488MADcemll8aoUaMOaNz+TJ06NcrKymLnzp0xevToOP300/c75pFHHonRo0fX+zyefPLJ6N27d3zjG9+IadOmRefOnSMiYteuXTF9+vQYMWJEk8+9XbNmzYpMJhNbt26NmpqamDRpUlRUVMRPf/rTKCwsjLVr18YZZ5yxz3s1NK4pO3bsiIcffjjuueee+Na3vhXnnnvuAc2vtrY2rr/++ujSpUuUl5fH7bffHsccc8x+nwNoiLAHWs0PfvCDuOuuu2LcuHHx6quvxo033hgjRoyIjh07xqRJk2LNmjUxZMiQ6NChQ6OvUVtbG4WFhfXWPffcczFgwIB9tr3kkkuipqam3ro5c+bEnXfeGe9973vj17/+dQwaNChOOOGEiIjo0KFD7N27t972r7zySrzwwgvRpk2bdyzoIyLq6upi5syZ8eCDD0ZERFVVVUREtGnTJj7zmc/Eiy++GJlM5oDHNeXPf/5zLF26NObOnRu7d++O8847L5544ok4/PDDmxz3yiuvxMqVK6O4uLjBeZSVlcXRRx8dERG33357fOpTn9rvc2/Hxo0bY8mSJfHDH/4wduzYEbNmzYqIiOuvvz6+973vRZcuXSIiYtCgQXHhhRfGscce2+S4phx11FExcuTIePTRR/d7+tib/dd//Vd88IMfjKuuuiqWL18e1157bcyePXu/zwE0RNgDrWbr1q2RzWZj7ty5ceWVV0b79u1j8eLFccYZZ0RNTU384he/iKqqqqiuro7jjjsutm3bFueff34cffTRcdhhr//x9eyzz8bw4cOjXbt2udd95plnYsaMGTF8+PDYsGFDDBs2LIqLi3MhPm7cuKisrIwXXnghCgoK4p577smN/djHPhbjx4+PLVu2xJAhQ6K4uDheeumlOO+88+K5556LCy64IDp27Bhf/OIX39HPqqysLI488sjc8n/+53/We76xHzL2N64h99xzT+4IdseOHaNv376xYMGC+Pd///cmx+3cuTOKiooafG7UqFG5cF+zZk2ceOKJud/Dpp57OzZs2JD7V4Cjjjoqrrrqqoh4/XSq559/Ps4///yIiHjve98b69aty4V9Y+MORD4/7GWz2fj5z38eS5cujYiI0047LZ588smoqKiI4uLiRp9z1B5ojLAHWkVVVVUMGzYsunTpEocddlj84he/iD179sQLL7wQe/fujbZt28b5558fW7ZsieOPPz4WLlwYXbp0iWeffbZe9J1++unxxBNP1HvtU045JS699NKIiOjTp08899xzuefuvffeWL9+fWzYsCEuvvji2LNnT5SXl8dHPvKRGDRoUO5UnBNOOCFWrlwZa9asibvvvjumTZsWF198cfz+97+PiIj//u//jrq6uoP6mcyZMycqKyujbdu28eqrr8YNN9wQERHz58+P1atXR0lJScyaNSsKCgrisssu2+/rNTaurKwsfvCDH+yzfbdu3eL666+PxYsXx5QpU3Lr+/fvH08//fR+w75NmzYxY8aMeOmll2LNmjXx5S9/OYYNGxYRUe9fUO69996YOHFibrmp5/bnRz/6URQUFER1dXV07tw5dyrSAw88ECtWrIgXXnghZs2aFV26dImPfexjERHxy1/+Mnr37p17jbVr1+au0Whs3KpVq+KXv/zlPu9/8sknx+c+97kDnu+bvfzyy9GuXbt6of7+978/nnnmmTj55JMbfe6CCy5o1vsB6RP2QKv48Y9/HF/72tfiq1/9aoPPl5aWRo8ePeKWW26JL33pS7kjoW+O+k2bNkXPnj33Gbtnz55o3759vXWLFy+ORYsWxdlnnx1f+MIX4pprrolBgwZFnz59Yvv27fHd7343xo0bt88PCTNnzoyRI0dGRNQ7xeKMM86IgoKCeO2115r3AbzF008/HU888UT8+Mc/joiIfv36xRe/+MUoKiqKT3ziE9GvX7949tln47Of/ewBv2Zj47p37x7f+c53Gh1XVlaWO2Id8fr1CSUlJft9v507d8Ypp5wSV111VezatSsGDRoU5557br1Tpf7xj39EJpPZ5/dnf8815IEHHogdO3bENddcExERPXr0yIX9pz/96TjuuOPi8MMP3+cz++AHP5j77z/+8Y9xwQUX5E4famxcv379mvzMmuOtn3PE6591eXl5HH300Y0+B9AYYQ+0iqKiohgyZEicc8458eqrr8ZRRx2Vey6TycTSpUvjqaeeittuu63R0zJ+85vfxH/8x3/UW/fW88zLy8vj+eefj549e8ZNN90UERGrVq2KqqqqOP744yMionPnzvGd73wnVqxYEbW1tblz+hctWhS9e/eO0047LSIijjnmmNiwYUP06dMnunfvHvPmzYvZs2fvc2HptGnTYvbs2fHII49Et27dDujzuOeee+KKK67ILd9///2NntbS0urq6ur9EJPJZKJjx477HXfttdfm/rugoCA+/OEPx1NPPRVDhgzJrb/nnnviwgsvbHB8U881tv1Pf/rT3PKCBQsOeGxExObNm2PhwoVx++235zXuYHnr5xzxf591U88BNEbYA63ijaOsf/7zn3O3ixw4cGBERHz/+9+PAQMGxIABA+rdpebNMplMzJkzJ/7nf/6n3vp//vOf9U5feOihh+L++++vt01VVVVs27atXnBGRLz44ovx6U9/Ou66667YunVrHH300fXOpZ85c2acdtpp8Yc//CG6du0an/zkJ+O4446Lj370o/Vep7KyMrZu3brPhbdNKS0tje7du+eWG7r492DZ36k4Xbt2jYqKitxFxFVVVQf0A8r27dvrHWXu3Llz7i5Cb3jwwQcb/Veapp5ryNv5zCoqKuJnP/tZfPvb3250H3uzljgV543P+c3e+Kybeg6gMcIeaHUDBw6Mm2++OU444YRYv359/O53v4sFCxY0GVz33XdffPKTn9znjjgbN27MBWnE6xdmjhgxIndxZkTE1772tRg6dGi8/PLLceWVV9a78PYNXbt2ja5du8aUKVPq/fCwfv36uPzyyyPi9XOks9lsLF26tN7R9UmTJu339ohvddxxx8X27dvrrWupCyX3dyrOmWeeGcuXL899js8991y9+/Y35uMf/3hMnTo1zjnnnIh4PfTf/HtRXV0dq1evrvd7cSDPNeaNz+zNcV9ZWdngXXnerK6uLqZNmxa33HJLtGvXLjKZTKxevTre//73NzqmJU7FOfHEE2PHjh1RXV2d23/Wr18fAwYMiCOPPLLR5wAa45tngUPCjTfeGCNHjoxx48bFgw8+2OR51uvWrYvf//73cf311+/z3KpVq6Jv37655SOPPLJeLG7cuDGWLVsWQ4cOjYsvvjjGjh0b1dXVjb7XV77ylfjtb38bjz/+eDz++ONx6qmn5v579erVsWbNmn1Ombn99ttj0KBBeX277aWXXhq/+tWvcssrV66Ml1566YDH79mzJ6/bLDbl6quvzt0ec9euXbFhw4bcHWTuvffemDx5coPjevXqFR/4wAciImLv3r3x4osvxoc+9KHc8+vWrYvdu3c3OLax56677rrcRa9v9dbP7E9/+tMB3c5z2rRpcd111+VOufr973+/zw9VzdXQ78Ptt9/e4HcHtG3bNr74xS/GQw89FBERS5cujbPPPjs6derU5HMAjXHEHmh127dvjylTpsQZZ5wRGzZsiMmTJ8eoUaPqXeT4htLS0rj11lvjZz/7We5I+/PPPx/ZbDb69u0b9913X9x8880Nvs9LL70Uo0ePjp///OfRtm3b6NatW3z1q1+NT37ykzF48OC4/PLL49/+7d/qjdnfee67du2Kxx57LHf3l4jXvzSrqR8WGnLJJZfEqlWr4utf/3p06dIlOnfuHFdeeWVEvH5Lz9/+9rexfPnymDVrVpx55pm5u7hks9n4xS9+EQ8++GB06dKl3kWfTY1rygUXXBDPPfdc3HTTTVFdXR3Tp0/P/evJqlWrYtOmTQ2Omz59esycOTMOP/zwKC0tje9973v1ro8oKCiIXr16NTi2secuueSSRu/d/pWvfCUmTJgQEyZMiKOPPjre8573xIknnhgREX/5y1/ioYceilWrVsWsWbPi/PPPjxNOOCFeeeWVmDx5ckyfPj33+f3jH//I/ZoaG7c/O3bsiLlz58ajjz4a1dXVsWPHjtw+8cwzz+yzX73hm9/8ZowdOza+9a1vxZYtW+K73/3uAT0H0JA22YN1iAcgD29cILto0aLYs2dPjBw5MneHm0WLFsVdd90Vixcvjm7dusVHPvKRuPXWW6OkpCQWLVpU72hrxOtHh6dNmxY33XRTnHfeefG///u/9U7jWbZsWSxcuDD27t0bV1999T6xvnPnzvj2t78dM2bMiG984xtxww03xEsvvRRf/vKX95n3s88+G6eeempuuaysLNavXx9/+ctf4swzzzzInxLbtm2Lb3zjGzFjxozWngrAIU/YA++4Xbt2xaJFi6JXr17Rr1+/Rrerra2NlStXRt++fXPnG5988smNbr9o0aL4f//v/9U7Srx27dpo3759o0eK32zPnj31vl21rKwsunbt+o5+wyz1/eQnP4krrrjCKSgAB0DYAwBAAhyGAgCABOQd9iUlJfGTn/yk3tdx78/GjRtj5MiR8c1vfjNuvvnmg3bnBgAA4HXNPhWnV69ejd4Z4a0++tGPxvTp0+Pkk0+OO++8M4466qgYPXp0c94WAABoQLNPxTnQi8nWrVsXlZWVuQvehg0bFnfffXdz3xYAAGhAi59j/9RTT8Xpp5+eW+7bt2+sXr06amtrW/qtAQDgXaPFv6CqrKwsOnfuXG9dp06dYvv27XH88cfvs31tbW296M9kMlFRURGdO3du8uvlAQDgX0U2m41XXnkljj/++IN2W+UWD/u6urp9LpbNZDLRsWPHBrefMmVKTJw4saWnBQAAra60tDR69OhxUF6rxcO+a9eusX79+nrrdu3aFcccc0yD248fPz5uuOGG3HJ1dXX06tUrSktLo7CwsEXnCgAA74Sampro2bPnQf0CvhYP+zPPPLPexbKrV6+u93Xsb9WhQ4d6XxX/hsLCQmEPAEBSDuap5s0+oWfPnj25U2wymUyMGDEili1bts92AwYMiCOOOCLWrl0bERHz5s1zq0sAADjI8g77devWxXe+8514+eWXY+zYsbFs2bKoq6uLJUuWxObNmxscM2vWrLj99ttj4sSJUVFREZ/97Gff9sQBAID/0+wvqHqn1NTURFFRUVRXVzsVBwCAJLRE47b4fewBAICWJ+wBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEiDsAQAgAcIeAAASIOwBACABwh4AABIg7AEAIAHCHgAAEnBYvgMqKytjzJgx0adPn6ioqIg77rgjOnbs2OSY3/3ud7FixYooKiqKzZs3x5gxY6Jbt27NnjQAAFBf3mE/duzYGD58eAwdOjQefvjhmDRpUkyePLnR7bdv3x73339/zJo1KyIiysrKYuzYsTF79uzmzxoAAKgnr1NxduzYEY899lgMGTIkIiKGDh0a9913X2QymUbHlJSURKdOnXLL3bt3j3/84x/NnC4AANCQvMJ+xYoVcdJJJ0Xbtq8PKygoiMLCwigpKWl0zIABA+LRRx+N+fPnR0TE3//+9zj33HMb3b62tjZqamrqPQAAgKblFfZlZWXRuXPneuuKi4ujvLy80TEdO3aMefPmxciRI+MTn/hEPPDAAzFhwoRGt58yZUoUFRXlHj179sxnigAA8K6UV9jX1dVFNputty6TyTR58Wwmk4np06fHkiVL4qKLLooZM2bE008/3ej248ePj+rq6tyjtLQ0nykCAMC7Ul4Xz3bt2jUqKirqrauqqmryDjePPPJI9O3bN/fo06dPXHvttfG3v/2twe07dOgQHTp0yGdaAADwrpfXEfuBAwfGypUrc0ftd+7cGZlMJrp3797omBdffDH69euXW77ooov2+eEAAAB4e/IK++Li4hg8eHAsXLgwIiIWLFgQo0aNimw2GyNGjIhly5btM+bss8+OJUuW5Ja3bdsW/fv3f5vTBgAA3izv+9hPnz49xo0bF08++WSUl5fH1KlTo66uLpYsWRKbN2+O008/vd72H/rQh2LTpk1x5513RkFBQWzZsiXuvvvug/YLAAAAItpk33o17CGmpqYmioqKorq6OgoLC1t7OgAA8La1ROPmdSoOAABwaBL2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJAAYQ8AAAkQ9gAAkABhDwAACRD2AACQAGEPAAAJEPYAAJCAw/IdUFlZGWPGjIk+ffpERUVF3HHHHdGxY8cmx9TW1sYPf/jDaN++fSxdujQuv/zyuOiii5o9aQAAoL68w37s2LExfPjwGDp0aDz88MMxadKkmDx5cpNjJk6cGNdff30cd9xx8Ze//CU2b97c7AkDAAD7apPNZrMHuvGOHTuiX79+sWHDhmjbtm3s2rUr3vOe98TmzZujbduGz+rZtm1bfPWrX43777+/WROsqamJoqKiqK6ujsLCwma9BgAAHEpaonHzOsd+xYoVcdJJJ+UivqCgIAoLC6OkpKTRMYsWLYru3bvHTTfdFKNHj44LL7wwnn/++bc3awAAoJ68TsUpKyuLzp0711tXXFwc5eXl0bdv3wbHbNiwIebPnx/z58+Pvn37xqpVq+K6666LRx99tMHta2tro7a2NrdcU1OTzxQBAOBdKa8j9nV1dfHWM3cymUyTF8/u2rUrLrjgglz49+vXL7Zt2xa7d+9ucPspU6ZEUVFR7tGzZ898pggAAO9KeYV9165do6Kiot66qqqq6NatW6NjOnXqFO3atau3rri4uNEj8ePHj4/q6urco7S0NJ8pAgDAu1Jep+IMHDgwVq5cGdlsNtq0aRM7d+6MTCYT3bt3b3RM//79Y/78+fXW7d69O7p06dLg9h06dIgOHTrkMy0AAHjXy+uIfXFxcQwePDgWLlwYERELFiyIUaNGRTabjREjRsSyZcv2GXPOOedESUlJ7sh7VVVVDBgwINq0aXMQpg8AAEQ04z7206dPj3HjxsWTTz4Z5eXlMXXq1Kirq4slS5bE5s2b4/TTT6+3ffv27ePBBx+Mm2++OT784Q9HRUVFTJky5aD9AgAAgDzvY98a3MceAIDUtPp97AEAgEOTsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIgLAHAIAECHsAAEiAsAcAgAQIewAASICwBwCABAh7AABIQN5hX1lZGZ///Ofjtttui6997Wuxe/fuvMYOGjQo37cEAAD2I++wHzt2bAwfPjxuu+22OP/882PSpEkHPPbee++NrVu35vuWAADAfuQV9jt27IjHHnsshgwZEhERQ4cOjfvuuy8ymcx+xy5evDjOOOOM5s0SAABoUl5hv2LFijjppJOibdvX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",
      "text/plain": [
       "<Figure size 900x1800 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "from itertools import cycle\n",
    "import math\n",
    "def create_flexible_plot_updated(\n",
    "    df: pd.DataFrame,\n",
    "    x_param: str = 'meshsz',         \n",
    "    y_param: str = 'Bcf12f',        \n",
    "    subplot_params: list = ['cf1f', 'cf2f'], \n",
    "    line_params: list = ['H', 'B', 'T1', 'T2', 'L'],  # 包含L参数\n",
    "    plot_type: str = 'line',          \n",
    "    palette: str = 'husl',            \n",
    "    marker_pool: list = ['o', 's', 'D', '^', 'p'], \n",
    "    legend_cols: int = 2,             \n",
    "    invert_xaxis: bool = True,         \n",
    "    manual_nrows: int = 3,            \n",
    "    manual_ncols: int = 1              # 示例布局参数\n",
    "):\n",
    "    subplot_combos = df[subplot_params].drop_duplicates().apply(tuple, axis=1).unique()\n",
    "    line_combos = df[line_params].drop_duplicates().apply(tuple, axis=1).unique()\n",
    "    n_lines = len(line_combos)\n",
    "    colors = sns.color_palette(palette, n_colors=n_lines)\n",
    "    markers = marker_pool\n",
    "    marker_cycle = cycle(markers)\n",
    "\n",
    "    fig = plt.figure(figsize=(9, 18))\n",
    "    nrows, ncols = manual_nrows, manual_ncols\n",
    "\n",
    "    for idx, sp_combo in enumerate(subplot_combos, start=1):\n",
    "        ax = fig.add_subplot(nrows, ncols, idx)\n",
    "        cf1f, cf2f = sp_combo\n",
    "        ax.set_title(f'受力类型：cf1f={cf1f:.3f},cf2f={cf2f:.2f}', fontsize=10)\n",
    "        \n",
    "        subset = df[df[subplot_params].apply(tuple, axis=1) == sp_combo]\n",
    "\n",
    "        for l_idx, line_combo in enumerate(line_combos):\n",
    "            # 构建线条筛选条件（包含L参数）\n",
    "            line_mask = pd.DataFrame([(subset[col] == val) for col, val in zip(line_params, line_combo)]).T.all(axis=1)\n",
    "            line_data = subset[line_mask]\n",
    "            \n",
    "            if line_data.empty:\n",
    "                continue\n",
    "            \n",
    "            # ------------------- 正确生成百分比偏差列（后缀为_percent_deviation）-------------------\n",
    "            min_meshsz = line_data[x_param].min()\n",
    "            baseline_result = line_data[line_data[x_param] == min_meshsz][y_param].values[0]\n",
    "            if baseline_result == 0:\n",
    "                line_data[y_param + '_percent_deviation'] = 0  # 处理零基准值（可根据需求调整）\n",
    "            else:\n",
    "                line_data[y_param + '_percent_deviation'] = ((line_data[y_param] - baseline_result) / baseline_result) * 100\n",
    "            # ------------------- 核心修正：列名使用_percent_deviation -------------------\n",
    "            \n",
    "            plot_args = {\n",
    "                'x': x_param,\n",
    "                'y': y_param + '_percent_deviation',  # 使用正确的百分比偏差列\n",
    "                'data': line_data.sort_values(x_param, ascending=not invert_xaxis),\n",
    "                'color': colors[l_idx],\n",
    "                'marker': next(marker_cycle),\n",
    "                'label': f'H={int(line_combo[0])}, B={int(line_combo[1])}, T1={int(line_combo[2])}, T2={int(line_combo[3])},L={int(line_combo[4])}',\n",
    "                'markersize': 8,\n",
    "                'ax': ax\n",
    "            }\n",
    "\n",
    "            if plot_type == 'line':\n",
    "                sns.lineplot(linewidth=2, **plot_args)\n",
    "            elif plot_type == 'scatter':\n",
    "                sns.scatterplot(s=80, edgecolor='w', **plot_args)\n",
    "\n",
    "        # ------------------- 更新纵坐标标签（明确百分比）-------------------\n",
    "#         ax.set_ylabel(f'{y_param} Deviation (%) vs Min {x_param}')\n",
    "        ax.set_ylabel(f'{y_param} 变化百分比(%)')\n",
    "        ax.set_xlabel(f'网格尺寸')\n",
    "        # ------------------- 其他子图设置保持不变 -------------------\n",
    "        ax.grid(alpha=0.3)\n",
    "        if invert_xaxis:\n",
    "            ax.invert_xaxis()\n",
    "\n",
    "    # 图例和全局设置（根据line_params包含L调整标签）\n",
    "#     legend_elements = [\n",
    "#         plt.Line2D([0], [0], \n",
    "#                   color=colors[i],\n",
    "#                   marker=markers[i%len(markers)],\n",
    "#                   linestyle='' if plot_type=='scatter' else '-',\n",
    "#                   label=f'H={int(combo[0])}, B={combo[1]}, T1={combo[2]}, T2={combo[3]}, L={combo[4]}'\n",
    "#                  )\n",
    "#         for i, combo in enumerate(line_combos)\n",
    "#     ]\n",
    "    \n",
    "#     fig.legend(\n",
    "#         handles=legend_elements,\n",
    "#         loc='center right',\n",
    "#         bbox_to_anchor=(1.05, 0.5),\n",
    "#         ncol=legend_cols,\n",
    "#         title='H/B/T1/T2/L Combinations',\n",
    "#         fontsize=9\n",
    "#     )\n",
    "\n",
    "#     plt.suptitle(f'{y_param} Percentage Deviation vs {x_param} by cf1f/cf2f', fontsize=12)\n",
    "    \n",
    "    plt.tight_layout(rect=[0, 0, 0.9, 0.97])\n",
    "    return fig, None\n",
    "data = final_data.copy()\n",
    "# data = data[data['L'] == 2000]\n",
    "# data=data[(data['L']==1000)] \n",
    "display(data)\n",
    "fig, _ = create_flexible_plot_updated(\n",
    "    df=data,\n",
    "    x_param='meshsz',         \n",
    "    y_param='Pucf12f',        \n",
    "    subplot_params=['cf1f', 'cf2f'],  # 子图按这两个参数的所有组合分组\n",
    "    line_params=['H', 'B', 'T1', 'T2', 'L'],  # 线条标签仅用这四个参数\n",
    "    plot_type='line',          \n",
    "    palette='husl',            \n",
    "    marker_pool=['o', 's', 'D', '^', 'p'], \n",
    "    legend_cols=2,             \n",
    "    invert_xaxis=True,         \n",
    "    manual_nrows=3,            # 手动设置3行\n",
    "    manual_ncols=1             # 手动设置2列\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4aa1f4b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 计算参数重要性\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "\n",
    "features = ['H','B','T1','L','cf1f','cf2f']\n",
    "model = RandomForestRegressor().fit(data[features], data['Bcf12f'])\n",
    "\n",
    "plt.figure(figsize=(10, 5))\n",
    "pd.Series(model.feature_importances_, index=features).sort_values().plot.barh()\n",
    "plt.title('参数对Bcf12f的影响重要性')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b39577fe",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_convergence(group, result_col, threshold=2.0):\n",
    "    group = group.sort_values('meshsz', ascending=True)\n",
    "    baseline = group[result_col].iloc[0]\n",
    "    group['rel_error'] = (group[result_col] - baseline) / baseline * 100\n",
    "    \n",
    "    # 寻找收敛点\n",
    "    converged = group[group['rel_error'].abs() < threshold]\n",
    "    return converged['meshsz'].max() if not converged.empty else np.nan\n",
    "\n",
    "# 按关键参数分组计算\n",
    "convergence_results = data.groupby(['L', 'cf1f', 'B']).apply(\n",
    "    lambda g: pd.Series({\n",
    "        'Bcf12f_mesh': calculate_convergence(g, 'Bcf12f', 2.0),\n",
    "        'Pucf12f_mesh': calculate_convergence(g, 'Pucf12f', 1.5)\n",
    "    })\n",
    ").reset_index()\n",
    "\n",
    "print(\"各参数组合收敛阈值：\")\n",
    "display(convergence_results)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a5eec21",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(14, 6))\n",
    "for i, col in enumerate(['Bcf12f_mesh', 'Pucf12f_mesh'], 1):\n",
    "    plt.subplot(1, 2, i)\n",
    "    sns.boxplot(x='L', y=col, hue='cf1f', data=convergence_results)\n",
    "    plt.title(f'{col.split(\"_\")[0]} 收敛meshsz分布')\n",
    "plt.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "46af4a59",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy import stats\n",
    "\n",
    "# ====================== 修正后的收敛分析函数 ======================\n",
    "def analyze_mesh_convergence(result_col, data, mesh_col='meshsz', error_threshold=1.0):\n",
    "    \"\"\"修正后的网格收敛性分析函数（基准为最小meshsz）\"\"\"\n",
    "    # 按meshsz升序排序（最小meshsz为最细网格）\n",
    "    grouped = data.groupby(mesh_col)[result_col].agg(['mean', 'std', 'count'])\n",
    "    grouped = grouped.sort_index(ascending=True)  # 确保升序排列\n",
    "    \n",
    "    if len(grouped) < 2:\n",
    "        print(f\"【{result_col}】样本不足，至少需要2个不同meshsz\")\n",
    "        return np.nan\n",
    "    \n",
    "    # 计算相对误差（以最细网格为基准）\n",
    "    finest_mean = grouped['mean'].iloc[0]\n",
    "    grouped['rel_error'] = (grouped['mean'] - finest_mean) / finest_mean * 100\n",
    "    \n",
    "    # 计算误差变化率\n",
    "    x = grouped.index.values\n",
    "    y = grouped['rel_error'].abs().values\n",
    "    dy = np.gradient(y, x)\n",
    "    \n",
    "    # 寻找收敛区域\n",
    "    convergence_mask = (y < error_threshold) & (np.abs(dy) < error_threshold/2)\n",
    "    convergence_zones = np.where(convergence_mask)[0]\n",
    "    \n",
    "    # 确定最优meshsz\n",
    "    optimal_mesh = None\n",
    "    if len(convergence_zones) > 0:\n",
    "        optimal_mesh = x[convergence_zones[0]]\n",
    "        \n",
    "        # 置信区间检验\n",
    "        sample = data[data[mesh_col] == optimal_mesh][result_col]\n",
    "        t_stat, p_value = stats.ttest_1samp(sample, finest_mean)\n",
    "        if p_value < 0.05:\n",
    "            print(f\"  ⚠️ 警告：meshsz={optimal_mesh}与基准值有显著差异 (p={p_value:.4f})\")\n",
    "    else:\n",
    "        print(f\"【{result_col}】未找到收敛区间\")\n",
    "\n",
    "    return optimal_mesh if optimal_mesh else np.nan\n",
    "\n",
    "# ====================== 主分析流程 ======================\n",
    "# 定义关键控制参数（去重并选择重要参数）\n",
    "CONTROL_PARAMS = ['H', 'B', 'L', 'cf1f', 'cf2f']  # 移除重复的T1\n",
    "\n",
    "# 生成参数组合分组键\n",
    "group_keys = []\n",
    "for col in CONTROL_PARAMS:\n",
    "    if data[col].nunique() <= 5:  # 更严格的分组控制\n",
    "        group_keys.append(col)\n",
    "\n",
    "# 分层分析\n",
    "groups = data.groupby(group_keys)\n",
    "print(f\"总分组数：{len(groups)}\")\n",
    "\n",
    "results = []\n",
    "for name, group in groups:\n",
    "    if len(group) < 3:  # 至少需要3个数据点\n",
    "        continue\n",
    "    \n",
    "    try:\n",
    "        optimal_mesh = analyze_mesh_convergence(\n",
    "            result_col='Bcf12f',\n",
    "            data=group,\n",
    "            error_threshold=5.0  # 可调整误差阈值\n",
    "        )\n",
    "        \n",
    "        results.append({\n",
    "            'group_params': str(name),\n",
    "            'optimal_mesh': optimal_mesh,\n",
    "            'group_size': len(group)\n",
    "        })\n",
    "    except Exception as e:\n",
    "        print(f\"分组 {name} 分析失败：{str(e)}\")\n",
    "\n",
    "# 结果处理与分析\n",
    "summary_df = pd.DataFrame(results).dropna(subset=['optimal_mesh'])\n",
    "\n",
    "if not summary_df.empty:\n",
    "    print(\"\\n各子组推荐meshsz统计：\")\n",
    "    print(summary_df['optimal_mesh'].describe())\n",
    "    \n",
    "    # 可视化\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    plt.hist(summary_df['optimal_mesh'], bins=15, edgecolor='k', alpha=0.7)\n",
    "    plt.xlabel('Optimal Mesh Size')\n",
    "    plt.ylabel('Frequency')\n",
    "    plt.title('Optimal Mesh Size Distribution Across Parameter Groups')\n",
    "    plt.grid(True)\n",
    "    plt.show()\n",
    "    \n",
    "    # 输出推荐值\n",
    "    mode_mesh = summary_df['optimal_mesh'].mode()[0]\n",
    "    print(f\"\\n推荐全局meshsz: {mode_mesh}（出现频次最高）\")\n",
    "else:\n",
    "    print(\"警告：未找到有效推荐值，请检查输入参数或放宽阈值\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "36aabaab",
   "metadata": {},
   "source": [
    "#### 敏感性分析确认修改df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c20c16f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_all_dic = df_all_dic[(df_all_dic['meshsz'] == 40) | (df_all_dic['meshsz'] == 20)].copy()\n",
    "display('df_all_dic',df_all_dic)\n",
    "df_alltype =df_alltype[(df_alltype['meshsz'] == 40) | (df_alltype['meshsz'] == 20)]\n",
    "display('df_alltype',df_alltype)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f06d9018",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "def adjust_column_types(df):\n",
    "    for col in df.columns:\n",
    "        s = df[col].dropna()  # 排除NaN以便判断\n",
    "        has_nan = df[col].isna().any()\n",
    "        \n",
    "        # 检查是否全为整数（无NaN且所有值为整数）\n",
    "        all_integers = (s % 1 == 0).all()\n",
    "        if all_integers and not has_nan:\n",
    "            df[col] = df[col].astype(int)\n",
    "            continue\n",
    "        \n",
    "        # 检查是否存在非0/0.5的小数\n",
    "        has_other_decimals = ((s % 1) != 0) & ((s % 1) != 0.5)\n",
    "        if has_other_decimals.any():\n",
    "            continue  # 存在其他小数，保持原样\n",
    "        \n",
    "        # 处理0.5小数的情况：整数型浮点转为int，其余保持\n",
    "        df[col] = df[col].apply(lambda x: int(x) if x % 1 == 0 else x)\n",
    "    return df\n",
    "\n",
    "# 示例用法\n",
    "# df = pd.DataFrame(...)  # 替换为你的DataFrame\n",
    "adjusted_df = adjust_column_types(df_all_dic)\n",
    "df_alltype= adjust_column_types(df_alltype)\n",
    "display(df_alltype)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7860b7ef",
   "metadata": {},
   "source": [
    "### 标签及索引"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "593ee060",
   "metadata": {},
   "source": [
    "#### 展示行列"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef8f8d1c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "def add_combination_count(original_df, type_value):\n",
    "    \"\"\"\n",
    "    通用函数：为指定type的筛选数据计算组合出现次数，并添加到去重后的组合数据中\n",
    "    \n",
    "    参数：\n",
    "        original_df: 原始数据（未筛选前的完整数据）\n",
    "        type_value: 要筛选的type值（0, 1, 2）\n",
    "    \n",
    "    返回：\n",
    "        去重后的组合数据（含count列）\n",
    "    \"\"\"\n",
    "    # 步骤1：筛选指定type的数据\n",
    "    filtered_df = original_df[original_df['type'] == type_value].copy()\n",
    "    \n",
    "    # 步骤2：去重得到唯一组合（与用户原逻辑一致）\n",
    "    unique_combinations = filtered_df[['cf1f', 'cf2f', 'axialratio']].drop_duplicates()\n",
    "    \n",
    "    # 步骤3：分组统计每个组合的出现次数\n",
    "    # 按三列分组，统计每组的行数（出现次数）\n",
    "    count_df = filtered_df.groupby(['cf1f', 'cf2f', 'axialratio']).size().reset_index(name='count')\n",
    "    \n",
    "    # 步骤4：合并次数到唯一组合数据中（确保顺序与去重结果一致）\n",
    "    merged_df = pd.merge(\n",
    "        unique_combinations,  # 去重后的组合（保留原始顺序）\n",
    "        count_df,             # 统计的次数\n",
    "        on=['cf1f', 'cf2f', 'axialratio'],  # 按三列匹配\n",
    "        how='left'            # 左连接（确保去重后的组合全部保留）\n",
    "    )\n",
    "    \n",
    "    # 验证：确保合并后无缺失值（理论上不会有，因count_df包含所有组合）\n",
    "    if merged_df['count'].isna().any():\n",
    "        print(f\"警告：type={type_value} 的数据中存在未统计到的组合，可能是去重或分组错误！\")\n",
    "    \n",
    "    return merged_df\n",
    "\n",
    "# ====================== 实际调用 ======================\n",
    "# 假设原始数据为 dfdelpara（需替换为实际数据）\n",
    "dfdelpara = dfdelpara\n",
    "\n",
    "# 计算三种type的组合次数\n",
    "unique_combinations_T = add_combination_count(dfdelpara, type_value=0)\n",
    "unique_combinations_S = add_combination_count(dfdelpara, type_value=1)\n",
    "unique_combinations_B = add_combination_count(dfdelpara, type_value=2)\n",
    "\n",
    "# 打印结果（示例）\n",
    "print(\"===== unique_combinations_T（含次数） =====\")\n",
    "print(unique_combinations_T)\n",
    "print(\"\\n===== unique_combinations_S（含次数） =====\")\n",
    "print(unique_combinations_S)\n",
    "print(\"\\n===== unique_combinations_B（含次数） =====\")\n",
    "print(unique_combinations_B)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e4ab03cc",
   "metadata": {},
   "source": [
    "#### 展示各列数据"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f9cf7d9",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.650810Z",
     "start_time": "2024-02-05T07:20:38.635880Z"
    }
   },
   "outputs": [],
   "source": [
    "df=df_alltype\n",
    "df['Bcf1f'].value_counts()\n",
    "df['Bcf2f'].value_counts()\n",
    "df['Bcf3f'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4ff42dcd",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.665795Z",
     "start_time": "2024-02-05T07:20:38.651837Z"
    }
   },
   "outputs": [],
   "source": [
    "df_all_dic['axialratio'].value_counts()\n",
    "df_all_dic.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b03f7a1",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.681752Z",
     "start_time": "2024-02-05T07:20:38.666768Z"
    }
   },
   "outputs": [],
   "source": [
    "df['B'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6d4b9fca",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.697710Z",
     "start_time": "2024-02-05T07:20:38.682727Z"
    }
   },
   "outputs": [],
   "source": [
    "df['Imperfectfactor'].value_counts()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c6daf6c4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.713672Z",
     "start_time": "2024-02-05T07:20:38.699680Z"
    }
   },
   "outputs": [],
   "source": [
    "df['T2'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a5003636",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.729629Z",
     "start_time": "2024-02-05T07:20:38.714640Z"
    }
   },
   "outputs": [],
   "source": [
    "df['L'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f17f52c2",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.745557Z",
     "start_time": "2024-02-05T07:20:38.730598Z"
    }
   },
   "outputs": [],
   "source": [
    "df['n'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0e8133ac",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.761514Z",
     "start_time": "2024-02-05T07:20:38.746554Z"
    }
   },
   "outputs": [],
   "source": [
    "df['Imperfectfactor'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2b3bd462",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.776476Z",
     "start_time": "2024-02-05T07:20:38.762512Z"
    }
   },
   "outputs": [],
   "source": [
    "df['Imperfectfactor'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "81a1fc7d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.792434Z",
     "start_time": "2024-02-05T07:20:38.777473Z"
    }
   },
   "outputs": [],
   "source": [
    "df['sfricn'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e163ba55",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.808390Z",
     "start_time": "2024-02-05T07:20:38.793430Z"
    }
   },
   "outputs": [],
   "source": [
    "df['pbol'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "184cf0c4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.824347Z",
     "start_time": "2024-02-05T07:20:38.809386Z"
    }
   },
   "outputs": [],
   "source": [
    "# df['Pucff'].value_counts()\n",
    "df['KG_quge_web'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aa3e24f2",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.840304Z",
     "start_time": "2024-02-05T07:20:38.825344Z"
    }
   },
   "outputs": [],
   "source": [
    "for i in range(0,len(df.columns)):\n",
    "    name = df.columns[i]\n",
    "    print(name)\n",
    "#     print(df[name].value_counts())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62a504ef",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.856262Z",
     "start_time": "2024-02-05T07:20:38.844294Z"
    }
   },
   "outputs": [],
   "source": [
    "df['n'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c829fe2c",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.871222Z",
     "start_time": "2024-02-05T07:20:38.858256Z"
    }
   },
   "outputs": [],
   "source": [
    "# min(dfdelpara['ratio_alpha_tflange_to_tweb'])\n",
    "max(dfdelpara['ratio_alpha_tflange_to_tweb'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "332957eb",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.887179Z",
     "start_time": "2024-02-05T07:20:38.872218Z"
    }
   },
   "outputs": [],
   "source": [
    "print(max(df['k_taucr_fem2']),\n",
    "min(df['k_taucr_fem2']))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9cb83be6",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.903136Z",
     "start_time": "2024-02-05T07:20:38.895158Z"
    }
   },
   "outputs": [],
   "source": [
    "df\n",
    "print(len(df))\n",
    "dt_T=df\n",
    "# dt_T.to_excel('dt_T.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3bd81952",
   "metadata": {},
   "source": [
    "## 打开图片"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3b379a81",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:38.919094Z",
     "start_time": "2024-02-05T07:20:38.904135Z"
    }
   },
   "outputs": [],
   "source": [
    "# from PIL import Image\n",
    "\n",
    "\n",
    "# picname='ElasticA'+'100'+'B100C6.0D8.0L3000E2F2'\n",
    "# img = Image.open(r'R:\\Jupyterdemo\\\\'+picname+'.tiff') # 打开图像\n",
    "# img.show() # 显示图像\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e8247023",
   "metadata": {},
   "source": [
    "## 绘图包的导入"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "775c40c4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-02-05T07:20:40.823096Z",
     "start_time": "2024-02-05T07:20:38.920092Z"
    }
   },
   "outputs": [],
   "source": [
    "# 绘图包\n",
    "from matplotlib import pyplot as plt\n",
    "# %matplotlib inline\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "# 拟合包\n",
    "# import statsmodels.api as sm\n",
    "from scipy.stats import pearsonr\n",
    "from scipy.optimize import curve_fit\n",
    "import math\n",
    "# 机器学习包\n",
    "from sklearn.model_selection import train_test_split,cross_val_score\n",
    "from sklearn.linear_model import Lasso, Ridge, LinearRegression as LR\n",
    "\n",
    "from sklearn import linear_model\n",
    "from sklearn.model_selection import GridSearchCV\n",
    "from sklearn.metrics import r2_score, explained_variance_score as EVS, mean_squared_error as MSE\n",
    "from pylab import xticks,yticks,np\n",
    "# from symfit import Fit \n",
    "# from symfit import parameters, variables, Fit, Piecewise, exp, Eq, Model\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from matplotlib.ticker import IndexLocator\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=12)  # 字体设置宋体\n",
    "plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "# plt.rcParams['font.sans-serif'] = ['SimHei']  # 设置中文字体为黑体\n",
    "plt.rcParams['axes.unicode_minus'] = False     # 解决负号显示问题"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ae224cc7",
   "metadata": {},
   "source": [
    "# 数据自变量参数设置分析"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7be2527d",
   "metadata": {},
   "source": [
    "## 参数分布图"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "59a79e4c",
   "metadata": {},
   "source": [
    "### 一维分布维关系图（柱状图）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3fd8c025",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.188006Z",
     "start_time": "2023-12-27T12:36:51.003523Z"
    }
   },
   "outputs": [],
   "source": [
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "from matplotlib.font_manager import FontProperties\n",
    "import numpy as np\n",
    "\n",
    "# plt.rcParams['axes.grid'] = False\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=12)  # 字体设置宋体\n",
    "plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "# plt.rcParams['axes.unicode_minus'] = False\n",
    "# plt.rcParams['xtick.direction'] = 'in'  # x刻度向内侧显示\n",
    "# plt.rcParams['ytick.direction'] = 'in'  # y刻度向内侧显示\n",
    "# plt.tick_params(labelsize=12)\n",
    "# plt.rc('font', family='Times New Roman')  # 全局字体为新罗马\n",
    "\n",
    "general_list = ['yfss', 'Imperfectfactor', 'meshsz', 'cf1f', 'cf2f', 'cf3f', 'type']  # 筛选基础数据用的list_分离面内\n",
    "general_list_number = [355.61, 0.002, 20, 0, 1, 0, 0]  # 面内受剪_分离面内\n",
    "\n",
    "df_selected_del = df_T.copy()\n",
    "for i in range(0, len(general_list)):\n",
    "    df_selected_del = df_selected_del[df_selected_del[general_list[i]] == general_list_number[i]].copy()\n",
    "\n",
    "\n",
    "df_para = df_selected_del[(df_selected_del['n'] == 1)]\n",
    "\n",
    "\n",
    "# KH_quge_web、ratio_alpha_tflange_to_tweb、ratio_alpha_Bflange_to_Hn、GH_quge_web\n",
    "\n",
    "# 使用 plt.subplots 创建图形和坐标轴对象\n",
    "fig, ax = plt.subplots()\n",
    "# 使用 ax.hist 绘制直方图\n",
    "n, bins, patches = ax.hist(df_para['GH_quge_web'].values, bins='auto', edgecolor='black')\n",
    "# 在直方图的柱子上添加数值，仅添加计数不为 0 的柱子\n",
    "for rect, num in zip(patches, n):\n",
    "    height = rect.get_height()\n",
    "    if num > 0:\n",
    "        ax.text(rect.get_x() + rect.get_width() / 2, height, f'{int(num)}', ha='center', va='bottom', fontsize=10)\n",
    "# \\alpha}_{\\text {wKH}}、{t_2}/{t_1}\n",
    "plt.xlabel(str(r'${t_2}/{t_1}$'), fontproperties=font_setS, size=14)\n",
    "plt.ylabel('计算点数量', fontproperties=font_setS, size=12)\n",
    "\n",
    "plt.ylim(0, 300)\n",
    "\n",
    "# bwith = 1  # 边框宽度\n",
    "# TK = plt.gca()\n",
    "# TK.spines['bottom'].set_linewidth(bwith)  # 图框下边\n",
    "# TK.spines['left'].set_linewidth(bwith)  # 图框左边\n",
    "# TK.spines['top'].set_linewidth(bwith)  # 图框上边\n",
    "# TK.spines['right'].set_linewidth(bwith)  # 图框右边\n",
    "\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01aa2cea",
   "metadata": {},
   "source": [
    "### 二维关系图（散点图）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5655200",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.191994Z",
     "start_time": "2023-12-27T12:36:54.191994Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "from matplotlib.font_manager import FontProperties\n",
    "import latex\n",
    "import matplotlib.pyplot as plt\n",
    "# df2d_rela=df[(df['n']==1)]\n",
    "# # df2d_rela1=df2d_rela[(df2d_rela['KG_quge_web']==5.6)]ratio_alpha_tflange_to_tweb\n",
    "# print(len(df))\n",
    "pointsize=10\n",
    "textsize=14\n",
    "figsizex= 6# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= 6\n",
    "labelss=str(r'$\\mathrm{SS}$ ')\n",
    "labelsf=str(r'$\\mathrm{SF}$ ')\n",
    "labelfs=str(r'$\\mathrm{FS}$ ')\n",
    "labelff=str(r'$\\mathrm{FF}$ ')\n",
    "labeldftype0=str(r'$\\mathrm{S}_{\\mathrm{T}}$ ')\n",
    "labeldftype1=str(r'$\\mathrm{S}_{\\mathrm{S}}$ ')\n",
    "labeldftype2=str(r'$\\mathrm{S}_{\\mathrm{B}}$ ')\n",
    "\n",
    "# general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f', 'type']# 筛选基础数据用的list_分离面内\n",
    "# general_list_number=[355.61,     0.002       , 20     ,  0   , 1     ,0    , 0]# 面内受剪_分离面内\n",
    "# df_selected_del=dfdelpara.copy()\n",
    "# for i in range (0,len(general_list)):\n",
    "#     df_selected_del=df_selected_del[df_selected_del[general_list[i]]==general_list_number[i]].copy()\n",
    "# df=df_selected_del\n",
    "# ————————————第一张图————————————————\n",
    "# font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "# plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "# plt.rcParams['axes.unicode_minus']=False\n",
    "# plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "# plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "# plt.figure(figsize=[figsizex,figsizey])\n",
    "# plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# plt.grid(b=1, which='major') \n",
    "# linewidth=2\n",
    "\n",
    "# plt.legend(fontsize=textsize, title_fontsize=textsize)\n",
    "fig = plt.figure(figsize=[80,80])\n",
    "ylist=df.columns\n",
    "\n",
    "# num_ax=0\n",
    "for j in range (0,len(ylist)): \n",
    "    \n",
    "    ax_num=fig.add_subplot(12,12,j+1)# 小图编号参数\n",
    "    yname=ylist[j]\n",
    "    ax_num.scatter(df['KG_total_web'].values,df[yname].values,label=labeldftype0,c='black',s=10)#绘图命令\n",
    "    print(j)\n",
    "    ax_num.set_ylabel(yname,fontsize=textsize)\n",
    "    plt.show()\n",
    "# plt.scatter(dftype2['KG_quge_web'].values,dftype2['k_taucr_fem2_n'].values,label=labeldftype0,c='black',s=10)#绘图命令\n",
    "\n",
    "# xticks(np.linspace(0,3,13,endpoint=True),size=14)# x轴标签\n",
    "# yticks(np.linspace(5,45,9,endpoint=True),size=14)# y轴标签  \n",
    "# plt.xlim(0,3)\n",
    "# plt.ylim(5,45)\n",
    "# plt.xlabel(r'$\\frac{1}{\\alpha}$',fontsize=textsize)\n",
    "# plt.ylabel(r'$k_{\\mathrm{s}}$',fontsize=textsize)\n",
    "\n",
    "# pltsvgname=str('整体截面板件alph拟合受剪') #保存名字\n",
    "# plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "plt.show()\n",
    "# plt.clf\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "41ef30d6",
   "metadata": {},
   "source": [
    "### 相同值分组"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c1a8fe54",
   "metadata": {},
   "source": [
    "#### 参数分布情况图（几何）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4346d3b1",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.194988Z",
     "start_time": "2023-12-27T12:36:54.194988Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "import pandas as pd\n",
    "\n",
    "# 配置基本参数\n",
    "pointsize = 10\n",
    "textsize = 16\n",
    "figsizex = 3.5\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize)\n",
    "\n",
    "# 定义x取值列表\n",
    "x_values = ['H', 'B', 'T1', 'T2', 'n', 'L']\n",
    "\n",
    "# 定义x轴刻度映射（修正原代码中的重复刻度问题）\n",
    "xticks_dict = {\n",
    "    'H': [250, 500, 750, 1000],\n",
    "    'B': [100, 200, 300, 400],\n",
    "    'T1': [0, 5, 10, 15, 20, 25, 30],\n",
    "    'T2': [0, 5, 10, 15, 20, 25, 30, 35, 40],\n",
    "    'n': [0, 1, 2, 3, 4, 5, 6],\n",
    "    'L': [1000, 2000, 3000, 4000]\n",
    "}\n",
    "\n",
    "y = 'sfricn'  # 固定y值\n",
    "\n",
    "# 数据预处理（假设已正确筛选数据）\n",
    "data_var = df_all_dic[(df_all_dic[str('type')] == 2)].copy()\n",
    "\n",
    "for x in x_values:\n",
    "    # 创建新图形\n",
    "    plt.figure(figsize=(figsizex, figsizex))\n",
    "    \n",
    "    # 配置通用绘图参数\n",
    "    plt.rc('font', family='Times New Roman')\n",
    "    plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "    plt.rcParams['axes.unicode_minus'] = False\n",
    "    plt.rcParams['xtick.direction'] = 'in'\n",
    "    plt.rcParams['ytick.direction'] = 'in'\n",
    "    plt.tick_params(bottom=True, top=True, left=True, right=True)\n",
    "    \n",
    "    # 绘制散点图\n",
    "    plt.scatter(data_var[x].values, data_var[y].values, c='black', s=pointsize)\n",
    "    \n",
    "    # 设置x轴刻度\n",
    "    plt.xticks(xticks_dict[x], fontsize=textsize)\n",
    "    \n",
    "    # 设置y轴刻度（可根据需要扩展y的映射字典，当前示例保持固定）\n",
    "    plt.yticks(fontsize=textsize)  # 如需动态设置可添加y刻度映射\n",
    "    \n",
    "    # 设置坐标轴标签\n",
    "    plt.xlabel(r'${}$'.format(x), fontproperties=font_setS, fontsize=textsize)\n",
    "    plt.ylabel(r'$\\mu$', fontproperties=font_setS, fontsize=textsize)\n",
    "#     '$\\lambda$\n",
    "    plt.tight_layout()\n",
    "    \n",
    "    # 显示或保存图形（取消注释保存逻辑）\n",
    "    # plt.savefig(f'R:\\PhDall\\matplotilibpic\\{x}_para.svg', bbox_inches='tight')\n",
    "    plt.show()\n",
    "    plt.close()  # 关闭当前图形释放内存\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77916587",
   "metadata": {},
   "source": [
    "#### 参数分布情况图（物理）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3d3675a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_alltype_connect['F'].value_counts()\n",
    "#     'Imperfectfactor': [0.002, 0.005, 0.01, 0.02],  # 示例Y参数坐标\n",
    "#     'meshsz': [100, 200, 300, 400],                  # 网格尺寸坐标\n",
    "#     'yfss': [355.61, 461.03],                        # 材料强度坐标\n",
    "#     'L': [50, 100, 150, 200],                         # 长度参数坐标\n",
    "#     'n': [2, 4, 6, 8],                                # 数量参数坐标\n",
    "#     'sfricn': [0.3, 0.35, 0.4, 0.45],                 # 摩擦系数坐标\n",
    "#     'pbol': [1000, 2000, 3000],                       # 螺栓预紧力坐标\n",
    "#     'F': [1,2,3,4,5,6]      "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ca77b83",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "# ==================== 一、参数配置区（用户可修改部分） ====================\n",
    "param_config = {\n",
    "    'Imperfectfactor': {\n",
    "        'name': 'Imperfectfactor',  \n",
    "        'ticks': [0.002, 0.005, 0.01, 0.02],  \n",
    "        'convert': lambda x: x,         \n",
    "        'unit': ''                      \n",
    "    },\n",
    "    'meshsz': {\n",
    "        'name': '网格尺寸',           \n",
    "        'ticks': [ 10, 20, 40, 80, 100, 130, 160], \n",
    "        'convert': lambda x: x,         \n",
    "        'unit': 'mm'                    \n",
    "    },\n",
    "    'yfss': {\n",
    "        'name': '钢材强度等级',      \n",
    "        'ticks': [355.61, 461.03],       \n",
    "        'convert': lambda x: x,         \n",
    "        'unit': 'MPa'                   \n",
    "    },\n",
    "    'L': {\n",
    "        'name': '试件长度$L$',          \n",
    "        'ticks': [500, 1000, 1500, 2000, 3000, 4000],  \n",
    "        'convert': lambda x: x / 1000,  \n",
    "        'unit': 'm'                     \n",
    "    },\n",
    "    'n': {\n",
    "        'name': '拼接数量$n$',           \n",
    "        'ticks': [1, 2, 3, 4, 5, 6],     \n",
    "        'convert': lambda x: x,         \n",
    "        'unit': ''                      \n",
    "    },\n",
    "    'sfricn': {\n",
    "        'name': '摩擦系数$\\mu$',         \n",
    "        'ticks': [ 0.3, 0.35, 0.4, 0.45],  \n",
    "        'convert': lambda x: x,         \n",
    "        'unit': ''                      \n",
    "    },\n",
    "    'pbol': {\n",
    "        'name': '预紧力$P$',  \n",
    "        'ticks': [80000, 15000, 125000, 175000, 230000, 280000], \n",
    "        'convert': lambda x: x / 1000,  \n",
    "        'unit': 'kN'                    \n",
    "    },\n",
    "    'F': {\n",
    "        'name': '螺栓数量 $F$',               \n",
    "        'ticks': [1, 2, 3, 4, 5, 8, 10],  \n",
    "        'convert': lambda x: x,         \n",
    "        'unit': '个'                    \n",
    "    }\n",
    "}\n",
    "\n",
    "current_x = ['Imperfectfactor','meshsz', 'yfss', 'L', 'n', 'sfricn', 'pbol', 'F']\n",
    "current_y = 'pbol'\n",
    "\n",
    "plot_params = {\n",
    "    'pointsize': 10,        \n",
    "    'textsize': 10,         \n",
    "    'figsize': (3, 3),      \n",
    "    'dpi': 300,             \n",
    "    'scatter_color': '#1f77b4', \n",
    "    'grid_alpha': 0.2,      \n",
    "    'spine_width': 0.8,     \n",
    "    'tick_length': 3,       \n",
    "    'tick_width': 0.8,       \n",
    "    'fontsize':10       \n",
    "}\n",
    "\n",
    "\n",
    "# ==================== 二、绘图核心逻辑 ====================\n",
    "def draw_scatter_plots(data_var):\n",
    "    font_eng = {'family': 'Times New Roman', 'size': plot_params['textsize']}\n",
    "    font_chi = FontProperties(fname=r'c:\\windows\\fonts\\simsun.ttc', size=plot_params['textsize'])\n",
    "\n",
    "    current_x_filtered = [param for param in current_x if param != current_y]\n",
    "\n",
    "    if current_y not in param_config:\n",
    "        raise ValueError(f\"错误：Y参数 '{current_y}' 未在param_config中配置！\")\n",
    "\n",
    "    for x_param in current_x_filtered:\n",
    "        if x_param not in param_config:\n",
    "            print(f\"警告：参数 '{x_param}' 未配置，跳过绘图！\")\n",
    "            continue\n",
    "\n",
    "        fig, ax = plt.subplots(figsize=plot_params['figsize'], dpi=plot_params['dpi'])\n",
    "        \n",
    "        for spine in ax.spines.values():\n",
    "            spine.set_linewidth(plot_params['spine_width'])\n",
    "        \n",
    "        ax.tick_params(\n",
    "            direction='in',        \n",
    "            length=plot_params['tick_length'],\n",
    "            width=plot_params['tick_width'],\n",
    "            labelsize=plot_params['textsize'],\n",
    "            bottom=True, top=True, left=True, right=True\n",
    "        )\n",
    "\n",
    "        # 数据转换\n",
    "        x_data = param_config[x_param]['convert'](data_var[x_param].values)  # 关键：数据已转换为千牛\n",
    "        y_data = param_config[current_y]['convert'](data_var[current_y].values)\n",
    "\n",
    "        # 绘制散点图\n",
    "        ax.scatter(\n",
    "            x_data, y_data,\n",
    "            color=plot_params['scatter_color'],\n",
    "            s=plot_params['pointsize'],\n",
    "            alpha=0.8,\n",
    "            edgecolor='none'\n",
    "        )\n",
    "\n",
    "        # -------------------- 关键修复：X轴刻度标签显示转换后的值 --------------------\n",
    "        x_ticks_raw = np.unique(param_config[x_param]['ticks'])  \n",
    "        x_ticks_sorted = np.sort(x_ticks_raw)                   \n",
    "        x_ticks_converted = [param_config[x_param]['convert'](t) for t in x_ticks_sorted]  # 转换后的千牛值\n",
    "        ax.set_xticks(x_ticks_converted)  # 设置转换后的刻度位置\n",
    "        ax.set_xticklabels(  # 显示转换后的值（千牛）\n",
    "            [f\"{t:.0f}\" for t in x_ticks_converted],  # 格式化显示（去除小数位）\n",
    "#             rotation=45,\n",
    "            ha='right',\n",
    "            rotation_mode='anchor',\n",
    "            fontsize=plot_params['fontsize']\n",
    "        )\n",
    "\n",
    "        # Y轴刻度处理\n",
    "        y_ticks_raw = np.unique(param_config[current_y]['ticks'])\n",
    "        y_ticks_sorted = np.sort(y_ticks_raw)\n",
    "        y_ticks_converted = [param_config[current_y]['convert'](t) for t in y_ticks_sorted]\n",
    "        ax.set_yticks(y_ticks_converted)\n",
    "        ax.set_yticklabels(  # 显示转换后的值（千牛）\n",
    "            [f\"{t:.0f}\" for t in y_ticks_converted],  # 格式化显示（去除小数位）\n",
    "            #             rotation=45,\n",
    "            ha='right',\n",
    "            rotation_mode='anchor',\n",
    "            fontsize=plot_params['fontsize']\n",
    "        )\n",
    "#         ax.set_yticklabels(\n",
    "#             y_ticks_sorted,  # 显示原始刻度值\n",
    "#             fontsize=plot_params['fontsize']\n",
    "#         )\n",
    "\n",
    "        # 坐标轴标签\n",
    "        x_label = f\"{param_config[x_param]['name']}\"\n",
    "        if param_config[x_param]['unit']:\n",
    "            x_label += f\" ({param_config[x_param]['unit']})\"\n",
    "        ax.set_xlabel(x_label, fontproperties=font_chi, **font_eng)\n",
    "\n",
    "        y_label = f\"{param_config[current_y]['name']}\"\n",
    "        if param_config[current_y]['unit']:\n",
    "            y_label += f\" ({param_config[current_y]['unit']})\"\n",
    "        ax.set_ylabel(y_label, fontproperties=font_chi, **font_eng)\n",
    "\n",
    "        # 网格线\n",
    "        ax.grid(\n",
    "            visible=True, \n",
    "            which='major', \n",
    "            axis='both', \n",
    "            color='gray', \n",
    "            alpha=plot_params['grid_alpha'],\n",
    "            linestyle='--', \n",
    "            linewidth=0.5\n",
    "        )\n",
    "\n",
    "        # 保存图片\n",
    "        fig.tight_layout(pad=1.5)\n",
    "        plt.savefig(\n",
    "            f'{x_param}_vs_{current_y}_academic.svg', \n",
    "            bbox_inches='tight', \n",
    "            dpi=plot_params['dpi']\n",
    "        )\n",
    "        plt.show()\n",
    "        plt.close()\n",
    "\n",
    "\n",
    "# ==================== 三、测试数据与执行入口 ====================\n",
    "if __name__ == \"__main__\":\n",
    "    np.random.seed(42)\n",
    "  # 数据预处理（假设已正确筛选数据）\n",
    "    data_var = df_alltype_connect[(df_alltype_connect[str('type')] ==2)].copy()\n",
    "\n",
    "    draw_scatter_plots(data_var)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a240e2b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-03-19T11:50:34.166305Z",
     "start_time": "2023-03-19T11:50:33.692572Z"
    }
   },
   "source": [
    "#### 基本物理参数组"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "7414631d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "🚀 综合数据处理与可视化系统示例\n",
      "============================================================\n",
      "85558 len\n",
      "76417 len\n",
      "17826 len\n",
      "17826 len\n",
      "10408 len\n",
      "4745 len\n",
      "4745 len\n",
      "2979 len\n",
      "2891 len\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>H</th>\n",
       "      <th>B</th>\n",
       "      <th>T1</th>\n",
       "      <th>T2</th>\n",
       "      <th>L</th>\n",
       "      <th>n</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>...</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>F</th>\n",
       "      <th>pbol</th>\n",
       "      <th>sfricn</th>\n",
       "      <th>yfss</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>SFcf2f</th>\n",
       "      <th>KG_sing_web</th>\n",
       "      <th>KH_sing_flange</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>41386</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2327950.0</td>\n",
       "      <td>727939.0</td>\n",
       "      <td>0.738653</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41446</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>1549440.0</td>\n",
       "      <td>485504.0</td>\n",
       "      <td>0.738975</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41448</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>230000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>1551900.0</td>\n",
       "      <td>485191.0</td>\n",
       "      <td>0.738498</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41449</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>1551870.0</td>\n",
       "      <td>485166.0</td>\n",
       "      <td>0.738460</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41503</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>754790.0</td>\n",
       "      <td>242271.0</td>\n",
       "      <td>0.737510</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66411</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>230000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61760300.0</td>\n",
       "      <td>22960300.0</td>\n",
       "      <td>0.980978</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66412</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61159500.0</td>\n",
       "      <td>22958200.0</td>\n",
       "      <td>0.980889</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66413</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61632400.0</td>\n",
       "      <td>22208000.0</td>\n",
       "      <td>0.948836</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66414</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61756700.0</td>\n",
       "      <td>22962400.0</td>\n",
       "      <td>0.981068</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66415</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>65334600.0</td>\n",
       "      <td>22959200.0</td>\n",
       "      <td>0.980931</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>2891 rows × 22 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            H      B    T1    T2       L    n  cf1f  cf2f  cf3f  type  ...  \\\n",
       "41386   200.0  200.0   8.0  12.0  3000.0  3.0   0.0   1.0   0.0   2.0  ...   \n",
       "41446   200.0  200.0   8.0  12.0  3000.0  2.0   0.0   1.0   0.0   2.0  ...   \n",
       "41448   200.0  200.0   8.0  12.0  3000.0  2.0   0.0   1.0   0.0   2.0  ...   \n",
       "41449   200.0  200.0   8.0  12.0  3000.0  2.0   0.0   1.0   0.0   2.0  ...   \n",
       "41503   200.0  200.0   8.0  12.0  3000.0  1.0   0.0   1.0   0.0   2.0  ...   \n",
       "...       ...    ...   ...   ...     ...  ...   ...   ...   ...   ...  ...   \n",
       "66411  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66412  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66413  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66414  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66415  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "\n",
       "       meshsz     F      pbol  sfricn    yfss       Bcf2f      Pucf2f  \\\n",
       "41386    40.0   8.0  125000.0    0.35  355.61   2327950.0    727939.0   \n",
       "41446    40.0  10.0  125000.0    0.35  355.61   1549440.0    485504.0   \n",
       "41448    40.0   4.0  230000.0    0.35  355.61   1551900.0    485191.0   \n",
       "41449    40.0   4.0  280000.0    0.35  355.61   1551870.0    485166.0   \n",
       "41503    40.0  10.0  125000.0    0.35  355.61    754790.0    242271.0   \n",
       "...       ...   ...       ...     ...     ...         ...         ...   \n",
       "66411    40.0   5.0  230000.0    0.35  355.61  61760300.0  22960300.0   \n",
       "66412    40.0   1.0  280000.0    0.35  355.61  61159500.0  22958200.0   \n",
       "66413    40.0   3.0  280000.0    0.35  355.61  61632400.0  22208000.0   \n",
       "66414    40.0   4.0  280000.0    0.35  355.61  61756700.0  22962400.0   \n",
       "66415    40.0   5.0  280000.0    0.35  355.61  65334600.0  22959200.0   \n",
       "\n",
       "         SFcf2f  KG_sing_web  KH_sing_flange  \n",
       "41386  0.738653     0.066667       16.666667  \n",
       "41446  0.738975     0.066667       16.666667  \n",
       "41448  0.738498     0.066667       16.666667  \n",
       "41449  0.738460     0.066667       16.666667  \n",
       "41503  0.737510     0.066667       16.666667  \n",
       "...         ...          ...             ...  \n",
       "66411  0.980978     0.333333        8.333333  \n",
       "66412  0.980889     0.333333        8.333333  \n",
       "66413  0.948836     0.333333        8.333333  \n",
       "66414  0.981068     0.333333        8.333333  \n",
       "66415  0.980931     0.333333        8.333333  \n",
       "\n",
       "[2891 rows x 22 columns]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "✅ df_6已保存至: R:\\Jupyterdemo\\phdcode\\df_6.pkl\n",
      "============================================================\n",
      "开始执行综合数据分析...\n",
      "============================================================\n",
      "\n",
      "📌 步骤1: 多策略重复数据处理\n",
      "----------------------------------------\n",
      "✓ IQR方法完成: 2891 → 2891 行\n",
      "✓ 随机森林方法完成: 2891 → 2891 行\n",
      "✓ 多数投票法完成: 2891 → 2891 行\n",
      "✓ 综合评分法完成: 2891 → 2891 行\n",
      "\n",
      "📌 步骤2: 趋势分析\n",
      "----------------------------------------\n",
      "✓ 趋势分析在第 4 次迭代后收敛\n",
      "\n",
      "📌 步骤3: 生成可视化\n",
      "----------------------------------------\n",
      "发现 480 个重复数据组\n"
     ]
    },
    {
     "data": {
      "image/png": "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ns2GqfPmIencOZzMzcX1XbuW206SJOi1WjSOjMSSfftwb9++sLtcuLdPHzz566/48rrrABRNeGng7ShJ5e644w7vZW2llS76lLZhwwbs378fU6dOLffY+++/j9TUVPz0009o2rRpha+ZkpKC+Pj4Sm/n+vPPP+PRRx8FABw8eBANGzaEtpLbbptMpgofE5GXl4dXX3014FFMsixj7dq1eO+99ypc5+eff8ayZcswe/Zsn+VZWVmYNWsWNBoNNBoNsrOz0bNnT1x//fU+63k8Hnz66afYs2cPQkNDERYWhqeffhohISHiO1iFgoICvP7661i4cCEmTJiAV155BQaDAXv37sVzzz2HtLQ0vPDCCxg/fvwFPf+xY8ewaNEiPPnkk34fP3ToEP7973+jfv36yMrKwm233YZBgwaVW2/FihWYP38+4uLikJOTg6effrrSEXmVOX36NF577TWEhobCYrFg1KhRF7x/VTl16hQ++ugjLFy4EDfccANatGiBgoIC7N27FwkJCXjggQfKFWJFLFmyBFqtFqNHj/b7eCDvW3XnbcuWLfjvf/+LuLg4ZGVl4cEHH0SXLl2q3vACuN1u9O7dG1dccQWaNWuGH374AT169ECrVq2wceNGjBs3Dvfff3+57T777DP06dMHCQkJF/X6y5cvx7Zt22A2m3H48GGMGjUKEyZMuKDnqs6MV+XcuXMYPHgwrrrqKsTExODbb7/F1Vdfjfr162P16tV48sknMXZs0bwVVqsVc+fORX5+Pux2O1JTUzF8+HBMnDjxgl77jz/+wKpVqxAVFQW3242CggIMDq+4k15V327P6dMI0euh12rx94kTaFe/PgD19e0y8vPxxebNeHbEiIt6ntWHD2Ph7t1oEBYGi82GxwYPRtPiebCq29q1azFz5kycOXMGd911FwwGA9xuNw4ePIjff/8d//d//4fbb7/9gp5b9LO5IpfyeERU2xxafwhavdY74snj9iBxaSKO7ziOs8fOokHrBrDl2XDZ0Mu82+Rl5iElMQXrvlqHBq0b4Nb3b8U/S/6B5awFw6YNw6H1h1CQXeC3OJN7Jhdh9cJ8liXvSMbaz9d6fy5bUCohe2Sk7ErBkKlDMPiewWjZsyWaJTTzmVMq+1Q25j01z+/oKe/zyDIO/nUQUY2ioDfpoS3UolGHRpj42kSf59n07Sa/X3zENItB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rY5nZWWlqqqr9fxTT6miQ4fk9gsvu0y33HijtuvRI+X6X82Zo1gspp49emjibbfptltvTXvfAQAAthRpTz65rquGhgYVFRWpQ4cOKln7wu1HP/qR7rrrLvXp00fHHXdc8vo/+9nPNGTIEK1evZqP3QEA4IV4XFq0SGrlSKDNkkg0TjStr6BA6tEj7QmoWCymo0eNUufOnbVX//6qrKzUqlWr9M28eZpyzz3acYcdlJeXp4KCAm2//faSGtdrmDplihYuXKg77rpLvXr2VCwW04svvaTJt92mGydM0KUXXdRsDZD8/Hwd8atf6ZSTTmpxLK7rtrouUSgUajbxJEnBQEBlFRUasv/++mbePNXV1am4uDitfQcAANhSpD359Mwzz+i+++5T165dJUlLlizRqaeeKklaunSpunfvrv/7v/+T1PjiLZFIJP9ss802uummm7Iw/C1PUVGR10OAj9ALLOilHUokGieeQiHT0UjpCLhu88U64/HGx0sk0n68YDCoA4YM0ZHDh2ve/PmaOWuWpk6ZogsuuUT9+vbVfz/4QP/+z390yMEHJ28TCjW+fHnplVd0wbnnSpIeeewxnXj88SosLNSwww/XeRddpJtvuEFlZWXJ26072oULF2q77bZLfp1IJHTS6NE663e/05D99291vDfdcos++fTT5Nc/rFihYDCohx99VHPnzdNXX3+t666+Oq1939JwJDwseE6CBb3Agl68kfbk0+67766//OUvyRd8f/zjH3X88cdr5syZ+v777zVnzhz97ne/09577y3XdeW6ruLxuBKJBJ+pzBDHcZSfn8/K/EhLshcgDfTSzgWDUl5exu7OUepETooMP+cXFBSkTCBJjb0mEgl17NRJ3bp107z587Vy5Ur95oQTJEl777WXevXsqV+NGKHRJ5+sE0eNUnC9ybBly5fr8y+/1GE/+5kk6elnn2287YABKdf7es4cLV22TLW1tXry6ae16y676LTRo9Vxq61UXV2t1998U3l5eRr2i18oGo0qL4Pf5/aEs93BguckWNALLHhP7Z20J592XG/thOLiYh166KE69NBDJUlz5szRk08+qY8//lgXX3yxunXrltmRonFl/poaleTnt/6iH1ir6UwOJSUlvODHRtELLFw1HikUCASy+nw0/9tvFWilx1g8rlAwqO+XLtWMWbPkOI6OP/lkOZLC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JIUCeZKkWDimRDyx+XfsSIl4QvFwPOX+99h2d/NdxeNxua6reDyuyffeq3GXXqr8/HzFYo0TZeeceaZumzxZ42++WWvWrJHU+BGujWnpOiOGD1evXr20cNEiVVRU6JJx41RVVaXrb7pJN48fr+vGj9cns2cnr79s+XL98c9/1suvvqrvly7V9j17qnv37orHYrp47FidNHq0Tho9WhdeeqniaYxpS8ZaLLDgOQkW9AILevEGRz75iOM4Ki0tZWV+pCXZC5AGemm/9th2d4UCjU/3ISekmBtTQ3WDiiuKN/OeHTVU18uVq5ATUjAQVCgQ2qTJp2g0qpraWj3z3HM647TTVNGhgyQpEolIajz66J477tCs999PdppIJFI+didJH3z4oW5f+//z5s9PWTjcdV399/339fmXX6rvTjvpz1deKUl67Y039Og//6k/XHqpSktLte022+isc8/VsF/8Qhedf766de2qMWecodVr1igRj+vkk05qHHMsplvGj9d2a4+cWrR4sabykbtWOZKCnIgGaeI5CRb0AgveU3vHcdc/Jr2disfj+uijj9S/f3/fznS6kYiiX3+tvNJSOWvXxQBa47quotGo8vLy+G0zNope/K0hFtP8qir17tmz2cfEJOl3j5yl52a/qPponaoi1QqGgurYs+NmnZU2EU+ocmGl4rG4yvPLVJRXrF/vPkx3jbrDfF9ffvWVioqKUhbwlhonhg49+OAWb/PaG29o11120dbdu7d4+X8/+EC77rxz8mQoy5YvV1FhYcqCtF/PmaMO5eXq1q1bym1XrV6tDuXlG/z+rF6zJjlJJjW+zggEAvz7aUVbn+2uoaFB8xcsUO/ychWG+F2r3/CcBAt6gYUbiShaU6O8nXby7Xtqv85t8Cson6mvr/d6CPAReoEFvbRfJw9qPFqnMFSkoBNUPBZXzYqazbrPmhU1isfiCjpBFYYaJ3h+M/DETbqvfn37Npt4ktTqxFPTZa1NPEnSPgMGpJyFt1vXrs3OhLRTnz7NJp4kaauKio1OzK078SQ1HsLPm54NS+ejkkATnpNgQS+woBdvMPkEAEA7N7j3IA3ZYbAcx1GHgsYJmPqqetWuqt2k+6tdVav6qsYXbh0KyuU4jobsMFiDew/ayC0BAACwJWLyCQCAds5xHN185A0qzitSXjBfpXmNa2PUrKxR1fKqtI9I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4zLklpZ6Wbx4sXvJJZe4n376qfv000+7/fv3d++7777kbfj5suVqqZeamhp38uTJ7urVq90333zT3WWXXdz//Oc/ydvQy5atteekJnfccYc7YMAA97333ktuo5ktV2u9hMNh98orr3T/85//uP/5z3/c+fPnJy+jl9zC5FMb23PPPd1vvvnGdV3XXblypTtkyBB36dKl7u677+42NDQkt++xxx5udXV1Vi6DP/zzn/90R4wYkfx6wYIF7q677kovaCYej6c8Ebd1I/TjL+v30mTixInNJp+uvPJKd+LEicmvr7rqKveWW27J2mXIPev3MmvWLDcajSYvv/HGG93f/va3ruu2/c8e5J71e2loaHATiUTy8iOPPNKdPn2667r0gkatPSf997//df/1r3+5P/3pT5OTTzSDlnr55z//6d59991uXV1dynXpJfew5lMb+8UvfqErrrhCNTU1evbZZ3XllVdq5syZ2mqrrVRQUCBJ6tixo/Ly8vTpp59m5TL4Q21trZYtW5b8unv37opGo3ryySfpBSkCgdQf5W39M4V+/GX9Xja0fcaMGdpmm22SX/fq1UuzZs3K2mXIPet3sc8++yQ/YidJXbt21dZbby2p7X/2IPes30tBQYEcx5HU+FGVHXbYIfnxKXqB1PJzT21traZNm6aRI0embKcZtNTLs88+q1tvvVVDhgzRM888k9xOL7mHyac2duWVVyovL09HHXWUiouLddhhh2nZsmXq0KFDyvVKSkq0bNmyrFwGfxg0aJBWrlypF154QZL02WefSZKCwSC9YIPa+mcK/bRfy5YtU0VFRfLrkpISLV++PGuXwX8+/fRTjRo1SlLb/+yBf7z77rs69dRTFYvFVF9fL4le0Lp7771XZ5xxRrPtNIOWTJ06Ve+++65+85vf6LLLLtNbb70liV5yEQuOt7GGhgYNGzZMlZWVuv7669WzZ085jpOcPW0SjUaVl5eXlcvgD/369dPEiRP18MMP68MPP1QikVAwGFQwGKQXbFBb/0yhn/bLcZyURTSj0WjyqJdsXAZ/+fbbb9W5c2f169dPUtv/7IF/9OnTR0cffbRuvPFG3XjjjbrqqqvoBS16++23teeee6pTp07NLqMZtGarrbbS+eefL8dx9NBDD+mggw6ilxzEq702dskll2jChAmqqKiQ67q64IILNG7cOFVXV6dcr66uTl27dlUikcj4ZfCPww47TIcddpgk6bzzztOBBx6orl270gs2qK0boZ/2q2vXrqqpqUl+XVtbm/x7zcZl8I9YLKbHHntMF154YXIbz09oTZcuXTRy5EgFAgHdd999kugFLZsyZYpmz56d/LqmpkZjxozRmWeeqa233ppmsEEnnHCCXn75ZUn8jMlFfOyuDVVWVuqrr75KftzgzDPPVElJibbeemstW7ZMkUhEkpKH7e2xxx7ab7/9Mn4Z/Ofrr7/WO++8o4suuigrTdBL+9LWjdBP+zVo0CDNnz8/+fWCBQuS67Vk4zL4x/3336/TTz895Sg2fr5gY3bZZRd169ZNEr2gZTfddJOefvrp5J+uXbvq2muv1XHHHUcz2KhAIKBddtlFEj9jchGTT22ooqJC+fn5KZ8J7dChg3beeWcdcMAByQVX//Of/2jUqFEqKChQt27dMn4Z/KW6ulqXX365brjhBvXp0ycrTdCLv7mum/Lftm6Efvxl/V7W3b7+tlGjRmn69OmSGo90+eSTT3TMMcdk7TLknpZ6ufPOO7Xrrruqvr5eCxcu1L/+9S999913/HxBs17C4XDKUSzvvPOOTjrpJElt/1yF3LR+M126dFGPHj2Sf0KhkDp37qzy8nKaQbNeKisr9eSTTyoej8t1Xd1///06//zzJfEzJhc57vqvNJFVX375pR555BHtuuuuWrFihfbdd1/tt99+qqys1IQJE7TttttqzZo1uuiii5K/TczGZch9P/zwg9599119/vnnOuKII5Kz+FJ2mqAXf6qtrdUzzzyjP//5zzrnnHN0wgknqGPHjm3eCP34Q2u9zJ49W9dff70qKyt19dVXa999903e5oknntA333yjaDSqQw89VIMGDcrqZcgdLfXy6KOPatKkSSnX22GHHfTSSy9J4ufLlqylXpYvX65TTz1VPXv21F577aXddttNw4YNS96GXrZsrT0nrevggw/W9ddfnzxClma2XC31Ultbq9GjRysYDGrvvffW6NGj1adPn+Rt6CW3MPkEAAAAAACArOFjdwAAAAAAAMgaJp8AAAAAAACQNUw+AQAAAAAAIGuYfAIAAAAAAEDWMPkEAAAAAACArGHyCQAAAAAAAFnD5BMAAAAAAACyhsknAACAHJRIJLweAgAAQEaEvB4AAACA37z00kvafvvttfPOO7d6nccee0xVVVUaPXq0QiH7S666ujr94Q9/0Omnn6499tgj7ds99thj6tmzpwKBln/H+M477+iQQw7RgAEDkttisZjuuOMOnXfeeeZxAgAAbAxHPgEAgJxUXV2t2bNnez2MZmbMmKGvv/56gxNPkvTiiy+quLh4kyaeJKm0tFS//OUvdf755ze77LvvvtPUqVNbvN3zzz+vYDCo7t27t/hnwYIFCofDKbcJhULab7/9NGnSpE0aKwAAwIZw5BMAAMg5CxYs0LXXXquddtpJu+222ybfz7Jly/TGG2/oww8/VCAQ0A033LBZ46qpqdHtt9+uKVOmNLts5cqVqqioUDAY1LJly/SjH/1IJ5xwQsp1vv32WxUUFGjrrbdObovFYrroootUWVnZ7D6j0ahisZhOOumklO3ffPONVq1apR49euinP/1pymXBYFA333yzCgoKWtyHefPm6bTTTmu2ffDgwZo2bZref/997b333q1/EwAAAIyYfAIAADmnZ8+eGjp0qObNm7dZ99OtWzeNGjVKO+ywg5566qnNHtcdd9yhkSNHtng00/Tp0/XXv/5V3bt3V2VlpYqKippNGi1cuFCFhYV64YUXFAwGJTUedXT55ZerqKhIZWVlcl1XjuPo4IMP1ksvvaSCggKNHTtWhx9+uA488MCNjjGRSOiWW25Rjx49Wrx87NixisfjLV42ZswYnX322frnP//Z6sf2AAAArJh8AgAASEMkEtHzzz+vCy64oMXLg8Ggdt555w1+dO22225LXnddXbt2lSQtWrRIF198se64444Wb//8889r8ODB6tSpU6uPEY/HdeGFF27wyKcjjjiixcu6deumLl26aObMmRo0aFCrjwEAAGDB5BMAAEAa3nnnHe22227Kz89v8fJ0jxRaf+JpXddcc40GDRqkDh06tHj5IYccouuvv17l5eUaM2aMSktLJTV+5C8ajUqSfvKTn+jnP/+5CgsLW7yPRYsWaZttttFnn32mhx9+WJdffrlKSkqSlx900EF64YUXmHwCAAAZw+QTAADwxLRp03T11Vfrkksu0ezZs5WXl6cVK1bo1FNPVb9+/ZLXe+yxx7RkyRLNnz9f/fv316mnnpq8bNmyZbrzzju13Xbbqbq6WhUVFRo9enRWxvv111+rd+/erV4eCAQ0c+bMZh+1W9fixYt11FFHtXjZ448/rh122KHFBcabFBUV6eqrr9Ztt92mww8/XP/85z/VvXt3LVu2TCtWrFB5ebn69u2r1atXt3ofDQ0NWrJkiUKhkI455hjV1dWlTD717t07Ix9RBAAAaMLkEwAA8MTPf/5zvfHGG3r77bc1fvx45eXlaeXKlTrqqKP07LPPSpJef/11TZw4Uccee6zi8bhGjhyp/fffX/369VMikdB5552nm266Sdttt50kacKECXr66ac1fPjwjI932bJl6tWr1wavs7EzxjV97G59s2fP1uLFi3XZZZdt8P6/+uorhcNh/f73v1c4HNaSJUvUvXt37bLLLsnrDBw4UDvttFPy6/r6euXn5yePuFq2bJkGDhyoa665psXH6Ny5s5YuXbrBcQAAAFgw+QQAADx19NFHKy8vT5LUqVMn9evXT2+//bYkqW/fvurbt6+kxo+rHXTQQXrllVfUr18/vfbaa+rRo0dy4kmSTjnlFB199NFZmXwqLi5WfX19xu/3u+++04IFC3T++efr97//vVavXq3ly5erS5cuOv300yU1nvXu7rvv1jfffKOuXbvqySef1MUXX9zi/ZWWlmrq1KnJr8eOHavjjjtO/fv3lyTdf//9ra4HJTVOVhUXF2duBwEAwBaPyScAAOCp9ddK6t69uxYvXqwuXbo0O2Nb165d9emnn0qSPvzwQ+2www4pl3fq1ElVVVVauXLlBhfl3hTdu3fXt99+2+rljuNs0v326NEjeURV05FR77//vlatWqVDDz00eb2ZM2fqiiuu0P3335+crGtJTU1Nykf/5s2bp6+++iq5PtT333+vk08+udXbr1ixQltvvfUm7QsAAEBLmHwCAAA5JRKJpKxBtC7XdRUKhZr9/7pCoZASiUTGxzVw4EA9+eSTrV7uuu4mrfnU0gLke++9t8aPH6+ddtpJPXv21Ny5c3XFFVfozjvvTJ4ZrzUlJSUbPfIpHo+3evsPPvhAAwcO3OBjAAAAWDD5BAAAcsqCBQs0bNgwLV26tNkkyfLly9WzZ09J0i677KL//ve/KZdXV1crLy9PXbp0yfi4+vXrp3g8rsWLF2vbbbdt8TqbuuZTS8455xxdcMEFOvHEEzVhwgRNmjRJP/rRjzZ6u/r6+g0e+bRmzZoNTpC9+eabuuuuu9IeJwAAwMakd05gAACALJk5c2by/7/44gvV1NRo8ODBkqSPPvooeVk0GtX06dM1YsQISdLhhx+uL7/8UpWVlcnr/OMf/9C5556btbGef/75uvfee1u8zHXdjD5WSUmJBg0apN/+9rc68cQTU84A2JJoNKpzzz13oxNUZWVlmjRpUsr3vcmbb76p/v37a5ttttmssQMAAKyLI58AAICnYrGY7r//flVVVenbb7/VpEmT5DiOAoGAjj76aN19992SGo+IuuCCC5JrOYVCIU2YMEG33367evTooYaGBpWWluroo49O3vfChQv173//Wx9++KE+/vhjPfLII9p22231k5/8ZJPGeuihh+rFF1/UnDlz1KdPn5TLMvlRvzlz5uiOO+5Qly5d9Oyzz+rGG2/U//3f/2nUqFEaOHBgs3WyJCkvL09XXXWVCgoKUj62uP7H7ppUV1frq6++Si7oHolE9Pe//1233nprxvYDAABAkhw307+mAwAASNPYsWN15JFH+mqNobq6Ol1zzTW6/PLLkx9lk6QXX3xRV199dbNJqXUtXrxYI0aM0DnnnNPssnA4rDfffFMff/yxysvLddRRR6V8fPCdd97R/fffry+//FIDBgxQnz59tOuuu+qwww7T//3f/+mee+5p8THnzZunrl27poxVajzLnuM4euqpp9SxY0eNHz9eRxxxxEaPsAIAALDiyCcAAOCJmTNn6sMPP1Q8HleXLl2anbkuVxUXF2vs2LFatWpVyoROLBbTz3/+c1199dWt3vb2229XWVlZyrbVq1frvffeUzgcVv/+/TV06NAWb3vggQfqwAMP1OLFi/XWW29p6dKlOuCAAyRJ+++/v3r37q3u3bu3uAj7xsRiMSaeAABA1nDkEwAAQAbEYrGNTvykcx0AAID2hsknAAAAAAAAZA1nuwMAAAAAAEDWMPkEAAAAAACArGHyCQAAAAAAAFnD5BMAAAAAAACyhsknAAAAAAAAZA2TTwAAAAAAAMgaJp8AAAAAAACQNf8PrYNce1oLCWIAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1200x800 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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4kmXXy4zZIhMOCwnBhMK6enpyt3hBBuO4ygcDmv3li3Vtm1bLVu+XJs2bdKlF10kSTqkd2917NBBpw8dqisuu0wXX3CBioqLdemVVyonJ0c///yzJGnN2rWS46hVy5ZasnSpvp0zR5sKChQIBHTEoEG6+8479fiTT+qLL7/UmrVr9fGnn6pFixbqsu++WrZsmZYtX65gMCifz6fCoiKFXfzBrjkxUsx6QXLjeQi2aAVuRN4/c7a7mHI9+XT88cdr77331pdffqmioiJt3rxZq1evrvW6hYWFuzxA2AkEAsqo/2qApG29ZFAM6kcrzcjOJqBef10qKKh5m8svj9wubIya+jif5StW1PlxrWAoJJ/Xq1/WrdOXX30lx3F04WWXyZFUEQgoNydH5wwdKrPtLGst8vP1+iuv6PMvv9Trb76ptb/8op4HHqjzzz1Xjzz2mEbfcosGDhig5198URkZGTr7rLMkSdddc42uu+YajR03TgMHDFD3rl31xKRJuuiCC3TgAQfo9Tff1JatWzVyxAgWHN+JWPSC1MDzEGzRCtzg/XPsuZ58kqTu3bure/fukqR//vOfUWtAba9Vq1YNHxkAAIituiag6pl4aiw//vSTbrzlFhUWFuqHH39UeXm5CouKdMkVV2jJsmVavWaNzq9lHSbHcZTm96t9+/aa8eqrGjlihCoqKjRyxAhdd8MNen7CBElVLzS3X+PhnffeUygU0i2//70eGzdOw84+Wy9On64Rv/2tVm47+90v69bp8EGDah3vv995RyUlJSouKdGf7r9fmRkZKti8WaFQSO+9/76W//yz7vrDH3TCccc16vcJAAAg2TRo8ml7BxxwQJ2XnXTSSbt69wAAIJbqmoDaXhNMPElSt65d9eLUqXp03DidctJJWrZ8ub748kv97ZFHdOMtt2jsQw9p4fff64vZs6NuZ0zV+fb69umjh8eOlcfj0X8//1yS9NPixbrkiiskVR059cLUqeqw995avWaNBg0YoJycHD3+5JPq36+f9txjD11y0UVq26aNZn/1lSRpydKlGr7t9pJUWVmpf7/7rj78+GMNv/xyHTN4sJ5/8UW9OHWq/H6//v3uuyotLdXQM89s9O8PAABAstrlyaeDDjqozstatGixq3cPS+kcYgoX6lqnDdgRrTRTQ4bU/VG73XevdeLJ43F9DpNaFRYVqUV+fuRr3w6Ldoe3TTTtqLikRDJGFRUVuuTCC3X6qaeq/V576eqRIzXx8cdrrAESCoV03sUXq0V+vn5avFhdunTRpGeeUb++fXXn6NEKhkLasnWrtmzZot22ez3zwJgxCoVCOvLww7XHHnsoFAqpvLxca9auVccOHSLXCwaD+nnlSu27zz6N8F1JPY3VC1Ifz0OwRStwg/fPsdegyaetW7dqzpw5kqS+ffsqJycn6vKXX35Zu+22m/baa6/Ix/PQdBzHUUZ6usTierDgOA6fh4cVWmnGXnut9oknqWr7a69FTUA5UqMt8PrzypVq37595Osdp5oqKytVXl4etc0Yo/nz5+um227THbffrvT0dF0zapT+ct99kqRfN27U+x9+qHPOOivysbuOHTrotZdf1vc//KBP//MfXXfNNbr3z3/WpRdfLEk6YtAg3Xzbberfr1/UY912881KT0/XY+PHS5LmzJunAYcdpmenTdPC77+vej6W9M+XXpIjafrzzzfK9yWVNGYvSG08D8EWrcAN3j/Hh+s/O33zzTc688wz9eyzz+q5557TSSedpOeeey7qOmeeeaZ+/PFHnbVtcU40LWOMSkpKIh87AHaGXmCLVpqpus5qt71nn6263jZGUigcrjFR1BALFi5Un169qu7XGGVlZUVd3qljR517zjlR28LhsAYcdpg+fOcdnXryyXp03DhdNXy4Dty2NECb1q01oH9/XXXttVVHSG3j8/m0ZOlSpfn9embKFBVs3qwOe+8duc03336ro448MuqxdjyT0puzZumcs86Sz+fTww8+qGlTpmjalCl69K9/VY/992+E70jqacxekNp4HoItWoEb9BIfriefXnjhBb3yyit69tlnNWXKFL3zzjsqLCzUmDFjItfx+Xz6zW9+ww8zhoLBYLyHgCRCL7BFK81MXRNPu+9ec9uOE1CN9Jy/detWFRQU6KOPP9bSpUs1oH//6KHstptat2qlYGVlZBIoHA5LqpoYmv7SSxrQv39kke9gKCRJ6typkw7r318ffPhh1P0NPfNMdezYUatWr1aLFi10y+jRKiws1F8eekgPjxmjB8aM0XcLFkSuv37DBt11zz3693vv6Zd169SpQwe1a9dOoWBQN99+uy654gpdcsUV+v2ttyq0bVyoideIsMXzEGzRCtygl9hz/bG7zp07a/ftXoRmZ2dr1KhR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keb111+PXPbrr7+abt26mZUrV5oVK1aYrl27mnXr1kUuf+utt8zgwYObalfRCD755BNz0EEHmYqKisi2t956ywwcONBMnz6dXpq5GTNmmMGDB5u33nor6ok5nr9L6ntsxE9dvdx+++3m3HPPNX//+99rTD7RSvNUVyv//ve/zQMPPBB13QceeMCMGDHCGEMvzVFdrRhjTFFRkTHGmMrKSvPxxx+bnj17moULFxpjaKW52lkvxhgzbtw4c8stt5ijjz46avKJXpqfulqpqKgwBxxwgPnpp59qvR2tJB4+dhdHu+22my6//HKNGTNGBx10kI466ih16tRJl19+uRYvXqyuXbtGXX+//fbTokWLJElLliyp8/KioiKtW7cu6vJWrVopPz9fP/74oxYvXqwWLVqobdu2kcv33XdfrV27VoWFhU24x9gV4XBYfr9ffr8/ss1xHG3cuFFz5syhl2bu8MMP13vvvadTTjklans8f5fU99iIn7p6uf766zV9+nT16NGjxm1opXmqq5UTTzxRo0ePjnxdXl6ujz/+WAcccIAkemmO6mpFknJycrRs2TL17NlTV111lS644ILI7xlaaZ521ssXX3yht956S3fffXeNy+il+amrlUWLFikYDGrcuHEaOHCgTjzxRD311FORj3/TSuJh8imOwuGwMjIy9Mc//lFz587Vm2++qaVLl2rcuHEqKSlRZmZm1PUzMjJUWloqSTu9vKSkRJKUlZVV4/KSkpJab1v9dfX9I/H06dNHGRkZeuSRR1RWVqY1a9Zo8uTJkcvppXlr3bq1fD5fje3x/F1S32MjfurqpV27dnXehlaap7pa2V5xcbFGjhypjIwMXX755ZLopTmqr5W9995b8+bN08svv6y33npLTz31lCRaaa7q6mXTpk36wx/+oIcffljZ2dk1LqeX5qeuVoqKitSvXz9dcskl+uSTT/TQQw9p2rRp+vvf/y6JVhIRk09x9N577+mdd97RhRdeqLS0NHXp0kUjR47Uiy++qMzMTJWXl0ddv7y8PPJLeGeXV/9DKCsrq/XyrKysGpdVf13bL3kkhry8PD399NOaN2+eBg8erBtuuEFnnnmmJMnr9dILahXP3yX1PTaSC62gNsuWLdP555+vYDCoqVOnKicnRxK9oKbqo7cPOuggXXrppXrzzTcl0Qr+xxijW2+9VZdccokOPPDAWq9DL6g2aNAgTZ06Vf369ZPf71fPnj112WWXadasWZJoJREx+RRHv/zyS+TMdtV8Pp/8fr+6du2qxYsXR122ZMkSdenSRZLUpUuXOi/Pz89X27ZttWTJkshlv/76q7Zs2aKuXbuqS5cu2rJlizZu3Bi5fOnSpWrXrp1yc3MbezfRSAKBQOTF/ZdffqmXXnpJHo9H++23n3r27EkvqFU8f5fU99hILrSCHX3yyScaNmyYjjjiCE2ePFn5+fmRy+gF1Z599lndcMMNUdsCgUCkF1pBtV9++UWzZ8/WhAkT1LdvX/Xt21dr167VPffco6uvvloSveB/3n//ff3zn/+M2hYIBJSRkSGJVhIRk09xdPjhh+vXX3/VxIkTFQqFtGrVKj355JM6/fTTdfzxx2vjxo169tlnVVlZqS+++EJvvPGGzj77bEnSOeecozfeeENffPGFKisr9eyzz2rTpk06/vjjJUlDhw7Vk08+qVWrVqm4uFgPPPCA+vXrpw4dOqhTp0465JBD9MADD6i4uFirVq3SE088oXPOOSee3w5YGD58uF5++WUZY7RgwQJNnDhRl112Gb2gTvFso77HRnKhFWxv7ty5GjlypEaPHq3bbrutxkci6AXV+vbtq/fff1+zZs1SOBzWN998o6lTp+qCCy6QRCv4nz333FPz58/X119/Hflvzz331N13361JkyZJohf8jzFGf/nLX/T555/LGKM5c+Zo6tSpOu+88yTRSkKK73rn+L//+z8zbNgwc8ghh5jBgwebRx99NHI2s++++86cd955pnfv3ubYY4+NOtODMca8+uqr5sQTTzS9evUy55xzjpk7d27kskAgYB566CFzxBFHmD59+phrrrnGbNy4MXL5r7/+akaNGmX69etnDjvsMPPggw+aYDAYm51Gg82ePducddZZplevXubYY481U6dOjVxGL6i241lj4tlGfY+N+KvtLENffPFFjbPdGUMrzd32rVx99dWmW7duplevXlH/DR8+PHJ9emm+dvy98sEHH5jTTz/d9O7d25x22mnmtddei7o+rTRvtT0PVdvxbHfG0EtztmMrL774ojnhhBPMwQcfbI499ljzj3/8I+r6tJJYHGOMifcEGAAAAAAAAFITH7sDAAAAAABAk2HyCQAAAAAAAE2GyScAAAAAAAA0GSafAAAAAAAA0GSYfAIAAAAAAECTYfIJAAAAAAAATYbJJwAAAAAAADQZJp8AAAASXDgcjvcQAAAAGswX7wEAAAAks7fffludOnXS/vvvX+d1pk+frsLCQl1xxRXy+dy//CotLdUf/vAH/eY3v1HPnj2tbzd9+nR16NBBHk/tf2/89NNPdeyxx6pPnz6RbcFgUBMmTND111/vepwAAAC14cgnAACQ8IqKirRgwYJ4D6OGL7/8Uj/99NNOJ54kadasWcrKymrQxJMk5eTk6LTTTtMNN9xQ47Kff/5Z06ZNq/V2b775prxer9q1a1frfytXrlRFRUXUbXw+n/r166dx48Y1aKwAAAA74sgnAACQ0FauXKn7779fXbt21YEHHtjg+1m/fr0+/PBDzZkzRx6PRw8++OAujau4uFiPP/64pkyZUuOyTZs2qUWLFvJ6vVq/fr32228/XXTRRVHXWbFihdLT07XHHntEtgWDQd10000qKCiocZ+VlZUKBoO65JJLorYvWbJEmzdvVvv27XX00UdHXeb1evXwww8rPT291n1YtmyZhg8fXmP7gAED9O677+qbb77RIYccUvc3AQAAwAKTTwAAIKF16NBBJ510kpYtW7ZL99O2bVtdcMEF2meffTRz5sxdHteECRN09tln13o00+eff66//e1vateunQoKCpSZmVlj0mjVqlXKyMjQW2+9Ja/XK6nqqKM77rhDmZmZys3NlTFGjuPomGOO0dtvv6309HTdfvvtOuWUU3TkkUfWO8ZwOKxHH31U7du3r/Xy22+/XaFQqNbLRowYoZEjR+pf//pXnR/bAwAAsMHkEwAAgEuBQEBvvvmmbrzxxlov93q92n///Xf60bXx48dHrru9Nm3aSJJWr16tm2++WRMmTKj19m+++aYGDBigli1b1vkYoVBIv//973d65NOQIUNqvaxt27Zq3bq1Zs+ercMOO6zOxwAAAKgPk08AAAAuffrppzrwwAOVlpZW6+W2RwrtOPG0vfvuu0+HHXaY8vPza7382GOP1V/+8hfl5eVpxIgRysnJkVT1kb/KykpJ0lFHHaUTTjhBGRkZtd7H6tWrteeee2rhwoV6/vnndccddyg7Ozty+eDBg/XWW28x+QQAAHYJk08AACDu3n33Xd1777265ZZbtGDBAvn9fm3cuONtaqkAAAa0SURBVFFXXnmlunfvHrne9OnTtXbtWi1fvly9evXSlVdeGbls/fr1euKJJ7T33nurqKhILVq00BVXXNEk4/3pp5/UuXPnOi/3eDyaPXt2jY/abW/NmjU655xzar3spZde0j777FPrAuPVMjMzde+992r8+PE65ZRT9K9//Uvt2rXT+vXrtXHjRuXl5albt27asmVLnfdRXl6utWvXyufz6dxzz1VpaWnU5FPnzp0b5SOKAACgeWPyCQAAxN0JJ5ygDz/8UJ988onGjBkjv9+vTZs26ZxzztHrr78uSfrggw/02GOP6bzzzlMoFNLZZ5+tgQMHqnv37gqHw7r++uv10EMPae+995YkPfLII3r11Vd15plnNvp4169fr44dO+70OvWdMa76Y3c7WrBggdasWaPbbrttp/f/448/qqKiQqNGjVJFRYXWrl2rdu3aqUePHpHr9O/fX127do18XVZWprS0tMgRV+vXr1f//v1133331foYrVq10rp163Y6DgAAgPow+QQAABLGsGHD5Pf7JUktW7ZU9+7d9cknn0iSunXrpm7dukmq+rja4MGD9c4776h79+56//331b59+8jEkyRdfvnlGjZsWJNMPmVlZamsrKzR7/fnn3/WypUrdcMNN2jUqFHasmWLNmzYoNatW+s3v/mNpKqz3k2aNElLlixRmzZtNGPGDN1888213l9OTo6mTZsW+fr222/X+eefr169ekmSJk+eXOd6UFLVZFVWVlbj7SAAAGiWmHwCAAAJY8e1ktq1a6c1a9aodevWNc7Y1qZNG82fP1+SNGfOHO2zzz5Rl7ds2VKFhYXatGnTThflboh27dppxYoVdV7uOE6D7rd9+/aRI6qqj4z65ptvtHnzZh133HGR682ePVt33nmnJk+eHJmsq01xcXHUR/+WLVumH3/8MbI+1C+//KLLLruszttv3LhRe+yxR4P2BQAAoBqTTwAAIGEFAoGoNYi2Z4yRz+er8f+35/P5FA6HG31c/fv314wZM+q83BjToDWfaluA/JBDDtGYMWPUtWtXdejQQUuXLtWdd96pJ554InJmvLpkZ2fXe+RTKBSq8/bffvut+vfvv9PHAAAAqA+TTwAAIGGtXLlSp556qtatW1djkmTDhg3q0KGDJKlHjx76+uuvoy4vKiqS3+9X69atG31c3bt3VygU0po1a7TXXnvVep2GrvlUm+uuu0433nijLr74Yj3yyCMaN26c9ttvv3pvV1ZWttMjn7Zu3brTCbKPPvpIEydOtB4nAABAbezOAwwAABADs2fPjvz/H374QcXFxRowYIAkae7cuZHLKisr9fnnn2vo0KGSpFNOOUWLFi1SQUFB5Dr//Oc/9bvf/a7JxnrDDTfo6aefrvUyY0yjPlZ2drYOO+ww/fa3v9XFF18cdQbA2lRWVup3v/tdvRNUubm5GjduXNT3vdpHH32kXr16ac8999ylsQMAAHDkEwAASBjBYFCTJ09WYWGhVqxYoXHjxslxHHk8Hg0bNkyTJk2SVHVE1I033hhZy8nn8+mRRx7R448/rvbt26u8vFw5OTkaNmxY5L5XrVql//znP5ozZ47mzZunF154QXvttZeOOuqoBo31uOOO06xZs7R48WJ16dIl6rLG/Kjf4sWLNWHCBLVu3Vqvv/66/vrXv+qzzz7TBRdcoP79+9dYJ0uS/H6//vSnPyk9PT3qY4s7fuyuWlFRkX788cfIgu6BQED/+Mc/NHbs2EbbDwAA0Hw5prH/NAcAANAAt99+u84666ykWmOotLRU9913n+64447IR9kkadasWbr33ntrTEptb82aNRo6dKiuu+66GpdVVFToo48+0rx585SXl6dzzjkn6uODn376qSZPnqxFixapT58+6tKliw444ACdeOKJ+uyzz/TUU0/V+pjLli1TmzZtosYqVZ1lz3EczZw5U7vvvrvGjBmjIUOG1HuEFQAAgA2OfAIAAHE3e/ZszZkzR6FQSK1bt65x5rpElZWVpdtvv12bN2+OmtAJBoM64YQTdO+999Z528cff1y5ublR27Zs2aIvvvhCFRUV6tWrl0466aRab3vkkUfqyCOP1Jo1a/Txxx9r3bp1OuKIIyRJAwcOVOfOndWuXbtaF2GvTzAYZOIJAAA0Ko58AgAAaGTBYLDeiR+b6wAAAKQCJp8AAAAAAADQZDjbHQAAAAAAAJoMk08AAAAAAABoMkw+AQAAAAAAoMkw+QQAAAAAAIAmw+QTAAAAAAAAmgyTTwAAAAAAAGgyTD4BAAAAAACgyfw/mLKW3fCKy78AAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1200x800 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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ip7zbI/NNQlmf0QUyUT622t69Ki2XST2t+GC70YUsRgtOJ19GgP+OcB7N7vm5zXH7Z/ejoT0BHz1wFe44c0b4LA5oFKrYC4xIzYpFi26tUDJyRJccN0FAIBju44htUUqBt0wCACQOSgTqz5YhUunXVrtNc1FZhgSfeeAad2rNW567yb88O8fMPjmwUhqkoSsNVmwllrRuteZL5Uupwt5+/PQ58o+ADyXAlYdWVVywnO3gNOHT6NRm0Z+93v3qt0YcssQb5FLUkk49Ochn9FSTrsTzbo087u9IdGAsqKyGt5VimRmsxmTJk2C1WqtNocSAJw+fRr3339/jRN+9+jRAxdccIH356+++gpZWVl48cUXcc0116Bjx5ov19y9ezf69euHGTNm+C16Hjt2DJIkoU8fT/5nzJgBk8mEF154QeFeijly5AgeffRRrFy50tuezz77DJMnT8a8efNqLXqtWrUKQ4cOrfGvP3l5eXjzzTfRqZPvTQrsdjsmT56MRx55xDtiy+12Y9q0aTAajbj11lu9677++uvYuXMnZs2aBZVKhffeew8PPPAAPvroo3Pd9Wri4uJwzz33YP78+XjwwQe9n3+3bt1w2WWXYe3atWdVmFm2bBn27NmD2bNne09iqzp58iQmTZqEN998EwMHDkRhYSGuuOIKvP322+hdPlwbAH777Tc8//zz+OGHH5Ceno4///wTkyZNwsKFC/1muTYmkwmTJk3CnXfeiauvvhpWqxVXX301YmJiMGbMGMX7GUizZs287+/999+PRo08fbfNZsPEiRNhMBh8PntRs2bNwr59+/D999/jjTfe8LuO6PtWl3nbs2cP7rnnHsyZMwft27dHdnY2rr/+esyZMwetWrUK/AQK7d27F1dddRWeeuopAMDPP/+Mq6++GpdddhkKCwvx8ssve9c1mUyYN28etmzZghUrVmDOnDnn9NpffPEF8vPzMX36dADAt99+i2eeeQaXX355rYV2f+oy4yK2bNmChx56CP/6l+ePWV988QVuvfVW9OzZE9dffz3mzZvn/b295557cMcdd3j7LYvFggkTJiAmJsbnMmkRy5cvx9y5c/Hhhx9CWz757H/mzMFz27bh2969kVjljwqZjRrh03/+E++tW4dLO3XC4cJCbDp6FK+OH4/HFy9G7xYtMHvzZlzZrRsGtmmDmX/8ganff++d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4uIglR+gw6UKG05tqavl4dSWs1kOAA6HAxqNBpIkhWUb+TmFxz7Jsgyn0wlt+UE5GvYpGMvDqS11tTzgcag8KxX9Sji1/Wz3KRKXh1NbalsOVD8ORfo+RePnFA77FIzjULD3KZTLw6ktdbU8ko9DgfYpHNpSV8vDqS0AAIcDDpMJmsxMSJXqBpGyT06nE9u3b0fPnj19ahjhLixHPmVmZqK4uBj5+flIT08HABw8eBBNmjTxW3j67rvv8MILL+C+++7DrbfeelavWdFJVV1W07r1tfysnkPy/DUoMT7eu14o2l7T8nBqS10tD6e2KF0uy7InL4mJ1b70h0sb62p5OLWlrpYH+zUtFot3lEJ9vW44vb91tTyc2lJXywOtW7VfCae217Q8nNpSV8vDqS01La/pOFTT+uHU9rpaHk5tqavlkXwcqml5OL2/dbU8nNpSV8sj+ThU0/JwaktdLQ+ntsgoz4t0bjWAcNqnSBCWE463adMGffr0wUsvvQSTyYScnBx88MEHuOaaa6qtu3z5cjz77LN49913z7rwRERERERERERE9SMsi08A8M4778DpdGL48OGYOHEihgwZgilTpgAAevXqhR9//BEA8N5778HlcuG+++5Dr169vP+mT58eyuYTERERERERERHC9LI7AEhPT8c777zj97G//vrL+/+LFi0KVpPCWiRd60mhx7yQKGaFRDErpATzQqKYFRLFrJASzEvwhW3xicRJkoT4+HggQq/9pODy5oUoAGaFRDErpATzQqKYFRLFrJASPH8OjbC97I7EybIMu91e4x1liCpjXkgUs0KimBVSgnkhUcwKiWJWSAnmJTRYfIoSFosl1E2gCMK8kChmhUQxK6QE80KimBUSxayQEsxL8LH4RERERERERERE9YbFJyIiIiIiIiIiqjcsPkUJjYZzx5M45oVEMSskilkhJZgXEsWskChmhZRgXoKP73gUkCQJcXFxnK2fhHjzQhQAs0KimBVSgnkhUcwKiWJWSAmeP4cGRz5FAVmWYbXZOFs/CZFlGVarlXmhgJgVEsWskBLMC4liVkgUs0JK8Pw5NFh8ihI2qzXUTaAIYrPZQt0EihDMColiVkgJ5oVEMSskilkhJXj+HHwsPhERERERERERUb1h8YmIiIiIiIiIiOoNi09RQqfThboJFEGYFxLFrJAoZoWUYF5IFLNC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uPjkdDrx/PPPo1WrVvjmm2+g1+t9HtfpdEhKSkL79u1x7bXXIisrC6+++iquv/56DBw4sM4bTr5iY2ND3QSKIMwLiWJWSBSzQkowLySKWSFRzAopwbwEn3Dx6YMPPsBNN92EDh06CK3fqVMnvPvuu/jkk0+QmJiIrl27nnUjqXaSJEGr1XK2fhLizQtRAMwKiWJWSAnmhUQxKySKWSEleP4cGsITjt93333ChafKbr/9dhae6pksyzAajZytn4QwLySKWSFRzAopwbyQKGaFRDErpATzEhrndLe7wsJCnDhxotZ1jh49ei4vQYL4i0NKMC8kilkhUcwKKcG8kChmhUQxK6QE8xJ851R8eu2113D69OkaH9+xYwcmTJhwLi9BREREREREREQR7JyKT5MnT67xsSVLlqBz585ITU09l5cgIiIiIiIiIqIIJjzh+OrVq1FYWAi9Xg+32w273Y7+/fujrKwMt912Gzp16gRZluF2u5GYmIhvv/0WY8eORUZGRn22n8rFx8eHugkUQZgXEsWskChmhZRgXkgUs0KimBVSgnkJPuGRT7t378bu3bvx+uuv4/Dhw3j//feRn58PjUaDU6dOoUePHli3bh169+6NVatWoW3btvXZbqpEkiSoVCpInK2fBDAvJIpZIVHMCinBvJAoZoVEMSukBPMSGsLFp759++Lmm29G8+bNMXXqVDRr1gxNmzaFTqdDSkoKRo0aheTkZIwaNQpxcXH12WaqgrP1kxLMC4liVkgUs0JKMC8kilkhUcwKKcG8hIZw8UmkKsjKIRERERERERERVSY851NtnE4nlixZgsLCQu9/JUnCkiVLUFRUVBcvQUREREREREREEahOik8ulwuHDh2C2WzGoUOHYLFYIEmS9/+JiIiIiIiIiKhhEr7srjYxMTGYOnWqdz6o5s2b+8wNRfVLkiQkJibyskcSwryQKGaFRDErpATzQqKYFRLFrJASzEto1EnxqQI/vNCQZRlut5sTppEQ5oVEMSskilkhJZgXEsWskChmhZRgXkJDuPjkcDiwfft2lJaWYtOmTSgtLfWZz8lut0OWZdjt9nppKNXOZDKFugkUQZgXEsWskChmhZRgXkgUs0KimBVSgnkJPuHiU2FhITZs2ICuXbtiwYIF6NSpE7Zs2YKSkhIUFRVhwoQJKCkpwZVXXgmj0QgAKC0trbeG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8ssacOih8rt821zrVq30n//+Vwt++EG/37o2JgAAQHPX4MknJBaupAM36AW2aAW2GuvqZYVFRWqRnx/52LfdW+TCdbxdq7ikRDJGFRUVuuj883XqySer/R576IqRIzXx8cetzkD6/MsvtXHjRv196lTdcMstumnMGD320EP1ft738+froksvVTAUUvv27fXTzz/L5/OpxwEH1Pu5zRVXu4MtjkOwRStwg15ijyN/CnAcR2lpaZzaDyv0Alu0AluOJI/jNMqinb+sWKH27dtHPt5+qqmyslLl5eVR24wx+v777zXo5JP1+0svVXp6uq4cNUrzFyyQVHUFuhemT1cgEKjzeWd/9ZWWLl0auVren2+7TXPnzYu6kl21tWvXqrikRG+/845+XrRIEx9/XNOmTNFTEyYoKzNTK1et0tAzz5QkbdmypSFfhpTWmL0gtXEcgi1agRv0Eh+uz3yqvooAEocxRkWFhcpt1Ypf5FAvY4yKioqUm5vLD1zsEK2kqCZYYNNICodC8ni9/zsONfB55i9YoOOOOUYbNm6UMabGXyY7deyoPdu319p16yLbwuGw+h9yiD585x1lZGRo7MMP6/Lhw3XA/vtLktq0bq3+/frp8quu0uN//atytvs9ZvGSJZKkC847L7ItJydH99x5p1q0aBF136cmT9ay5ct1z5//rD3bt9ecuXP1y8qV+nnRIrXcdVetXLVKHTt21MeffqpBxx6rDz/+WGcMHtygr0WqqrUXoBYch2CLVuBG5PUzV7uLKVeTTx999JHuuOMOHXnkkVb3N8YoEAjo6quvVocOHRo0QNjhqjFwg15gi1ZSiMcjpadLFRVSMNjoD2/C4arn2FZ6es1t9diyZYsKCgr00ccfq7KyUv379Yu6fddddpEkrVq1KvICIxwOS5IyMjI0/aWX1L9fP/X73e8kVV0FT5I6d+qkQ/r10wcffqjBp55aNeatj7nP3ntL213VV5IOO/RQVVRU6KVXXomcyXT58OGR28vKyrR8xQoNGTxYubm5evX11+Xz+TR54kTdfe+9unHMGKWnpzP5VAt+ssAWxyHYohW4QS+x52ryqX379srOzlbv3r0lSU8//bT+8Ic/RG7f/uOnnnpKl19+eY3T4+vzySef6KGHHtLKlSu122676aabbtJRRx1V6303bdqksWPH6rPPPlMgENB+++2nW265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T1hUrquWpmu/vXoqw5ch3XmndMcdUh0LdwPVwuEwi7LDCsch2KIVuFFRXi5qiS3X5zxv3LhRb7/9dlOMBQAAxMpPP0klJZKkLH+mDu7QWw8Vdtftgf3l8/jk9XiV7suoWhPKn6Nsf7bSfRnyerzyeXy6PbC/HirsroM79FZmWmbVY5aUVD1uDBSXlKiyslKSVFpaGtm+afPmyP8vLy/X9TfdpIqKinof65cVK6K2LV22LPL4tZm/YEHkebd9/m0FAoEdPi8AAEBz4frMpz//+c8qLy/XiSeeKKnqF66srKxGHxgAAGhCp5wihULS1KmSqtbh2TVrF41YIl1y/j36tncHfbf6e63avFoVwQql+9LVvsUe6rHHger97QplvjBdyvJL0tYVoCQNG1b1uDshEAhow8aNykhPV3FJiUpLS9W9WzfNX7BA++27rzxb1wr64YcfNP2ll/TwAw/o5ltv1eatk04//fyzXnrxRXXs0EFvzJql8ooKrVy1SvvsvXeN55q/YIFatGghr9er2++6S88+84zGPvywrr36aj02frz69e2rC849t9Zx/uvdd9Vy11116SWXaNoLL+jDjz6S3++P3B4Kh5WZkaHJkybt1NcDAAAgFbiefBowYIDO3eYXsTfeeEPnnHNOrff97rvv1KNHj4aPDta2/YUXqA+9wBatpLjBg6v+d+sEVLXMF6ZrgH+YBgy+oubnvPaa9ML0mtsvueR/j7cTgsGghp53nlq1aqVePXuqoKBAmzZt0uKlSzXlqae09157KS0tTenp6erUqZOkqoVDp02ZopUrV2rCxInq2KGDgsGgZr39tp4cP14PPPywbrr+emVkZEQ9V9cuXXT2BRfoiXHjtFvbtvrk00/VrUsXpaena9Xq1Xp06NA6x+n1erXffvtJkjwej0ZffbUO7d8/cvuq1as18emnd/rrkao8rMkCSxyHYItW4Aa9xJ7rt92FQiHr+/74449uHx4N4DiOMjMzWVwPVugFtmilmRg8uOqMpe1NnVo10bSt116rMVElSc6wYfKccUajLNrp9Xp1+IAB+tPNN6tb167yer2aNmWKDunbV927ddO877/XY+PHy7PNekHVl0t++513dN0110iSXpg+XReef74yMjJ08kknafT116uoqCjqufx+v64ZOVLpW38BzcvLU35+vhb88IMOHzAgsibRosWL9ePChTXGGg6H9cmnn0qqervf2rVrI/9t2LCBNY3q4Khqwo6fLKgPxyHYohW4QS/x4frMpzZt2ujee+9Vly5dlJaWprlz59a5sNsHH3xQ51lRaDzGGJWXlSmDq93BgjFG5eXlysjI4AcudohWmpE6zoCKfDx4cJ0TTxo2TGbwYJlwWE4MJhTS09OVu90FNhzHUTgc1q4tW6pt27ZaumyZNm7cqIsvuECSdHCvXurYoYNOHTJEl15yiS487zwVFRfr4ssuU05Ojn755RdJ0uo1ayTHUauWLbV4yRJ9O2eONhYUKBAI6PABA3THbbfp8Sef1BdffqnVa9bo408/VYsWLdRl7721dOlSLV22TMFgUD6fT4VFRQq7+INdc2KkmPWC5MZxCLZoBW5EXj9ztbuYcj35dNxxx2nPPffUl19+qaKiIm3atEmrVq2q9b6FhYU7PUDYCQQCyqj/boCkrb1kUAzqRyvNyI4moF5/XSooqPk5w4ZFPi9sjJr6PJ9ly5fX+XatYCgkn9erX9eu1ZdffSXHcXT+JZfIkVQRCCg3J0dnDRkis/Uqay3y8/X6K6/o8y+/1Otvvqk1v/6qHgccoHPPPlsPP/aYxtx4ow7t31/Pv/iiMjIydOYZZ0iSrr7ySl195ZV6dNw4Hdq/v7p37aonJk3SBeedpwP231+vv/mmNm/ZopEjRrDg+A7EohekBo5DsEUrcIPXz7HnevJJkrp3767u3btLkv7xj39ErQG1rVatWjV8ZAAAILbqmoCqZ+Kpsfz088+67sYbVVhYqB9/+knl5eUqLCrSRZdeqsVLl2rV6tU6t5Z1mBzHkT8tTe3bt9eMV1/VyBEjVFFRoZEjRujqa6/V8xMmSKr6RXPbNR7eee89hUIh3fjHP+qxceM09Mwz9eL06Rrxhz9oxdar3/26dq0OGzCg1vH+6513VFJSouKSEv35nnuUmZGhgk2bFAqF9N7772vZL7/o9j/9SYOOPbZRv04AAADJpkGTT9vaf//967zthBNO2NmHBwAAsVTXBNS2mmDiSZK6de2qF597To+MG6eTTjhBS5ct0xdffqm/PvywrrvxRj364INa8MMP+mL27KjPM6bqent9evfWQ48+Ko/Ho/9+/rkk6edFi3TRpZdKqjpz6oXnnlOHPffUqtWrNaB/f+Xk5OjxJ59Uv759tftuu+miCy5Q2zZtNPurryRJi5cs0fCtny9JlZWV+te77+rDjz/W8GHDdPTAgXr+xRf14nPPKS0tTf96912VlpZqyOmnN/rXBwAAIFnt9OTTgQceWOdtLVq02NmHh6V0TjGFC3Wt0wZsj1aaqcGD636r3a671jrx5PG4voZJrQqLitQiPz/ysW+7RbvDWyeatldcUiIZo4qKCl10/vk69eST1X6PPXTFyJGa+PjjNdYACYVCOufCC9UiP18/L1qkLl26aNIzz6hvnz66bcwYBUMhbd6yRZs3b9Yu2/w+c+/YsQqFQjrisMO02267KRQKqby8XKvXrFHHDh0i9wsGg/plxQrtvddejfBVST2N1QtSH8ch2KIVuMHr59hr0OTTli1bNGfOHElSnz59lJOTE3X7yy+/rF122UV77LFH5O15aDqO4ygjPV1icT1YcByH98PDCq00Y6+9VvvEk1S1/bXXoiagHKnRFnj9ZcUKtW/fPvLx9lNNlZWVKi8vj9pmjNH333+v62++WbfecovS09N15ahRuu/uuyVJ6zds0Psffqizzjgj8ra7jh066LWXX9YPP/6oT//9b1195ZW66y9/0cUXXihJOnzAAN1w883q17dv1HPdfMMNSk9P12Pjx0uS5sybp/6HHKKp06ZpwQ8/VB2PJf3jpZfkSJr+/PON8nVJJY3ZC1IbxyHYohW4wevn+HD9Z6dvvvlGp59+uqZOnapnn31WJ5xwgp599tmo+5x++un66aefdMbWxTnRtIwxKikpibztANgReoEtWmmm6rqq3bamTq2631ZGUigcrjFR1BDzFyxQ7549qx7XGGVlZUXd3qljR5191llR28LhsPofcog+fOcdnXziiXpk3DhdPny4Dti6NECb1q3Vv18/XX7VVVVnSG3l8/m0eMkS+dPS9MyUKSrYtEkd9twz8jnffPutjjziiKjn2v5KSm/OmqWzzjhDPp9PD91/v6ZNmaJpU6bokQce0H777tsIX5HU05i9ILVxHIItWoEb9BIfriefXnjhBb3yyiuaOnWqpkyZonfeeUeFhYUaO3Zs5D4+n0+///3v+WbGUDAYjPcQkEToBbZopZmpa+Jp111rbtt+AqqRjvlbtmxRQUGBPvr4Yy1ZskT9+/WLHsouu6h1q1YKVlZGJoHC4bCkqomh6S+9pP79+kUW+Q6GQpKkzp066ZB+/fTBhx9GPd6Q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C2zRCmzRCtygl/jgzKcUYIxRaWkpq/XDCr3AFq3AFq3ADXqBLVqBLVqBG/QSH0w+pYhAIBDvISCJ0Ats0Qps0QrcoBfYohXYohW4QS+xx+QTAAAAAAAAmkyzX/Op+lS7UCgU55E0nDFG4XBYoVBIjuPEezhIcPQCW7QCW7QCN+gFtmgFtmgFbiR7L9VzF8n2tsFmP/kUDoclSd9//32cRwIAAAAAAFC/6rmMZOGYZJsua2ThcFjBYFAejycpZz0BAAAAAEDzUH3mls/nk8eTPCspNfvJJwAAAAAAADSd5JkmAwAAAAAAQNJh8gkAAAAAAABNhsknAAAAAAAANBkmnwAAAAAAANBkmHwCAAAAAABAk2HyCQAAAAAAAE2GyScAAAAAAAA0GSaf4mzBggW64IIL1KdPHx122GG65557FAgEJEnz5s3T0KFD1atXLx199NF66aWXoj535syZOu6449SzZ08NGTJEc+bMidwWCoU0duxYHXrooerVq5euvPJK/fbbb5HbN27cqKuuukp9+vRRv3799Je//EXBYDA2O40GW7JkiYYPH64+ffpo4MCBevLJJxUOhyXRC6oUFBTouOOO05dffhnZFs826ntuxFdtvUjSnDlzdOCBB9a4P600X7W18s4772jw4MHq3bu3jj76aD3++OORY5JEL81Vba08//zzGjRokHr16qVBgwbp73//e9Tn0ErzVddxSJJ+++03HXrooZoxY0bUdnppnmpr5Y477tABBxygXr16Rf6bPn165HZaSTAGcRMKhcyAAQPMs88+a0KhkPn111/N8ccfbx5//HGzefNm07dvX/P3v//dVFZWmv/+97+mV69eZt68ecYYY7744gvTq1cv8/XXX5tAIGCmTJli+vXrZ0pLS40xxowfP96ceuqpZs2aNaaoqMhce+215g9/+EPkuS+88EJz/fXXm9LSUrNixQpz8sknm6effjouXwfYKS4uNgMHDjS33nqrKSkpMatWrTKnnHKKGT9+PL3AGGPM119/bY499ljTtWtX88UXXxhjTFzbqO+5EV+19RIOh81LL71kevbsabp27Rp1f1ppvmpr5fvvvzc9evQwH374oQmFQmbx4sXmqKOOMpMnTzbG0EtzVVsrH3zwgfnd735nvv/+e2OMMfPmzTMHHnig+fzzz40xtNKc1dZLtVAoZC666CLTvXt388orr0S200vzVFcrZ5xxhpkxY0atn0MriYfJpzgqKCgwXbt2NVOmTDHBYND8+uuv5sQTTzSTJ082//znP82gQYOi7n/77bebm266yRhjzPXXX29uu+22qNtPOOEE8/LLLxtjjDniiCPM66+/Hrlt/fr1plu3bmbFihVm+fLlpmvXrmbt2rWR29966y0zcODAptpVNIJPPvnEHHjggaaioiKy7a233jKHHnqomT59Or00czNmzDADBw40b731VtSBOZ4/S+p7bsRPXb3ccsst5uyzzzZ/+9vfakw+0UrzVFcr//rXv8y9994bdd97773XjBgxwhhDL81RXa0YY0xRUZExxpjKykrz8ccfmx49epgFCxYYY2iludpRL8YYM27cOHPjjTeao446KmryiV6an7paqaioMPvvv7/5+eefa/08Wkk8vO0ujnbZZRcNGzZMY8eO1YEHHqgjjzxSnTp10rBhw7Ro0SJ17do16v777LOPFi5cKElavHhxnbcXFRVp7dq1Ube3atVK+fn5+umnn7Ro0SK1aNFCbdu2jdy+9957a82aNSosLGzCPcbOCIfDSktLU1paWmSb4zjasGGD5syZQy/N3GGHHab33ntPJ510UtT2eP4sqe+5ET919TJ69GhNnz5d++23X43PoZXmqa5Wjj/+eI0ZMybycXl5uT7++GPtv//+kuilOaqrFUnKycnR0qVL1aNHD11++eU677zzIj9naKV52lEvX3zxhd566y3dcccdNW6jl+anrlYWLlyoYDCocePG6dBDD9Xxxx+vp556KvL2b1pJPEw+xVE4HFZGRob+7//+T3PnztWbb76pJUuWaNy4cSopKVFmZmbU/TMyMlRaWipJO7y9pKREkpSVlVXj9pKSklo/t/rj6sdH4undu7cyMjL08MMPq6ysTKtXr9bkyZMjt9NL89a6dWv5fL4a2+P5s6S+50b81NVLu3bt6vwcWmme6mplW8XFxRo5cqQyMjI0bNgwSfTSHNXXyp577ql58+bp5Zdf1ltvvaWnnnpKEq00V3X1snHjRv3pT3/SQw89pOzs7Bq300vzU1crRUVF6tu3ry666CJ98sknevDBBzVt2jT97W9/k0QriYjJpzh677339M477+j888+X3+9Xly5dNHLkSL344ovKzMxUeXl51P3Ly8sjP4R3dHv1P4SysrJab8/KyqpxW/XHtf2QR2LIy8vT008/rXnz5mngwIG69tprdfrpp0uSvF4vvaBW8fxZUt9zI7nQCmqzdOlSnXvuuQoGg3ruueeUk5MjiV5QU/XZ2wceeKAuvvhivfnmm5JoBf9jjNFNN92kiy66SAcccECt96EXVBswYICee+459e3bV2lpaerRo4cuueQSzZo1SxKtJCImn+Lo119/jVzZrprP51NaWpq6du2qRYsWRd22ePFidenSRZLUpUuXOm/Pz89X27ZttXjx4sht69ev1+bNm9W1a1d16dJFmzdv1oYNGyK3L1myRO3atVNubm5j7yYaSSAQiPxy/+WXX+qll16Sx+PRPvvsox49etALahXPnyX1PTeSC61ge5988omGDh2qww8/XJMnT1Z+fn7kNnpBtalTp+raa6+N2hYIBCK90Aqq/frrr5o9e7YmTJigPn36qE+fPlqzZo3uvPNOXXHFFZLoBf/z/vvv6x//+EfUtkAgoIyMDEm0koiYfIqjww47TOvXr9fEiRMVCoW0cuVKPfnkkzr11FN13HHHacOGDZo6daoqKyv1xRdf6I033tCZZ54pSTrrrLP0xhtv6IsvvlBlZaWmTp2qjRs36rjjjpMkDRkyRE8++aRWrlyp4uJi3Xvvverbt686dOigTp066eCDD9a9996r4uJirVy5Uk888YTOOuuseH45YGH48OF6+eWXZYzR/PnzNXHiRF1yySX0gjrFs436nhvJhVawrblz52rkyJEaM2aMbr755hpviaAXVOvTp4/ef/99zZo1S+FwWN98842ee+45nXfeeZJoBf+z++676/vvv9fXX38d+W/33XfXHXfcoUmTJkmiF/yPMUb33XefPv/8cxljNGfOHD333HM655xzJNFKQorveuf4z3/+Y4YOHWoOPvhgM3DgQPPII49Ermb23XffmXPOOcf06tXLHHPMMVFXejDGmFdffdUcf/zxpmfPnuass84yc+fOjdwWCATMgw8+aA4//HDTu3dvc+WVV5oNGzZEbl+/fr0ZNWqU6du3rznkkEPM/fffb4LBYGx2Gg02e/Zsc8YZZ5iePXuaY445xjz33HOR2+gF1ba/akw826jvuRF/tV1l6IsvvqhxtTtjaKW527aVK664wnTr1s307Nkz6r/hw4dH7k8vzdf2P1c++OADc+qpp5pevXqZU045xbz22mtR96eV5q2241C17a92Zwy9NGfbt/Liiy+aQYMGmYMOOsgcc8wx5u9//3vU/WklsTjGGBPvCTAAAAAAAACkJt52BwAAAAAAgCbD5BMAAAAAAACaDJNPAAAAAAAAaDJMPgEAAAAAAKDJMPkEAAAAAACAJsPkEwAAAAAAAJoMk08AAAAAAABoMkw+AQAAJLhwOBzvIQAAADSYL94DAAAASGZvv/22OnXqpH333bfO+0yfPl2FhYW69NJL5fO5//WrtLRUf/rTn/T73/9ePXr0sP686dOnq0OHDvJ4av9746effqpjjjlGvXv3jmwLBoOaMGGCRo8e7XqcAAAAteHMJwAAkPCKioo0f/78eA+jhi+//FI///zzDieeJGnWrFnKyspq0MSTJOXk5OiUU07RtddeW+O2X375RdOmTav189588015vV61a9eu1v9WrFihioqKqM/x+Xzq27evxo0b16CxAgAAbI8znwAAQEJbsWKF7rnnHnXt2lUHHHBAgx9n3bp1+vDDDzVnzhx5PB7df//9OzWu4uJiPf7445oyZUqN2zZu3KgWLVrI6/Vq3bp12meffXTBBRdE3Wf58uVKT0/XbrvtFtkWDAZ1/fXXq6CgoMZjVlZWKhgM6qKLLoravnjxYm3atEnt27fXUUcdFXWb1+vVQw89pPT09Fr3YenSpRo+fHiN7f3799e7776rb775RgcffHDdXwQAAAALTD4BAICE1qFDB51wwglaunTpTj1O27Ztdd5552mvvfbSzJkzd3pcEyZM0Jlnnlnr2Uyff/65/vrXv6pdu3YqKChQZmZmjUmjlStXKiMjQ2+99Za8Xq+kqrOObr31VmVmZio3N1fGGDmOo6OPPlpvv/220tPTdcstt+ikk07SEUccUe8Yw+GwHnnkEbVv377W22+55RaFQqFabxsxYoRGjhypf/7zn3W+bQ8AAMAGk08AAAAuBQIBvfnmm7ruuutqvd3r9Wrffffd4VvXxo8fH7nvttq0aSNJWrVqlW644QZNmDCh1s9/88031b9/f7Vs2bLO5wiFQvrjH/+4wzOfBg8eXOttbdu2VevWrTV79mwdcsghdT4HAABAfZh8AgAAcOnTTz/VAQccIL/fX+vttmcKbT/xtK27775bhxxyiPLz82u9/ZhjjtF9991NdRsAAAcdSURBVN2nvLw8jRgxQjk5OZKq3vJXWVkpSTryyCM1aNAgZWRk1PoYq1at0u67764FCxbo+eef16233qrs7OzI7QMHDtRbb73F5BMAANgpTD4BAIC4e/fdd3XXXXfpxhtv1Pz585WWlqYNGzbosssuU/fu3SP3mz59utasWaNly5apZ8+euuyyyyK3rVu3Tk888YT23HNPFRUVqUWLFrr00kubZLw///yzOnfuXOftHo9Hs2fPrvFWu22tXr1aZ511Vq23vfTSS9prr71qXWC8WmZmpu666y6NHz9eJ510kv75z3+qXbt2WrdunTZs2KC8vDx169ZNmzdvrvMxysvLtWbNGvl8Pp199tkqLS2Nmnzq3Llzo7xFEQAANG9MPgEAgLgbNGiQPvzwQ33yyScaO3as0tLStHHjRp111ll6/fXXJUkffPCBHnvsMZ1zzjkKhUI688wzdeihh6p79+4Kh8MaPXq0HnzwQe25556SpIcfflivvvqqTj/99EYf77p169SxY8cd3qe+K8ZVv+1ue/Pnz9fq1at188037/Dxf/rpJ1VUVGjUqFGqqKjQmjVr1K5dO+23336R+/Tr109du3aNfFxWVia/3x8542rdunXq16+f7r777lqfo1WrVlq7du0OxwEAAFAfJp8AAEDCGDp0qNLS0iRJLVu2VPfu3fXJJ59Ikrp166Zu3bpJqnq72sCBA/XOO++oe/fuev/999W+ffvIxJMkDRs2TEOHDm2SyaesrCyVlZU1+uP+8ssvWrFiha699lqNGjVKmzdv1m+//abWrVvr97//vaSqq95NmjRJixcvVps2bTRjxgzdcMMNtT5eTk6Opk2bFvn4lltu0bnnnquePXtKkiZPnlznelBS1WRVVlZW4+0gAABolph8AgAACWP7tZLatWun1atXq3Xr1jWu2NamTRt9//33kqQ5c+Zor732irq9ZcuWKiws1MaNG3e4KHdDtGvXTsuXL6/zdsdxGvS47du3j5xRVX1m1DfffKNNmzbp2GOPjdxv9uzZuu222zR58uTIZF1tiouLo976t3TpUv3000+R9aF+/fVXXXLJJXV+/oYNG7Tbbrs1aF8AAACqMfkEAAASViAQiFqDaFvGGPl8vhr/f1s+n0/hcLjRx9WvXz/NmDGjztuNMQ1a86m2BcgPPvhgjR07Vl27dlWHDh20ZMkS3XbbbXriiSciV8arS3Z2dr1nPoVCoTo//9tvv1W/fv12+BwAAAD1YfIJAAAkrBUrVujkk0/W2rVra0yS/Pbbb+rQoYMkab/99tPXX38ddXtRUZHS0tLUunXrRh9X9+7dFQqFtHr1au2xxx613qehaz7V5uqrr9Z1112nCy+8UA8//LDGjRunffbZp97PKysr2+GZT1u2bNnhBNlHH32kiRMnWo8TAACgNnbXAQYAAIiB2bNnR/7/jz/+qOLiYvXv31+SNHfu3MhtlZWV+vzzzzVkyBBJ0kknnaSFCxeqoKAgcp9//OMfuuaaa5psrNdee62efvrpWm8zxjTqc2VnZ+uQQw7RH/7wB1144YVRVwCsTWVlpa655pp6J6hyc3M1bty4qK97tY8++kg9e/bU7rvvvlNjBwAA4MwnAACQMILBoCZPnqzCwkItX75c48aNk+M48ng8Gjp0qCZNmiSp6oyo6667LrKWk8/n08MPP6zHH39c7du3V3l5uXJycjR06NDIY69cuVL//ve/NWfOHM2bN08vvPCC9thjDx155JENGuuxxx6rWbNmadGiRerSpUvUbY35Vr9FixZpwoQJat26tV5//XU98MAD+uyzz3TeeeepX79+NdbJkqS0tDT9+c9/Vnp6etTbFrd/2121oqIi/fTTT5EF3QOBgP7+97/r0UcfbbT9AAAAzZdjGvtPcwAAAA1wyy236IwzzkiqNYZKS0t1991369Zbb428lU2SZs2apbvuuqvGpNS2Vq9erSFDhujqq6+ucVtFRYU++ugjzZs3T3l5eTrrrLOi3j746aefavLkyVq4cKF69+6tLl26aP/999fxxx+vzz77TE899VStz7l06VK1adMmaqxS1VX2HMfRzJkzteuuu2rs2LEaPHhwvWdYAQAA2ODMJwAAEHezZ8/WnDlzFAqF1Lp16xpXrktUWVlZuuWWW7Rp06aoCZ1gMKhBgwbprrvuqvNzH3/8ceXm5kZt27x5s7744gtVVFSoZ8+eOuGEE2r93COOOEJHHHGEVq9erY8//lhr167V4YcfLkk69NBD1blzZ7Vr167WRdjrEwwGmXgCAACNijOfAAAAGlkwGKx34sfmPgAAAKmAyScAAAAAAAA0Ga52BwAAAAAAgCbD5BMAAAAAAACaDJNPAAAAAAAAaDJMPgEAAAAAAKDJMPkEAAAAAACAJsPkEwAAAAAAAJoMk08AAAAAAABoMv8Pk0jhBO4L3F4AAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1200x800 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA90AAAGNCAYAAAAM3xJYAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAArFpJREFUeJzs3Xl8E2X+B/DP5GybphfQAnKKcsuhHIKCeCAe640/BY9VYVVkPdBlFVdc1EVcserqqqh4XyiooCsioi66oFwCgghyX4VwlB5J2lwzvz9CQtI2aZImeWbC572vvFaemUw/801m8jyZyYykKIoCIiIiIiIiIko6negARERERERERJmKg24iIiIiIiKiFOGgm4iIiIiIiChFOOgmIiIiIiIiShEOuomIiIiIiIhShINuIiIiIiIiohThoJuIiIiIiIgoRTjoJiIiIiIiIkoRDrqJiCgj2Gy2pC1LUZSkLMdut+P3339PyrIy2aFDh0RHICIiShkOuomISPNsNhuuvPJKvPnmm3E9b9OmTfjiiy/qDbLvvvtuvP7667Db7fjpp58SzpWbm4uXX34ZDzzwALxeb0LLmDFjBn777bd67b/88gtmz54NWZZjWs4jjzwS9sXExo0bI84ryzK2b98e03L3798flmHVqlVYuHBhTM8NGDFiBD777LOwtrqviaIoWLNmDSZNmoTbb78dbrc7rr9BREQkikF0ACIioqaorKzErbfeinPPPRfXXXdd2DSfz4fFixfjnHPOafC5CxYswPz589GrVy+0bdsWgH/AuWTJEnTt2hW5ublYvHgx3n//fTz55JPIyspqcDlutxvbtm1D165d60178MEHcdZZZ+G2225Dx44dw7L961//wtixY5GXlxe2rE8++QTXXHMNJEnCd999h2bNmqFbt2545ZVXUFJSgssuuww//PAD3njjDfTp0wcnn3xyo3X6+OOP0b17d1x99dUAgJdffhlbtmxBQUFBvXmrq6uxb98+zJs3Dy1btoy63ClTpsDtdmPGjBkwmUxo3rw5vv/+e5x//vmNZgqQZRm9e/cOa7vzzjsxbNgwuFwuVFRUwGazwWg0on379ujbty/27duH9u3bx/w3iIiIROGgm4iINOvQoUMYO3Ystm3bhry8PNxyyy1h0ysqKrB582b8+9//xnnnnVfv+V9//TUeeOCB4IAbAH777TfIsozrr78eADB+/HicddZZ2LBhA0499dQGc+j1elx55ZXo06cP9Hp9vekFBQV4+OGH62X7/fffsW7dOrz66qswGPwfySaTCXv37sVf/vIXlJaWwmg0ol27drDb7Zg9ezaeeOIJAMDPP/+MsWPHxjTgDmQcNGhQ2L9vvvlmXHnllfXmXblyJaZPn97ogHvXrl1YvHgxnn32WZhMJgBA+/btsWXLlpgyhWapa8uWLbj22mtx5plnxrUsIiIiteGgm4iINGnt2rX461//itatW+PHH39Ebm5u2PSDBw/ij3/8IwYNGtTgEdG1a9eisLAQZ599NmRZxqpVq9C/f3989913uOSSS4JHn3Nzc/Hiiy+ib9++OHjwIGbMmIGHHnoIkiQFl6XX66HT6TBt2rTg39q0aROqq6vRr1+/4Hwulwvfffcdzj//fOh0kX/hdf311+Pcc8/F3//+9+DfeffddzFt2jScdtppcLvd+OWXX4ID8FgE/t727dvRokWLRucPfAkQzdtvv42BAwdixIgRYe3t27fHTz/9hNNPPz2ubDt37oTX60WnTp1gNBqj1oiIiEgrOOgmIiJNqa2txYwZM1BWVobXX38d27Ztwx//+Ee8/PLLaN68OQBgx44duO2223DmmWdi0qRJDQ4gP/74Y/z1r38F4D+ye8stt2DOnDn49ttv4XK5cMMNNwAAampqIEkSsrKycOjQIZSXl6Nr167B07QD9Hp92O+QDxw4gMmTJ+PTTz9FYWFhsP3uu+/Gm2++GXbUua6SkhK89dZbyMvLg06ng6IoOOOMM7Bjxw58//33kCQJ/fr1Cxs8+3w+PPLII7j55pvRsWNH1NTUYMKECXA4HMH1uPfee7Fp0yYMHToUJpMJc+bMwfLly+v9/YMHDzb6m+nt27fj448/xocfflhv2i233IJx48bhvffeCx4BDyXLMu6//37s378fAOBwOPCXv/wFe/bsQV5eHubMmcMBNxERZQwOuomISDP++9//4pdffsFFF12Ezp07AwBOOOEEvPzyy1iwYAGuv/56fPPNN5g6dSruvPNOXHHFFQ0u5+DBg/B6vTjllFMAAB9++CEuvPBCGAwG/Prrr3jhhReCp6M///zz0Ov1uOOOO6JmUxQl7Oi3yWRC27ZtwwbcZrMZkiRh0KBB2LJlCx599FHMmDEDOTk5APxHwkeNGgWHw4EWLVrAZrNh165dqKioCB55z8vLg9VqxdatW4NfDFRXV2PLli3o27cv3njjDTzyyCPIzs7GE088gfz8/OAg/emnn0abNm0AABMmTMC1116LSy+9FACwevVqHDlyBGeffTY2bNiADRs2RF3fxx9/HHfccUfwdQjVvHlz9O3bF5MmTcL06dPrDaB1Oh0mT54Mq9UKp9OJ/v3746mnngo7IyG0lkRERFrGQTcREWnGmWeeiWHDhtVrv/fee5GTk4OJEyeipqYGs2bNQnFxccTlPP300xg/fjxkWca2bduwZMkSfP7553j99dejPi8aj8eDBQsWYNGiRcjKykJ1dTX27NkTHBgHKIoS1jZnzhzceOONAPyD8k8++QQAUFVVhdGjR6N58+bo1asXhg0bhiFDhgAArrrqKtxyyy249tprAQDffPMNnn32Wbzzzjthf6uhi6QF2O32sAvDlZWV4ZVXXsHAgQPRo0cP9OjRI+JzZ8+eDZ/PhzFjxkSc5+6778aVV16JP/3pT/jnP/8ZPAshIPAlwi+//AKfz1fv+dEG3StXrsS8efPw2GOPRZyHiIhILTjoJiIizWjoNPGNGzdi/vz52LBhA04//XTcddddUZexYcMGLFiwAKtWrUKvXr3w66+/YuLEibBYLKioqECfPn0iPvf9999HeXk5/vznP4e1u1wuyLKMkSNH4rbbbgMALF++HM8//3y9gXD37t3x9ttvRx1U2u123HfffZgyZQr+/e9/Y9iwYfjoo4/w8ccf49JLL8XVV18Nl8sVnP/w4cNo1apV1PUOWLx4MZxOJyorK8Oumm42m3HCCSfAYrEAANasWQOXy4WBAweGPX/9+vX47LPPMGPGjKingG/btg1XXnkl3nnnHYwYMQLXX389LrnkEpx00klh861atQoA8M477+Cee+4J/jZfkiT885//DMu4atUq9OzZE2azGYC/xgMGDIhpvYmIiEThoJuIiDRn+/bt+N///oelS5eiZcuW+MMf/oCCggLMmDEDgwYNQv/+/SM+t3v37hg3bhwuu+wybNmyBQ6HA1dddRVmz56Nu+66C48//jieffZZvPXWWwCAvXv3AgB+/PFHAP6B/8GDB8N+T+10OgEAVqs12Obz+fDbb7/VO9Lt8/ng8Xga/K0zAOzZswfPP/887r///uAA1Wq14vnnn8f777+PlStX4oEH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iChFOOgmIiIiIiIiShEOuomIiIiIiIhShINuIiIiIiIiohThoJuIiIiIiIgoRTjoJiIiIiIiIkoRDrqJiIiIiIiIUoSDbiIiIiIiIqIU4aCbiIiIiIiIKEU46CYiIiIiIiJKEQ66iYiIiIiIiFKEg24iIiIiIiKiFOGgm4iIiIiIiChFOOgmIiIiIiIiShEOuomIiIiIiIhShINuIiIiIiIiohThoJuIiIiIiIgoRTjoJiIiIiIiIkoRg+gARCKtXLkSb731FhYuXIg+ffqgbdu2AAC73Y6ffvoJV199Nf72t78JTklERERqtW/fPnzwwQeYPXs2fvzxx4SWUVtbi3nz5uHtt9/Gww8/jIEDByY5JRGJxEE3Hdf69euHwsJCLFy4ECNHjsTVV18dnLZ69Wp89dVXaclRXl6OV199Neo81157Ldq3b5+xzyEiItIiSZLgdDpRXl6e8DJcLhfMZjO2bNmSxGSN+/zzz7Fhw4aI09u0aYPrrrsuo59DlA4cdNNxz2w2N9jet29f2O32tGSorq7GddddhzZt2jQ43ev1YtWqVWGD1Ex7DhERkRa1bNkSXbp0adIy8vPzcdpppyUpUeyaNWuG+++/P+L0pUuXZvxziNKBv+kmimLIkCGiIxAREZHK6fX6Ji9DkqQkJCEiNeKgm6gB3377LX777bcGp23cuBFXXHEFunTpgmeffRaKogAA5s6di7POOgvr1q0DALz44ot45plncN9996Fbt274/fff05afiIiIkmflypWYMGECJk+ejPnz52PIkCE466yzMHv27LD5duzYgf/7v/9D//798fDDD8PlcgWn2Ww2PPzww/jnP/+JG264AQ8//HBcZ9S98MIL6Nq1Ky688EJs2rQJAFBWVoYbb7wRjz76KHw+H7Zu3YqHH34YpaWlGD58OO66667kFICImoSnlxMd9d577+G7776Dy+XCsmXL6n2QBnTt2hXTpk3DZZddhj59+gS/mW7VqhXGjx+PU045BatXr8aGDRvw73//G4D/dCciIiLSpry8PKxduxaFhYU4+eST8dJLL2HatGmYPHkyTjnllOB8s2fPxl133YWVK1dixowZsFgsuP/++1FTU4Mbb7wR//rXv9C1a1e43W5ce+21uPfee/HKK6/ElGH8+PH47bffsG/fvuDp7K1bt0arVq3wt7/9DXq9Ho8//jgmTpyIrl274vrrr8fTTz+dknoQUXx4pJvoqOuuuw4vvvgiXnvtNTzwwANR5+3atStOO+00fPLJJ8G2hQsX4g9/+AMA4ODBg1i6dGnwKqbXX3898vLyUheeiIiIUqZz585o3bo12rZtixtvvBE9e/bEY489BkmSMGfOnOB8EydOxJlnnol77rkHl19+OWbNmgUAwXm6du0KADCZTBg7diwWL16MVatWxZzjuuuuw/r167F582YAwO7du9G+ffvg6e0HDhzAK6+8ArvdjpKSElx55ZVJWX8iahoOuokaMGzYMBiNxqjzjBo1Ct9++y0OHjyI6upqGAwG5OTkAPD/Frxz58646aabMGbMGFRVVaFly5bpiE5EREQpIEkSsrKygv8+8cQT0bJlS+zatavB+YcOHQqn04nDhw9j2bJlsFqtYdMDR8gDP0uLxemnn44OHToEB/Offvpp2MD6jjvuwMKFC3HuuefilVdeQd++fWNeNhGlDgfdRA1o06YNTjrppKjzjBgxAlarFXPmzMHnn3+OSy65JDgtOzsb7733Hh5++GFs2LAB11xzDb7//vtUxyYiIqI0KioqgslkanCaxWIJG6gfPHgwbHrz5s0BoNEv+UNJkoRrr70W8+bNg91ux6FDh8K+1L/wwgvx+eefo2/fvigtLcXNN98MWZbjXS0iSjIOuokSZDKZcOWVV2L27Nn49ddf0bNnz+C0H3/8ETU1NbjuuuvwxRdf4MQTT8T7778vMC0RERE1lc/nC/v3wYMHceqppzY4744dO9CnTx9YLBb06tUL+/fvx/bt24PTKyoqAPiPXsfjiiuugNvtxgMPPIBhw4aFTfv666/RsWNHzJgxA48++ihWrlwZ8cKwRJQ+HHTTca+2thYAwq4wGqtrr70WZWVlYQNuACgvL8c777wDwP8t+Omnn46OHTs2PSwREREJs2XLluBdS5YtWwZZljFy5Mjg9N27dwMA7HY75syZE7xGzKhRo9CiRQvMmDEjOO+CBQtwySWXoFOnTgAQPCLd2JHpgoICXHjhhfjll19w1llnhU175513UF5eDsB/1NtsNqNVq1ZNWWUiSgJevZyOaz///DPeffddAMCsWbOQm5uLyy+/PObnt23bFsOHDw87tTzg2Wefxfr163HSSSfB5XJhwoQJUZf18ssvIzc3t8FpiqLg7LPPzvjnEBERqZkk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",
      "text/plain": [
       "<Figure size 1000x400 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "📌 步骤4: 导出分析报告\n",
      "----------------------------------------\n",
      "✅ 综合分析报告已导出至: 综合分析报告_示例.xlsx\n",
      "\n",
      "📊 报告结构:\n",
      "├── 分析总览: 各方法处理效果概览\n",
      "├── 原始数据: 未处理的原始数据集\n",
      "├── IQR方法: 处理后的数据\n",
      "├── 随机森林方法: 处理后的数据\n",
      "├── 多数投票法: 处理后的数据\n",
      "├── 综合评分法: 处理后的数据\n",
      "├── 趋势分析结果: 分析结果数据\n",
      "├── 数据质量报告: 处理前后质量对比\n",
      "├── 配置参数: 分析使用的参数记录\n",
      "└── 方法比较: 不同方法效果对比\n",
      "\n",
      "============================================================\n",
      "✅ 综合数据分析完成!\n",
      "============================================================\n",
      "\n",
      "📊 分析结果摘要:\n",
      "----------------------------------------\n",
      "原始数据: 2891 行 × 22 列\n",
      "\n",
      "各方法处理结果:\n",
      "  • IQR方法: 2891 行 (减少 0.0%)\n",
      "  • 随机森林方法: 2891 行 (减少 0.0%)\n",
      "  • 多数投票法: 2891 行 (减少 0.0%)\n",
      "  • 综合评分法: 2891 行 (减少 0.0%)\n",
      "\n",
      "目标变量 'SFcf2f' 统计:\n",
      "  • 原始均值: 0.846\n",
      "  • 原始标准差: 0.335\n",
      "  • 处理后均值: 0.846\n",
      "  • 处理后标准差: 0.335\n",
      "\n",
      "============================================================\n",
      "💡 提示:\n",
      "1. 请将示例数据替换为您的实际数据\n",
      "2. 根据需要调整特征列和目标列\n",
      "3. 可以选择性地启用不同的处理方法\n",
      "4. 查看生成的Excel报告了解详细结果\n",
      "============================================================\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "综合数据处理与可视化系统\n",
    "整合了重复数据处理、趋势分析、可视化和科学绘图的完整解决方案\n",
    "\"\"\"\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import platform\n",
    "import warnings\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "from sklearn.model_selection import train_test_split\n",
    "from matplotlib.font_manager import FontProperties, findfont, findSystemFonts\n",
    "from matplotlib.ticker import MultipleLocator, FormatStrFormatter\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib.colors import Normalize\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib.ticker as mtick\n",
    "\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "class IntegratedDataProcessor:\n",
    "    \"\"\"\n",
    "    综合数据处理器：整合重复数据处理、趋势分析和可视化功能\n",
    "    \n",
    "    主要功能模块：\n",
    "    1. 多策略重复数据处理（IQR、随机森林、多数投票、综合评分）\n",
    "    2. 差值计算与趋势分析\n",
    "    3. 重复数据可视化\n",
    "    4. 科学绘图系统\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, df, feature_cols, target_col):\n",
    "        \"\"\"\n",
    "        初始化综合数据处理器\n",
    "        \n",
    "        参数:\n",
    "        - df: 输入数据框\n",
    "        - feature_cols: 特征列列表\n",
    "        - target_col: 目标列名称\n",
    "        \"\"\"\n",
    "        self.raw_df = df.copy().reset_index(drop=True)\n",
    "        self.feature_cols = feature_cols\n",
    "        self.target_col = target_col\n",
    "        self.results = {}\n",
    "        self.processed_data = {}\n",
    "        \n",
    "        # 验证输入\n",
    "        self._validate_input()\n",
    "        # 编码分类变量\n",
    "        self._encode_categorical()\n",
    "        # 检查缺失值\n",
    "        self._check_nan()\n",
    "        # 设置中文字体\n",
    "        self.font_prop = self._set_font()\n",
    "        \n",
    "    def _validate_input(self):\n",
    "        \"\"\"验证输入数据的完整性\"\"\"\n",
    "        missing_cols = set(self.feature_cols) - set(self.raw_df.columns)\n",
    "        if missing_cols:\n",
    "            raise ValueError(f\"特征列缺失: {missing_cols}\")\n",
    "        if self.target_col not in self.raw_df.columns:\n",
    "            raise ValueError(f\"目标列 {self.target_col} 不存在\")\n",
    "    \n",
    "    def _encode_categorical(self):\n",
    "        \"\"\"对分类变量进行编码\"\"\"\n",
    "        self.encoded_features = []\n",
    "        self.label_encoders = {}\n",
    "        \n",
    "        for col in self.feature_cols:\n",
    "            if col in self.raw_df.columns and self.raw_df[col].dtype == 'object':\n",
    "                le = LabelEncoder()\n",
    "                encoded_col = f\"{col}_encoded\"\n",
    "                self.raw_df[encoded_col] = le.fit_transform(self.raw_df[col])\n",
    "                self.encoded_features.append(encoded_col)\n",
    "                self.label_encoders[col] = le\n",
    "            else:\n",
    "                self.encoded_features.append(col)\n",
    "    \n",
    "    def _check_nan(self):\n",
    "        \"\"\"检查并处理缺失值\"\"\"\n",
    "        nan_in_target = self.raw_df[self.target_col].isna().any()\n",
    "        if nan_in_target:\n",
    "            nan_count = self.raw_df[self.target_col].isna().sum()\n",
    "            median_val = self.raw_df[self.target_col].median()\n",
    "            print(f\"⚠️ 警告: 目标列 {self.target_col} 包含 {nan_count} 个NaN值\")\n",
    "            self.raw_df[self.target_col].fillna(median_val, inplace=True)\n",
    "            print(f\"✓ 已用中位数 {median_val:.3f} 填充NaN\")\n",
    "    \n",
    "    def _set_font(self):\n",
    "        \"\"\"智能设置中文字体，适应不同操作系统\"\"\"\n",
    "        system = platform.system()\n",
    "        if system == 'Windows':\n",
    "            font_names = ['SimSun', 'SimSun', 'SimSun']\n",
    "        elif system == 'Darwin':  # macOS\n",
    "            font_names = ['Heiti TC', 'PingFang SC', 'STHeiti']\n",
    "        else:  # Linux\n",
    "            font_names = ['WenQuanYi Micro Hei', 'Noto Sans CJK SC']\n",
    "        \n",
    "        for font_name in font_names:\n",
    "            try:\n",
    "                font_path = findfont(FontProperties(family=font_name))\n",
    "                if font_path and font_path != 'DejaVuSans.ttf':\n",
    "                    plt.rcParams['font.sans-serif'] = [font_name]\n",
    "                    plt.rcParams['axes.unicode_minus'] = False\n",
    "                    return FontProperties(family=font_name)\n",
    "            except:\n",
    "                continue\n",
    "        \n",
    "        plt.rcParams['axes.unicode_minus'] = False\n",
    "        return FontProperties()\n",
    "    \n",
    "    # ==================== 模块1: 多策略重复数据处理 ====================\n",
    "    \n",
    "    def handle_duplicates_iqr(self, return_consensus=True):\n",
    "        \"\"\"\n",
    "        使用IQR方法处理重复数据\n",
    "        \n",
    "        参数:\n",
    "        - return_consensus: 是否返回共识值\n",
    "        \n",
    "        返回:\n",
    "        - 处理后的DataFrame\n",
    "        \"\"\"\n",
    "        df = self.raw_df.copy()\n",
    "        df['重复组ID'] = df.groupby(self.feature_cols).ngroup()\n",
    "        results = []\n",
    "        \n",
    "        for _, group in df.groupby(self.feature_cols):\n",
    "            if len(group) == 1:\n",
    "                results.append(group.iloc[0])\n",
    "                continue\n",
    "            \n",
    "            # 计算IQR\n",
    "            q1 = group[self.target_col].quantile(0.25)\n",
    "            q3 = group[self.target_col].quantile(0.75)\n",
    "            iqr = q3 - q1\n",
    "            lower = q1 - 1.5 * iqr\n",
    "            upper = q3 + 1.5 * iqr\n",
    "            \n",
    "            # 过滤异常值\n",
    "            clean_group = group[(group[self.target_col] >= lower) & \n",
    "                               (group[self.target_col] <= upper)]\n",
    "            \n",
    "            if len(clean_group) == 0:\n",
    "                clean_group = group\n",
    "            \n",
    "            if return_consensus:\n",
    "                row = clean_group.iloc[0].copy()\n",
    "                row[self.target_col] = clean_group[self.target_col].median()\n",
    "                results.append(row)\n",
    "            else:\n",
    "                results.extend(clean_group.to_dict('records'))\n",
    "        \n",
    "        result_df = pd.DataFrame(results)\n",
    "        self.results['IQR方法'] = result_df\n",
    "        print(f\"✓ IQR方法完成: {len(df)} → {len(result_df)} 行\")\n",
    "        return result_df\n",
    "    \n",
    "    def handle_duplicates_rf(self, threshold=2.0):\n",
    "        \"\"\"\n",
    "        使用随机森林方法处理重复数据\n",
    "        \n",
    "        参数:\n",
    "        - threshold: 异常值阈值\n",
    "        \n",
    "        返回:\n",
    "        - 处理后的DataFrame\n",
    "        \"\"\"\n",
    "        df = self.raw_df.copy()\n",
    "        \n",
    "        # 准备训练数据\n",
    "        X = df[self.encoded_features]\n",
    "        y = df[self.target_col]\n",
    "        X_train, X_val, y_train, y_val = train_test_split(\n",
    "            X, y, test_size=0.2, random_state=42\n",
    "        )\n",
    "        \n",
    "        # 训练随机森林\n",
    "        rf = RandomForestRegressor(\n",
    "            n_estimators=150, \n",
    "            min_samples_leaf=5, \n",
    "            n_jobs=-1, \n",
    "            random_state=42\n",
    "        )\n",
    "        rf.fit(X_train, y_train)\n",
    "        \n",
    "        # 计算异常阈值\n",
    "        y_pred_val = rf.predict(X_val)\n",
    "        residuals = np.abs(y_val - y_pred_val)\n",
    "        thresh = residuals.mean() + threshold * residuals.std()\n",
    "        \n",
    "        # 处理每个重复组\n",
    "        df['重复组ID'] = df.groupby(self.feature_cols).ngroup()\n",
    "        results = []\n",
    "        \n",
    "        for _, group in df.groupby(self.feature_cols):\n",
    "            if len(group) == 1:\n",
    "                results.append(group.iloc[0])\n",
    "                continue\n",
    "            \n",
    "            X_group = group[self.encoded_features]\n",
    "            y_pred = rf.predict(X_group)\n",
    "            group['残差'] = np.abs(group[self.target_col] - y_pred)\n",
    "            clean_group = group[group['残差'] <= thresh]\n",
    "            \n",
    "            if len(clean_group) == 0:\n",
    "                clean_group = group\n",
    "            \n",
    "            row = clean_group.iloc[0].copy()\n",
    "            row[self.target_col] = clean_group[self.target_col].median()\n",
    "            results.append(row)\n",
    "        \n",
    "        result_df = pd.DataFrame(results)\n",
    "        self.results['随机森林方法'] = result_df\n",
    "        print(f\"✓ 随机森林方法完成: {len(df)} → {len(result_df)} 行\")\n",
    "        return result_df\n",
    "    \n",
    "    def handle_duplicates_majority_vote(self):\n",
    "        \"\"\"使用多数投票法处理重复数据\"\"\"\n",
    "        df = self.raw_df.copy()\n",
    "        df['重复组ID'] = df.groupby(self.feature_cols).ngroup()\n",
    "        results = []\n",
    "        \n",
    "        for _, group in df.groupby(self.feature_cols):\n",
    "            if len(group) == 1:\n",
    "                results.append(group.iloc[0])\n",
    "                continue\n",
    "            \n",
    "            # 统计目标值频次\n",
    "            counts = group[self.target_col].value_counts()\n",
    "            max_count = counts.max()\n",
    "            candidates = counts[counts == max_count].index\n",
    "            \n",
    "            # 选择共识值\n",
    "            if len(candidates) > 1:\n",
    "                consensus = group[self.target_col].median()\n",
    "            else:\n",
    "                consensus = candidates[0]\n",
    "            \n",
    "            row = group.iloc[0].copy()\n",
    "            row[self.target_col] = consensus\n",
    "            results.append(row)\n",
    "        \n",
    "        result_df = pd.DataFrame(results)\n",
    "        self.results['多数投票法'] = result_df\n",
    "        print(f\"✓ 多数投票法完成: {len(df)} → {len(result_df)} 行\")\n",
    "        return result_df\n",
    "    \n",
    "    def handle_duplicates_composite_score(self, weights=None, time_col=None, decay=0.1):\n",
    "        \"\"\"\n",
    "        使用综合评分法处理重复数据\n",
    "        \n",
    "        参数:\n",
    "        - weights: 各评分的权重字典\n",
    "        - time_col: 时间列名称\n",
    "        - decay: 时间衰减系数\n",
    "        \n",
    "        返回:\n",
    "        - 处理后的DataFrame\n",
    "        \"\"\"\n",
    "        df = self.raw_df.copy()\n",
    "        df['重复组ID'] = df.groupby(self.feature_cols).ngroup()\n",
    "        \n",
    "        # 初始化评分列\n",
    "        score_cols = ['频率评分', '一致性评分', '完整性评分', '近期性评分', '综合评分']\n",
    "        df[score_cols] = 0.0\n",
    "        \n",
    "        for group_id in df['重复组ID'].unique():\n",
    "            group = df[df['重复组ID'] == group_id]\n",
    "            \n",
    "            if len(group) == 1:\n",
    "                df.loc[group.index, score_cols] = 1.0\n",
    "                continue\n",
    "            \n",
    "            # 计算各项评分\n",
    "            # 1. 频率评分\n",
    "            freq = group[self.target_col].value_counts(normalize=True)\n",
    "            df.loc[group.index, '频率评分'] = group[self.target_col].map(freq)\n",
    "            \n",
    "            # 2. 一致性评分\n",
    "            median_val = group[self.target_col].median()\n",
    "            value_range = group[self.target_col].max() - group[self.target_col].min() + 1e-8\n",
    "            df.loc[group.index, '一致性评分'] = 1 - (\n",
    "                np.abs(group[self.target_col] - median_val) / value_range\n",
    "            )\n",
    "            \n",
    "            # 3. 完整性评分\n",
    "            df.loc[group.index, '完整性评分'] = group.notna().mean(axis=1)\n",
    "            \n",
    "            # 4. 近期性评分\n",
    "            if time_col and time_col in group.columns:\n",
    "                max_time = group[time_col].max()\n",
    "                time_diff = (max_time - group[time_col]).dt.days\n",
    "                df.loc[group.index, '近期性评分'] = np.exp(-decay * time_diff)\n",
    "            else:\n",
    "                df.loc[group.index, '近期性评分'] = 0.5\n",
    "            \n",
    "            # 5. 综合评分\n",
    "            if weights:\n",
    "                for idx in group.index:\n",
    "                    df.loc[idx, '综合评分'] = sum(\n",
    "                        df.loc[idx, k] * v for k, v in weights.items()\n",
    "                    )\n",
    "            else:\n",
    "                df.loc[group.index, '综合评分'] = (\n",
    "                    0.4 * df.loc[group.index, '频率评分'] +\n",
    "                    0.3 * df.loc[group.index, '一致性评分'] +\n",
    "                    0.2 * df.loc[group.index, '完整性评分'] +\n",
    "                    0.1 * df.loc[group.index, '近期性评分']\n",
    "                )\n",
    "        \n",
    "        # 标记删除的数据\n",
    "        df['是否删除'] = df.groupby('重复组ID')['综合评分'].transform(\n",
    "            lambda x: x != x.max()\n",
    "        )\n",
    "        \n",
    "        processed_df = df[~df['是否删除']].drop(\n",
    "            columns=score_cols + ['是否删除'], errors='ignore'\n",
    "        )\n",
    "        \n",
    "        self.results['综合评分法'] = processed_df\n",
    "        self.before_with_marks = df  # 保留标记数据\n",
    "        print(f\"✓ 综合评分法完成: {len(df)} → {len(processed_df)} 行\")\n",
    "        return processed_df\n",
    "    \n",
    "    # ==================== 模块2: 差值计算与趋势分析 ====================\n",
    "    \n",
    "    def analyze_trends(self, general_filters=None, sort_columns=None, \n",
    "                      ascending_list=None, max_iterations=10):\n",
    "        \"\"\"\n",
    "        执行差值计算和趋势分析\n",
    "        \n",
    "        参数:\n",
    "        - general_filters: 筛选条件字典\n",
    "        - sort_columns: 排序列列表\n",
    "        - ascending_list: 排序方向列表\n",
    "        - max_iterations: 最大迭代次数\n",
    "        \n",
    "        返回:\n",
    "        - 趋势分析后的DataFrame\n",
    "        \"\"\"\n",
    "        df = self.raw_df.copy()\n",
    "        \n",
    "        # 应用筛选条件\n",
    "        if general_filters:\n",
    "            for col, val in general_filters.items():\n",
    "                if col in df.columns:\n",
    "                    df = df[df[col] == val].copy()\n",
    "        \n",
    "        if sort_columns is None:\n",
    "            sort_columns = self.feature_cols\n",
    "        \n",
    "        if ascending_list is None:\n",
    "            ascending_list = [True] * len(sort_columns)\n",
    "        \n",
    "        # 排序并去重\n",
    "        df_sorted = df.sort_values(\n",
    "            by=sort_columns + [self.target_col],\n",
    "            ascending=ascending_list + [True]\n",
    "        ).reset_index(drop=True)\n",
    "        \n",
    "        df_sorted = df_sorted.drop_duplicates(\n",
    "            subset=sort_columns, \n",
    "            keep='first'\n",
    "        ).reset_index(drop=True)\n",
    "        \n",
    "        # 添加差值列\n",
    "        df_sorted['因变量差值'] = 0.0\n",
    "        df_sorted['自变量差值'] = 0.0\n",
    "        df_sorted['相对变化率'] = 0.0\n",
    "        df_sorted['组号'] = 0\n",
    "        \n",
    "        # 迭代优化\n",
    "        for iteration in range(max_iterations):\n",
    "            prev_len = len(df_sorted)\n",
    "            \n",
    "            # 计算差值\n",
    "            df_sorted = self._calculate_differences(df_sorted, sort_columns)\n",
    "            \n",
    "            # 分组处理\n",
    "            df_sorted = self._assign_groups(df_sorted, sort_columns)\n",
    "            \n",
    "            # 趋势分析\n",
    "            df_sorted = self._analyze_group_trends(df_sorted)\n",
    "            \n",
    "            # 异常值处理\n",
    "            df_sorted = self._handle_outliers(df_sorted)\n",
    "            \n",
    "            # 检查收敛\n",
    "            if len(df_sorted) == prev_len:\n",
    "                print(f\"✓ 趋势分析在第 {iteration + 1} 次迭代后收敛\")\n",
    "                break\n",
    "        \n",
    "        self.processed_data['趋势分析结果'] = df_sorted\n",
    "        return df_sorted\n",
    "    \n",
    "    def _calculate_differences(self, df, sort_columns):\n",
    "        \"\"\"计算相邻数据点的差值\"\"\"\n",
    "        for i in range(len(df) - 1):\n",
    "            # 检查是否为同组数据\n",
    "            same_group = all(\n",
    "                df.iloc[i][col] == df.iloc[i + 1][col] \n",
    "                for col in sort_columns[:-1]\n",
    "            )\n",
    "            \n",
    "            if same_group:\n",
    "                # 计算差值\n",
    "                target_diff = (df.iloc[i + 1][self.target_col] / \n",
    "                             df.iloc[i][self.target_col]) * 100\n",
    "                df.iloc[i + 1, df.columns.get_loc('因变量差值')] = target_diff\n",
    "                \n",
    "                # 计算自变量差值\n",
    "                last_col = sort_columns[-1]\n",
    "                if last_col in df.columns:\n",
    "                    var_diff = df.iloc[i + 1][last_col] - df.iloc[i][last_col]\n",
    "                    df.iloc[i + 1, df.columns.get_loc('自变量差值')] = var_diff\n",
    "            else:\n",
    "                df.iloc[i + 1, df.columns.get_loc('因变量差值')] = 0\n",
    "                df.iloc[i + 1, df.columns.get_loc('自变量差值')] = 0\n",
    "        \n",
    "        return df\n",
    "    \n",
    "    def _assign_groups(self, df, sort_columns):\n",
    "        \"\"\"为数据分配组号\"\"\"\n",
    "        group_num = 1\n",
    "        df.iloc[0, df.columns.get_loc('组号')] = group_num\n",
    "        \n",
    "        for i in range(1, len(df)):\n",
    "            # 检查是否为新组\n",
    "            new_group = any(\n",
    "                df.iloc[i][col] != df.iloc[i - 1][col] \n",
    "                for col in sort_columns[:-1]\n",
    "            )\n",
    "            \n",
    "            if new_group:\n",
    "                group_num += 1\n",
    "            \n",
    "            df.iloc[i, df.columns.get_loc('组号')] = group_num\n",
    "        \n",
    "        return df\n",
    "    \n",
    "    def _analyze_group_trends(self, df):\n",
    "        \"\"\"分析每个组的趋势\"\"\"\n",
    "        for group_id in df['组号'].unique():\n",
    "            group = df[df['组号'] == group_id]\n",
    "            \n",
    "            if len(group) > 1:\n",
    "                # 计算趋势指标\n",
    "                pos_count = len(group[group['因变量差值'] > 100])\n",
    "                neg_count = len(group[(group['因变量差值'] < 100) & \n",
    "                                    (group['因变量差值'] > 0)])\n",
    "                zero_count = len(group[group['因变量差值'] == 0])\n",
    "                \n",
    "                # 标记主要趋势\n",
    "                if pos_count > neg_count:\n",
    "                    trend = '上升'\n",
    "                elif neg_count > pos_count:\n",
    "                    trend = '下降'\n",
    "                else:\n",
    "                    trend = '平稳'\n",
    "                \n",
    "                # 删除不符合趋势的数据点\n",
    "                if trend == '上升':\n",
    "                    df = df[~((df['组号'] == group_id) & \n",
    "                            (df['因变量差值'] < 100) & \n",
    "                            (df['因变量差值'] > 0))]\n",
    "                elif trend == '下降':\n",
    "                    df = df[~((df['组号'] == group_id) & \n",
    "                            (df['因变量差值'] > 100))]\n",
    "        \n",
    "        return df\n",
    "    \n",
    "    def _handle_outliers(self, df):\n",
    "        \"\"\"处理异常值\"\"\"\n",
    "        # 基于相对变化率处理异常值\n",
    "        for group_id in df['组号'].unique():\n",
    "            group = df[df['组号'] == group_id]\n",
    "            \n",
    "            if len(group) > 2:\n",
    "                # 计算组内变化率的统计指标\n",
    "                mean_change = group['因变量差值'].mean()\n",
    "                std_change = group['因变量差值'].std()\n",
    "                \n",
    "                # 标记异常值（3倍标准差之外）\n",
    "                if std_change > 0:\n",
    "                    lower_bound = mean_change - 3 * std_change\n",
    "                    upper_bound = mean_change + 3 * std_change\n",
    "                    \n",
    "                    df = df[~((df['组号'] == group_id) & \n",
    "                            ((df['因变量差值'] < lower_bound) | \n",
    "                             (df['因变量差值'] > upper_bound)))]\n",
    "        \n",
    "        return df.reset_index(drop=True)\n",
    "    \n",
    "    # ==================== 模块3: 可视化功能 ====================\n",
    "    \n",
    "    def visualize_duplicate_groups(self, independent_var=None, \n",
    "                                  max_groups_to_show=5, figsize=(12, 8)):\n",
    "        \"\"\"\n",
    "        可视化重复数据组的处理过程\n",
    "        \n",
    "        参数:\n",
    "        - independent_var: 自变量列名\n",
    "        - max_groups_to_show: 最多显示的组数\n",
    "        - figsize: 图形尺寸\n",
    "        \"\"\"\n",
    "        df = self.raw_df.copy()\n",
    "        \n",
    "        # 确定自变量\n",
    "        if independent_var is None:\n",
    "            independent_var = self.feature_cols[-1]\n",
    "        \n",
    "        # 按特征列分组\n",
    "        groups = df.groupby(self.feature_cols[:-1])\n",
    "        duplicate_groups = [(name, group) for name, group in groups if len(group) > 1]\n",
    "        \n",
    "        if len(duplicate_groups) == 0:\n",
    "            print(\"没有发现重复数据组\")\n",
    "            return\n",
    "        \n",
    "        print(f\"发现 {len(duplicate_groups)} 个重复数据组\")\n",
    "        \n",
    "        # 显示每个重复组\n",
    "        for idx, (group_key, group_data) in enumerate(duplicate_groups[:max_groups_to_show]):\n",
    "            self._plot_single_group(\n",
    "                group_data, group_key, independent_var, \n",
    "                idx + 1, len(duplicate_groups), figsize\n",
    "            )\n",
    "    \n",
    "    def _plot_single_group(self, group_data, group_key, independent_var, \n",
    "                          group_num, total_groups, figsize):\n",
    "        \"\"\"绘制单个重复组的可视化\"\"\"\n",
    "        fig, ax = plt.subplots(figsize=figsize)\n",
    "        sns.set_style('whitegrid')\n",
    "        \n",
    "        # 获取最大值作为阈值\n",
    "        max_val = group_data[self.target_col].max()\n",
    "        min_val = group_data[self.target_col].min()\n",
    "        \n",
    "        # 绘制阈值线\n",
    "        ax.axhline(y=max_val, color='blue', linestyle='--', \n",
    "                  linewidth=2, alpha=0.6, \n",
    "                  label=f'最大{self.target_col}阈值: {max_val:.3f}')\n",
    "        \n",
    "        # 填充删除区域\n",
    "        ax.fill_between([group_data[independent_var].min() - 1, \n",
    "                        group_data[independent_var].max() + 1],\n",
    "                       [min_val - 1, min_val - 1],\n",
    "                       [max_val, max_val],\n",
    "                       alpha=0.1, color='red', label='删除区域')\n",
    "        \n",
    "        # 标记保留和删除的点\n",
    "        kept_idx = group_data[self.target_col].idxmax()\n",
    "        kept_data = group_data.loc[[kept_idx]]\n",
    "        removed_data = group_data.drop(kept_idx)\n",
    "        \n",
    "        # 绘制数据点\n",
    "        ax.scatter(kept_data[independent_var], kept_data[self.target_col],\n",
    "                  c='green', marker='o', s=300, alpha=0.9,\n",
    "                  edgecolors='darkgreen', linewidth=3, label='保留数据', zorder=5)\n",
    "        \n",
    "        if not removed_data.empty:\n",
    "            ax.scatter(removed_data[independent_var], removed_data[self.target_col],\n",
    "                      c='red', marker='x', s=200, alpha=0.7, \n",
    "                      linewidth=3, label='删除数据', zorder=4)\n",
    "        \n",
    "        # 添加标注\n",
    "        for idx, row in group_data.iterrows():\n",
    "            if idx == kept_idx:\n",
    "                reason = f'保留(最大值)\\n{self.target_col}={row[self.target_col]:.3f}'\n",
    "                bbox_props = dict(boxstyle=\"round,pad=0.4\", \n",
    "                                 facecolor='lightgreen',\n",
    "                                 edgecolor='darkgreen', alpha=0.8)\n",
    "            else:\n",
    "                reason = f'删除\\n{self.target_col}={row[self.target_col]:.3f}'\n",
    "                bbox_props = dict(boxstyle=\"round,pad=0.4\", \n",
    "                                 facecolor='lightcoral',\n",
    "                                 edgecolor='darkred', alpha=0.8)\n",
    "            \n",
    "            ax.annotate(reason,\n",
    "                       xy=(row[independent_var], row[self.target_col]),\n",
    "                       xytext=(row[independent_var] + 0.5, row[self.target_col] + 0.05),\n",
    "                       fontproperties=self.font_prop, fontsize=10,\n",
    "                       bbox=bbox_props,\n",
    "                       arrowprops=dict(arrowstyle='->', \n",
    "                                     connectionstyle='arc3,rad=0.3',\n",
    "                                     alpha=0.6, linewidth=1.5))\n",
    "        \n",
    "        # 设置标题和标签\n",
    "        if isinstance(group_key, tuple):\n",
    "            group_identifier = ', '.join([f'{col}={val}' \n",
    "                                        for col, val in zip(self.feature_cols[:-1], group_key)])\n",
    "        else:\n",
    "            group_identifier = f'{self.feature_cols[0]}={group_key}'\n",
    "        \n",
    "        ax.set_title(f'重复组 {group_num}/{total_groups}: {group_identifier}',\n",
    "                    fontproperties=self.font_prop, fontsize=14)\n",
    "        ax.set_xlabel(f'{independent_var} (自变量)', \n",
    "                     fontproperties=self.font_prop, fontsize=12)\n",
    "        ax.set_ylabel(f'{self.target_col} (目标变量)', \n",
    "                     fontproperties=self.font_prop, fontsize=12)\n",
    "        \n",
    "        # 添加网格和图例\n",
    "        ax.grid(True, linestyle='--', alpha=0.3)\n",
    "        ax.legend(prop=self.font_prop, loc='best')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "    \n",
    "    # ==================== 模块4: 科学绘图系统 ====================\n",
    "    \n",
    "    def create_scientific_plots(self, x_params=None, y_param='因变量差值',\n",
    "                               color_param=None, filter_params=None,\n",
    "                               subplot_layout=(2, 2), figsize=None,\n",
    "                               colormap='viridis'):\n",
    "        \"\"\"\n",
    "        创建科学论文级别的多维度可视化图表\n",
    "        \n",
    "        参数:\n",
    "        - x_params: X轴参数列表\n",
    "        - y_param: Y轴参数\n",
    "        - color_param: 颜色映射参数\n",
    "        - filter_params: 筛选参数字典\n",
    "        - subplot_layout: 子图布局(行数, 列数)\n",
    "        - figsize: 图形尺寸\n",
    "        - colormap: 颜色映射类型\n",
    "        \"\"\"\n",
    "        # 参数默认值设置\n",
    "        if x_params is None:\n",
    "            x_params = [self.feature_cols[-1]]\n",
    "        \n",
    "        if color_param is None:\n",
    "            color_param = self.feature_cols[0]\n",
    "        \n",
    "        if figsize is None:\n",
    "            figsize = (subplot_layout[1] * 5, subplot_layout[0] * 4)\n",
    "        \n",
    "        # 准备数据\n",
    "        df_plot = self.raw_df.copy()\n",
    "        \n",
    "        # 应用筛选\n",
    "        if filter_params:\n",
    "            for col, val in filter_params.items():\n",
    "                if col in df_plot.columns:\n",
    "                    df_plot = df_plot[df_plot[col] == val]\n",
    "        \n",
    "        # 创建图形\n",
    "        fig = plt.figure(figsize=figsize)\n",
    "        plt.rcParams['font.family'] = 'Times New Roman'\n",
    "        plt.rcParams['xtick.direction'] = 'in'\n",
    "        plt.rcParams['ytick.direction'] = 'in'\n",
    "        \n",
    "        # 获取颜色映射范围\n",
    "        vmin = df_plot[color_param].min()\n",
    "        vmax = df_plot[color_param].max()\n",
    "        norm = Normalize(vmin=vmin, vmax=vmax)\n",
    "        sm = cm.ScalarMappable(norm=norm, cmap=colormap)\n",
    "        \n",
    "        # 创建子图\n",
    "        for idx, x_param in enumerate(x_params):\n",
    "            if idx >= subplot_layout[0] * subplot_layout[1]:\n",
    "                break\n",
    "            \n",
    "            ax = plt.subplot(subplot_layout[0], subplot_layout[1], idx + 1)\n",
    "            \n",
    "            # 绘制散点图\n",
    "            scatter = ax.scatter(\n",
    "                df_plot[x_param],\n",
    "                df_plot[y_param] if y_param in df_plot.columns else df_plot[self.target_col],\n",
    "                c=df_plot[color_param],\n",
    "                cmap=colormap,\n",
    "                vmin=vmin,\n",
    "                vmax=vmax,\n",
    "                s=50,\n",
    "                alpha=0.7\n",
    "            )\n",
    "            \n",
    "            # 添加趋势线\n",
    "            if len(df_plot) > 1:\n",
    "                z = np.polyfit(df_plot[x_param], \n",
    "                             df_plot[y_param] if y_param in df_plot.columns else df_plot[self.target_col], \n",
    "                             1)\n",
    "                p = np.poly1d(z)\n",
    "                x_trend = np.linspace(df_plot[x_param].min(), \n",
    "                                    df_plot[x_param].max(), 100)\n",
    "                ax.plot(x_trend, p(x_trend), \"r--\", alpha=0.5, label='趋势线')\n",
    "            \n",
    "            # 设置标签\n",
    "            ax.set_xlabel(f'{x_param}', fontsize=11)\n",
    "            ax.set_ylabel(y_param if y_param in df_plot.columns else self.target_col, \n",
    "                         fontsize=11)\n",
    "            ax.set_title(f'{x_param} vs {y_param}', fontsize=12)\n",
    "            \n",
    "            # 添加网格\n",
    "            ax.grid(True, linestyle='--', alpha=0.3)\n",
    "            ax.minorticks_on()\n",
    "            \n",
    "            # 添加颜色条（仅在第一个子图）\n",
    "            if idx == 0:\n",
    "                divider = make_axes_locatable(ax)\n",
    "                cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n",
    "                plt.colorbar(sm, cax=cax)\n",
    "                cax.set_ylabel(color_param, fontsize=10)\n",
    "        \n",
    "        plt.suptitle('多维度数据分析', fontproperties=self.font_prop, fontsize=14)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "    \n",
    "    # ==================== 数据导出功能 ====================\n",
    "    \n",
    "    def export_comprehensive_report(self, filename='comprehensive_analysis.xlsx',\n",
    "                                   include_visualizations=True):\n",
    "        \"\"\"\n",
    "        导出综合分析报告到Excel\n",
    "        \n",
    "        参数:\n",
    "        - filename: 输出文件名\n",
    "        - include_visualizations: 是否包含可视化说明\n",
    "        \"\"\"\n",
    "        with pd.ExcelWriter(filename, engine='openpyxl') as writer:\n",
    "            # 1. 总览信息\n",
    "            summary_data = {\n",
    "                '分析项目': [],\n",
    "                '原始数据量': [],\n",
    "                '处理后数据量': [],\n",
    "                '处理方法': [],\n",
    "                '关键发现': []\n",
    "            }\n",
    "            \n",
    "            # 填充总览数据\n",
    "            for method_name, result_df in self.results.items():\n",
    "                summary_data['分析项目'].append(method_name)\n",
    "                summary_data['原始数据量'].append(len(self.raw_df))\n",
    "                summary_data['处理后数据量'].append(len(result_df))\n",
    "                summary_data['处理方法'].append(method_name)\n",
    "                \n",
    "                # 计算关键指标\n",
    "                reduction_rate = (1 - len(result_df) / len(self.raw_df)) * 100\n",
    "                summary_data['关键发现'].append(f'数据减少{reduction_rate:.1f}%')\n",
    "            \n",
    "            summary_df = pd.DataFrame(summary_data)\n",
    "            summary_df.to_excel(writer, sheet_name='分析总览', index=False)\n",
    "            \n",
    "            # 2. 原始数据\n",
    "            self.raw_df.to_excel(writer, sheet_name='原始数据', index=False)\n",
    "            \n",
    "            # 3. 各方法处理结果\n",
    "            for method_name, result_df in self.results.items():\n",
    "                sheet_name = method_name[:31]  # Excel工作表名称限制\n",
    "                result_df.to_excel(writer, sheet_name=sheet_name, index=False)\n",
    "            \n",
    "            # 4. 趋势分析结果\n",
    "            for data_name, data_df in self.processed_data.items():\n",
    "                sheet_name = data_name[:31]\n",
    "                data_df.to_excel(writer, sheet_name=sheet_name, index=False)\n",
    "            \n",
    "            # 5. 数据质量报告\n",
    "            quality_report = self._generate_quality_report()\n",
    "            quality_report.to_excel(writer, sheet_name='数据质量报告', index=False)\n",
    "            \n",
    "            # 6. 参数配置记录\n",
    "            config_data = {\n",
    "                '参数名称': ['特征列', '目标列', '数据行数', '数据列数'],\n",
    "                '参数值': [\n",
    "                    str(self.feature_cols),\n",
    "                    self.target_col,\n",
    "                    len(self.raw_df),\n",
    "                    len(self.raw_df.columns)\n",
    "                ]\n",
    "            }\n",
    "            config_df = pd.DataFrame(config_data)\n",
    "            config_df.to_excel(writer, sheet_name='配置参数', index=False)\n",
    "            \n",
    "            # 7. 方法比较\n",
    "            if len(self.results) > 1:\n",
    "                comparison_df = self._compare_methods()\n",
    "                comparison_df.to_excel(writer, sheet_name='方法比较', index=False)\n",
    "        \n",
    "        print(f\"✅ 综合分析报告已导出至: {filename}\")\n",
    "        self._print_report_structure(filename)\n",
    "    \n",
    "    def _generate_quality_report(self):\n",
    "        \"\"\"生成数据质量报告\"\"\"\n",
    "        report_data = {\n",
    "            '指标': [],\n",
    "            '原始数据': [],\n",
    "            '处理后数据': []\n",
    "        }\n",
    "        \n",
    "        # 计算各项质量指标\n",
    "        metrics = [\n",
    "            ('缺失值比例', lambda df: (df.isna().sum().sum() / df.size) * 100),\n",
    "            ('重复值比例', lambda df: (df.duplicated().sum() / len(df)) * 100),\n",
    "            ('异常值比例', lambda df: self._calculate_outlier_ratio(df)),\n",
    "            ('数据完整性', lambda df: (1 - df.isna().sum().sum() / df.size) * 100)\n",
    "        ]\n",
    "        \n",
    "        for metric_name, metric_func in metrics:\n",
    "            report_data['指标'].append(metric_name)\n",
    "            report_data['原始数据'].append(f\"{metric_func(self.raw_df):.2f}%\")\n",
    "            \n",
    "            # 使用第一个处理结果作为代表\n",
    "            if self.results:\n",
    "                first_result = list(self.results.values())[0]\n",
    "                report_data['处理后数据'].append(f\"{metric_func(first_result):.2f}%\")\n",
    "            else:\n",
    "                report_data['处理后数据'].append('N/A')\n",
    "        \n",
    "        return pd.DataFrame(report_data)\n",
    "    \n",
    "    def _calculate_outlier_ratio(self, df):\n",
    "        \"\"\"计算异常值比例\"\"\"\n",
    "        numeric_cols = df.select_dtypes(include=[np.number]).columns\n",
    "        total_outliers = 0\n",
    "        \n",
    "        for col in numeric_cols:\n",
    "            Q1 = df[col].quantile(0.25)\n",
    "            Q3 = df[col].quantile(0.75)\n",
    "            IQR = Q3 - Q1\n",
    "            outliers = ((df[col] < Q1 - 1.5 * IQR) | \n",
    "                       (df[col] > Q3 + 1.5 * IQR)).sum()\n",
    "            total_outliers += outliers\n",
    "        \n",
    "        return (total_outliers / (len(df) * len(numeric_cols))) * 100\n",
    "    \n",
    "    def _compare_methods(self):\n",
    "        \"\"\"比较不同处理方法的效果\"\"\"\n",
    "        comparison_data = {\n",
    "            '方法名称': [],\n",
    "            '保留数据量': [],\n",
    "            '数据保留率': [],\n",
    "            '目标值均值': [],\n",
    "            '目标值标准差': [],\n",
    "            '处理时间': []\n",
    "        }\n",
    "        \n",
    "        for method_name, result_df in self.results.items():\n",
    "            comparison_data['方法名称'].append(method_name)\n",
    "            comparison_data['保留数据量'].append(len(result_df))\n",
    "            comparison_data['数据保留率'].append(\n",
    "                f\"{(len(result_df) / len(self.raw_df)) * 100:.1f}%\"\n",
    "            )\n",
    "            comparison_data['目标值均值'].append(\n",
    "                f\"{result_df[self.target_col].mean():.3f}\"\n",
    "            )\n",
    "            comparison_data['目标值标准差'].append(\n",
    "                f\"{result_df[self.target_col].std():.3f}\"\n",
    "            )\n",
    "            comparison_data['处理时间'].append('< 1s')  # 示例值\n",
    "        \n",
    "        return pd.DataFrame(comparison_data)\n",
    "    \n",
    "    def _print_report_structure(self, filename):\n",
    "        \"\"\"打印报告结构说明\"\"\"\n",
    "        print(\"\\n📊 报告结构:\")\n",
    "        print(\"├── 分析总览: 各方法处理效果概览\")\n",
    "        print(\"├── 原始数据: 未处理的原始数据集\")\n",
    "        \n",
    "        for method_name in self.results.keys():\n",
    "            print(f\"├── {method_name}: 处理后的数据\")\n",
    "        \n",
    "        for data_name in self.processed_data.keys():\n",
    "            print(f\"├── {data_name}: 分析结果数据\")\n",
    "        \n",
    "        print(\"├── 数据质量报告: 处理前后质量对比\")\n",
    "        print(\"├── 配置参数: 分析使用的参数记录\")\n",
    "        \n",
    "        if len(self.results) > 1:\n",
    "            print(\"└── 方法比较: 不同方法效果对比\")\n",
    "        else:\n",
    "            print(\"└── [单一方法，无比较数据]\")\n",
    "    \n",
    "    # ==================== 主执行函数 ====================\n",
    "    \n",
    "    def run_complete_analysis(self, \n",
    "                            methods=['iqr', 'rf', 'majority', 'composite'],\n",
    "                            visualize=True,\n",
    "                            export_report=True,\n",
    "                            report_filename='complete_analysis.xlsx'):\n",
    "        \"\"\"\n",
    "        执行完整的数据分析流程\n",
    "        \n",
    "        参数:\n",
    "        - methods: 要使用的去重方法列表\n",
    "        - visualize: 是否生成可视化\n",
    "        - export_report: 是否导出报告\n",
    "        - report_filename: 报告文件名\n",
    "        \n",
    "        返回:\n",
    "        - 处理结果字典\n",
    "        \"\"\"\n",
    "        print(\"=\" * 60)\n",
    "        print(\"开始执行综合数据分析...\")\n",
    "        print(\"=\" * 60)\n",
    "        \n",
    "        # 1. 执行各种去重方法\n",
    "        print(\"\\n📌 步骤1: 多策略重复数据处理\")\n",
    "        print(\"-\" * 40)\n",
    "        \n",
    "        if 'iqr' in methods:\n",
    "            self.handle_duplicates_iqr()\n",
    "        \n",
    "        if 'rf' in methods:\n",
    "            self.handle_duplicates_rf()\n",
    "        \n",
    "        if 'majority' in methods:\n",
    "            self.handle_duplicates_majority_vote()\n",
    "        \n",
    "        if 'composite' in methods:\n",
    "            self.handle_duplicates_composite_score()\n",
    "        \n",
    "        # 2. 趋势分析\n",
    "        print(\"\\n📌 步骤2: 趋势分析\")\n",
    "        print(\"-\" * 40)\n",
    "        trend_result = self.analyze_trends()\n",
    "        \n",
    "        # 3. 可视化\n",
    "        if visualize:\n",
    "            print(\"\\n📌 步骤3: 生成可视化\")\n",
    "            print(\"-\" * 40)\n",
    "            \n",
    "            # 重复组可视化\n",
    "            self.visualize_duplicate_groups(max_groups_to_show=3)\n",
    "            \n",
    "            # 科学绘图\n",
    "            self.create_scientific_plots(\n",
    "                x_params=self.feature_cols[-2:],\n",
    "                subplot_layout=(1, 2)\n",
    "            )\n",
    "        \n",
    "        # 4. 导出报告\n",
    "        if export_report:\n",
    "            print(\"\\n📌 步骤4: 导出分析报告\")\n",
    "            print(\"-\" * 40)\n",
    "            self.export_comprehensive_report(report_filename)\n",
    "        \n",
    "        print(\"\\n\" + \"=\" * 60)\n",
    "        print(\"✅ 综合数据分析完成!\")\n",
    "        print(\"=\" * 60)\n",
    "        \n",
    "        # 打印结果摘要\n",
    "        self._print_analysis_summary()\n",
    "        \n",
    "        return self.results\n",
    "    \n",
    "    def _print_analysis_summary(self):\n",
    "        \"\"\"打印分析结果摘要\"\"\"\n",
    "        print(\"\\n📊 分析结果摘要:\")\n",
    "        print(\"-\" * 40)\n",
    "        \n",
    "        # 原始数据信息\n",
    "        print(f\"原始数据: {len(self.raw_df)} 行 × {len(self.raw_df.columns)} 列\")\n",
    "        \n",
    "        # 各方法结果\n",
    "        if self.results:\n",
    "            print(\"\\n各方法处理结果:\")\n",
    "            for method_name, result_df in self.results.items():\n",
    "                reduction = (1 - len(result_df) / len(self.raw_df)) * 100\n",
    "                print(f\"  • {method_name}: {len(result_df)} 行 (减少 {reduction:.1f}%)\")\n",
    "        \n",
    "        # 数据质量改善\n",
    "        print(f\"\\n目标变量 '{self.target_col}' 统计:\")\n",
    "        print(f\"  • 原始均值: {self.raw_df[self.target_col].mean():.3f}\")\n",
    "        print(f\"  • 原始标准差: {self.raw_df[self.target_col].std():.3f}\")\n",
    "        \n",
    "        if self.results:\n",
    "            first_result = list(self.results.values())[0]\n",
    "            print(f\"  • 处理后均值: {first_result[self.target_col].mean():.3f}\")\n",
    "            print(f\"  • 处理后标准差: {first_result[self.target_col].std():.3f}\")\n",
    "\n",
    "\n",
    "# ==================== 使用示例 ====================\n",
    "\n",
    "def main_example():\n",
    "    \"\"\"\n",
    "    综合数据处理系统使用示例\n",
    "    \"\"\"\n",
    "    print(\"🚀 综合数据处理与可视化系统示例\")\n",
    "    print(\"=\" * 60)\n",
    " \n",
    "    # 定义特征列和目标列\n",
    "    feature_cols = ['H', 'B', 'T1', 'T2', 'n', 'F', 'pbol']\n",
    "    target_col = 'SFcf2f'\n",
    "    df=df_all_dic.copy()\n",
    "    general_list       =['yfss','Imperfectfactor','meshsz', 'L','sfricn','cf1f', 'cf2f', 'cf3f','type']# 筛选基础数据用的list_分离面内\n",
    "    general_list_number=[355.61,     0.002       , 40     ,3000,0.35,0.0   ,1.0     ,0.0   ,2]# 面内受剪_分离面内\n",
    "    for i in range (0,len(general_list)):\n",
    "        df=df[df[general_list[i]]==general_list_number[i]].copy()\n",
    "        print(len(df),'len')\n",
    "    display(df)  \n",
    "    # 定义df_6并保存\n",
    "    df_6 = df  # 这里是你需要保存的df_6\n",
    "    # 保存为pickle文件（推荐，保留数据类型）\n",
    "    df_6.to_pickle('df_6.pkl')  # 保存到当前目录，文件名可自定义\n",
    "    print(f\"✅ df_6已保存至: {os.path.abspath('df_6.pkl')}\")  # 显示保存路径\n",
    "    # 创建处理器实例\n",
    "    processor = IntegratedDataProcessor(\n",
    "        df=df,\n",
    "        feature_cols=feature_cols,\n",
    "        target_col=target_col\n",
    "    )\n",
    "    \n",
    "    # 运行完整分析\n",
    "    results = processor.run_complete_analysis(\n",
    "        methods=['iqr', 'rf', 'majority', 'composite'],\n",
    "        visualize=True,\n",
    "        export_report=True,\n",
    "        report_filename='综合分析报告_示例.xlsx'\n",
    "    )\n",
    "    \n",
    "    return processor, results\n",
    "\n",
    "\n",
    "# 如果直接运行此文件\n",
    "if __name__ == \"__main__\":\n",
    "    # 运行示例\n",
    "    processor, results = main_example()\n",
    "    \n",
    "    print(\"\\n\" + \"=\" * 60)\n",
    "    print(\"💡 提示:\")\n",
    "    print(\"1. 请将示例数据替换为您的实际数据\")\n",
    "    print(\"2. 根据需要调整特征列和目标列\")\n",
    "    print(\"3. 可以选择性地启用不同的处理方法\")\n",
    "    print(\"4. 查看生成的Excel报告了解详细结果\")\n",
    "    print(\"=\" * 60)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "2718ec1c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "已加载df_6，数据量: 2891\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# 加载保存的df_6\n",
    "df_6 = pd.read_pickle('df_6.pkl')  # 路径需与保存时一致\n",
    "print(\"已加载df_6，数据量:\", len(df_6))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "456c26ee",
   "metadata": {},
   "source": [
    "#### 作图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "102a51c3",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.197979Z",
     "start_time": "2023-12-27T12:36:54.197979Z"
    }
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'sort_list' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[33], line 125\u001b[0m\n\u001b[0;32m    116\u001b[0m colorltype\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mstr\u001b[39m(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mviridis\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\u001b[0;32m    117\u001b[0m \u001b[38;5;66;03m# prelist=list(df['KG_quge_web'].sort_values().unique())\u001b[39;00m\n\u001b[0;32m    118\u001b[0m \u001b[38;5;66;03m# 筛选\u001b[39;00m\n\u001b[0;32m    119\u001b[0m \u001b[38;5;66;03m# para_without_para=str('F')\u001b[39;00m\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    123\u001b[0m \u001b[38;5;66;03m# 图内分类型参数（变色或者变形状）\u001b[39;00m\n\u001b[0;32m    124\u001b[0m \u001b[38;5;66;03m# div_colandlegend_para_list=['L']\u001b[39;00m\n\u001b[1;32m--> 125\u001b[0m div_colandlegend_para_list\u001b[38;5;241m=\u001b[39m\u001b[43msort_list\u001b[49m[\u001b[38;5;28mlen\u001b[39m(sort_list)\u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m]\n\u001b[0;32m    126\u001b[0m \u001b[38;5;66;03m# ['KG_quge_web','KH_quge_web','KG_consedge_flange','KH_consedge_flange']\u001b[39;00m\n\u001b[0;32m    127\u001b[0m \u001b[38;5;66;03m# div_colandlegend_para_list=df.columns\u001b[39;00m\n\u001b[0;32m    128\u001b[0m \u001b[38;5;66;03m# div_colandlegend_para_list=['KG_quge_web']\u001b[39;00m\n\u001b[0;32m    129\u001b[0m \u001b[38;5;66;03m# div_colandlegend_para=str('KG_total_web')['B', 'H','L', 'T1', 'T2', 'n']\u001b[39;00m\n\u001b[0;32m    130\u001b[0m \u001b[38;5;66;03m# # x_轴\u001b[39;00m\n\u001b[0;32m    131\u001b[0m x_aixs_paralist\u001b[38;5;241m=\u001b[39m[zi_ori]\n",
      "\u001b[1;31mNameError\u001b[0m: name 'sort_list' is not defined"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAiMAAAGdCAYAAADAAnMpAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAGrRJREFUeJzt3WFsXeVhx+G/IxxfKvkaEqcqLhZuozR8mGhh4BapEi6EKTCtjKnV1KpMohSNpMvIoorGjKlb8ZowItp+oDFDWgVTSURhHwJVRdRSp9rQ4iGRaoI2QNaIJK4oLJmNw2qTcPeh9RVeEuqbXPt1neeRrpJzeO/JG70y55dzj49barVaLQAAhSwqPQEA4OwmRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKJOK0a+//3vp7e3N/v37z/lmB07duT222/Pbbfdlh/84AenOz8AYIE7p9E3/PKXv8yxY8fyH//xH6cc87Of/SwDAwPZvXt3arVaLr/88jzxxBN5//vff0aTBQAWnoavjLz3ve/NH/7hH77rmG984xtZvXp1WlpasmjRolx55ZXZunXraU8SAFi4Gr4ykiSLFr17wzz99NP58pe/XN9esWJFHn/88RPGvf3229m/f39aW1vT0tJS39/W1pa2trbTmRoA0GQTExOZmJiob9dqtbz11lvp6en5rU0wE6cVI7/NoUOHsmTJkvp2e3t7RkZGThi3f//+LF++fDamAADMsn379uWDH/zgGR9nVmKkpaUllUqlvj05OZnW1tYTxk3tGx4ezgUXXFDf78pIGWNjY+nu7s6BAwdSrVZLT+esZi3mD2sxf1iLcv7/lZFf/OIX6e3tPem5/XTMSox0dXVldHS0vv3GG2+kq6vrhHFTH81ccMEFufDCC2djKpyGarXqC32esBbzh7WYP6zF/PHOWyzOxKw8Z+Saa67Jiy++WN9++eWX84lPfGI2/igA4HfcacVIrVab9muSbNmyJXv37k2Sac8WOXbsWIaHh3Prrbee6VwBgAWo4RgZHx/P4OBgkuShhx7K66+/niTZtm1b/vM//zNJ8uEPfzg333xzvvSlL2XDhg35+te/nve9730nHGvqvhD3h8wPbW1t+cpXvmI95gFrMX9Yi/nDWswfzT5/t9TeeXljjo2NjaWjoyOjo6M+/wOA3xHNPn/72TQAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQ1DmNvuHo0aO54447cv7552d8fDz33HNP2traThj3ta99LW+//XYWLVqUN998M3fffXdaWlqaMmkAYOFo+MrImjVrsmrVqgwMDOSyyy5Lf3//CWOefPLJ/PznP89dd92VO++8MyMjI3n00UebMmEAYGFpKEZGRkby3e9+N9ddd12S5Lrrrsvg4GDeeOONaeN++tOfTtt37rnnZnR09JTHHRsbm/aamJhoZFoAwCyamJg44VzdTA3FyNDQUDo7O1OpVJIky5Yty+LFizM8PDxt3Cc/+cns2LEjjz32WI4cOZLXX389N9100ymP293dnY6Ojvpr06ZNp/FXAQBmw6ZNm6adp7u7u5t6/IbuGTl06FCWLFkybV97e3tGRkam7Vu5cmUeeeSRfPazn81VV12Vxx9/POeee+4pj3vgwIFUq9X69snuQQEAyujv78+GDRvq22NjY00NkoaujLS0tNSvikyZnJxMa2vrCWN/9atfZceOHdm3b18+85nP5NixY6c8brVanfYSIwAwf7S1tZ1wrm6mhmKkq6vrhHs/xsfH09XVNW3f0NBQnn322axatSpDQ0N57rnnct999535bAGABaehGOnr68vBgwczOTmZJPWPZ3p7e6eNe+yxx7JixYokvw6YgYGB/PjHP27GfAGABabhKyOrV6/Orl27kiQ7d+7M2rVrU6lUsmXLluzduzdJ8pGPfCTPPfdc/X0tLS0nBAsAQHIaDz0bHBzMxo0bs3v37hw+fDibN29Okmzbti09PT1ZuXJlPv/5z+eVV17J5s2b09nZmQMHDuTOO+9s+uQBgN99LbVarVbqDx8bG0tHR0dGR0ebfjMMADA7mn3+9rNpAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoKhzGn3D0aNHc8cdd+T888/P+Ph47rnnnrS1tZ107JtvvpkHHnggS5cuzYc+9KF87GMfO+MJAwALS8NXRtasWZNVq1ZlYGAgl112Wfr7+0867vDhw/n0pz+dP/7jP86f/dmfCREA4KRaarVabaaDR0ZGsnz58hw5ciSVSiWvvfZaLrroorz66qtpb2+fNvYP/uAPcuedd6avr++UxxsbG0tHR0cOHDiQarVa39/W1nbKqy0AwNyamJjIxMREfXtsbCzd3d0ZHR2ddv4+XQ1dGRkaGkpnZ2cqlUqSZNmyZVm8eHGGh4enjXvyySfz0ksvZXh4ONdff336+/vz1ltvnfK43d3d6ejoqL82bdp0Gn8VAGA2bNq0adp5uru7u6nHb+iekUOHDmXJkiXT9rW3t2dkZGTavu985zv56Ec/mvXr1+eWW27JpZdemlqtls2bN5/0uCe7MgIAzA/9/f3ZsGFDfXvqykizNHRlpKWlpX5VZMrk5GRaW1un7Xv++efz8Y9/PIsXL87SpUtz66235uGHHz7lcavV6rSXGAGA+aOtre2Ec3UzNRQjXV1dGR0dnbZvfHw8XV1d0/YdO3Ysx48fr29fcsklOXz48BlMEwBYqBqKkb6+vhw8eDCTk5NJUv94pre3d9q4Sy65JC+99FJ9+5xzzsnFF198pnMFABaghq+MrF69Ort27UqS7Ny5M2vXrk2lUsmWLVuyd+/eJMntt9+e733ve/U7b5955pmsW7euyVMHABaChh96Njg4mI0bN2b37t05fPhw/abUbdu2paenJytXrsyVV16Zu+++O+vWrcvKlStTqVRyyy23NH3yAMDvvoaeM9JsU88Zadb3KQMAs6/Z528/mwYAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKajhGjh49mi9+8Yu56667sn79+kxMTLzr+O3bt6evr+905wcALHANx8iaNWuyatWqDAwM5LLLLkt/f/8px46MjOTv//7vz2iCAMDC1lKr1WozHTwyMpLly5fnyJEjqVQqee2113LRRRfl1VdfTXt7+wnj//Iv/zIXX3xxHn300QwNDZ3w38fGxtLR0ZEDBw6kWq3W97e1taWtre30/kYAQFNNTExM+yRkbGws3d3dGR0dnXb+Pl0NXRkZGhpKZ2dnKpVKkmTZsmVZvHhxhoeHTxj74IMP5nOf+1ze8573/Nbjdnd3p6Ojo/7atGlTI9MCAGbRpk2bpp2nu7u7m3r8cxoZfOjQoSxZsmTavvb29oyMjEzb9/LLL2dsbCy9vb154YUXfutxT3ZlBACYH/r7+7Nhw4b69tSVkWZpKEZaWlrqV0WmTE5OprW1tb59/PjxfOtb38q999474+NWq9WmXOYBAJpvtm+faChGurq6Mjo6Om3f+Ph4urq66tvPPPNMBgcH80//9E9Jfh0rk5OTOe+88/I///M/Zz5jAGBBaeiekb6+vhw8eDCTk5NJUv94pre3tz7miiuuyAsvvJA9e/Zkz549+epXv5rLL788e/bsad6sAYAFo6EY6erqyurVq7Nr164kyc6dO7N27dpUKpVs2bIle/fuTaVSSU9PT/01dcNrT0/PbMwfAPgd19DHNEkyODiYjRs3Zvfu3Tl8+HA2b96cJNm2bVt6enqycuXKpk8SAFi4GnrOSLNNPWekWd+nDADMvmafv/1sGgCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEACiq4Rg5evRovvjFL+auu+7K+vXrMzExccKY0dHRfPrTn061Ws2ll16af//3f2/KZAGAhafhGFmzZk1WrVqVgYGBXHbZZenv7z9hzD333JM/+ZM/yY9+9KN0d3fnhhtuyNGjR5syYQBgYWmp1Wq1mQ4eGRnJ8uXLc+TIkVQqlbz22mu56KKL8uqrr6a9vb0+7umnn87VV1+dJBkbG0tnZ2f+7d/+LVdcccW0442NjaWjoyMHDhxItVqt729ra0tbW9uZ/t0AgCaYmJiY9knI2NhYuru7Mzo6Ou38fboaujIyNDSUzs7OVCqVJMmyZcuyePHiDA8PTxs3FSJJUq1WU61Wc+GFF57yuN3d3eno6Ki/Nm3a1Mi0AIBZtGnTpmnn6e7u7qYe/5xGBh86dChLliyZtq+9vT0jIyOnfM+LL76Yvr6+XHDBBaccc7IrIwDA/NDf358NGzbUt6eujDRLQzHS0tJSvyoyZXJyMq2trad8z/3335977733XY87dfUEAJh/Zvv2iYY+punq6sro6Oi0fePj4+nq6jrp+KeeeipXX311PvCBD5z+DAGABa2hGOnr68vBgwczOTmZJPWPZ3p7e08Y+/zzz+eVV17JDTfc0IRpAgALVcNXRlavXp1du3YlSXbu3Jm1a9emUqlky5Yt2bt3b5Jk3759efDBB3Pttddm//79+clPfpKtW7c2f/YAwO+8hu4ZSZLBwcFs3Lgxu3fvzuHDh7N58+YkybZt29LT05NqtVq/gvLNb36z/r7t27c3b9YAwILR0HNGmm3qOSPN+j5lAGD2Nfv87WfTAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABQlRgCAosQIAFCUGAEAihIjAEBRYgQAKEqMAABFiREAoCgxAgAUJUYAgKLECABQlBgBAIoSIwBAUWIEAChKjAAARYkRAKAoMQIAFCVGAICixAgAUFTRGJmYmJj2K2VNTEzkb//2b63HPGAt5g9rMX9Yi/mj2efvllqtVmvKkU7DwYMH093dnQMHDuTCCy8sNQ1+Y2xsLB0dHRkdHU21Wi09nbOatZg/rMX8YS3mj2afv89p9A1Hjx7NHXfckfPPPz/j4+O555570tbWdsK4HTt25Ic//GEmJibyqU99KqtWrTrjyQIAC0/DMbJmzZrceOONufHGG/Pwww+nv78/991337QxP/vZzzIwMJDdu3enVqvl8ssvzxNPPJH3v//9TZs4ALAwNBQjIyMj+e53v5t//Md/TJJcd911ue222/J3f/d3aW9vr4/7xje+kdWrV6elpSUtLS258sors3Xr1gwMDEw73tQnRL/4xS+m7W9razvp1RZm19jY2LRfKcdazB/WYv6wFuVMTExMuz9k6rzdrDs9GoqRoaGhdHZ2plKpJEmWLVuWxYsXZ3h4ONdcc0193NNPP50vf/nL9e0VK1bk8ccfP+F4b731VpKkt7f3tCbP7Oju7i49BX7DWswf1mL+sBbzx9R5/Ew1FCOHDh3KkiVLpu1rb2/PyMjIu4472Zgk6enpyb59+9La2pqWlpb6fldGAGD++P9XRmq1Wt5666309PQ05fgNxUhLS0v9qsiUycnJtLa2vuu4k41JkkWLFuWDH/xgI1MAABaYhp4z0tXVldHR0Wn7xsfH09XV9a7j3njjjRPGAAAkDcZIX19fDh48mMnJySSpf/Ty/+/5uOaaa/Liiy/Wt19++eV84hOfONO5AgALUMNXRlavXp1du3YlSXbu3Jm1a9emUqlky5Yt2bt3b5Lktttuyw9+8IMkybFjxzI8PJxbb721yVMHABaChp/A+vrrr2fjxo3p6enJ4cOHs3nz5ixevDi///u/n/7+/nzqU59Kknz729/O888/n8nJydx4442ujAAAJzUnj4P31Nb5YyZrMTo6mi984Qt56qmnsnz58mzdujUf+9jHCs14YZvp18aU7du3Z3BwMENDQ3M3ybNEI2vx5ptv5oEHHsjSpUvzoQ99yNdHk810Lb72ta/l7bffzqJFi/Lmm2/m7rvvnvadmTTH97///XzlK1/Jo48+esrvnjnj83dtDtx00021f/mXf6nVarXaQw89VPurv/qrE8b89Kc/rV1xxRW1t99+u3b8+PHapZdeWjt48OBcTO+sMpO16O/vrz3yyCO1Z599tvZHf/RHtfe+97218fHxuZ7qWWEm6zHl0KFDtd/7vd+rXXXVVXM0u7PLTNfiv//7v2vXX3997b/+67/mcnpnlZmsxRNPPFH7whe+UN+++eaba9u3b5+zOZ4tXn311dqOHTtqSWo///nPTzqmGefvWY+RQ4cO1SqVSu1///d/a7VarfbLX/6ydu6559bGxsamjfvzP//z2t/8zd/Ut9euXVv767/+69me3lllpmvxwx/+sP770dHRWmtra214eHhO53o2mOl6TFm3bl3t/vvvFyOzoJG1uPbaa2s/+tGP5niGZ4+ZrsU//MM/1P70T/+0vr127draAw88MKdzPVscP378XWOkGefvhm5gPR3v9tTWd3r66adz0UUX1bdXrFhRv1GW5pjpWlx99dX131er1VSrVT9VeRbMdD2S5MEHH8znPve5vOc975nraZ4VZroWTz75ZF566aUMDw/n+uuvT39/f9OeQMmvzXQtPvnJT2bHjh157LHHcuTIkbz++uu56aabSkx5wVu06N1ToRnn74Z/UF6jmv3UVk7fTNfinV588cX09fXlggsumO3pnXVmuh4vv/xyxsbG0tvbmxdeeGEup3jWmOlafOc738lHP/rRrF+/PrfccksuvfTS1Gq1bN68eS6nu6DNdC1WrlyZRx55JJ/97Gdz1VVX5fHHH8+55547l1PlN5px/p71KyPNfmorp2+ma/FO999/f+69997ZntpZaSbrcfz48XzrW9/K+vXr53h2Z5eZfm08//zz+fjHP57Fixdn6dKlufXWW/Pwww/P5VQXvEb+P/WrX/0qO3bsyL59+/KZz3wmx44dm6tp8g7NOH/Peox4auv8MdO1mPLUU0/l6quvzgc+8IG5mN5ZZybr8cwzz2RwcDBLly7Neeedl7Vr1+Zf//Vfc955583xbBe2mX5tHDt2LMePH69vX3LJJTl8+PCczPFsMdO1GBoayrPPPptVq1ZlaGgozz33XO677765nCq/0Yzz96zHiKe2zh8zXYvk1/8CfOWVV3LDDTfM6RzPJjNZjyuuuCIvvPBC9uzZkz179uSrX/1qLr/88uzZs6fElBesmX5tXHLJJXnppZfq2+ecc04uvvjiuZvoWWCma/HYY49lxYoVSX59MhwYGMiPf/zjuZ0sSZpz/p6TKyOe2jo/zHQt9u3blwcffDDXXntt9u/fn5/85CfZunVryakvSDNZj0qlkp6envpr6sa+Zv2kTH5tpl8bt99+e773ve/Vf3rpM888k3Xr1hWb90I007X4yEc+kueee67+vpaWlpP+w4ozV/vN48hq73gsWbPP37N+A2uSDA4OZuPGjdm9e3f9qa1Jsm3btvT09GTlypX58Ic/nJtvvjlf+tKXMjk5ma9//et53/veNxfTO6v8trWoVqv1f5l885vfrL9v+/btpaa8oM3ka4O5MZO1uPLKK3P33Xdn3bp1WblyZSqVSm655ZbCM194ZrIWn//85/PKK69k8+bN6ezszIEDB3LnnXcWnvnCMz4+nn/+539Okjz00EP5i7/4i3R2djb9/D0nT2AFADiVWf+YBgDg3YgRAKAoMQIAFCVGAICixAgAUJQYAQCKEiMAQFFiBAAoSowAAEWJEQCgKDECABT1f8hSXnsrfFnIAAAAAElFTkSuQmCC",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from pylab import mpl\n",
    "from matplotlib.ticker import MultipleLocator,FormatStrFormatter\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis \n",
    "from matplotlib.colors import Normalize\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib.ticker as mtick\n",
    "\n",
    "yin_ori='SFcf2f'\n",
    "# yin_diff='yin_diff'#不同值的数列名称：通用因变量 EigenValue  diff SLcf2f z\n",
    "zi_ori='sfricn'\n",
    "# zi_diff='pbol_diff_percent'#不同值的数列名称：通用自变量pbol_diff_percent\n",
    "yin_ori=yin_ori\n",
    "pointsize=10\n",
    "textsize=12\n",
    "xlinenum=4\n",
    "ylinenum=4\n",
    "\n",
    "figsizex=2.5*ylinenum# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= figsizex/ylinenum*xlinenum\n",
    "controlpicnum=5\n",
    "labelsize=pointsize\n",
    "# plt.figure(figsize=(figsizex,figsizex))\n",
    "\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马  \n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "\n",
    "\n",
    "# # # ——————————散点图(每一张小图）——————————\n",
    "def pic_ktaucr_inpicolor_x_scatter(df_pre,div_colandlegend_para,x_aixs_para,y_aixs_para):\n",
    "# #     下面的函数定义是绘图用的\n",
    "    # 分类准备工作，这些都是针对‘颜色分类的参数’div_colandlegend_para\n",
    "    df_pre1=df_pre.reset_index(drop=True)#去掉行名\n",
    "    df_pre1[div_colandlegend_para].value_counts()#可能——数值统计\n",
    "    div_pic=df_pre1[div_colandlegend_para].sort_values()#可能——数值排序\n",
    "    div_pic.unique()#分颜色参数的唯一数值统计\n",
    "    num_diff_divpic=len(div_pic.value_counts())#可能——不同数值的数量\n",
    "# ——————构造颜色数值对应关系——————————\n",
    "    coltocmap=df[div_colandlegend_para].values#采用外层的df分颜色,所有数据的最小值\n",
    "    coltocmap_unique=list(df[div_colandlegend_para].sort_values().unique())\n",
    "#     minco=min(coltocmap)-((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))# colorbar的上下界进行一定程度的缩放\n",
    "#     maxco=max(coltocmap)+((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))\n",
    "\n",
    "    minco=min(df[div_colandlegend_para].values)#采用外层的df分颜色,所有数据的最小值\n",
    "    maxco=max(df[div_colandlegend_para].values)#采用外层的df分颜色,所有数据的最大值\n",
    "\n",
    "    num_scatter=[]\n",
    "# ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend in range(0,num_diff_divpic):\n",
    "        df_div_colandlegend=df_pre1[(df_pre1[div_colandlegend_para]==div_pic.unique()[num_colandlegend])]\n",
    "        #上面是可能——数值df建立\n",
    "        #如果最小值确实，则跳过；如果上升下降趋势点数量相同，则跳过\n",
    "\n",
    "        if min(df_div_colandlegend[x_aixs_para])!=min(df[x_aixs_para]) :\n",
    "# #         or len(df_div_colandlegend[(df_div_colandlegend[yin_diff]>100)])==len(df_div_colandlegend[(df_div_colandlegend[yin_diff]<100)]): \n",
    "            continue\n",
    "#         else:\n",
    "        df_div_colandlegend=df_div_colandlegend.reset_index(drop=True)#去掉行名    \n",
    "        #此处得到的df_div_colandlegend就是已经按照颜色分类过的dataframe\n",
    "        div_colandlegend_finalpre=df_div_colandlegend.sort_values(by=div_colandlegend_para,ascending=False)#单拿出来并排序 \n",
    "        div_colandlegend_final=div_colandlegend_finalpre.reset_index(drop=True)#去掉行名           \n",
    "        #  对本种颜色下进行循环构造画图的listdf，x轴从小到大\n",
    "        x_ks_plotlist =[]\n",
    "        y_ks_plotlist =[]\n",
    "        num_del=0\n",
    "#——————把每个点循环并赋予颜色（一行一行的绘制，即一个点一个点的绘制），构造出来需要的list——————\n",
    "        for num_ks in range(0,len(div_colandlegend_final)):\n",
    "            x_ks=div_colandlegend_final.at[num_ks, x_aixs_para]\n",
    "            y_ks=div_colandlegend_final.at[num_ks, y_aixs_para]\n",
    "            z_ks=div_colandlegend_final.at[num_ks, div_colandlegend_para]\n",
    "#             x_ks_plotlist.append(x_ks/1000)\n",
    "            x_ks_plotlist.append(x_ks)\n",
    "            y_ks_plotlist.append(y_ks)\n",
    "            num_scatter.append(x_ks)\n",
    "        print('颜色变量',div_colandlegend_para,'最小',minco,'最大',maxco)\n",
    "        colorlmap_ks=(z_ks-minco)/(maxco-minco)\n",
    "        colorlmap_ks_list=np.full((len(div_colandlegend_final)-num_del,1),colorlmap_ks)\n",
    "#————————————————小图内每个颜色的绘制——————————————————\n",
    "        axes_sub_fig.scatter(x_ks_plotlist,y_ks_plotlist,c=colorlmap_ks_list, cmap=colorltype, vmin=0, vmax=1,s=20,alpha=1)\n",
    "        print('自变量的数值',x_ks_plotlist,'颜色变量的数值',colorlmap_ks)\n",
    "        norm_plot = mpl.colors.Normalize(vmin=0, vmax=1)\n",
    "        cmap_plot = cm.get_cmap(colorltype)\n",
    "#         norm = Normalize(vmin=0, vmax=1)\n",
    "        m_plot = cm.ScalarMappable(norm=norm_plot, cmap=cmap_plot)\n",
    "        axes_sub_fig.plot(x_ks_plotlist, y_ks_plotlist,c=m_plot.to_rgba(float(min(colorlmap_ks_list))))\n",
    "    if len(num_scatter)>=controlpicnum:\n",
    "    # ———————————colorbar的位置———————————  \n",
    "        divider = make_axes_locatable(plt.gca()) \n",
    "        cax = divider.append_axes(\"right\", \"5 %\",  pad =\"0%\")  \n",
    "    #———————————对颜色参数进行处理，以方便构造colorbar———————————  \n",
    "       #下面是采用实统一的数值来构造colorbar\n",
    "        colorbarpara=np.round(coltocmap_unique,0)\n",
    "    #——————————————colorbar设置————————————————————————————————\n",
    "        cmap = plt.get_cmap(colorltype) #获取颜色类型\n",
    "        #对颜色类型进行最大最小值正则化，这里的vmin和vmax指的是填充colorbar的区域\n",
    "        norm = mpl.colors.Normalize(vmin=min(colorbarpara), vmax= max(colorbarpara))\n",
    "        scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)#提供一个可以映射颜色的对象\n",
    "    # #——————————————colorbar右侧数字的设置————————————————————————————————\n",
    "    #     cb = \n",
    "        plt.colorbar(scalarMap,cax=cax, orientation=\"vertical\") \n",
    "    #     labels =np.round(colorbarpara,0)#指的是cb标签的数字\n",
    "    #     loc    =np.round(colorbarpara,0)#指的是cb横线的位置\n",
    "    #     cb.set_ticks(loc) \n",
    "    #     cb.set_ticklabels(labels)  \n",
    "    #     cb.ax.tick_params(labelsize=labelsize)\n",
    "    return len(num_scatter)\n",
    "# # # ——————————————def函数定义结束————————————————————————————————  \n",
    "\n",
    "# # ——————————预设信息设置————————\n",
    "colorltype=str('viridis')\n",
    "# prelist=list(df['KG_quge_web'].sort_values().unique())\n",
    "# 筛选\n",
    "# para_without_para=str('F')\n",
    "# para_without_paranum=2 and 3\n",
    "# # 分图后df\n",
    "# div_pic_para=str('KG_quge_web')\n",
    "# 图内分类型参数（变色或者变形状）\n",
    "# div_colandlegend_para_list=['L']\n",
    "div_colandlegend_para_list=sort_list[len(sort_list)-1]\n",
    "# ['KG_quge_web','KH_quge_web','KG_consedge_flange','KH_consedge_flange']\n",
    "# div_colandlegend_para_list=df.columns\n",
    "# div_colandlegend_para_list=['KG_quge_web']\n",
    "# div_colandlegend_para=str('KG_total_web')['B', 'H','L', 'T1', 'T2', 'n']\n",
    "# # x_轴\n",
    "x_aixs_paralist=[zi_ori]\n",
    "# x_aixs_paralist=['T1']\n",
    "# x_aixs_para=df.columns\n",
    "# y_轴\n",
    "y_aixs_para=str('yin_diff')\n",
    "# yin_diff，pbol_del, SFcf2f, SLcf2f\n",
    "\n",
    "# 分图筛选一下\n",
    "# 参数KG_quge_web，KH_quge_web，ratio_alpha_Bflange_to_Hn，ratio_alpha_tflange_to_tweb，pbol_del，EigenValue\n",
    "# ['B', 'H','L', 'T1', 'T2', 'n','ratio_alpha_Bflange_to_Hn','KH_quge_web']\n",
    "div_para_list=sort_list[0]\n",
    "# ['H']#第一层筛选参数\n",
    "div_para_half_list=[sort_list[1]]#第一层半筛选参数\n",
    "div_para_half_prelist=[sort_list[2]]#第二层前筛选参数\n",
    "div_para_sechalf_prelist=[sort_list[3]]#第最后一层筛选参数\n",
    "div_para_second_list=[sort_list[3]]#第二层筛选参数\n",
    "\n",
    "# dfori=df[df[para_without_para]==para_without_paranum]\n",
    "# print(len(dfori))\n",
    "  \n",
    "numaxsub=0\n",
    "# 筛选拼接数量n，用的是函数中的第一个参数\n",
    "# df=df_selected_del[(df_selected_del['n']!=1)&(df_selected_del['n']!=1)]# 这个df_pre已经筛选完了‘不需要的参数’和它“不需要的参数”\n",
    "df=df_S\n",
    "\n",
    "plt.figure(figsize=(figsizex,figsizey))\n",
    "# #————————分割图形的筛选方法（筛选第一层）——————————\n",
    "for num_div_para in range(0,len(div_para_list)):\n",
    "    df_pre_df_para=df.reset_index(drop=True)#去掉行名\n",
    "    div_para=div_para_list[num_div_para]\n",
    "    div_pic_df_para=df_pre_df_para[div_para].sort_values()#可能——数值排序\n",
    "    len_diff_divpic_df_para=len(div_pic_df_para.value_counts())#可能——不同数值的数量\n",
    "    \n",
    "    # ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend_df_para in range(0,len_diff_divpic_df_para):\n",
    "        df_second=df_pre_df_para[(df_pre_df_para[div_para]==div_pic_df_para.unique()[num_colandlegend_df_para])]\n",
    "\n",
    "# #————————第一层筛选结束——————————    \n",
    "# #————————分割图形的筛选方法（筛选一层半）——————————\n",
    "        for num_div_half_para in range(0,len(div_para_half_list)):\n",
    "            df_pre_df_half_para=df_second.reset_index(drop=True)#去掉行名\n",
    "            div_half_para=div_para_half_list[num_div_half_para]\n",
    "            div_pic_df_half_para=df_pre_df_half_para[div_half_para].sort_values()#可能——数值排序\n",
    "            len_diff_divpic_df_half_para=len(div_pic_df_half_para.value_counts())#可能——不同数值的数量\n",
    "\n",
    "            # ——————对每一种颜色数值关系都作图——————————\n",
    "            for num_colandlegend_df_half_para in range(0,len_diff_divpic_df_half_para):\n",
    "                df_half=df_pre_df_half_para[(df_pre_df_half_para[div_half_para]==div_pic_df_half_para.unique()[num_colandlegend_df_half_para])]\n",
    "#                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                #连接两种作用的函数的df\n",
    "        # #————————第层半筛选结束——————————    \n",
    "                # #————————分割图形的筛选方法（筛选二层前）——————————\n",
    "                for num_div_half_prepara in range(0,len(div_para_half_prelist)):\n",
    "                    df_pre_df_half_prepara=df_half.reset_index(drop=True)#去掉行名\n",
    "                    div_half_prepara=div_para_half_prelist[num_div_half_prepara]\n",
    "                    div_pic_df_half_prepara=df_pre_df_half_prepara[div_half_prepara].sort_values()#可能——数值排序\n",
    "                    len_diff_divpic_df_half_prepara=len(div_pic_df_half_prepara.value_counts())#可能——不同数值的数量\n",
    "        #             plt.figure(figsize=(figsizex,figsizey))\n",
    "                    # ——————对每一种颜色数值关系都作图——————————\n",
    "                    for num_colandlegend_df_half_prepara in range(0,len_diff_divpic_df_half_prepara):\n",
    "                        df_sechalf=df_pre_df_half_prepara[(df_pre_df_half_prepara[div_half_prepara]==div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])]\n",
    "        #                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                        #连接两种作用的函数的df\n",
    "        \n",
    "                        # #————————分割图形的筛选方法（筛选二层前F）——————————\n",
    "                        for num_div_sechalf_prepara in range(0,len(div_para_sechalf_prelist)):\n",
    "                            df_pre_df_sechalf_prepara=df_sechalf.reset_index(drop=True)#去掉行名\n",
    "                            div_sechalf_prepara=div_para_sechalf_prelist[num_div_sechalf_prepara]\n",
    "                            div_pic_df_sechalf_prepara=df_pre_df_sechalf_prepara[div_sechalf_prepara].sort_values()#可能——数值排序\n",
    "                            len_diff_divpic_df_sechalf_prepara=len(div_pic_df_sechalf_prepara.value_counts())#可能——不同数值的数量\n",
    "                #             plt.figure(figsize=(figsizex,figsizey))\n",
    "                            # ——————对每一种颜色数值关系都作图——————————\n",
    "                            for num_colandlegend_df_sechalf_prepara in range(0,len_diff_divpic_df_sechalf_prepara):\n",
    "                                df_prehalf=df_pre_df_sechalf_prepara[(df_pre_df_sechalf_prepara[div_sechalf_prepara]==div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara])]\n",
    "\n",
    "                                #连接两种作用的函数的df\n",
    "                # #————————第二层前筛选结束——————————   \n",
    "\n",
    "                #————————分割图形的筛选方法（筛选第第二层）——————————\n",
    "                                for num_div_second_para in range(0,len(div_para_second_list)):\n",
    "                                    if len(df_prehalf)<controlpicnum:\n",
    "                                        continue\n",
    "                                    else:\n",
    "                                        df_pre_df_second_para=df_prehalf.reset_index(drop=True)#去掉行名\n",
    "                                        div_second_para=div_para_second_list[num_div_second_para]\n",
    "                                        div_pic_df_second_para=df_pre_df_second_para[div_second_para].sort_values()#可能——数值排序\n",
    "                                        len_diff_divpic_df_second_para=len(div_pic_df_second_para.value_counts())#可能——不同数值的数量\n",
    "                                        # ——————对每一种颜色数值关系都作图——————————\n",
    "                                        for num_colandlegend_df_second_para in range(0,len_diff_divpic_df_second_para):\n",
    "                                            df_div_para_second_colandlegend=df_pre_df_second_para[(df_pre_df_second_para[div_second_para]==div_pic_df_second_para.unique()[num_colandlegend_df_second_para])]\n",
    "                                            df_pre=df_div_para_second_colandlegend #连接两种作用的函数的df\n",
    "\n",
    "\n",
    "                                            print('本轮数值数量',len(df_pre))\n",
    "                                            print('第一层参数',div_para,div_pic_df_para.unique()[num_colandlegend_df_para],type(div_pic_df_para.unique()[num_colandlegend_df_para]))\n",
    "                                            print('第一层半参数',div_half_para,div_pic_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                                            print('第二层前参数',div_half_prepara,div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])\n",
    "                                            print('第二层参数',div_sechalf_prepara,div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara])\n",
    "                                            print('最后一层参数',div_second_para,div_pic_df_second_para.unique()[num_colandlegend_df_second_para])\n",
    "\n",
    "                                            numaxsub=numaxsub+1\n",
    "                                            axes_sub_fig=plt.subplot(xlinenum,ylinenum,numaxsub)# 小图排布\n",
    "                            # # #————————第二层筛选结束——————————    \n",
    "                                            for i in range(0,len(x_aixs_paralist)):\n",
    "                                                x_aixs_para=x_aixs_paralist[i]\n",
    "                                                #——————每一张大图内一点一点画小图，主要作用——————————————————\n",
    "                                                for j in range(0,len(div_colandlegend_para_list)):\n",
    "                                                    div_colandlegend_para=div_colandlegend_para_list[j]\n",
    "                                                    pointnum=pic_ktaucr_inpicolor_x_scatter(df_pre,div_colandlegend_para,x_aixs_para,y_aixs_para) \n",
    "                                                    textlegend=round(div_pic_df_para.unique()[num_colandlegend_df_para],0)#小数位数,2\n",
    " \n",
    "                                                    if pointnum<controlpicnum:\n",
    "#                                                         axes_sub_fig.remove()\n",
    "                                                        numaxsub=numaxsub-1\n",
    "                                                        continue\n",
    "\n",
    "#                                                         axes_sub_fig.remove()\n",
    "\n",
    "                                        axes_sub_fig.text(0.2,1.02,str('%.0f'%div_pic_df_para.unique()[num_colandlegend_df_para])+str('×')\n",
    "                                                      +str('%.0f'%div_pic_df_half_para.unique()[num_colandlegend_df_half_para])+str('×')\n",
    "                                                      +str('%.0f'%div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])+str('×')                                              \n",
    "                                                      +str('%.0f'%div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara]),\n",
    "                                                        fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "\n",
    "                                        axes_sub_fig.text(1.02,1.02,'$'+div_colandlegend_para_list[0]+'$',fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "\n",
    "#                                                     if pointnum<controlpicnum:\n",
    "# #                                                         axes_sub_fig.remove()\n",
    "#                                                         numaxsub=numaxsub-1\n",
    "\n",
    "# #                                                         axes_sub_fig.remove()\n",
    "\n",
    "\n",
    "\n",
    "                                    #                 axes_sub_fig.text(0.4,0.75,str(r'$\\alpha_{\\mathrm{wKH}}$')+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                                    #                 axes_sub_fig.text(0.2,0.6,str(r'$\\alpha_{\\mathrm{BtHn}}$')+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                                    #                 axes_sub_fig.text(0.4,0.75,str(div_para)+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "\n",
    "                            #-----------------------单独的图纸设置--------------------------------------------\n",
    "\n",
    "                        #                 axes_sub_fig.set_xlabel(str(r'$t_\\mathrm{f}/t_\\mathrm{w}$'),fontsize=textsize)\n",
    "                        #                 axes_sub_fig.set_ylabel(r'$k_{\\mathrm{fem}}$',fontsize=textsize)\n",
    "\n",
    "            #                     axes_sub_fig.yaxis.set_major_formatter(mtick.FormatStrFormatter('%.0f'))\n",
    "#                                     axes_sub_fig.ticklabel_format(axis=\"y\", style=\"sci\", scilimits=(0,6))#表示对范围之外的值换科学记数法，范围内的数不换；\n",
    "            #                     axes_sub_fig.ticklabel_format(axis=\"x\", style=\"sci\", scilimits=(50,300))\n",
    "\n",
    "\n",
    "            #                     axes_sub_fig.set_xlabel('螺栓预拉力(kN)', fontproperties=font_setS)\n",
    "#                                             axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$'+'(mm)', fontproperties=font_setS)\n",
    "#                                             axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$'+'(mm)', fontproperties=font_setS)\n",
    "#                                             axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$', fontproperties=font_setS) \n",
    "#                                             axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$', fontproperties=font_setS)   \n",
    "#                                             axes_sub_fig.set_ylim(-0.1,0.1)\n",
    "#                                             axes_sub_fig.set_ylim(-0.1,1)\n",
    "#                                             ymajorLocator = MultipleLocator(0.1)\n",
    "#                                             axes_sub_fig.yaxis.set_major_locator(ymajorLocator)\n",
    "\n",
    "                                        axes_sub_fig.set_xlim(0.3,0.45)\n",
    "                                        axes_sub_fig.set_xlabel('$μ$', fontproperties=font_setS)  \n",
    "#                                         axes_sub_fig.set_xticks([0.3,0.35,0.4,0.45],fontsize=textsize) \n",
    "#                                             axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "                                        axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'),fontproperties=font_setS)  \n",
    "#                                   axes_sub_fig.set_ylabel('临界力(kN)', fontproperties=font_setS)           \n",
    "\n",
    "# #         # # 横坐标n，分图L\n",
    "# #                                             if x_aixs_paralist==['n']:\n",
    "# #                                                 axes_sub_fig.set_xlim(0,7)\n",
    "# #                                                 xmajorLocator = MultipleLocator(1)\n",
    "# #                                                 axes_sub_fig.xaxis.set_major_locator(xmajorLocator)\n",
    "# # #                                                 axes_sub_fig.set_xticks([1,2,3,4,5,6])# x轴标签\n",
    "\n",
    "\n",
    "# #                                                 if y_aixs_para==str('pbol_del'):\n",
    "# # #                                                     axes_sub_fig.set_ylim(-50,50)\n",
    "# # #                                                     ymajorLocator = MultipleLocator(10)\n",
    "# # #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "# # #                                                     axes_sub_fig.set_ylim(-20,10)\n",
    "# # #                                                     ymajorLocator = MultipleLocator(5)\n",
    "# # #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "# #                                                     axes_sub_fig.set_ylim(-10,10)\n",
    "# #                                                     ymajorLocator = MultipleLocator(5)\n",
    "# #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "# #                                                     if yin_ori==str('SLcf2f'):\n",
    "# #                                                         axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "# #                                                     if yin_ori==str('SFcf2f'):\n",
    "# #                                                         axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "# #                                             if y_aixs_para==str('SFcf2f'):\n",
    "# #                                                 axes_sub_fig.set_ylim(0,1)\n",
    "\n",
    "#         # # 横坐标L，颜色n\n",
    "#                                             if x_aixs_paralist==['L']:\n",
    "#                                                 axes_sub_fig.set_xlim(0,4500)\n",
    "#                                                 xmajorLocator = MultipleLocator(1000)\n",
    "#                                                 axes_sub_fig.xaxis.set_major_locator(xmajorLocator) \n",
    "# #                                                 axes_sub_fig.set_xticks([1000,2000,3000,4000])# x轴标签\n",
    "#                                                 if y_aixs_para==str('pbol_del'):\n",
    "# #                                                     if y_aixs_para==str('pbol_del'):\n",
    "# #                                                     axes_sub_fig.set_ylim(0,1000)\n",
    "#     #                                                     ymajorLocator = MultipleLocator(200)\n",
    "#     #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "\n",
    "#                                                     axes_sub_fig.set_ylim(-100,0)\n",
    "#                                                     ymajorLocator = MultipleLocator(20)\n",
    "#                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#                                                     if yin_ori==str('SLcf2f'):\n",
    "#                                                         axes_sub_fig.set_ylim(0,300)\n",
    "#                                                         ymajorLocator = MultipleLocator(100)\n",
    "#                                                         axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#                                                         axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "#                                                     if yin_ori==str('SFcf2f'):\n",
    "#                                                         axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "   \n",
    "\n",
    "#             # # 横坐标n，分图L\n",
    "#                                             if x_aixs_paralist==['F']:\n",
    "#                                                 axes_sub_fig.set_xlim(0,10)\n",
    "# #                                                 xmajorLocator = MultipleLocator(1)\n",
    "# #                                                 axes_sub_fig.xaxis.set_major_locator(xmajorLocator) \n",
    "#                                                 axes_sub_fig.set_xticks([1,2,3,4,5,6,7,8,9,10])# x轴标签\n",
    "\n",
    "#             #纵坐标\n",
    "# #                                             if y_aixs_para==str('SLcf2f'):\n",
    "# #                                                 axes_sub_fig.set_ylim(0,3)\n",
    "# #                                                 ymajorLocator = MultipleLocator(0.5)\n",
    "# #                                                 axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "\n",
    "#                                                 if y_aixs_para==str('SLcf2f'):\n",
    "#                                                     axes_sub_fig.set_ylim(0.3,1)\n",
    "#                                                     ymajorLocator = MultipleLocator(0.2)\n",
    "#                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#  # # 横坐标L，分图n\n",
    "#                                             if x_aixs_paralist==['pbol']:\n",
    "\n",
    "#                                                 axes_sub_fig.set_xticks([80,125,175,230,280],fontsize=textsize)\n",
    "\n",
    "#                                                 if y_aixs_para==str('SLcf2f'):\n",
    "#                                                     axes_sub_fig.set_ylim(0.5,1)\n",
    "#                                                     ymajorLocator = MultipleLocator(0.2)\n",
    "#                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#                                                 if y_aixs_para==str('pbol_del'):\n",
    "#                                                     axes_sub_fig.set_ylim(-0.4,0.05)\n",
    "#                                                     ymajorLocator = MultipleLocator(0.05)\n",
    "#                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#                                                     axes_sub_fig.set_ylabel(str(r'特征值'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "\n",
    "# #                                                 if yin_ori==str('SLcf2f'):\n",
    "# #                                                     axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "# #                                                 if yin_ori==str('SFcf2f'):\n",
    "# #                                                     axes_sub_f\n",
    "# # \n",
    "# #                                                 if y_aixs_para==str('SLcf2f'):\n",
    "# # #                                                     axes_sub_fig.set_ylim(0,1000)\n",
    "# #     #                                                     ymajorLocator = MultipleLocator(200)\n",
    "# #     #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "\n",
    "# #                                                     axes_sub_fig.set_ylim(-100,0)\n",
    "# #                                                     ymajorLocator = MultipleLocator(20)\n",
    "# #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "# #                                                     if yin_ori==str('SLcf2f'):\n",
    "# #                                                         axes_sub_fig.set_ylim(0,300)\n",
    "# #                                                         ymajorLocator = MultipleLocator(100)\n",
    "# #                                                         axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "# #                                                         axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "# #                                                     if yin_ori==str('SFcf2f'):\n",
    "# #                                                         axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "   \n",
    "\n",
    "\n",
    "# #                                             if y_aixs_para==str('pbol_del'):\n",
    "# #                                                 axes_sub_fig.set_ylim(0,1000)\n",
    "# #                                                 ymajorLocator = MultipleLocator(200)\n",
    "# #                                                 axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "# #                                                 if yin_ori==str('SLcf2f'):\n",
    "# #                                                     axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "# #                                                 if yin_ori==str('SFcf2f'):\n",
    "# #                                                     axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "\n",
    "\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.show\n",
    "#     plt.savefig(r'R:\\PhDall\\matplotilibpic\\\\'+str('colorsdivlittle6')+x_aixs_para+'.svg')#保存图   "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "666d4001",
   "metadata": {},
   "source": [
    "#### 基本几何参数组"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a27ed955",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.198977Z",
     "start_time": "2023-12-27T12:36:54.198977Z"
    }
   },
   "outputs": [],
   "source": [
    "general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f','F']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[355.61,     0.002       , 20      , 0 ,  1  ,0 ,0   ]# 面内受剪_分离面内\n",
    "# general_list       =['type','yfss','Imperfectfactor','sfricn','F','meshsz','L','cf1f', 'cf2f', 'cf3f']# 筛选基础数据用的list—螺栓\n",
    "# general_list_number=[2     ,355.61,     0.002       ,0.35,5,40      ,3000,  0   , 1     ,0    ]# 面内受剪—螺栓\n",
    "# general_list_number=[2     ,355.61,     0.002       ,  0.35  ,40,3000,1,  1   , 0     ,0    ]# 面外受剪\n",
    "# general_list_number=[2     ,355.61,     0.002       ,  0.35  ,40,3000,1,  1   ,  1    ,0    ]# 45度角受剪\n",
    "# general_list_number=[2     ,355.61,     0.002       ,  0.35  ,40,3000,1,   0.577  ,  1    , 0   ]# 偏面内30内受剪\n",
    "# general_list_number=[2     ,355.61,     0.002       ,  0.35  ,40,3000,1,  1.732   ,  1    ,   0 ]# 偏面内60受剪\n",
    "# general_list       =['type','yfss','Imperfectfactor','sfricn','meshsz','L','n','cf1f', 'cf2f', 'cf3f']# 带轴压面内筛选基础数据用的list\n",
    "# general_list_number=[2     ,355.61,     0.002       ,  0.35  ,40,3000,1,  0   ,  1    ,   0 ]# 带轴压面内面内受剪\n",
    "sort_list=['L','T2','B','T1','H']#最后一个参数是组内排序小参数\n",
    "# 排序用的list准备，经过过下面删除再叠加最末尾是自变量，对于螺栓截面来说F是一种等同于其他的变量所以要参与排序\n",
    "\n",
    "\n",
    "ascending_list = [True]*len(sort_list)# ascending_list = [True,True,True,True,True,True]\n",
    "yin_ori='k_taucr_fem2'#不同值的数列名称：通用因变量 EigenValue  diff SLcf2f SFcf2f yin_diff k_taucr_fem2\n",
    "yin_diff='yin_diff'\n",
    "zi_ori='EigenValue'\n",
    "zi_diff='pbol_diff_percent'#不同值的数列名称：通用自变量pbol_diff_percent\n",
    "\n",
    "# df=dfpp\n",
    "df=data0\n",
    "# df.to_excel('df.xlsx')\n",
    "def diffmethod(df,general_list,general_list_number,sort_list,yin_diff,zi_diff):# 分离截面dfdelpara,dfBAllo_final\n",
    "    df_basepara=df.copy()\n",
    "# 固定标准参数general list和其值\n",
    "    for i in range (0,len(general_list)):\n",
    "        df_basepara=df_basepara[df_basepara[general_list[i]]==general_list_number[i]].copy()\n",
    "    df_selected_pre=df_basepara.sort_values(by=sort_list+[zi_ori]+[yin_ori],axis=0,ascending=ascending_list+[True]+[True]).copy()#  排序(for除完全重复值)\n",
    "    df_selected=df_selected_pre.drop_duplicates(subset=sort_list+[zi_ori],keep='last').copy()# 删除完全重复值，保留后值（大）\n",
    "\n",
    "    if yin_ori == 'SLcf2f' or 'Bcf2f':\n",
    "        df_selected.drop(df_selected[(df_selected['EigenValue']==0)|(df_selected['EigenValue'].isnull())].index,inplace=True)\n",
    "    if yin_ori == 'SFcf2f' or 'Pucf2f':\n",
    "        df_selected.drop(df_selected[(df_selected['Pucf2f']==0) | (df_selected['Pucf2f'].isnull())].index,inplace=True)\n",
    "\n",
    "\n",
    "# 706830963893.037\n",
    "    #重新按照sortlist排序默认是升序\n",
    "\n",
    "    df_selected_del=df_selected.copy()\n",
    "    #上面这个list里面的最后一个就是需要研究的参数\n",
    "    df_selected_del.reset_index(drop=True)#删除行索引\n",
    "    df_selected_del[yin_diff] = \"\"#增加因变量列\n",
    "    df_selected_del[zi_diff] = \"\"##增加因自变量列\n",
    "    df_selected_del.reset_index(inplace=True)#重置行索引\n",
    "    print(len(df_selected_del))\n",
    "    yin_ori_num=df_basepara.columns.to_list().index(yin_ori)+1#所需计算差值的因变量特征在列中的位置的返回值\n",
    "    zi_ori_num=df_basepara.columns.to_list().index(zi_ori)+1#所需计算差值的自变量特征在列中的位置的返回值\n",
    "    numcolum=df_basepara.columns.size+1#计算总列数一遍往后面加数据就是'yin_diff'列\n",
    "    columnnum_cato=df_basepara.columns.to_list().index(sort_list[len(sort_list)-1])+1\n",
    "    print('columnnum_cato',columnnum_cato)\n",
    "    print(df_selected_del.iloc[0,columnnum_cato])\n",
    "    print(df_selected_del)\n",
    "    df_selected_del[\"pbol_del\"] = \"\"\n",
    "    df_selected_del[\"cato\"] = \"\"\n",
    "# ——————————计算差值函数——————————————\n",
    "    def cal_yin_diff(df_selected_del):\n",
    "        for hang in range (0,len(df_selected_del)-1):\n",
    "            df_hang=df_selected_del[hang:hang+1]#   选择两个相邻行数的上一行df，按照位置序号的切片,左闭右开\n",
    "            df_hang2=df_selected_del[hang+1:hang+2]#  选择两个相邻行数的下一行df\n",
    "# 1\t2\t3\t 4\t5\t6\t7\t     8       \t9            \t 10  \t11  \t12\t13  \t14  \t15  \t16  \t17\n",
    "# H\tB\tT1\tT2\tL\tn\ttype\tyfss\tImperfectfactor \tpbol\tsfricn\tF\tBoltB\tBoltD\tcf1f\tcf2f\tcf3f\n",
    "#判断其他值是否相等，如果其他数值相等，说明是一类数据之内，则做EigenValue_diff_percent的数值计算\n",
    "# 前6个是基本几何参数，7-11是已经在bap中进行了筛选\n",
    "#15-17是受力状态一致\n",
    "            if df_hang.iloc[0, 1] == df_hang2.iloc[0, 1]\\\n",
    "            and df_hang.iloc[0, 2] == df_hang2.iloc[0, 2]\\\n",
    "            and df_hang.iloc[0, 3] == df_hang2.iloc[0, 3]\\\n",
    "            and df_hang.iloc[0, 4] == df_hang2.iloc[0, 4]\\\n",
    "            and df_hang.iloc[0, 7] == df_hang2.iloc[0, 7]\\\n",
    "            and df_hang.iloc[0, 15] == df_hang2.iloc[0, 15]\\\n",
    "            and df_hang.iloc[0, 16] == df_hang2.iloc[0, 16]\\\n",
    "            and df_hang.iloc[0, 17] == df_hang2.iloc[0,17]:\n",
    "                yindiff=df_selected_del.iloc[hang+1,yin_ori_num]/df_selected_del.iloc[hang,yin_ori_num]\n",
    "                df_selected_del.iloc[hang+1,numcolum]=yindiff*100#因变量特征值差异\n",
    "                zidiff=df_selected_del.iloc[hang+1,zi_ori_num]-df_selected_del.iloc[hang,zi_ori_num]\n",
    "                df_selected_del.iloc[hang+1,numcolum+1]=zidiff#自变量差异\n",
    "                \n",
    "    #判断其他值是否相等，如果其他数值不相等，说明是两类数据的边缘，则跳行\n",
    "            else:\n",
    "                df_selected_del.iloc[hang+1,numcolum]=0\n",
    "                df_selected_del.iloc[hang+1,numcolum+1]=df_selected_del.iloc[hang+1,zi_ori_num]\n",
    "            df_selected_del[yin_diff]= pd.to_numeric(df_selected_del[yin_diff])\n",
    "        df_selected_del\n",
    "#         df_selected_del.to_excel('df_selected_de1.xlsx')\n",
    "        return df_selected_del\n",
    "\n",
    "# ——————————分组组号函数——————————————\n",
    "    def cato(df_selected_del,yin_diff):\n",
    "        cato=1\n",
    "        for hang_cato in range (0,len(df_selected_del)-1):\n",
    "            df_selected_del.iloc[hang_cato,numcolum+3]=cato#pbol差异\n",
    "            if df_selected_del.iloc[hang_cato,columnnum_cato]!=df_selected_del.iloc[hang_cato+1,columnnum_cato]:\n",
    "                cato=cato+1\n",
    "            print('cato',cato)\n",
    "        #补齐最后一行\n",
    "        if df_selected_del.iloc[len(df_selected_del)-2,columnnum_cato]==df_selected_del.iloc[len(df_selected_del)-1,columnnum_cato]:\n",
    "            df_selected_del.iloc[len(df_selected_del)-1,numcolum+3]=cato\n",
    "        else:\n",
    "             df_selected_del.iloc[len(df_selected_del)-1,numcolum+3]=cato+1\n",
    "        df_selected_del=df_selected_del.copy()\n",
    "        df_selected_del['cato']= pd.to_numeric(df_selected_del['cato'])#转换格式\n",
    "\n",
    "        return df_selected_del\n",
    "# ———————————重新索引函数——————————————————\n",
    "    def df_reindex(df_selected_del):\n",
    "        df_selected_del = df_selected_del.reset_index(drop=True)\n",
    "        for indexnum in range(0,len(df_selected_del)):\n",
    "            df_selected_del.iloc[indexnum,0]=indexnum\n",
    "        return df_selected_del\n",
    "\n",
    "# —————————异常大小数值处理函数—————————————\n",
    "    def diffin_cato(df_selected_del,yin_diff):\n",
    "        for catonum in range(1,int(max(df_selected_del['cato'])+1)):\n",
    "            zero_time=0# 用来判断第几次达到0值\n",
    "            max_time=0# 用来判断第几次达到最大值\n",
    "            df_dd=df_selected_del[df_selected_del['cato'] ==catonum]# 同一个组\n",
    "            df_selected_del.drop(df_selected_del[(df_selected_del['cato']==catonum)].index,inplace=True)#   删除本cato\n",
    "            print('新的一轮catonum',catonum)\n",
    "            num_intrend=0\n",
    "            max_num_intrend=0\n",
    "\n",
    "            trend_list = pd.DataFrame(columns=df_dd.columns)\n",
    "            for df_ddhang in range(0,len(df_dd)):\n",
    "                if df_ddhang!=len(df_dd)-1:\n",
    "                    print('本轮整体数值',df_dd.iloc[df_ddhang,zi_ori_num],'行数',df_ddhang,'总行数',len(df_dd))\n",
    "                    if df_dd.iloc[df_ddhang,zi_ori_num]<df_dd.iloc[df_ddhang+1,zi_ori_num]:# 多少个连续增长，前一个小于后一个\n",
    "                        num_intrend=num_intrend+1#连续数值记账\n",
    "#                         print('本轮进入顺序累积，次数',num_intrend)\n",
    "\n",
    "                        if num_intrend>=max_num_intrend or df_dd.iloc[df_ddhang,zi_ori_num]>max(trend_list[zi_ori]):\n",
    "        #连续数值是否大过之前的最大值，则对trendlist进行累积\n",
    "                            max_num_intrend=num_intrend\n",
    "#                             trend_list=df_dd.iloc[df_ddhang-max_num_intrend+1:df_ddhang+1,:]#这里的问题是无法包住最后一个\n",
    "#                             print('df_dd.iloc[[df_ddhang]',df_dd.iloc[[df_ddhang]])\n",
    "                            trend_list=pd.concat([trend_list, df_dd.iloc[[df_ddhang]]] )#  df_ddhang外的双重[[]]是由于只取一行是series要转成df\n",
    "#                             print('当前最大值max_num_intrend',max_num_intrend)\n",
    "#                             print('trend_list')\n",
    "#                             print(trend_list)#这个的最后一次出现就是最大值\n",
    "\n",
    "                    if df_dd.iloc[df_ddhang,zi_ori_num]>df_dd.iloc[df_ddhang+1,zi_ori_num]:#破坏了趋势,重新计数\n",
    "                            num_intrend=0\n",
    "    #                         trend_list=[]# 这里不应该重置trendlist\n",
    "#                             print('本轮不进入顺序累积，次数num_intrend',num_intrend)\n",
    "#                             print('本轮不进入顺序累积，trendlist',trend_list)\n",
    "                if df_ddhang==len(df_dd)-1:# 判断一下最后一个数值\n",
    "                    if df_dd.iloc[df_ddhang,zi_ori_num]>df_dd.iloc[df_ddhang-1,zi_ori_num]:# 看最后一个和倒数第二个之间的关系\n",
    "\n",
    "                        trend_list=pd.concat([trend_list, df_dd.iloc[[df_ddhang]]] )\n",
    "\n",
    "            df_selected_del= pd.concat([df_selected_del, trend_list])\n",
    "\n",
    "        return df_selected_del\n",
    "# ——————————————————————————————————————————————————————————\n",
    "#                 if len(df_dd)<12:#判断剩余数值够不够六个，注意iloc左开右闭\n",
    "#                     if np.all(df_dd.iloc[df_ddhang:df_ddhang+6,zi_ori_num].reset_index(drop=True)==pd.Series([1,2,3,4,5,8]).reset_index(drop=True)):#   如果F连续数值，则只保留本组\n",
    "# #                         print('有1个连续值')\n",
    "# #                         如果有连续重复值，则将连续值之后的都删除\n",
    "#                         df_selected_del.drop(df_selected_del[(df_selected_del['cato']==catonum)].index,inplace=True)#   删除本cato\n",
    "#                         df_selected_del= pd.concat([df_selected_del, df_dd.iloc[df_ddhang:df_ddhang+6,:]])\n",
    "# #                         跳出循环本级循环\n",
    "#                         break\n",
    "#                   判断一下有几个连续增长数值，如果有两个，则筛选一下按照哪个座位baseline\n",
    "#                   如果趋势改变，则有几个最小值1，如果有两个，则筛选一下按照哪个座位baseline\n",
    "#                     if df_dd[df_ddhang,zi_ori_num]<df_dd[df_ddhang,zi_ori_num]# 多少个连续增长，前一个小于后一个\n",
    "        \n",
    "#                     num_F1=len(df_dd[df_dd['F']==1])# 最小值为1的数量\n",
    "#                     print('num_F1',num_F1)\n",
    "#                     if num_F1==2:#如果有两个\n",
    "# #                     if np.all(df_dd.iloc[df_ddhang:df_ddhang+6,zi_ori_num].reset_index(drop=True)==pd.Series([1,2,3,4,5,8]).reset_index(drop=True)):#   如果F连续数值，则只保留本组\n",
    "#                         print('有2个num_F1')\n",
    "# #                         如果有连续重复值，则将连续值之后的都删除\n",
    "# #                         df_selected_del.drop(df_selected_del[(df_selected_del['cato']==catonum)].index,inplace=True)#   删除本cato\n",
    "# #                         df_selected_del= pd.concat([df_selected_del, df_dd.iloc[df_ddhang:df_ddhang+6,:]])\n",
    "# #                         跳出循环本级循环\n",
    "#                         break\n",
    "#                     trend_list=df_dd.iloc[df_ddhang-max_num_intrend-1:df_ddhang,zi_ori_num]\n",
    "#                 print('trend_list')\n",
    "#                 print(trend_list)#这个的最后一次出现就是最大值\n",
    "# #     ——————————————————————————————————\n",
    "#                 if len(df_dd)>=12:#判断剩余数值够不够六个，如果不算F=10的话，则最多只有12个可能数值，所以只要不计算第1个，则可进行后面的选择\n",
    "# #                         如果有两个重复连续值，则只保留后面的一组\n",
    "# #                     print('有2组连续值，该组数值是',df_dd.iloc[0,0:13])\n",
    "# #                     print('df_dd.iloc[df_ddhang+1:df_ddhang+8,zi_ori_num]',df_dd.iloc[df_ddhang+1:df_ddhang+8,zi_ori_num])\n",
    "# #                     if np.all(df_dd.iloc[df_ddhang+6:df_ddhang+11,zi_ori_num].reset_index(drop=True)==\\\n",
    "# #                               pd.Series([1,2,3,4,5,8]).reset_index(drop=True)):#   如果F连续数值，则只保留本组\n",
    "#                     df_selected_del.drop(df_selected_del[(df_selected_del['cato']==catonum)].index,inplace=True)#   删除本cato\n",
    "#                     df_dd_pre=df_dd.sort_values(by=sort_list+['EigenValue'],axis=0,ascending=ascending_list).copy()# 排序\n",
    "#                     df_dd_pre=df_dd.drop_duplicates(subset=sort_list+[zi_ori],keep='last').copy()# 删除完全重复值\n",
    "\n",
    "#                     df_selected_del= pd.concat([df_selected_del, df_dd_pre])\n",
    "#                 break  \n",
    "\n",
    "# —————————计算差值函数（这个函数必须放在最后）—————————————\n",
    "    def cal_pbol_del(df_selected_del):\n",
    "        hang_del=0\n",
    "        for catonum in range(1,int(max(df_selected_del['cato'])+1)):\n",
    "            df_dd=df_selected_del[df_selected_del['cato'] ==catonum]# 同一个组\n",
    "            for df_ddhang in range(0,len(df_dd)):\n",
    "                pbol_deldiff=(df_dd.iloc[df_ddhang,yin_ori_num]-df_dd.iloc[0,yin_ori_num])/df_dd.iloc[0,yin_ori_num]\n",
    "                df_selected_del.iloc[hang_del,numcolum+2]=pbol_deldiff*100#自变量差异\n",
    "                hang_del=hang_del+1\n",
    "        df_selected_del['pbol_del']= pd.to_numeric(df_selected_del['pbol_del'])\n",
    "        return df_selected_del\n",
    "    def yindiff_zero(df_selected_del):      \n",
    "        for numdflen in range(0,len(df_selected_del)):\n",
    "            if df_selected_del.iloc[numdflen,numcolum+2]==0:\n",
    "#                 print('df_selected_del.iloc[numdflen,numcolum+2]',df_selected_del.iloc[numdflen,numcolum+2])\n",
    "                df_selected_del.iloc[numdflen,numcolum]=0\n",
    "        df_selected_del['yin_diff']= pd.to_numeric(df_selected_del['yin_diff'])\n",
    "        return df_selected_del\n",
    "# # —————————异常大趋势函数（总体是增长和下降）—————————————\n",
    "    def diffin_cato_trend(df_selected_del):\n",
    "        print('未删除时数量总数',len(df_selected_del))  \n",
    "        for catonum in range(1,int(max(df_selected_del['cato']))):\n",
    "            df_dd_posneg=df_selected_del[df_selected_del['cato'] ==catonum]# 同一个组\n",
    "            num_pos=len(df_dd_posneg[(df_dd_posneg[yin_diff]>100)&(df_dd_posneg[yin_diff]!=0)])# 组内上升数量\n",
    "            num_neg=len(df_dd_posneg[(df_dd_posneg[yin_diff]<100)&(df_dd_posneg[yin_diff]!=0)])# 组内下降数量\n",
    "            \n",
    "            if num_pos>=num_neg:#上升\n",
    "                df_selected_del.drop(df_selected_del[(df_selected_del['cato']==catonum)&(df_selected_del[yin_diff]<100)&(df_selected_del[yin_diff]!=0)].index-1,inplace=True)\n",
    "\n",
    "            if num_pos<num_neg:#下降\n",
    "                df_selected_del.drop(df_selected_del[(df_selected_del['cato']==catonum)&(df_selected_del[yin_diff]>100)&(df_selected_del[yin_diff]!=0)].index-1,inplace=True)\n",
    "#                 print('正少负多，删正值。删除后数据数量',len(df_selected_del))\n",
    "        return df_selected_del\n",
    "# # —————————异常小趋势函数（小趋势的增长和下降）—————————————\n",
    "    def diffin_cato_little_trend(df_selected_del):\n",
    "        for little_catonum in range(1,int(max(df_selected_del['cato']))):\n",
    "            df_dd_posneg=df_selected_del[df_selected_del['cato'] ==little_catonum]# 同一个组\n",
    "            num_pos=len(df_dd_posneg[(df_dd_posneg[yin_diff]>100)&(df_dd_posneg[yin_diff]!=0)])# 组内上升数量\n",
    "            num_neg=len(df_dd_posneg[(df_dd_posneg[yin_diff]<100)&(df_dd_posneg[yin_diff]!=0)])# 组内下降数量      \n",
    "\n",
    "            if len(df_dd_posneg)>1:\n",
    "\n",
    "                for df_trend_hang in range(0,len(df_dd_posneg)-1):#把上下跳动的删掉\n",
    "                    if num_pos>=num_neg:#上升\n",
    "                        if df_dd_posneg.iloc[df_trend_hang,numcolum+2]>df_dd_posneg.iloc[df_trend_hang+1,numcolum+2]:#下前一个比后一个高，前一个上升太快 \n",
    "                            last_diff_pbol_value=df_dd_posneg.iloc[len(df_dd_posneg)-1,numcolum+2]\n",
    "                            df_selected_del.drop(df_selected_del[(df_selected_del['cato']==little_catonum)# 删除上下跳动\n",
    "                                                                 &(df_selected_del['pbol_del']>last_diff_pbol_value)].index,inplace=True)\n",
    "                            drop_diff_pbol_value=df_dd_posneg.iloc[df_trend_hang,numcolum+2]\n",
    "                            df_selected_del.drop(df_selected_del[(df_selected_del['cato']==little_catonum)# 删除明显偏离 \n",
    "                                                                 &(df_selected_del['pbol_del']==drop_diff_pbol_value)].index,inplace=True)\n",
    "                        \n",
    "                    if num_pos<=num_neg:#下降\n",
    "                        if df_dd_posneg.iloc[df_trend_hang,numcolum+2]<df_dd_posneg.iloc[df_trend_hang+1,numcolum+2]:#前一个比后一个低，前一个下降太快                            drop_diff_pbol_value=df_dd_posneg.iloc[df_trend_hang,numcolum+3]\n",
    "                            last_diff_pbol_value=df_dd_posneg.iloc[len(df_dd_posneg)-1,numcolum+2]\n",
    "                            df_selected_del.drop(df_selected_del[(df_selected_del['cato']==little_catonum)# 删除明显偏离 \n",
    "                                                                 &(df_selected_del['pbol_del']==last_diff_pbol_value)].index,inplace=True)\n",
    "                            drop_diff_pbol_value=df_dd_posneg.iloc[df_trend_hang,numcolum+2]\n",
    "                            df_selected_del.drop(df_selected_del[(df_selected_del['cato']==little_catonum)# 删除上下跳动\n",
    "                                                                 &(df_selected_del['pbol_del']==drop_diff_pbol_value)].index,inplace=True)\n",
    "\n",
    "                    df_trend_hang=df_trend_hang+1\n",
    "        return df_selected_del\n",
    "# —————————————————————————————————————\n",
    "    for num_cyc in range(10):\n",
    "\n",
    "        df_selected_del1=cal_yin_diff(df_selected_del).copy()#计算差值\n",
    "        df_selected_del2=cato(df_selected_del1,yin_diff).copy()#组序号\n",
    "        df_selected_del3=cal_pbol_del(df_selected_del2).copy()\n",
    "        df_selected_del4=yindiff_zero(df_selected_del3).copy()   \n",
    "#         df_selected_del5=diffin_cato_trend(df_selected_del4).copy()\n",
    "\n",
    "\n",
    "\n",
    "#         df_selected_del4['pbol_del']= pd.to_numeric(df_selected_del4['pbol_del'])\n",
    "\n",
    "#         df_selected_del4.drop(df_selected_del4[(df_selected_del4['pbol_del']<-10)].index,inplace=True)\n",
    "#         df_selected_del4.drop(df_selected_del4[(df_selected_del4['pbol_del']>10)].index,inplace=True)\n",
    "#         df_selected_del6=diffin_cato_little_trend(df_selected_del4).copy()\n",
    "    \n",
    "        df_selected_del=df_reindex(df_selected_del4).copy()#重新index排序      \n",
    "        if len(df_selected_del)==len(df_selected_del1):\n",
    "            print('break','循环次数',num_cyc)\n",
    "            return df_selected_del\n",
    "            break          \n",
    "        print('循环次数',num_cyc,len(df_selected_del))\n",
    "    return df_selected_del\n",
    "df_selected_del12=diffmethod(df,general_list,general_list_number,sort_list,yin_diff,zi_diff)   \n",
    "print('行数',len(df_selected_del12))\n",
    "# df_selected_del12.to_excel('df_selected_del12.xlsx')\n",
    "df_selected_del=df_selected_del12\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7758fc65",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-05-11T16:05:45.455782Z",
     "start_time": "2023-05-11T16:05:45.444812Z"
    }
   },
   "source": [
    "#### 作图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "13090452",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.199973Z",
     "start_time": "2023-12-27T12:36:54.199973Z"
    },
    "code_folding": [
     31
    ]
   },
   "outputs": [],
   "source": [
    "from pylab import mpl\n",
    "from matplotlib.ticker import MultipleLocator,FormatStrFormatter\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis \n",
    "from matplotlib.colors import Normalize\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib.ticker as mtick\n",
    "\n",
    "pointsize=10\n",
    "textsize=12\n",
    "# xlinenum=11\n",
    "# ylinenum=12\n",
    "xlinenum=4\n",
    "ylinenum=4\n",
    "figsizex=2.5*ylinenum# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= figsizex/ylinenum*xlinenum\n",
    "controlpicnum=8\n",
    "labelsize=pointsize\n",
    "# plt.figure(figsize=(figsizex,figsizex))\n",
    "\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马  \n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "\n",
    "\n",
    "# # # ——————————散点图(每一张小图）——————————\n",
    "def pic_ktaucr_inpicolor_x_scatter(df_pre,div_colandlegend_para,x_aixs_para,y_aixs_para):\n",
    "# #     下面的函数定义是绘图用的\n",
    "    # 分类准备工作，这些都是针对‘颜色分类的参数’div_colandlegend_para\n",
    "    df_pre1=df_pre.reset_index(drop=True)#去掉行名\n",
    "    df_pre1[div_colandlegend_para].value_counts()#可能——数值统计\n",
    "    div_pic=df_pre1[div_colandlegend_para].sort_values()#可能——数值排序\n",
    "    div_pic.unique()#分颜色参数的唯一数值统计\n",
    "    num_diff_divpic=len(div_pic.value_counts())#可能——不同数值的数量\n",
    "# ——————构造颜色数值对应关系——————————\n",
    "    coltocmap=df[div_colandlegend_para].values#采用外层的df分颜色,所有数据的最小值\n",
    "    coltocmap_unique=list(df[div_colandlegend_para].sort_values().unique())\n",
    "#     minco=min(coltocmap)-((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))# colorbar的上下界进行一定程度的缩放\n",
    "#     maxco=max(coltocmap)+((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))\n",
    "\n",
    "    minco=min(df[div_colandlegend_para].values)#采用外层的df分颜色,所有数据的最小值\n",
    "    maxco=max(df[div_colandlegend_para].values)#采用外层的df分颜色,所有数据的最大值\n",
    "\n",
    "\n",
    "    num_scatter=[]\n",
    "# ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend in range(0,num_diff_divpic):\n",
    "        df_div_colandlegend=df_pre1[(df_pre1[div_colandlegend_para]==div_pic.unique()[num_colandlegend])]\n",
    "        #上面是可能——数值df建立\n",
    "        #如果最小值确实，则跳过；如果上升下降趋势点数量相同，则跳过\n",
    "\n",
    "        if min(df_div_colandlegend[x_aixs_para])!=min(df[x_aixs_para]) :\n",
    "#         or len(df_div_colandlegend[(df_div_colandlegend[yin_diff]>100)])==len(df_div_colandlegend[(df_div_colandlegend[yin_diff]<100)]): \n",
    "            continue\n",
    "        else:\n",
    "\n",
    "            df_div_colandlegend=df_div_colandlegend.reset_index(drop=True)#去掉行名    \n",
    "            #此处得到的df_div_colandlegend就是已经按照颜色分类过的dataframe\n",
    "            div_colandlegend_finalpre=df_div_colandlegend.sort_values(by=div_colandlegend_para,ascending=False)#单拿出来并排序 \n",
    "            div_colandlegend_final=div_colandlegend_finalpre.reset_index(drop=True)#去掉行名           \n",
    "            #  对本种颜色下进行循环构造画图的listdf，x轴从小到大\n",
    "            x_ks_plotlist =[]\n",
    "            y_ks_plotlist =[]\n",
    "            num_del=0\n",
    "    #——————把每个点循环并赋予颜色（一行一行的绘制，即一个点一个点的绘制），构造出来需要的list——————\n",
    "            for num_ks in range(0,len(div_colandlegend_final)):\n",
    "                x_ks=div_colandlegend_final.at[num_ks, x_aixs_para]\n",
    "                y_ks=div_colandlegend_final.at[num_ks, y_aixs_para]\n",
    "                z_ks=div_colandlegend_final.at[num_ks, div_colandlegend_para]\n",
    "                x_ks_plotlist.append(x_ks)\n",
    "                y_ks_plotlist.append(y_ks)\n",
    "                num_scatter.append(x_ks)\n",
    "            print('颜色变量',div_colandlegend_para,'最小',minco,'最大',maxco)\n",
    "            colorlmap_ks=(z_ks-minco)/(maxco-minco)\n",
    "            colorlmap_ks_list=np.full((len(div_colandlegend_final)-num_del,1),colorlmap_ks)\n",
    "    #————————————————小图内每个颜色的绘制——————————————————\n",
    "            axes_sub_fig.scatter(x_ks_plotlist,y_ks_plotlist,c=colorlmap_ks_list, cmap=colorltype, vmin=0, vmax=1,s=20,alpha=1)\n",
    "            print('自变量的数值',x_ks_plotlist,'颜色变量的数值',colorlmap_ks)\n",
    "            norm_plot = mpl.colors.Normalize(vmin=0, vmax=1)\n",
    "            cmap_plot = cm.get_cmap(colorltype)\n",
    "    #         norm = Normalize(vmin=0, vmax=1)\n",
    "            m_plot = cm.ScalarMappable(norm=norm_plot, cmap=cmap_plot)\n",
    "            axes_sub_fig.plot(x_ks_plotlist, y_ks_plotlist,c=m_plot.to_rgba(float(min(colorlmap_ks_list))))\n",
    "    if len(num_scatter)>=controlpicnum:\n",
    "    # ———————————colorbar的位置———————————  \n",
    "        divider = make_axes_locatable(plt.gca()) \n",
    "        cax = divider.append_axes(\"right\", \"5 %\",  pad =\"0%\")  \n",
    "    #———————————对颜色参数进行处理，以方便构造colorbar———————————  \n",
    "       #下面是采用实统一的数值来构造colorbar\n",
    "        colorbarpara=np.round(coltocmap_unique,0)\n",
    "    #——————————————colorbar设置————————————————————————————————\n",
    "        cmap = plt.get_cmap(colorltype) #获取颜色类型\n",
    "        #对颜色类型进行最大最小值正则化，这里的vmin和vmax指的是填充colorbar的区域\n",
    "        norm = mpl.colors.Normalize(vmin=min(colorbarpara), vmax= max(colorbarpara))\n",
    "        scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)#提供一个可以映射颜色的对象\n",
    "    # #——————————————colorbar右侧数字的设置————————————————————————————————\n",
    "    #     cb = \n",
    "        plt.colorbar(scalarMap,cax=cax, orientation=\"vertical\") \n",
    "    #     labels =np.round(colorbarpara,0)#指的是cb标签的数字\n",
    "    #     loc    =np.round(colorbarpara,0)#指的是cb横线的位置\n",
    "    #     cb.set_ticks(loc) \n",
    "    #     cb.set_ticklabels(labels)  \n",
    "    #     cb.ax.tick_params(labelsize=labelsize)\n",
    "    return len(num_scatter)\n",
    "# # # ——————————————def函数定义结束————————————————————————————————  \n",
    "\n",
    "# # ——————————预设信息设置————————\n",
    "colorltype=str('viridis')\n",
    "# prelist=list(df['KG_quge_web'].sort_values().unique())\n",
    "# 筛选\n",
    "# para_without_para=str('F')\n",
    "# para_without_paranum=2 and 3\n",
    "# # 分图后df\n",
    "# div_pic_para=str('KG_quge_web')\n",
    "# 图内分类型参数（变色或者变形状）\n",
    "# div_colandlegend_para_list=['L']\n",
    "div_colandlegend_para_list=sort_list[len(sort_list)-1]# sort_list里面最后一个就是分色参数\n",
    "# ['KG_quge_web','KH_quge_web','KG_consedge_flange','KH_consedge_flange']\n",
    "# div_colandlegend_para_list=df.columns\n",
    "# div_colandlegend_para_list=['KG_quge_web']\n",
    "# div_colandlegend_para=str('KG_total_web')['B', 'H','L', 'T1', 'T2', 'n']\n",
    "# # x_轴\n",
    "x_aixs_paralist=[zi_ori]\n",
    "# x_aixs_paralist=['H']\n",
    "# x_aixs_para=df.columns\n",
    "# y_轴\n",
    "# y_aixs_para=str('yin_diff')\n",
    "# yin_diff，pbol_del, SFcf2f yin_ori\n",
    "y_aixs_para=yin_ori\n",
    "# 分图筛选一下\n",
    "# 参数KG_quge_web，KH_quge_web，ratio_alpha_Bflange_to_Hn，ratio_alpha_tflange_to_tweb，pbol_del，EigenValue\n",
    "# ['B', 'H','L', 'T1', 'T2', 'n','ratio_alpha_Bflange_to_Hn','KH_quge_web']\n",
    "div_para_list=sort_list[0]# ['H']#第一层筛选参数\n",
    "div_para_half_list=[sort_list[1]]#第一层半筛选参数\n",
    "div_para_half_prelist=[sort_list[2]]#第二层前筛选参数\n",
    "div_para_sechalf_prelist=[sort_list[3]]#第最后一层筛选参数\n",
    "div_para_second_list=[sort_list[3]]#第二层筛选参数\n",
    "\n",
    "\n",
    "\n",
    "# dfori=df[df[para_without_para]==para_without_paranum]\n",
    "print('sort_list',sort_list)\n",
    "  \n",
    "numaxsub=0\n",
    "# 筛选拼接数量n，用的是函数中的第一个参数\n",
    "# df=df_selected_del[(df_selected_del['n']!=1)&(df_selected_del['n']!=1)]# 这个df_pre已经筛选完了‘不需要的参数’和它“不需要的参数”\n",
    "df=df_selected_del\n",
    "\n",
    "plt.figure(figsize=(figsizex,figsizey))\n",
    "# #————————分割图形的筛选方法（筛选第一层）——————————\n",
    "for num_div_para in range(0,len(div_para_list)):\n",
    "    df_pre_df_para=df.reset_index(drop=True)#去掉行名\n",
    "    div_para=div_para_list[num_div_para]\n",
    "    div_pic_df_para=df_pre_df_para[div_para].sort_values()#可能——数值排序\n",
    "    len_diff_divpic_df_para=len(div_pic_df_para.value_counts())#可能——不同数值的数量\n",
    "    \n",
    "    # ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend_df_para in range(0,len_diff_divpic_df_para):\n",
    "        df_second=df_pre_df_para[(df_pre_df_para[div_para]==div_pic_df_para.unique()[num_colandlegend_df_para])]\n",
    "\n",
    "# #————————第一层筛选结束——————————    \n",
    "# #————————分割图形的筛选方法（筛选一层半）——————————\n",
    "        for num_div_half_para in range(0,len(div_para_half_list)):\n",
    "            df_pre_df_half_para=df_second.reset_index(drop=True)#去掉行名\n",
    "            div_half_para=div_para_half_list[num_div_half_para]\n",
    "            div_pic_df_half_para=df_pre_df_half_para[div_half_para].sort_values()#可能——数值排序\n",
    "            len_diff_divpic_df_half_para=len(div_pic_df_half_para.value_counts())#可能——不同数值的数量\n",
    "\n",
    "            # ——————对每一种颜色数值关系都作图——————————\n",
    "            for num_colandlegend_df_half_para in range(0,len_diff_divpic_df_half_para):\n",
    "                df_half=df_pre_df_half_para[(df_pre_df_half_para[div_half_para]==div_pic_df_half_para.unique()[num_colandlegend_df_half_para])]\n",
    "#                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                #连接两种作用的函数的df\n",
    "        # #————————第层半筛选结束——————————    \n",
    "                # #————————分割图形的筛选方法（筛选二层前）——————————\n",
    "                for num_div_half_prepara in range(0,len(div_para_half_prelist)):\n",
    "                    df_pre_df_half_prepara=df_half.reset_index(drop=True)#去掉行名\n",
    "                    div_half_prepara=div_para_half_prelist[num_div_half_prepara]\n",
    "                    div_pic_df_half_prepara=df_pre_df_half_prepara[div_half_prepara].sort_values()#可能——数值排序\n",
    "                    len_diff_divpic_df_half_prepara=len(div_pic_df_half_prepara.value_counts())#可能——不同数值的数量\n",
    "        #             plt.figure(figsize=(figsizex,figsizey))\n",
    "                    # ——————对每一种颜色数值关系都作图——————————\n",
    "                    for num_colandlegend_df_half_prepara in range(0,len_diff_divpic_df_half_prepara):\n",
    "                        df_sechalf=df_pre_df_half_prepara[(df_pre_df_half_prepara[div_half_prepara]==div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])]\n",
    "        #                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                        #连接两种作用的函数的df\n",
    "        \n",
    "                        # #————————分割图形的筛选方法（筛选二层前F）——————————\n",
    "                        for num_div_sechalf_prepara in range(0,len(div_para_sechalf_prelist)):\n",
    "                            df_pre_df_sechalf_prepara=df_sechalf.reset_index(drop=True)#去掉行名\n",
    "                            div_sechalf_prepara=div_para_sechalf_prelist[num_div_sechalf_prepara]\n",
    "                            div_pic_df_sechalf_prepara=df_pre_df_sechalf_prepara[div_sechalf_prepara].sort_values()#可能——数值排序\n",
    "                            len_diff_divpic_df_sechalf_prepara=len(div_pic_df_sechalf_prepara.value_counts())#可能——不同数值的数量\n",
    "                #             plt.figure(figsize=(figsizex,figsizey))\n",
    "                            # ——————对每一种颜色数值关系都作图——————————\n",
    "                            for num_colandlegend_df_sechalf_prepara in range(0,len_diff_divpic_df_sechalf_prepara):\n",
    "                                df_prehalf=df_pre_df_sechalf_prepara[(df_pre_df_sechalf_prepara[div_sechalf_prepara]==div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara])]\n",
    "                #                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                                #连接两种作用的函数的df\n",
    "                # #————————第二层前筛选结束——————————   \n",
    "\n",
    "                #————————分割图形的筛选方法（筛选第第二层）——————————\n",
    "                                for num_div_second_para in range(0,len(div_para_second_list)):\n",
    "                                    if len(df_prehalf)<controlpicnum:\n",
    "                                        continue\n",
    "                                    else:\n",
    "                                        df_pre_df_second_para=df_prehalf.reset_index(drop=True)#去掉行名\n",
    "                                        div_second_para=div_para_second_list[num_div_second_para]\n",
    "                                        div_pic_df_second_para=df_pre_df_second_para[div_second_para].sort_values()#可能——数值排序\n",
    "                                        len_diff_divpic_df_second_para=len(div_pic_df_second_para.value_counts())#可能——不同数值的数量\n",
    "                                        # ——————对每一种颜色数值关系都作图——————————\n",
    "                                        for num_colandlegend_df_second_para in range(0,len_diff_divpic_df_second_para):\n",
    "                                            df_div_para_second_colandlegend=df_pre_df_second_para[(df_pre_df_second_para[div_second_para]==div_pic_df_second_para.unique()[num_colandlegend_df_second_para])]\n",
    "                                            df_pre=df_div_para_second_colandlegend #连接两种作用的函数的df\n",
    "\n",
    "\n",
    "                                            print('本轮数值数量',len(df_pre))\n",
    "                                            print('第一层参数',div_para,div_pic_df_para.unique()[num_colandlegend_df_para],type(div_pic_df_para.unique()[num_colandlegend_df_para]))\n",
    "                                            print('第一层半参数',div_half_para,div_pic_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                                            print('第二层前参数',div_half_prepara,div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])\n",
    "                                            print('第二层参数',div_sechalf_prepara,div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara])\n",
    "                                            print('最后一层参数',div_second_para,div_pic_df_second_para.unique()[num_colandlegend_df_second_para])\n",
    "\n",
    "                                            numaxsub=numaxsub+1\n",
    "                                            axes_sub_fig=plt.subplot(xlinenum,ylinenum,numaxsub)# 小图排布\n",
    "                            # # #————————第二层筛选结束——————————    \n",
    "                                            for i in range(0,len(x_aixs_paralist)):\n",
    "                                                x_aixs_para=x_aixs_paralist[i]\n",
    "                                                #——————每一张大图内一点一点画小图，主要作用——————————————————\n",
    "                                                for j in range(0,len(div_colandlegend_para_list)):\n",
    "                                                    div_colandlegend_para=div_colandlegend_para_list[j]\n",
    "                                                    pointnum=pic_ktaucr_inpicolor_x_scatter(df_pre,div_colandlegend_para,x_aixs_para,y_aixs_para) \n",
    "                                                    textlegend=round(div_pic_df_para.unique()[num_colandlegend_df_para],0)#小数位数,2\n",
    "#                                                     if dfpp['type'].all()==0 or dfpp['type'].all()==1:\n",
    "#                                                         axes_sub_fig.text(0.15,1.02,str('%.0f'%div_pic_df_para.unique()[num_colandlegend_df_para])+str('×')\n",
    "#                                                                       +str('%.0f'%div_pic_df_half_para.unique()[num_colandlegend_df_half_para])+str('×')\n",
    "#                                                                       +str('%.0f'%div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])+str('×')                                              \n",
    "#                                                                       +str('%.0f'%div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara]),\n",
    "#                                                                         fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "#                                                     if dfpp['type'].all()==2:\n",
    "                                                    axes_sub_fig.text(0.05,1.02,str('%.0f'%div_pic_df_para.unique()[num_colandlegend_df_para])+str('×')\n",
    "                                                                  +str('%.0f'%div_pic_df_half_para.unique()[num_colandlegend_df_half_para])+str('×')\n",
    "                                                                  +str('%.0f'%div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])+str('×')                                              \n",
    "                                                                  +str('%.0f'%div_pic_df_sechalf_prepara.unique()[num_colandlegend_df_sechalf_prepara])+str('  ')  \n",
    "                                                                  +str(div_second_para)           \n",
    "                                                                  +str('%.0f'%div_pic_df_second_para.unique()[num_colandlegend_df_second_para]),\n",
    "                                                                    fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                                                    axes_sub_fig.text(1.02,1.02,'$'+div_colandlegend_para_list[0]+'$',fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    " \n",
    "#                                                     if pointnum<controlpicnum:\n",
    "#                                                         numaxsub=numaxsub-1\n",
    "#                                                         axes_sub_fig.remove()\n",
    "\n",
    "\n",
    "\n",
    "                                        #                 axes_sub_fig.text(0.4,0.75,str(r'$\\alpha_{\\mathrm{wKH}}$')+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                                        #                 axes_sub_fig.text(0.2,0.6,str(r'$\\alpha_{\\mathrm{BtHn}}$')+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                                        #                 axes_sub_fig.text(0.4,0.75,str(div_para)+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "\n",
    "                                #-----------------------单独的图纸设置--------------------------------------------\n",
    "\n",
    "                            #                 axes_sub_fig.set_xlabel(str(r'$t_\\mathrm{f}/t_\\mathrm{w}$'),fontsize=textsize)\n",
    "                            #                 axes_sub_fig.set_ylabel(r'$k_{\\mathrm{fem}}$',fontsize=textsize)\n",
    "\n",
    "                #                     axes_sub_fig.yaxis.set_major_formatter(mtick.FormatStrFormatter('%.0f'))\n",
    "#                                     axes_sub_fig.ticklabel_format(axis=\"y\", style=\"sci\", scilimits=(0,6))#表示对范围之外的值换科学记数法，范围内的数不换；\n",
    "                #                     axes_sub_fig.ticklabel_format(axis=\"x\", style=\"sci\", scilimits=(50,300))\n",
    "\n",
    "\n",
    "                #                     axes_sub_fig.set_xlabel('螺栓预拉力(kN)', fontproperties=font_setS)\n",
    "#                                             axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$'+'(mm)', fontproperties=font_setS)\n",
    "#                                             axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$'+'(mm)', fontproperties=font_setS)\n",
    "                                            axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$', fontproperties=font_setS)                           \n",
    "#                                   axes_sub_fig.set_ylabel('临界力(kN)', fontproperties=font_setS)           \n",
    "\n",
    "        # # 横坐标n，分图L\n",
    "                                            if x_aixs_paralist==['n']:\n",
    "                                                axes_sub_fig.set_xlim(0,7)\n",
    "                                                xmajorLocator = MultipleLocator(1)\n",
    "                                                axes_sub_fig.xaxis.set_major_locator(xmajorLocator)\n",
    "#                                                 axes_sub_fig.set_xticks([1,2,3,4,5,6])# x轴标签\n",
    "\n",
    "\n",
    "                                                if y_aixs_para==str('pbol_del'):\n",
    "#                                                     axes_sub_fig.set_ylim(-50,50)\n",
    "#                                                     ymajorLocator = MultipleLocator(10)\n",
    "#                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#                                                     axes_sub_fig.set_ylim(-20,10)\n",
    "#                                                     ymajorLocator = MultipleLocator(5)\n",
    "#                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "                                                    axes_sub_fig.set_ylim(-10,10)\n",
    "                                                    ymajorLocator = MultipleLocator(5)\n",
    "                                                    axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "                                                    if yin_ori==str('SLcf2f'):\n",
    "                                                        axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "                                                    if yin_ori==str('SFcf2f'):\n",
    "                                                        axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "                                            if y_aixs_para==str('SFcf2f'):\n",
    "                                                axes_sub_fig.set_ylim(0,1)\n",
    "\n",
    "        # # 横坐标L，分图n\n",
    "                                            if x_aixs_paralist==['L']:\n",
    "                                                axes_sub_fig.set_xlim(0,4500)\n",
    "                                                xmajorLocator = MultipleLocator(1000)\n",
    "                                                axes_sub_fig.xaxis.set_major_locator(xmajorLocator) \n",
    "#                                                 axes_sub_fig.set_xticks([1000,2000,3000,4000])# x轴标签\n",
    "                                                if y_aixs_para==str('pbol_del'):\n",
    "#                                                     if y_aixs_para==str('pbol_del'):\n",
    "#                                                     axes_sub_fig.set_ylim(0,1000)\n",
    "    #                                                     ymajorLocator = MultipleLocator(200)\n",
    "    #                                                     axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "\n",
    "                                                    axes_sub_fig.set_ylim(-100,0)\n",
    "                                                    ymajorLocator = MultipleLocator(20)\n",
    "                                                    axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "                                                    if yin_ori==str('SLcf2f'):\n",
    "                                                        axes_sub_fig.set_ylim(0,300)\n",
    "                                                        ymajorLocator = MultipleLocator(100)\n",
    "                                                        axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "                                                        axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "                                                    if yin_ori==str('SFcf2f'):\n",
    "                                                        axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "   \n",
    "\n",
    "            # # 横坐标n，分图L\n",
    "#                                             if x_aixs_paralist==['F']:\n",
    "#                                                 axes_sub_fig.set_xlim(1,5)\n",
    "#                                                 xmajorLocator = MultipleLocator(1)\n",
    "#             #                                                 axes_sub_fig.set_xticks([1,2,3,4,5])# x轴标签\n",
    "\n",
    "            #纵坐标\n",
    "#                                             if y_aixs_para==str('SLcf2f'):\n",
    "#                                                 axes_sub_fig.set_ylim(0,3)\n",
    "#                                                 ymajorLocator = MultipleLocator(0.5)\n",
    "#                                                 axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "\n",
    "#                                             if y_aixs_para==str('SFcf2f'):\n",
    "#                                                 axes_sub_fig.set_ylim(0,4500)\n",
    "#                                                 ymajorLocator = MultipleLocator(1000)\n",
    "#                                                 axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "\n",
    "\n",
    "#                                             if y_aixs_para==str('pbol_del'):\n",
    "#                                                 axes_sub_fig.set_ylim(0,1000)\n",
    "#                                                 ymajorLocator = MultipleLocator(200)\n",
    "#                                                 axes_sub_fig.yaxis.set_major_locator(ymajorLocator) \n",
    "#                                                 if yin_ori==str('SLcf2f'):\n",
    "#                                                     axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "#                                                 if yin_ori==str('SFcf2f'):\n",
    "#                                                     axes_sub_fig.set_ylabel(str(r'$\\phi$'+'变化率(%)'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "\n",
    "\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show\n",
    "plt.savefig(r'R:\\PhDall\\matplotilibpic\\\\'+str('colorsdivlittle6')+x_aixs_para+'.svg')#保存图   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3b1afbdc",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.201969Z",
     "start_time": "2023-12-27T12:36:54.201969Z"
    }
   },
   "outputs": [],
   "source": [
    "df_selected_del=df_selected_del[df_selected_del['n']!=1].copy()\n",
    "\n",
    "# ————————————— 物理参数几何参数相关性绘图————————————\n",
    "# %matplotlib inline\n",
    "from matplotlib.font_manager import FontProperties\n",
    "import latex\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.axes_grid1 import make_axes_locatable\n",
    "textsize=14\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "figsizex= 12# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= 12\n",
    "plt.figure(figsize=[figsizex,figsizey])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "linewidth=2\n",
    "pointsize=14\n",
    "colorltype=str('viridis')\n",
    "labelsize=12\n",
    "commonx_x=str('pbol')\n",
    "commonx_y=str('yin_diff')\n",
    "commonx_c_list=['KG_total_web']\n",
    "# commonx_c_list=['H','B','T1','T2','L','n','pbol','F','cf1f', 'cf2f', 'cf3f','EigenValue','Bcf1f', 'Bcf2f', 'Bcf3f', 'Pucf1f',\n",
    "#                'KG_quge_web','KG_total_web','KG_total_web','k_taucr_fem2','k_taucr_fem2_n']\n",
    "\n",
    "\n",
    "def diffpic(commonx_x,commonx_y,commonx_c):\n",
    "# ——————图形基本参数——————————\n",
    "    # plt.xticks(np.linspace(0,3,13,endpoint=True),size=14)# x轴标签\n",
    "    # plt.yticks(np.linspace(5,45,9,endpoint=True),size=14)# y轴标签  \n",
    "    plt.xticks(size=textsize)# x轴标签\n",
    "    plt.yticks(size=textsize)# y轴标签  \n",
    "    # plt.xlim(0,3)\n",
    "    # plt.ylim(5,45)\n",
    "    plt.xlabel(commonx_x,fontsize=textsize)\n",
    "    plt.ylabel(commonx_y,fontsize=textsize)\n",
    "    # ——————构造颜色数值对应关系——————————\n",
    "    coltocmap=df_selected_del[commonx_c].values\n",
    "    coltocmap_unique=list(df_selected_del[commonx_c].sort_values().unique())\n",
    "    if len(coltocmap_unique)!=1:\n",
    "        minco=min(coltocmap)-((max(coltocmap)-min(coltocmap))/((len(coltocmap_unique)-1)*2))\n",
    "        maxco=max(coltocmap)+((max(coltocmap)-min(coltocmap))/((len(coltocmap_unique)-1)*2))\n",
    "    if len(coltocmap_unique)==1:    \n",
    "        minco=min(coltocmap)\n",
    "        maxco=max(coltocmap)\n",
    "    for catonum in range(0,int(max(df_selected_del['cato']))):\n",
    "        df_plo=df_selected_del[df_selected_del['cato']==catonum]\n",
    "        df_plo.sort_values(by=['cato'],axis = 0)\n",
    "        plt.scatter(df_plo[commonx_x].values,abs(df_plo[commonx_y].values),c=(df_plo[commonx_c].values-minco)/maxco,s=pointsize)#绘图命令\n",
    "    #——————————————colorbar设置————————————————————————————————\n",
    "    # ———————————colorbar的位置———————————  \n",
    "    divider = make_axes_locatable(plt.gca()) \n",
    "    cax = divider.append_axes(\"right\", \"5 %\",  pad =\"0%\")  \n",
    "    #———————————对颜色参数进行处理，以方便构造colorbar———————————  \n",
    "    if len(coltocmap_unique)!=1:\n",
    "        minco_colorbar=min(coltocmap_unique)-((max(coltocmap_unique)-min(coltocmap_unique))/((len(coltocmap_unique)-1)*2))\n",
    "        maxco_colorbar=max(coltocmap_unique)+((max(coltocmap_unique)-min(coltocmap_unique))/((len(coltocmap_unique)-1)*2))\n",
    "    if len(coltocmap_unique)==1:          \n",
    "        minco_colorbar=min(coltocmap_unique)\n",
    "        maxco_colorbar=max(coltocmap_unique)\n",
    "        colorbarparadiff=(maxco_colorbar-minco_colorbar)/1000\n",
    "    #下面是采用平均的数值来构造colorbar\n",
    "    # colorbarparadiff=(maxco_colorbar-minco_colorbar)/10\n",
    "    # colorbarpara=[minco_colorbar]+[minco_colorbar+colorbarparadiff*1]+[minco_colorbar+colorbarparadiff*2]+[minco_colorbar+colorbarparadiff*3]+[minco_colorbar+colorbarparadiff*4]+[minco_colorbar+colorbarparadiff*5]+[minco_colorbar+colorbarparadiff*6]+[minco_colorbar+colorbarparadiff*7]+[minco_colorbar+colorbarparadiff*8]+[minco_colorbar+colorbarparadiff*9]+[maxco_colorbar]\n",
    "    #下面是采用实际的可能的数值来构造colorbar\n",
    "    colorbarpara=[minco_colorbar]+coltocmap_unique+[maxco_colorbar]\n",
    "    cmap = plt.get_cmap(colorltype) #获取颜色类型\n",
    "    #对颜色类型进行最大最小值正则化，这里的vmin和vmax指的是填充colorbar的区域\n",
    "    norm = mpl.colors.Normalize(vmin=min(colorbarpara), vmax= max(colorbarpara))\n",
    "    scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)#提供一个可以映射颜色的对象 \n",
    "    # #——————————————colorbar右侧数字的设置————————————————————————————————\n",
    "    cb = plt.colorbar(scalarMap,cax=cax, orientation=\"vertical\") \n",
    "    #     if maxco_colorbar<1:\n",
    "    #     labels =np.round(colorbarpara,2)#指的是cb标签的数字\n",
    "    #     loc    =np.round(colorbarpara,2)#指的是cb横线的位置\n",
    "    #     else:\n",
    "    labels =np.round(colorbarpara,2)#指的是cb标签的数字\n",
    "    loc    =np.round(colorbarpara,2)#指的是cb横线的位置\n",
    "    cb.set_ticks(loc) \n",
    "    cb.set_ticklabels(labels)  \n",
    "    cb.ax.tick_params(labelsize=labelsize)\n",
    "    for labels in cb.ax.yaxis.get_ticklabels()[::len(coltocmap_unique)+1]:# 隐藏掉最大值和最小值\n",
    "        labels.set_visible(False)\n",
    "    plt.colorbar\n",
    "    #——————————————colorbar设置————————————————————————————————\n",
    "    bwith = 1 #边框宽度设置为2\n",
    "    TK = plt.gca()#获取边框\n",
    "    TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "    TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "    TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "    TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "    TK.spines[:].set_color('black')\n",
    "    pltsvgname=str('物理参数几何参数相关性绘图') #保存名字\n",
    "    plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "    plt.show()\n",
    " \n",
    "\n",
    "for commonx_c in commonx_c_list:\n",
    "    diffpic(commonx_x,commonx_y,commonx_c)\n",
    "# plt.hist(df_selected_del[yin_diff].values, bins=50)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "52155113",
   "metadata": {},
   "source": [
    "### 三维关系图（3D三点图）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bfe0f7cb",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize pca scores via triplot\n",
    "fig = plt.figure()\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "# ax.scatter(pca_scores['PC1'], pca_scores['PC2'], pca_scores['PC3'], c='b')\n",
    "ax.set_xlabel('PC1')\n",
    "ax.set_ylabel('PC2')\n",
    "ax.set_zlabel('PC3')\n",
    "scatter = ax.scatter(\n",
    "    data_var[x].values,\n",
    "    data_var[y].values,\n",
    "    data_var[z].values,\n",
    "    c='navy',\n",
    "    s=30,\n",
    "    alpha=0.8,\n",
    "    edgecolors='w',\n",
    "    marker='o'\n",
    ")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0a1f0aeb",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.202965Z",
     "start_time": "2023-12-27T12:36:54.202965Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "from matplotlib.font_manager import FontProperties\n",
    "data_var = df_all_dic[(df_all_dic[str('type')] == 0)].copy()\n",
    "plt.rcParams.update({\n",
    "    \"font.family\": \"Times New Roman\",\n",
    "    \"font.size\": 12,\n",
    "    \"axes.labelsize\": 14,\n",
    "    \"axes.titlesize\": 16,\n",
    "    \"xtick.labelsize\": 12,\n",
    "    \"ytick.labelsize\": 12,\n",
    "    \"legend.fontsize\": 12,\n",
    "    \"figure.dpi\": 300,\n",
    "    \"savefig.dpi\": 300,\n",
    "    \"axes.linewidth\": 1.2,\n",
    "    \"xtick.major.width\": 1.2,\n",
    "    \"ytick.major.width\": 1.2,\n",
    "    \"grid.linestyle\": \"--\",\n",
    "    \"grid.linewidth\": 0.8,\n",
    "    \"grid.color\": \"gray\",\n",
    "})\n",
    "\n",
    "font_path = r\"C:\\Windows\\Fonts\\simsun.ttc\"\n",
    "font_cn = FontProperties(fname=font_path, size=14)\n",
    "\n",
    "fig = plt.figure(figsize=(10, 8), facecolor='white')  # 增大图形尺寸\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "\n",
    "x = 'cf1f'\n",
    "y = 'cf2f'\n",
    "z = 'cf3f'\n",
    "\n",
    "scatter = ax.scatter(\n",
    "    data_var[x].values,\n",
    "    data_var[y].values,\n",
    "    data_var[z].values,\n",
    "    c='navy',\n",
    "    s=30,\n",
    "    alpha=0.8,\n",
    "    edgecolors='w',\n",
    "    marker='o'\n",
    ")\n",
    "\n",
    "# # 设置坐标轴标签（调整Z轴标签位置和旋转）\n",
    "ax.set_xlabel(r'$cf1f$', fontproperties=font_cn)\n",
    "ax.set_ylabel(r'$cf2f$', fontproperties=font_cn)\n",
    "ax.set_zlabel(r'$H$', fontproperties=font_cn, \n",
    "             rotation=60,  # 调整标签旋转角度\n",
    "             labelpad=20,  # 增加标签与轴的距离\n",
    "             ha='left',    # 水平对齐方式设为左对齐（避免靠右溢出）\n",
    "             va='bottom')  # 垂直对齐方式\n",
    "# # 设置刻度（确保x和y轴刻度范围合理）\n",
    "# ax.set_xticks([0, 0.577, 1, 1.732])\n",
    "# ax.set_yticks([0, 1])\n",
    "\n",
    "# # 设置坐标轴比例和范围\n",
    "# ax.set_box_aspect([1, 1, 1])  # 强制坐标轴比例一致\n",
    "# ax.set_xlim(0, 2)\n",
    "# ax.set_ylim(0, 1.5)\n",
    "# ax.set_zlim(0, max(data_var[z].values)*1.1)\n",
    "\n",
    "# # 调整视角\n",
    "ax.view_init(elev=20, azim=45)  # 更优化的视角\n",
    "\n",
    "# # 设置刻度宽度和颜色\n",
    "# ax.tick_params(axis='x', direction='in', width=1.2)\n",
    "# ax.tick_params(axis='y', direction='in', width=1.2)\n",
    "# ax.tick_params(axis='z', direction='in', width=1.2)\n",
    "\n",
    "# # 扩大图形边距（防止标签被截断）\n",
    "# plt.subplots_adjust(left=0.15, right=0.9, top=0.95, bottom=0.15)  # 调整左右上下边距\n",
    "\n",
    "# plt.tight_layout(pad=2)\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8658dee6",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.204961Z",
     "start_time": "2023-12-27T12:36:54.204961Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.scatter(df['H'].values ,df['B'].values,c='blue',alpha=1)\n",
    "# min(df['H'].values/df['T1'].values)\n",
    "# max(df['H'].values/df['T1'].values)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66df058d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.205958Z",
     "start_time": "2023-12-27T12:36:54.205958Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.scatter(df['H'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['H'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['H'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['B'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['B'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['B'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['T1'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['T1'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['T1'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['T2'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['T2'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['T2'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['n'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['n'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['n'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['L'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['L'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "plt.show()\n",
    "plt.scatter(df['L'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5aebf87f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-12-27T12:36:54.206955Z",
     "start_time": "2023-12-27T12:36:54.206955Z"
    }
   },
   "outputs": [],
   "source": [
    "# plt.scatter(df['axialratio'].values ,df['Bcf1f'].values,c='blue',alpha=1)\n",
    "# plt.show()\n",
    "# plt.scatter(df['axialratio'].values ,df['Bcf2f'].values,c='red',alpha=1)\n",
    "# plt.show()\n",
    "# plt.scatter(df['axialratio'].values ,df['Bcf3f'].values,c='g',alpha=1)\n",
    "# plt.show()\n",
    "# plt.scatter(df['axialratio'].values ,df['Pucf1f'].values,c='blue',alpha=1)\n",
    "# plt.show()\n",
    "# plt.scatter(df['axialratio'].values ,df['Pucf2f'].values,c='red',alpha=1)\n",
    "# plt.show()\n",
    "# plt.scatter(df['axialratio'].values ,df['Pucf3f'].values,c='g',alpha=1)\n",
    "# plt.show()\n",
    "# plt.scatter(df['axialratio'].values ,df['SFcf2f'].values,c='g',alpha=1)\n",
    "# plt.show()\n",
    "plt.scatter(df['SLcf2f'].values ,df['SFcf2f'].values,c='g',alpha=1)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89a1e568",
   "metadata": {},
   "source": [
    "## 雷达图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7f97fdea",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "# 设置随机种子以保证结果可复现\n",
    "np.random.seed(42)\n",
    "\n",
    "# 生成示例数据\n",
    "data = {\n",
    "    '参数1': np.random.randint(1, 10, 50),\n",
    "    '参数2': np.random.uniform(0.5, 2, 50),\n",
    "    '参数3': np.random.randint(20, 80, 50),\n",
    "    '参数4': np.random.uniform(0.1, 1, 50),\n",
    "    '参数5': np.random.randint(5, 15, 50),\n",
    "    '参数6': np.random.uniform(1, 5, 50),\n",
    "    '参数7': np.random.randint(10, 30, 50),\n",
    "    '参数8': np.random.uniform(0.2, 0.8, 50)\n",
    "}\n",
    "\n",
    "# 创建 DataFrame\n",
    "df = pd.DataFrame(data)\n",
    "\n",
    "# 输出数据集的前几行\n",
    "print(df.head())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9b120768",
   "metadata": {},
   "source": [
    "## 平行坐标图（Parallel Coordinates Plot）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b87f8f46",
   "metadata": {},
   "outputs": [],
   "source": [
    "import seaborn as sns\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 假设 data 是你的数据集，包含七八个参数列\n",
    "data = df\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from pandas.plotting import parallel_coordinates\n",
    "\n",
    "# 假设 data 是你的数据集，包含七八个参数列\n",
    "# data = pd.read_csv('your_data.csv')\n",
    "\n",
    "# 绘制平行坐标图\n",
    "parallel_coordinates(data, '参数8')  # 'category_column' 是用于区分不同类别的列\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f2c8454",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "# 假设df是数据集，参数为param1、param2、...、param8\n",
    "cross_tab = pd.crosstab(df['参数1'], df['参数2'], values=df['参数3'], aggfunc='mean')\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "sns.heatmap(cross_tab, annot=True, cmap='YlGnBu')\n",
    "plt.title('Cross-tabulation of Param1 vs Param2')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bf278a07",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.preprocessing import StandardScaler\n",
    "scaler = StandardScaler()\n",
    "df_scaled = scaler.fit_transform(df.select_dtypes(include=['number']))\n",
    "import plotly.express as px\n",
    "fig = px.parallel_coordinates(df, color='target_variable')  # target_variable为分类标签（如结果）\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2ea9f718",
   "metadata": {},
   "source": [
    "## 雷达图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "33d1af7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 假设 data 是你的数据集，包含七八个参数列\n",
    "data = df_all_dic\n",
    "\n",
    "# 取一个样本进行演示\n",
    "sample = data.iloc[0].values\n",
    "\n",
    "# 计算参数数量\n",
    "num_vars = len(data.columns)\n",
    "\n",
    "# 计算角度\n",
    "angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()\n",
    "angles += angles[:1]\n",
    "\n",
    "# 绘制雷达图\n",
    "fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))\n",
    "ax.plot(angles, sample.tolist() + sample.tolist()[:1], linewidth=1, linestyle='solid')\n",
    "ax.fill(angles, sample.tolist() + sample.tolist()[:1], alpha=0.25)\n",
    "\n",
    "# 设置坐标轴标签\n",
    "ax.set_xticks(angles[:-1])\n",
    "ax.set_xticklabels(data.columns)\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4be46a90",
   "metadata": {},
   "outputs": [],
   "source": [
    "import seaborn as sns\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 假设 data 是你的数据集，包含七八个参数列\n",
    "# data = pd.read_csv('your_data.csv')\n",
    "\n",
    "# 创建散点图矩阵\n",
    "g = sns.pairplot(df_T)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9b6a0513",
   "metadata": {},
   "source": [
    "# 相关性系数与主成分分析"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "569adf50",
   "metadata": {},
   "source": [
    "## Pearson相关性系数矩阵"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3584430b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "# 设置中文字体支持，增大基础字体大小\n",
    "\n",
    "# 设置中文字体支持，确保学术图表中文正常显示\n",
    "plt.rcParams[\"font.family\"] = [\"Simsun\", \"Simsun\", \"Simsun\", \"Simsun\"]\n",
    "plt.rcParams[\"axes.unicode_minus\"] = False  # 解决负号显示问题\n",
    "plt.rcParams[\"font.size\"] = 12  # 基础字体大小\n",
    "\n",
    "# 定义数据处理和可视化的辅助函数\n",
    "def process_data(data, cols):\n",
    "    \"\"\"处理数据：转换为数值型并删除缺失值\"\"\"\n",
    "    df = data[cols].apply(pd.to_numeric, errors='coerce')\n",
    "    return df.dropna()\n",
    "\n",
    "def plot_heatmap_subplot(ax, corr_matrix, title, annot_size=12, label_size=14):\n",
    "    \"\"\"在子图上绘制热力图，使用更大的字体\"\"\"\n",
    "    # 仅显示下三角矩阵，避免重复\n",
    "    mask = np.triu(np.ones_like(corr_matrix, dtype=bool))\n",
    "    \n",
    "    sns.heatmap(\n",
    "        corr_matrix,\n",
    "        mask=mask,\n",
    "        cmap=\"coolwarm\",\n",
    "        annot=True,\n",
    "        fmt=\".2f\",\n",
    "        vmin=-1, vmax=1,\n",
    "        cbar=False,  # 共享一个颜色条\n",
    "        linewidths=0.8,\n",
    "        annot_kws={'fontsize': annot_size, 'fontweight': 'bold'},\n",
    "        square=True,\n",
    "        ax=ax\n",
    "    )\n",
    "    \n",
    "    # 设置标题和轴标签，使用更大的字体\n",
    "    ax.set_title(title, fontsize=14, pad=15, fontweight='bold')\n",
    "    plt.setp(ax.get_xticklabels(), rotation=45, ha='right', fontsize=label_size)\n",
    "    plt.setp(ax.get_yticklabels(), rotation=0, fontsize=label_size)\n",
    "\n",
    "# 数据处理与可视化主流程\n",
    "if __name__ == \"__main__\":\n",
    "    # 假设df_all_dic已存在，实际使用时替换为你的数据加载代码\n",
    "    # df_all_dic = pd.read_csv(\"your_data_file.csv\")\n",
    "    \n",
    "    # 按类型筛选数据\n",
    "    data0 = df_all_dic[df_all_dic['type'] == 0]  # 整体\n",
    "    data1 = df_all_dic[df_all_dic['type'] == 1]  # 分离\n",
    "    data2 = df_all_dic[df_all_dic['type'] == 2]  # 螺栓\n",
    "    \n",
    "    # 定义各类型数据的特征列\n",
    "    cols0 = ['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor',\n",
    "            'cf1f','cf2f','cf3f','Bcf12f','Pucf12f']  # 整体\n",
    "    cols1 = ['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor',\n",
    "            'cf1f','cf2f','cf3f','sfricn','Bcf12f','Pucf12f']  # 分离\n",
    "    cols2 = ['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor',\n",
    "            'cf1f','cf2f','cf3f','sfricn','pbol','F','Bcf12f','Pucf12f']  # 螺栓\n",
    "    \n",
    "    # 处理数据并计算相关矩阵\n",
    "    processed_data0 = process_data(data0, cols0)\n",
    "    processed_data1 = process_data(data1, cols1)\n",
    "    processed_data2 = process_data(data2, cols2)\n",
    "    \n",
    "    corr0 = processed_data0.corr().round(2)\n",
    "    corr1 = processed_data1.corr().round(2)\n",
    "    corr2 = processed_data2.corr().round(2)\n",
    "    \n",
    "    # 创建一个更大的画布，容纳更大的字体\n",
    "    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(30, 10))\n",
    "#     fig.suptitle('不同截面类型的参数相关性热力图', fontsize=18, y=1.02, fontweight='bold')\n",
    "    \n",
    "    # 绘制三张热力图，使用更大的字体参数\n",
    "    plot_heatmap_subplot(ax1, corr0, '整体截面', annot_size=16, label_size=11)\n",
    "    plot_heatmap_subplot(ax2, corr1, '分离截面', annot_size=16, label_size=11)\n",
    "    plot_heatmap_subplot(ax3, corr2, '螺栓截面', annot_size=16, label_size=11)\n",
    "    \n",
    "#     # 添加共享的颜色条，增大颜色条标签\n",
    "#     cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])  # 位置：[左, 下, 宽, 高]\n",
    "#     cbar = fig.colorbar(ax1.collections[0], cax=cbar_ax)\n",
    "#     cbar.set_label('Pearson 相关系数', rotation=270, labelpad=20, fontsize=12)\n",
    "#     cbar.ax.tick_params(labelsize=10)\n",
    "    \n",
    "    # 调整布局，避免标签重叠\n",
    "    plt.tight_layout()\n",
    "    \n",
    "    # 保存图片\n",
    "    plt.savefig('三种截面类型相关性热力图(大字体).pdf', dpi=300, bbox_inches='tight')\n",
    "    print(\"热力图已保存为PDF文件\")\n",
    "    \n",
    "    # 显示所有三张图\n",
    "    plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0a6a6cf0",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "93425436",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "# 设置图片大小\n",
    "plt.figure(figsize=[20, 20])\n",
    "data0pp=df_all_dic[(df_all_dic[str('type')]==0)]\n",
    "data1pp=df_all_dic[(df_all_dic[str('type')]==1)]\n",
    "data2pp=df_all_dic[(df_all_dic[str('type')]==2)]\n",
    "# 定义各截面的特征列（自变量+因变量）\n",
    "cols0 = ['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor','cf1f','cf2f','cf3f','Bcf12f','Pucf12f']  # 整体\n",
    "cols1 = ['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor','cf1f','cf2f','cf3f','sfricn','Bcf12f','Pucf12f']  # 分离（多摩擦系数sfricn）\n",
    "cols2 = ['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor','cf1f','cf2f','cf3f','sfricn','pbol','F','Bcf12f','Pucf12f']  # 螺栓（多螺栓参数pbol、F）\n",
    "\n",
    "# 计算相关性矩阵（处理非数值型数据，保留两位小数）\n",
    "def get_corr(data, cols):\n",
    "    df = data[cols].apply(pd.to_numeric, errors='coerce').dropna()  # 强制转换为数值，删除含NaN的行\n",
    "    return df.corr().round(2)  # 皮尔逊相关系数，保留两位小数\n",
    "\n",
    "corr0 = get_corr(data0, cols0)  # 整体截面相关矩阵\n",
    "corr1 = get_corr(data1, cols1)  # 分离截面相关矩阵\n",
    "corr2 = get_corr(data2, cols2)  # 螺栓截面相关矩阵\n",
    "display(corr0)\n",
    "display(corr1)\n",
    "display(corr2)\n",
    "# 整体\n",
    "# df_para=data0[['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor','cf1f','cf2f','cf3f','Bcf12f','Pucf12f']]\n",
    "\n",
    "# # 分离\n",
    "# df_para=data1[['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor','cf1f','cf2f','cf3f','sfricn','Bcf12f','Pucf12f']]\n",
    "\n",
    "# # 螺栓\n",
    "df_para=data2[['H','B','T1','T2','L','n','yfss','axialratio','Imperfectfactor','cf1f','cf2f','cf3f','sfricn','pbol','F','Bcf12f','Pucf12f']]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# 检查列名和数据类型（确保全为数值型）\n",
    "print(df_para.dtypes)\n",
    "# 转换非数值列（如有）\n",
    "# df_para['Imperfectfactor'] = pd.to_numeric(df_para['Imperfectfactor'], errors='coerce')\n",
    "# 转换非数值列（确保全为数值型，否则热力图报错）\n",
    "df_para = df_para.apply(pd.to_numeric, errors='coerce')  # 强制转换，无效值转为NaN\n",
    "\n",
    "# 计算相关性矩阵（学术热力图通常展示相关性）\n",
    "corr_matrix = df_para.corr()\n",
    "\n",
    "# 创建高对比度热力图（学术风格）\n",
    "plt.figure(figsize=(6, 5))  # 调整合适尺寸\n",
    "ax = sns.heatmap(\n",
    "    corr_matrix,\n",
    "    cmap='viridis',              # 核心修改：使用学术常用高对比色（红-白-蓝）\n",
    "    annot=True,               # 显示相关系数\n",
    "    fmt=\".2f\",                # 保留两位小数（符合学术规范）\n",
    "    vmin=-1, vmax=1,          # 固定颜色范围（适用于相关性矩阵）\n",
    "#     cbar_kws={'label': '相关系数 (Pearson r)'},  # 添加专业色条标签\n",
    "    cbar=True,             # 核心修改：移除颜色条\n",
    "    linewidths=0.5,           # 增加网格线提升可读性\n",
    "    annot_kws={'fontsize': 8}  # 缩小注释字体（避免重叠）\n",
    ")\n",
    "\n",
    "# 学术论文必备要素\n",
    "# plt.title('参数相关性热力图', fontsize=12, pad=20)  # 标题加间距\n",
    "plt.xticks(rotation=45, ha='right', fontsize=8)     # 横向旋转x轴标签\n",
    "plt.yticks(fontsize=8)                               # 统一字体大小\n",
    "# ax.collections[0].colorbar.ax.tick_params(labelsize=8)  # 缩小色条刻度字体\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "# # 计算皮尔逊相关系数矩阵\n",
    "# mat = df_para.corr(method='pearson')\n",
    "\n",
    "# # 选择中心参数，这里以 'B' 为例，你可以根据需要修改\n",
    "# center_parameter = 'L'\n",
    "\n",
    "# # 提取与中心参数相关的相关系数，同时排除中心参数自身与自身的相关性\n",
    "# correlations = mat[center_parameter].drop(center_parameter)\n",
    "\n",
    "# # 按相关系数绝对值降序排序\n",
    "# correlations = correlations.abs().sort_values(ascending=False)\n",
    "\n",
    "# # 打印与中心参数相关性的排序结果\n",
    "# print(f\"与 {center_parameter} 相关性排序：\")\n",
    "# print(correlations)\n",
    "\n",
    "# # 设置相关性阈值，筛选出相关性较强的参数\n",
    "# threshold = 0.5\n",
    "# selected_parameters = correlations[correlations > threshold].index.tolist()\n",
    "\n",
    "# # 打印相关性绝对值大于阈值的参数\n",
    "# print(f\"\\n与 {center_parameter} 相关性绝对值大于 {threshold} 的参数：\")\n",
    "# print(selected_parameters)\n",
    "\n",
    "# # 提取相关性较强的参数以及中心参数组成新的数据框\n",
    "# selected_df = df_para[selected_parameters + [center_parameter]]\n",
    "\n",
    "# # 重新计算这些参数的相关系数矩阵\n",
    "# selected_mat = selected_df.corr(method='pearson')\n",
    "\n",
    "# # 绘制聚焦于与中心参数相关性较强参数的热力图\n",
    "# plt.figure(figsize=(10, 8))\n",
    "# ax = sns.heatmap(data=selected_mat, cmap='RdYlGn', annot=True) \n",
    "# plt.title(f\"与 {center_parameter} 相关性较强的参数热力图\")\n",
    "# plt.tight_layout()\n",
    "\n",
    "# # 保存图片\n",
    "# pltsvgname = f'皮尔逊相关系数_{center_parameter}_重点'\n",
    "# # plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\" + pltsvgname + \".svg\", dpi=300)\n",
    "\n",
    "# # 显示图形\n",
    "# plt.show() \n",
    "   \n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72f7f6d6",
   "metadata": {},
   "source": [
    "## 成分相关性散点分析图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b0478ec",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T14:41:12.186806Z",
     "start_time": "2023-07-24T14:39:06.631160Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "pad_num=0.2\n",
    "\n",
    "# 设置全局字体大小和样式，提升可读性\n",
    "sns.set_context(\"talk\", font_scale=1.2)  # 增大字体比例\n",
    "plt.rcParams.update({\n",
    "    'font.family': 'sans-serif',\n",
    "    'font.sans-serif': ['Arial'],\n",
    "    'axes.labelsize': 12,         # 坐标轴标签字体大小\n",
    "    'xtick.labelsize': 10,        # x轴刻度标签字体大小\n",
    "    'ytick.labelsize': 10,        # y轴刻度标签字体大小\n",
    "    'legend.fontsize': 10,        # 图例字体大小\n",
    "})\n",
    "\n",
    "# 绘制第一个pairplot（data0）\n",
    "df_para = data0[['H', 'B', 'T1', 'T2', 'L', 'n', 'yfss', 'axialratio', 'Imperfectfactor', 'cf1f', 'cf2f', 'cf3f', 'Bcf12f', 'Pucf12f']]\n",
    "plt.figure(figsize=(16, 16))  # 增大图形尺寸，预留更多空间\n",
    "ax = sns.pairplot(data=df_para, kind='scatter', diag_kind='kde')\n",
    "ax.fig.tight_layout(pad=pad_num)  # 增加子图间距，pad参数控制边距\n",
    "pltsvgname = '参数分布和回归0'\n",
    "# ax.savefig(f\"R:\\\\PhDall\\\\matplotlibpic\\\\{pltsvgname}.svg\", dpi=300)\n",
    "plt.show()\n",
    "# plt.clf()\n",
    "\n",
    "# 绘制第二个pairplot（data1）\n",
    "df_para = data1[['H', 'B', 'T1', 'T2', 'L', 'n', 'yfss', 'axialratio', 'Imperfectfactor', 'cf1f', 'cf2f', 'cf3f', 'sfricn', 'Bcf12f', 'Pucf12f']]\n",
    "plt.figure(figsize=(16, 16))  # 根据变量数量适当增大尺寸\n",
    "ax = sns.pairplot(data=df_para, kind='scatter', diag_kind='kde')\n",
    "ax.fig.tight_layout(pad=pad_num)  # 变量较多时增加边距\n",
    "pltsvgname = '参数分布和回归1'\n",
    "# ax.savefig(f\"R:\\\\PhDall\\\\matplotlibpic\\\\{pltsvgname}.svg\", dpi=300)\n",
    "plt.show()\n",
    "# plt.clf()\n",
    "\n",
    "# 绘制第三个pairplot（data2）\n",
    "df_para = data2[['H', 'B', 'T1', 'T2', 'L', 'n', 'yfss', 'axialratio', 'Imperfectfactor', 'cf1f', 'cf2f', 'cf3f', 'sfricn','F', 'pbol',  'Bcf12f', 'Pucf12f']]\n",
    "plt.figure(figsize=(16, 16))  # 变量最多的情况使用更大的画布\n",
    "ax = sns.pairplot(data=df_para, kind='scatter', diag_kind='kde')\n",
    "ax.fig.tight_layout(pad=pad_num)  # 进一步增加边距防止标签重叠\n",
    "pltsvgname = '参数分布和回归2'\n",
    "# ax.savefig(f\"R:\\\\PhDall\\\\matplotlibpic\\\\{pltsvgname}.svg\", dpi=300)\n",
    "plt.show()\n",
    "# plt.clf()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44bbbad2",
   "metadata": {},
   "source": [
    "### 主成分分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "756b14a0",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-25T17:46:52.342642Z",
     "start_time": "2023-07-25T17:46:52.320671Z"
    }
   },
   "outputs": [],
   "source": [
    "#导入相关包\n",
    "import pandas as pd                      #读取数据\n",
    "from sklearn.preprocessing import scale  #数据中心标准化\n",
    "from sklearn.decomposition import PCA    #主成分分析算法\n",
    "\n",
    "# dfdelparapp=dfdelpara[['H','B','T1','T2','L','n','type',\n",
    "#                        'yfss','Imperfectfactor','pbol', 'sfricn','F','BoltB','BoltD',\n",
    "#                        'cf1f', 'cf2f', 'cf3f','EigenValue','Bcf1f','Bcf2f','Bcf3f','Pucf1f', 'Pucf2f']]\n",
    "\n",
    "listname_corr=['H','B','T1','T2','L','n','type','sfricn','pbol','F','BoltB','BoltD',\n",
    "                       'Bcf2f','KH_quge_web', 'KG_total_web', 'KH_total_web', 'KG_consedge_flange',\n",
    "       'KH_consedge_flange', 'KG_midstiff_flange', 'KH_midstiff_flange',\n",
    "       'I_single_ix', 'I_single_iy', 'I_web_quge_ix', 'I_web_quge_iy',\n",
    "       'I_flange_consedge_ix', 'I_flange_consedge_iy', 'I_flange_midstiff_ix',\n",
    "       'I_flange_midstiff_iy', 'I_total_webix', 'I_total_webiy', 'J_web',\n",
    "       'J_consedge_half', 'J_midstiff_half', 'J_consedge', 'J_midstiff',\n",
    "       'ratio_alpha_tflange_to_tweb', 'ratio_alpha_Bflange_to_Hn','k_taucr_fem2_n', 'ratio_eta_GJdivbyDL']\n",
    "dfdelparapp=df[listname_corr]\n",
    "\n",
    "\n",
    "\n",
    "data0pp=dfdelparapp[(dfdelparapp[str('type')]==0)]\n",
    "data1pp=dfdelparapp[(dfdelparapp[str('type')]==1)]\n",
    "data2pp=dfdelparapp[(dfdelparapp[str('type')]==2)]\n",
    "# data0.drop('F',axis=1, inplace=True)\n",
    "# data1.drop('F',axis=1, inplace=True)\n",
    "\n",
    "drop0=['type','F','BoltB','BoltD','sfricn','pbol']\n",
    "drop1=['type','F','BoltB','BoltD','pbol']\n",
    "drop2=['type']\n",
    "\n",
    "\n",
    "\n",
    "data0=data0pp.drop(drop0,axis=1,inplace=False)\n",
    "data1=data1pp.drop(drop1,axis=1,inplace=False)\n",
    "data2=data2pp.drop(drop2,axis=1,inplace=False)\n",
    "\n",
    "\n",
    "\n",
    "from collections import OrderedDict\n",
    "\n",
    "list1 = listname_corr\n",
    "list2 = drop0\n",
    "\n",
    "\n",
    "\n",
    "new_list1 = [item for item in list1 if item not in list2]\n",
    "\n",
    "print(new_list1)\n",
    "\n",
    "listname_corr=new_list1\n",
    "listname_corr\n",
    "# data0['F'].value_counts()\n",
    "# print(data0)\n",
    "# data=data1# 这里需要改成数值型数据后面才能做相关系数"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7034989f",
   "metadata": {},
   "source": [
    "#### 计算相关系数矩阵（与之前的相关性系数图相同）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3b2e58f9",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-25T17:47:17.216676Z",
     "start_time": "2023-07-25T17:47:17.193737Z"
    }
   },
   "outputs": [],
   "source": [
    "data=data0# 这里需要改成数值型数据后面才能做相关系数\n",
    "\n",
    "# data.F.astype('float64').dtypes\n",
    "# # data.astype({'F':'int32''}).dtype\n",
    "# data.dtypes\n",
    "# pd.set_option('display.max_rows', None) \n",
    "# print(data.dtypes)\n",
    "\n",
    "data=data.astype('float')# 这里需要改成数值型数据后面才能做相关系数\n",
    "corr=pd.DataFrame(np.corrcoef(data,rowvar=0))\n",
    "# 将labels重新赋予\n",
    "# df_corr=corr[corr[31]]\n",
    "list_corr=corr.iloc[:,31]\n",
    "# df_corr=df_corr+list_corr\n",
    "# df['col1'].values.tolist()\n",
    "# pd.DataFrame([df_corr])\n",
    "\n",
    "df_corr = pd.DataFrame()\n",
    "\n",
    "\n",
    "\n",
    "df_corr[0]=listname_corr\n",
    "df_corr[1]=list_corr\n",
    "\n",
    "df_corr\n",
    "# plt.plot(df_corr)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "15950ee9",
   "metadata": {},
   "source": [
    "#### 数据标准化（采用均值标准化方法）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "60283681",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:43:19.104239Z",
     "start_time": "2023-07-24T16:43:19.083296Z"
    }
   },
   "outputs": [],
   "source": [
    "data_=(data-data.mean(0))/data.std()\n",
    "data_\n",
    "from sklearn.preprocessing import MinMaxScaler,StandardScaler,MaxAbsScaler,RobustScaler\n",
    "ss = StandardScaler()\n",
    "ss.fit_transform(data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31df0923",
   "metadata": {},
   "source": [
    "#### sklearn实现PCA降维"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "77d5e21f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:13:05.907307Z",
     "start_time": "2023-07-24T16:13:05.776624Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.decomposition import PCA\n",
    "model_pca=PCA()  #建立PCA模型对象\n",
    "model_pca.fit(data_)   #将数据输入模型\n",
    "x_=model_pca.transform(data_)   #将数据集进行转换映射,x_为进行降维过后的数据集，形状和原数据集一样\n",
    "print('获得转换后的所有主成分')\n",
    "components=model_pca.components_  #获得转换后的所有主成分\n",
    "components\n",
    "print(type(components))\n",
    "print('#获得各主成分的方差')\n",
    "components_var=model_pca.explained_variance_    #获得各主成分的方差\n",
    "components_var\n",
    "print(len(components_var))\n",
    "print('#获得各主成分的方差占比')\n",
    "components_var_ratio=model_pca.explained_variance_ratio_   #获得各主成分的方差占比\n",
    "components_var_ratio\n",
    "\n",
    "# 其中，components代表的是所有的主成分，第一行代表的是第一个主成分e_{1}，第二行代表的是第一个主成分e_{2}，以此类推。\n",
    "# 由components_var_ratio我们知道前两个主成分对应的方差之和为0.8287309（超过80%"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e2059476",
   "metadata": {},
   "source": [
    "#### 选择最好的n_components：累积可解释方差贡献率曲线"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45741f8e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:13:09.210811Z",
     "start_time": "2023-07-24T16:13:08.974442Z"
    }
   },
   "outputs": [],
   "source": [
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=10) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# 解决中文显示问题\n",
    "plt.rcParams['font.family'] = ['sans-serif']\n",
    "plt.rcParams['font.sans-serif'] = ['SimHei']\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "\n",
    "# plt.rcParams['font.sans-serif'] = ['SimHei']\n",
    "plt.figure(figsize=[20,5])\n",
    "plt.plot(np.cumsum(components_var_ratio), 'o-')# 计算explained variance ratio数组各行的累加值\n",
    "plt.xlabel(\"主成分\")\n",
    "plt.ylabel('累计解释方差比例')\n",
    "plt.axhline(0.95, color='k', linestyle='--', linewidth=1)\n",
    "plt.title('累计 PVE')\n",
    "pltsvgname=str('累积可解释方差贡献率曲线') #保存名字\n",
    "plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图          "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87cba48e",
   "metadata": {},
   "source": [
    "#### 主成分载荷矩阵"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8867486b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:13:16.183561Z",
     "start_time": "2023-07-24T16:13:16.135687Z"
    }
   },
   "outputs": [],
   "source": [
    "#主成分核载矩阵\n",
    "model_pca.components_\n",
    "columns = ['PC' + str(i) for i in range(1, len(components_var)+1)]\n",
    "pca_loadings = pd.DataFrame(model_pca.components_, columns=data.columns, index=columns)\n",
    "round(pca_loadings, 2)# 四舍五入保留小数点"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "842af2df",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:14:53.497424Z",
     "start_time": "2023-07-24T16:14:48.832871Z"
    }
   },
   "outputs": [],
   "source": [
    "# Visualize pca loadings\n",
    "plt.figure(figsize=[20,20])\n",
    "# pltsvgname=str('参数分布和回归') #保存名字\n",
    "# plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图 \n",
    "fig, ax = plt.subplots(3, 3)\n",
    "# plt.subplots_adjust(hspace=1, wspace=0.5)   \n",
    "for i in range(1, len(components_var)):\n",
    "#     ax = plt.subplot(3, 3, i)\n",
    "    ax = plt.subplot(6, 6, i)\n",
    "    ax.plot(pca_loadings.T['PC' + str(i)], 'o-')\n",
    "    ax.axhline(0, color='k', linestyle='--', linewidth=1)\n",
    "    ax.set_xticks(range(len(components_var)))\n",
    "    ax.set_xticklabels(data.columns, rotation=30)\n",
    "    ax.set_title('PCA Loadings for PC' + str(i))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4e28ea89",
   "metadata": {},
   "source": [
    "#### 两个主成分的可视化，二维图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "30dd5932",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:14:58.851386Z",
     "start_time": "2023-07-24T16:14:58.720736Z"
    }
   },
   "outputs": [],
   "source": [
    "# PCA Scores\n",
    " \n",
    "pca_scores = model_pca.transform(data_)\n",
    "pca_scores = pd.DataFrame(pca_scores, columns=columns)\n",
    "pca_scores.shape\n",
    "pca_scores.head()\n",
    "#前两个主成分的可视化\n",
    "# visualize pca scores via biplot\n",
    " \n",
    "sns.scatterplot(x='PC1', y='PC2', data=pca_scores)\n",
    "plt.title('Biplot')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f703447b",
   "metadata": {},
   "source": [
    "#### 三个主成分的可视化，三维图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bf0c251f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:01.211343Z",
     "start_time": "2023-07-24T16:15:01.043792Z"
    }
   },
   "outputs": [],
   "source": [
    "# Visualize pca scores via triplot\n",
    "fig = plt.figure()\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.scatter(pca_scores['PC1'], pca_scores['PC2'], pca_scores['PC3'], c='b')\n",
    "ax.set_xlabel('PC1')\n",
    "ax.set_ylabel('PC2')\n",
    "ax.set_zlabel('PC3')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83c37870",
   "metadata": {},
   "source": [
    "#### 利用K均值聚类对三个主成分聚类，可视化"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "efdf589e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:07.529347Z",
     "start_time": "2023-07-24T16:15:06.693351Z"
    }
   },
   "outputs": [],
   "source": [
    " \n",
    "from sklearn.cluster import KMeans\n",
    "model = KMeans(n_clusters=3, random_state=1, n_init=20)\n",
    "model.fit(data_)\n",
    "model.labels_\n",
    " \n",
    "fig = plt.figure()\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.scatter(pca_scores['PC1'], pca_scores['PC2'], pca_scores['PC3'],\n",
    "           c=model.labels_, cmap='rainbow')\n",
    "ax.set_xlabel('PC1')\n",
    "ax.set_ylabel('PC2')\n",
    "ax.set_zlabel('PC3')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d9c9c08",
   "metadata": {},
   "source": [
    "### 最大似然估计自选超参数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c854bc3e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:09.452006Z",
     "start_time": "2023-07-24T16:15:09.341303Z"
    }
   },
   "outputs": [],
   "source": [
    "pca_mle = PCA(n_components=\"mle\")#n_components除了输入整数，还可以输入“mle”(最大似然估计maximum likelihood estimation)让PCA自选超参数。\n",
    "pca_mle = pca_mle.fit(data_)\n",
    "X_mle = pca_mle.transform(data_)\n",
    "print(X_mle)\n",
    "#可以发现，mle为我们自动选择了3个特征\n",
    "pca_mle.explained_variance_ratio_.sum()\n",
    "#得到了比设定2个特征时更高的信息含量，对于很小的数据集来说，3个特征对应这么高的信息含量，并不\n",
    "# 需要去纠结于只保留2个特征，毕竟三个特征也可以可视化\n",
    "components_var=pca_mle.explained_variance_    \n",
    "import matplotlib.pyplot as plt\n",
    "plt.plot(components_var,marker='o')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f321173",
   "metadata": {},
   "source": [
    "### 按信息量占比选超参数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a449d223",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:12.602893Z",
     "start_time": "2023-07-24T16:15:12.591924Z"
    }
   },
   "outputs": [],
   "source": [
    "pca_f = PCA(n_components=0.95,svd_solver=\"full\")\n",
    "pca_f = pca_f.fit(data_)\n",
    "X_f = pca_f.transform(data_)\n",
    "pca_f.explained_variance_ratio_.sum()\n",
    "components_var=pca_f.explained_variance_    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c37ded6",
   "metadata": {},
   "source": [
    "#### 画碎石图，选择主成分个数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "89027499",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:14.161407Z",
     "start_time": "2023-07-24T16:15:14.075609Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "plt.plot(components_var,marker='o')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "67812334",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:17.006254Z",
     "start_time": "2023-07-24T16:15:16.972345Z"
    }
   },
   "outputs": [],
   "source": [
    "# 有了这两个指标的意义，进一步探索一些典型样本主成分取值/得分\n",
    "x_.round(2)[[1,2,3],:]\n",
    "data.iloc[[1,2,3],:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e8d99a70",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T16:15:18.148456Z",
     "start_time": "2023-07-24T16:15:18.110549Z"
    }
   },
   "outputs": [],
   "source": [
    "# 产看上述数据对应的原始数据\n",
    "x_.round(2)[[1,2,3],:]\n",
    "data.iloc[[1,2,3],:]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c8a0b7b",
   "metadata": {},
   "source": [
    "#  结果数据展示（只展示稳定系数vs正则化长细比）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8ac1dc38",
   "metadata": {},
   "source": [
    "## 二维散点关系图（大图）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe4a2882",
   "metadata": {},
   "source": [
    "##### 固定单因素出图(二维，所有数据总图——固定一个因素，循环其他因素——固定下一个因素，循环其他因素"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5dab1db3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ———————————————— 导入必要的库 ———————————————————\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from matplotlib.font_manager import FontProperties\n",
    "# ———————————————— 全局参数设置 ———————————————————\n",
    "# 图表样式参数\n",
    "plt.rcParams['figure.dpi'] = 600\n",
    "\n",
    "# 通用参数\n",
    "POINT_SIZE = 6       # 数据点大小\n",
    "TEXT_SIZE = 8        # 文本标签大小\n",
    "LABEL_SIZE = 8       # 坐标轴标签大小\n",
    "XLIM_DATA = 3        # X轴范围\n",
    "YLIM_DATA = 1.2      # Y轴范围\n",
    "X_MAJOR_LOC = 0.5    # X主刻度间隔\n",
    "Y_MAJOR_LOC = 0.2    # Y主刻度间隔\n",
    "X_MINOR_LOC = 0.25   # X副刻度间隔\n",
    "Y_MINOR_LOC = 0.1    # Y副刻度间隔\n",
    "PAD_DIST = 2.0       # 刻度标签距离\n",
    "\n",
    "# 画布尺寸设置（英寸）\n",
    "FIG_SIZE_X = 1.8     # 主图宽度\n",
    "FIG_SIZE_Y = 1.5     # 主图高度\n",
    "LABEL_GAP = 0.3      # 标签间隙\n",
    "MOVE_OFFSET = (-0.01, -0.02)  # 坐标轴偏移\n",
    "\n",
    "# 子图布局参数\n",
    "SUBPLOT_GAP = 0.4    # 子图间距\n",
    "LEGEND_FONT_SIZE = 7 # 图例字体大小\n",
    "\n",
    "# 颜色和标记样式\n",
    "COLORS = ['r', 'g', 'b', 'y', 'c', 'm', 'tab:gray', 'tab:olive']\n",
    "MARKERS = ['^', 'x', '+', 's', 'v', 'o', '*', 'D']\n",
    "\n",
    "# ———————————————— 数据处理函数 ———————————————————\n",
    "def filter_data(df, general_list, general_values):\n",
    "    \"\"\"根据通用参数过滤数据\"\"\"\n",
    "    print(f\"基于以下参数进行数据筛选: {dict(zip(general_list, general_values))}\")\n",
    "    for param, value in zip(general_list, general_values):\n",
    "        df = df[df[param] == value].copy()\n",
    "    return df.sort_values(by='SLcf2f')\n",
    "\n",
    "# ———————————————— 图表绘制函数 ———————————————————\n",
    "def setup_axes(ax, xlim, ylim, aspect_ratio, pad_dist, major_loc_x, major_loc_y, minor_loc_x, minor_loc_y):\n",
    "    \"\"\"配置坐标轴属性\"\"\"\n",
    "    ax.set_xlim(0, xlim)\n",
    "    ax.set_ylim(0, ylim)\n",
    "    ax.set_aspect(aspect_ratio)\n",
    "    ax.xaxis.set_major_locator(plt.MultipleLocator(major_loc_x))\n",
    "    ax.xaxis.set_minor_locator(plt.MultipleLocator(minor_loc_x))\n",
    "    ax.yaxis.set_major_locator(plt.MultipleLocator(major_loc_y))\n",
    "    ax.yaxis.set_minor_locator(plt.MultipleLocator(minor_loc_y))\n",
    "    #     ax.legend(fontsize=LEGEND_FONT_SIZE)  # 添加图例时使用\n",
    "    ax.tick_params(\n",
    "        bottom=True, top=True, left=True, right=True,\n",
    "        pad=pad_dist, labelsize=LABEL_SIZE\n",
    "    )\n",
    "\n",
    "    plt.xlabel('正则化长细比', fontproperties=font_setS, size=LABEL_SIZE)\n",
    "    plt.ylabel('稳定系数', fontproperties=font_setS, size=LABEL_SIZE)\n",
    "\n",
    "def create_subplot_layout(num_plots, base_width, gap):\n",
    "    \"\"\"计算子图布局参数\"\"\"\n",
    "    cols = min(num_plots, 3)\n",
    "    rows = (num_plots + cols - 1) // cols\n",
    "    total_width = base_width * cols + gap * (cols + 1)\n",
    "    total_height = base_width * rows + gap * (rows + 1)\n",
    "    return cols, rows, total_width, total_height\n",
    "\n",
    "# ———————————————— 主程序逻辑 ———————————————————\n",
    "# 假设 df_all 是你的原始数据框\n",
    "# df_all = ...\n",
    "# 初始数据筛选\n",
    "general_list = ['yfss', 'Imperfectfactor', 'meshsz', 'cf1f', 'cf2f', 'cf3f', 'type']\n",
    "general_values = [355.61, 0.002, 20, 0, 1, 0, 1]\n",
    "df = filter_data(df_all.copy(), general_list, general_values)\n",
    "\n",
    "# ———————————————— 绘制总览图 ———————————————————\n",
    "print(\"开始绘制总览图，基于上述筛选后的数据\")\n",
    "plt.figure(figsize=(FIG_SIZE_X * 2, FIG_SIZE_Y * 2))\n",
    "ax = plt.gca()\n",
    "# setup_axes(ax, XLIM_DATA, YLIM_DATA, ASPECT_RATIO, PAD_DIST,\n",
    "#            X_MAJOR_LOC, Y_MAJOR_LOC, X_MINOR_LOC, Y_MINOR_LOC)\n",
    "\n",
    "plt.scatter(df['SLcf2f'], df['SFcf2f'], s=POINT_SIZE, c='blue', alpha=1)\n",
    "plt.show()\n",
    "\n",
    "# ———————————————— 绘制单参数分析图 ———————————————————\n",
    "geo_params = ['H', 'B', 'T1', 'T2', 'L', 'n']\n",
    "for param in geo_params:\n",
    "    unique_values = sorted(df[param].unique())\n",
    "\n",
    "    for value in unique_values:\n",
    "        subset = df[df[param] == value]\n",
    "        x = subset['SLcf2f']\n",
    "        y = subset['SFcf2f']\n",
    "        print(f\"开始绘制单参数分析图，固定参数 {param} = {value}，基于上述筛选后的数据\")\n",
    "        fig = plt.figure(figsize=(FIG_SIZE_X * 2, FIG_SIZE_Y * 2))\n",
    "        ax = fig.add_axes([0.15, 0.15, 0.7, 0.7])\n",
    "#         setup_axes(ax, XLIM_DATA, YLIM_DATA, ASPECT_RATIO, PAD_DIST,\n",
    "#                    X_MAJOR_LOC, Y_MAJOR_LOC, X_MINOR_LOC, Y_MINOR_LOC)\n",
    "\n",
    "        plt.scatter(x, y, s=POINT_SIZE, c='blue', alpha=1)\n",
    "        plt.text(1.5, 1.1, f'{param}={value}', fontsize=TEXT_SIZE)\n",
    "        plt.show()\n",
    "\n",
    "# ———————————————— 绘制双参数交互图 ———————————————————\n",
    "for first_param in geo_params:\n",
    "    df_first = df[df[first_param].isin(sorted(df[first_param].unique()))]\n",
    "    remaining_params = [p for p in geo_params if p != first_param]\n",
    "\n",
    "    for second_param in remaining_params:\n",
    "        df_second = df_first.groupby(first_param)\n",
    "\n",
    "        for value, group in df_second:\n",
    "            unique_second = sorted(group[second_param].unique())\n",
    "            num_plots = len(unique_second)\n",
    "            print(f\"开始绘制双参数交互图，固定第一个参数 {first_param} = {value}，基于上述筛选后的数据，第二个参数 {second_param} 有 {len(unique_second)} 个唯一值\")\n",
    "            cols, rows, fig_w, fig_h = create_subplot_layout(num_plots, FIG_SIZE_X, LABEL_GAP)\n",
    "            fig = plt.figure(figsize=(fig_w, fig_h))\n",
    "\n",
    "            for idx, sec_val in enumerate(unique_second):\n",
    "                subset = group[group[second_param] == sec_val]\n",
    "                x = subset['SLcf2f']\n",
    "                y = subset['SFcf2f']\n",
    "\n",
    "                ax = fig.add_subplot(rows, cols, idx + 1)\n",
    "#                 setup_axes(ax, XLIM_DATA, YLIM_DATA, ASPECT_RATIO, PAD_DIST,\n",
    "#                            X_MAJOR_LOC, Y_MAJOR_LOC, X_MINOR_LOC, Y_MINOR_LOC)\n",
    "\n",
    "                plt.scatter(x, y, s=POINT_SIZE/2, c=COLORS[idx], marker=MARKERS[idx])\n",
    "                plt.title(f'{second_param}={sec_val}', fontsize=TEXT_SIZE)\n",
    "\n",
    "            plt.suptitle(f'{first_param}={value}', fontsize=TEXT_SIZE, y=1.02)\n",
    "            plt.tight_layout(pad=SUBPLOT_GAP)    # 自动调整子图间距\n",
    "            plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c804ac4",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ec4660b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:29:07.407982Z",
     "start_time": "2023-09-18T07:29:07.060974Z"
    }
   },
   "outputs": [],
   "source": [
    "#原始代码，上一个单元格内优化后的代码已能完成完成相应的工作\n",
    "#——————————————一些初始包的导入————————————————————\n",
    "# # 图像设置\n",
    "# from matplotlib import pyplot as plt\n",
    "# from matplotlib.axis import Axis \n",
    "\n",
    "# font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=10) # 字体设置宋体\n",
    "# plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# # plt.rcParams['figure.dpi']=600\n",
    "# plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "# plt.rcParams['axes.unicode_minus']=False\n",
    "# plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "# plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "# pointsize=8\n",
    "# textx=1.5# legend的水平位置\n",
    "# texty=1.1# legend的垂直位置\n",
    "# textsize=10\n",
    "# labelsize=10\n",
    "# xlimdata=3                \n",
    "# ylimdata=1.2\n",
    "# xfenshu=7\n",
    "# yfenshu=7\n",
    "# xmajloc=0.5\n",
    "# ymajloc=0.2\n",
    "# xminloc=0.25\n",
    "# yminloc=0.1\n",
    "# paddist=2.5\n",
    "\n",
    "# figsizex= 2.2# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "# figsizey= figsizex*1.2\n",
    "# labelgapsizex=0.5\n",
    "# labelgapsizey=labelgapsizex\n",
    "# movex=-0.01\n",
    "# movey=-0.02\n",
    "# aspectratio=3# 表示 y轴的单位刻度显示长度 是 x轴的单位刻度显示长度 的aspect倍\n",
    "# padinchessize=1\n",
    "# # 横纵坐标设置\n",
    "# xhor=str('SLcf2f')# 横坐标\n",
    "# yver=str('SFcf2f')#纵坐标\n",
    "# # 数据点排序（为了数值拟合用）\n",
    "\n",
    "\n",
    "\n",
    "# general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f','type']# 筛选基础数据用的list_分离面内\n",
    "# general_list_number=[355.61,     0.002       , 20     ,  0   ,1     ,0   ,1]# 面内受剪_分离面内\n",
    "# # # 固定标准参数general list和其值\n",
    "# df_selected_del=df_all.copy()\n",
    "\n",
    "\n",
    "# for i in range (0,len(general_list)):\n",
    "#     df_selected_del=df_selected_del[df_selected_del[general_list[i]]==general_list_number[i]].copy()\n",
    "# df=df_selected_del.sort_values(by=[xhor])\n",
    "# # df=df.sort_values(by=[xhor])\n",
    "# print('len(df)',len(df))\n",
    "# plt.figure(figsize=(figsizex*2,figsizey*2))\n",
    "# yall=abs(df[yver])\n",
    "# xall=abs(df[xhor])\n",
    "# # xyfit(xall, yall)\n",
    "# finalfigx=figsizex+labelgapsizex\n",
    "# finalfigy=figsizey+labelgapsizey  \n",
    "# fig=plt.figure(figsize=(finalfigx*2,finalfigy*2))\n",
    "# axeslocatex=((1)*labelgapsizex)/finalfigx\n",
    "# axeslocatey=((1)*labelgapsizey)/finalfigy\n",
    "# axeswith=(1/1)*((figsizex*1)/finalfigx)\n",
    "# axesheight=(1/1)*(figsizey*1/finalfigy)\n",
    "# axes=fig.add_axes([axeslocatex,axeslocatey,axeswith,axesheight])\n",
    "# print('展示全部数据点','数量',len(yall))     # 展示全部数据点\n",
    "# ax = plt.gca()\n",
    "# plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# ax.xaxis.set_major_locator(plt.MultipleLocator(xmajloc)) # x轴的主刻度设置\n",
    "# ax.yaxis.set_major_locator(plt.MultipleLocator(ymajloc))  #x轴的主刻度设置\n",
    "# ax.xaxis.set_minor_locator(plt.MultipleLocator(xminloc)) # x轴的副刻度设置\n",
    "# ax.yaxis.set_minor_locator(plt.MultipleLocator(yminloc)) # y轴的副刻度设置\n",
    "# xticks(np.linspace(0,xlimdata,xfenshu,endpoint=True))# x轴标签\n",
    "# yticks(np.linspace(0,ylimdata,yfenshu,endpoint=True))# y轴标签    \n",
    "# plt.scatter(xall,yall,s=pointsize,c='blue',alpha=1)\n",
    "# # plt.text(2,1, str('IS all data')+'='+str(len(yall)),fontsize=textsize)\n",
    "# plt.xlim((0, xlimdata))  \n",
    "# plt.ylim((0, ylimdata))\n",
    "# ax.tick_params(pad=paddist)# 更改刻度线、刻度标签和网格线的外观。\n",
    "# ax.set_aspect(aspect=aspectratio)\n",
    "# plt.xlabel('正则化长细比', fontproperties=font_setS,size=labelsize) \n",
    "# plt.ylabel('稳定系数', fontproperties=font_setS,size=labelsize)      \n",
    "# print('show总')\n",
    "# pltsvgname=str('all') #保存名字\n",
    "# # plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图 \n",
    "# plt.show()# 输出\n",
    "# #——————————————单独截面设置—————————————————————\n",
    "# geo_var=['H','B','T1','T2','L','n']\n",
    "# for i in range(0,len(geo_var)):# 统计有多少个变量值\n",
    "#     geo_var=['H','B','T1','T2','L','n']\n",
    "#     bianvar=geo_var[i]# 从表中往出抽不同参数\n",
    "#     a = list(df[bianvar].unique())   # 列出该列的唯一值\n",
    "# #     print('len(a)',len(a)) # 统计变量ii中有多少个不一样的水平\n",
    "#     b=sorted(a)\n",
    "# #     print(\"bi\",b[i])\n",
    "#     for j in range(0,len(a)):\n",
    "#         y=abs(df[df[bianvar]==b[j]][yver])\n",
    "#         x=abs(df[df[bianvar]==b[j]][xhor])\n",
    "#         print('下图为包括',bianvar,'=',b[j],'固定第一参数的所有数据')\n",
    "#         finalfigx=figsizex+labelgapsizex\n",
    "#         finalfigy=figsizey+labelgapsizey  \n",
    "#         fig=plt.figure(figsize=(finalfigx*2,finalfigy*2))\n",
    "#         axeslocatex=((1)*labelgapsizex)/finalfigx\n",
    "#         axeslocatey=((1)*labelgapsizey)/finalfigy\n",
    "#         axeswith=(1/1)*((figsizex*1)/finalfigx)\n",
    "#         axesheight=(1/1)*(figsizey*1/finalfigy)\n",
    "#         axes=fig.add_axes([axeslocatex+movex,axeslocatey+movey,axeswith,axesheight])\n",
    "# #         print(axeslocatex+movex,axeslocatey+movey,axeswith,axesheight)\n",
    "# #         plt.figure(figsize=(figsizex*2,figsizey*2))\n",
    "#         plt.scatter(x,y,s=pointsize,c='blue',alpha=1)\n",
    "#         plt.xlim((0, xlimdata))  \n",
    "#         plt.ylim((0, ylimdata))\n",
    "#         ax = plt.gca()\n",
    "#         ax.xaxis.set_major_locator(plt.MultipleLocator(xmajloc)) # x轴的主刻度设置\n",
    "#         ax.yaxis.set_major_locator(plt.MultipleLocator(ymajloc))  #x轴的主刻度设置\n",
    "#         ax.xaxis.set_minor_locator(plt.MultipleLocator(xminloc)) # x轴的副刻度设置\n",
    "#         ax.yaxis.set_minor_locator(plt.MultipleLocator(yminloc)) # y轴的副刻度设置\n",
    "#         xticks(np.linspace(0,xlimdata,xfenshu,endpoint=True))# x轴标签\n",
    "#         yticks(np.linspace(0,ylimdata,yfenshu,endpoint=True))# y轴标签   、\n",
    "#         plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "#         ax.tick_params(pad=paddist)# 更改刻度线、刻度标签和网格线的外观。\n",
    "# #         ax.set_aspect(aspect=aspectratio)\n",
    "#         plt.xlabel('正则化长细比', fontproperties=font_setS,size=labelsize) \n",
    "#         plt.ylabel('稳定系数', fontproperties=font_setS,size=labelsize)      \n",
    "#         plt.text(textx,texty, str(bianvar)+'='+str(b[j]),fontsize=textsize)\n",
    "# #  单参数输出（只有一个参数）\n",
    "# #         xyfit(x, y)\n",
    "# #         print('show分总')\n",
    "\n",
    "#         pltsvgname=bianvar+str(b[j]) #保存名字\n",
    "# #         plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图    \n",
    "#         plt.show()# 正常输出\n",
    "#         plt.close() \n",
    "#         dff=df[df[str(bianvar)].isin([b[j]])]# 通过布尔索引引用，构造取出bianvar列中数值为b[j-1]的df表\n",
    "# #         print(len(x))\n",
    "# #         print(dff)\n",
    "# #         print(len(dff))\n",
    "#         geo_var=['H','B','T1','T2','L','n']\n",
    "#         geo_var.remove(bianvar)\n",
    "#         geo_varexcl=geo_var\n",
    "#         print(geo_varexcl)\n",
    "#         # 双因素交互图（一个参数不变，另一个参数变化，在一组图内展示）\n",
    "#         for k in range(0,len(geo_varexcl)):\n",
    "#             cianvar=geo_varexcl[k]# 从表中往出抽不同参数\n",
    "#             c = list(dff[cianvar].unique())      # 列出该列的唯一值    \n",
    "#             print(len(c)) # 统计变量中有多少个不一样的水平\n",
    "#             d=sorted(c)\n",
    "#             print('本轮中第一参数',bianvar,'=',b[j],'的所有数据')  \n",
    "            \n",
    "# #——————————————总画布行列数设置————————————————————————————————\n",
    "#             pichoriztal=int(len(c)/3)# 画布的分行，实际是列数\n",
    "# # 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，为了不重叠显示乘以二倍）\n",
    "#             picvertical=int(len(c)/3)# 画布的分列，实际是行数            \n",
    "#             # 修改子图排布以在整体图右侧和顶部上留出足够的位置，以将数字显示完成整\n",
    "#             if len(d)==1: # 一行1列\n",
    "#                 finalfigx=(figsizex+labelgapsizex)\n",
    "#                 finalfigy=(figsizey+labelgapsizex)   \n",
    "#             if len(d)==2: # 一行2列\n",
    "#                 finalfigx=(figsizex*2+labelgapsizex*1)\n",
    "#                 finalfigy=(figsizey+labelgapsizey*0)\n",
    "#             if len(d)==3:# 一行3列\n",
    "#                 finalfigx=(figsizex*3+labelgapsizex*3)\n",
    "#                 finalfigy=(figsizey+labelgapsizey*1)\n",
    "#             if len(d)==4:# 一行4列\n",
    "#                 finalfigx=(figsizex*4+labelgapsizex*4)\n",
    "#                 finalfigy=(figsizey*1+labelgapsizey*1) \n",
    "#             if len(d)==5:# 两行3列\n",
    "#                 finalfigx=(figsizex*3+labelgapsizex*3)\n",
    "#                 finalfigy=(figsizey*2+labelgapsizey*2)   \n",
    "#             if len(d)==6:# 两行3列\n",
    "#                 finalfigx=figsizex*3+labelgapsizex*3\n",
    "#                 finalfigy=figsizey*2+labelgapsizey*2   \n",
    "#             if len(d)==8:# 两行4列\n",
    "#                 finalfigx=figsizex*4+labelgapsizex*4\n",
    "#                 finalfigy=figsizey*2+labelgapsizey*2\n",
    "#             if len(d)==9:# 三行3列\n",
    "#                 finalfigx=figsizex*3+labelgapsizex*2\n",
    "#                 finalfigy=figsizey+labelgapsizey*0\n",
    "#             if len(d)>9:\n",
    "#                 finalfigx=figsizex*picvertical+labelgapsizex*1\n",
    "#                 finalfigy=figsizey*labelgapsizey*pichoriztal     \n",
    "#             fig=plt.figure(figsize=(finalfigx,finalfigy)) \n",
    "# #           色彩集和标注集\n",
    "#             colors=['r','g','b','y','c','m','tab:gray','tab:olive']\n",
    "#             markers=['^','x','+','s','v','o','*','D']            \n",
    "#             # 利用循环在子图上添加数据  ， 参数的变化为3的倍数多几张图张图\n",
    "#             picyu=(int(len(c)/3)*3)-len(c) # 余数\n",
    "# #——————————————总画布行列数设置———————————————————————————————— \n",
    "#             for l in range(0,len(c)):\n",
    "#                 ypic=abs(dff[dff[cianvar]==d[l]][yver])\n",
    "#                 xpic=abs(dff[dff[cianvar]==d[l]][xhor])\n",
    "#                 lnum=l+1\n",
    "#                 if len(c)==1:      \n",
    "#                     axeslocatex=0\n",
    "#                     axeslocatey=0/1\n",
    "#                     axeswith=1\n",
    "#                     axesheight=1\n",
    "#                     print('show1')\n",
    "#                 if len(c)==2 :  \n",
    "#                     axeslocatex=l/2\n",
    "#                     axeslocatey=0/1\n",
    "#                     axeswith=1/2\n",
    "#                     axesheight=1\n",
    "#                     print('show2')\n",
    "#                 if len(c)==3: \n",
    "#                     axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "#                     axeslocatey=0/2+1*labelgapsizey/finalfigy\n",
    "#                     axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "#                     axesheight=(1/1)*(figsizey*1/finalfigy)\n",
    "#                     print(l)\n",
    "#                     print('show3')\n",
    "#                     print(axeswith,axesheight)\n",
    "#                     print(axeslocatex,axeslocatey)\n",
    "#                 if len(c)==4:\n",
    "#                     axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "#                     axeslocatey=0/2+1*labelgapsizey/finalfigy\n",
    "#                     axeswith=(1/4)*((figsizex*4)/finalfigx)\n",
    "#                     axesheight=(1/1)*(figsizey*1/finalfigy)\n",
    "#                     print('show4')\n",
    "#                 if len(c)==5:   \n",
    "#                     if l <3:\n",
    "#                         axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "#                         axeslocatey=(1*figsizey+(2)*labelgapsizey)/finalfigy\n",
    "#                         axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "#                         axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "#                     if l >=3:\n",
    "#                         axeslocatex=((l-3)*figsizex+(lnum-3)*labelgapsizex)/finalfigx\n",
    "#                         axeslocatey=(0*figsizey+(1)*labelgapsizey)/finalfigy\n",
    "#                         axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "#                         axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "#                     print('show5')\n",
    "#                 if len(c)==6:   \n",
    "#                     if l <3:\n",
    "#                         axeslocatex=(l)/3+(l)*labelgapsizex/finalfigx\n",
    "#                         axeslocatey=1/2+labelgapsizey/finalfigy\n",
    "#                         axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "#                         axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "#                     if l >=3:\n",
    "#                         axeslocatex=(l-3)/3+(lnum-3)*labelgapsizex/finalfigx\n",
    "#                         axeslocatey=0/2\n",
    "#                         axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "#                         axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "#                     print('show6')\n",
    "#                 if len(c)== 8:\n",
    "#                     if l <4:\n",
    "#                         axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "#                         axeslocatey=(1*figsizey+(2)*labelgapsizey)/finalfigy\n",
    "#                         axeswith=(1/4)*((figsizex*4)/finalfigx)\n",
    "#                         axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "#                     if l >=4:\n",
    "#                         axeslocatex=((l-4)*figsizex+(lnum-4)*labelgapsizex)/finalfigx\n",
    "#                         axeslocatey=(0*figsizey+(1)*labelgapsizey)/finalfigy\n",
    "#                         axeswith=(1/4)*((figsizex*4)/finalfigx)\n",
    "#                         axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "#                     print('show8')\n",
    "#                     print(axeslocatex,axeslocatey,axeswith,axesheight)\n",
    "#                     print(axeslocatex+axeswith,axeslocatey+axesheight)\n",
    "#                 if len(c)==9:   \n",
    "#                     if l <3:\n",
    "#                         axeslocatex=(l)/3+(l)*labelgapsizex/finalfigx\n",
    "#                         axeslocatey=1/3+labelgapsizey/finalfigy\n",
    "#                         axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "#                         axesheight=(1/3)*(figsizey*3/finalfigy)\n",
    "#                     if 6 <= l <9:\n",
    "#                         axeslocatex=(l-3)/3+(l-3)*labelgapsizex/finalfigx\n",
    "#                         axeslocatey=0/3\n",
    "#                         axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "#                         axesheight=(1/3)*(figsizey*3/finalfigy)\n",
    "#                     if 6 <= l <9  :\n",
    "#                         axeslocatex=(l-6)/3+(l-6)*labelgapsizex/finalfigx\n",
    "#                         axeslocatey=0/3\n",
    "#                         axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "#                         axesheight=(1/3)*(figsizey*3/finalfigy)\n",
    "#                     print('show9')\n",
    "#                 if len(c)==10:   \n",
    "#                     if l < 5:\n",
    "#                         axeslocatex=l/5\n",
    "#                         axeslocatey=1/2\n",
    "#                         axeswith=1/5\n",
    "#                         axesheight=1/2\n",
    "#                     if l >= 5:\n",
    "#                         axeslocatex=(l-5)/5\n",
    "#                         axeslocatey=0/2\n",
    "#                         axeswith=1/5\n",
    "#                         axesheight=1/2\n",
    "#                     print('show10')\n",
    "# #———————————————————定位语句——————————————————      \n",
    "#                 axes=fig.add_axes([axeslocatex+movex,axeslocatey+movey,axeswith,axesheight]) # 定位语句\n",
    "# #                     print('本轮中双参数分析')   \n",
    "#                     print('本轮中第一参数',bianvar,'=',b[j],'同时第二参数',cianvar,'=',d[l],'参数数量',len(c))   \n",
    "# #————————————————单个图形的布局相关参数设置——————————— \n",
    "#                 plt.text(textx,texty, str(bianvar)+'='+str(b[j])+', '+str(cianvar)+'='+str(d[l]),fontsize=textsize)# 添加图例名字\n",
    "#                 plt.xlim((0, xlimdata))  \n",
    "#                 plt.ylim((0, ylimdata))\n",
    "#                 axes.xaxis.set_major_locator(plt.MultipleLocator(xmajloc)) # x轴的主刻度设置\n",
    "#                 axes.yaxis.set_major_locator(plt.MultipleLocator(ymajloc))  #x轴的主刻度设置\n",
    "#                 axes.xaxis.set_minor_locator(plt.MultipleLocator(xminloc)) # x轴的副刻度设置\n",
    "#                 axes.yaxis.set_minor_locator(plt.MultipleLocator(yminloc)) # y轴的副刻度设置\n",
    "#                 xticks(np.linspace(0,xlimdata,xfenshu,endpoint=True))# x轴标签\n",
    "#                 yticks(np.linspace(0,ylimdata,yfenshu,endpoint=True))# y轴标签    \n",
    "#                 plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "#                 axes.tick_params(pad=paddist)# 更改刻度线、刻度标签和网格线的外观。\n",
    "#                 axes.set_aspect(aspect=aspectratio)\n",
    "#                 plt.xlabel('正则化长细比', fontproperties=font_setS,size=labelsize) \n",
    "#                 plt.ylabel('稳定系数', fontproperties=font_setS,size=labelsize)   \n",
    "# #————————————————单个图形的布局相关参数设置——————————— \n",
    "#                 plt.scatter(xpic,ypic,alpha=1,c='blue',s=pointsize/2)#数据做图\n",
    "# #                 xyfit(xpic.sort_index(),xpic.sort_index())\n",
    "#             pltsvgname=bianvar+str(b[j])+cianvar #保存名字\n",
    "# #             plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图            \n",
    "#             plt.show()                    \n",
    "#             plt.close()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2c26562",
   "metadata": {},
   "source": [
    "## 二维颜色分类"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d72e1350",
   "metadata": {},
   "source": [
    "### 双因素颜色交互的大图(在一类截面数据中，按照HBT1T2L分类）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f537888f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:29:07.791292Z",
     "start_time": "2023-09-18T07:29:07.570832Z"
    }
   },
   "outputs": [],
   "source": [
    "#——————————————一些初始包的导入————————————————————\n",
    "# 图像设置\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis \n",
    "from textwrap import fill\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=10) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# plt.rcParams['figure.dpi']=600\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "pointsize=8\n",
    "textx=1.5# legend的水平位置\n",
    "texty=1.1# legend的垂直位置\n",
    "legendsize=10\n",
    "textsize=10\n",
    "labelsize=10\n",
    "xlimdata=3                \n",
    "ylimdata=1.2\n",
    "xfenshu=7\n",
    "yfenshu=7\n",
    "xmajloc=0.5\n",
    "ymajloc=0.2\n",
    "xminloc=0.25\n",
    "yminloc=0.1\n",
    "paddist=2.5\n",
    "\n",
    "figsizex= 2.2# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= figsizex*1.2\n",
    "labelgapsizex=0.5\n",
    "labelgapsizey=labelgapsizex\n",
    "movex=-0.01\n",
    "movey=-0.02\n",
    "aspectratio=3# 表示 y轴的单位刻度显示长度 是 x轴的单位刻度显示长度 的aspect倍\n",
    "padinchessize=1\n",
    "\n",
    "# 横纵坐标设置\n",
    "xhor=str('SLcf2f')# 横坐标\n",
    "yver=str('SFcf2f')#纵坐标\n",
    "\n",
    "# 数据点排序（为了数值拟合用）\n",
    "df=df_alltype[(df_alltype['type'] == 2) & (df_alltype['cf1f'] == 0)& (df_alltype['cf2f'] == 1)& (df_alltype['cf3f'] == 0)]\n",
    "# df=df_alltype[(df_alltype[str('type')]==1) | (df_all_dic['meshsz'] == 20)]\n",
    "\n",
    "df=df.sort_values(by=[xhor])\n",
    "yall=abs(df[yver])\n",
    "xall=abs(df[xhor])\n",
    "\n",
    "finalfigx=(figsizex+labelgapsizex)*1.8\n",
    "finalfigy=(figsizey+labelgapsizey) *1.8\n",
    "fig=plt.figure(figsize=(finalfigx,finalfigy))\n",
    "axeslocatex=((1)*labelgapsizex)/finalfigx\n",
    "axeslocatey=((1)*labelgapsizey)/finalfigy\n",
    "axeswith=(1/1)*((figsizex*1)/finalfigx)\n",
    "axesheight=(1/1)*(figsizey*1/finalfigy)\n",
    "\n",
    "print('展示全部数据点','数量',len(yall))     # 展示全部数据点\n",
    "plt.figure(figsize=(finalfigx,finalfigy))\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "plt.MultipleLocator(xmajloc) # x轴的主刻度设置\n",
    "plt.MultipleLocator(ymajloc)  #x轴的主刻度设置\n",
    "plt.MultipleLocator(xminloc) # x轴的副刻度设置\n",
    "plt.MultipleLocator(yminloc) # y轴的副刻度设置\n",
    "xticks(np.linspace(0,xlimdata,xfenshu,endpoint=True))# x轴标签\n",
    "yticks(np.linspace(0,ylimdata,yfenshu,endpoint=True))# y轴标签   \n",
    "plt.xlim((0, xlimdata))  \n",
    "plt.ylim((0, ylimdata))\n",
    "plt.tick_params(pad=paddist)# 更改刻度线、刻度标签和网格线的外观。\n",
    "#         plt.figaspect(aspectratio)\n",
    "plt.xlabel('正则化长细比', fontproperties=font_setS,size=labelsize) \n",
    "plt.ylabel('稳定系数', fontproperties=font_setS,size=labelsize)  \n",
    "plt.scatter(xall,yall,s=pointsize,c='black',alpha=1)    \n",
    "print('show总')\n",
    "pltsvgname=str('all') #保存名字\n",
    "# plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图 \n",
    "plt.show()# 输出\n",
    "standardvar=['H','B','T1','T2','L','n']\n",
    "#当处理几何因素时 'H','B','T1','T2','L','n','L','axialratio''F','pbol','sfricn','yfss','Imperfectfactor'\n",
    "# 当处理非几何因素时'pbol','sfricn','yfss','Imperfectfactor'\n",
    "geo_var=standardvar \n",
    "# ————————利用循环在子图上添加数据 ，参数的变化为3的倍数多几张图张图—————————————\n",
    "geo_varpicyu=len(geo_var)-(int(len(geo_var)/3)*3) # 余数   \n",
    "for vark in range(0,len(geo_var)):     \n",
    "    plt.figure(figsize=(finalfigx,finalfigy))\n",
    "    varcianvar=geo_var[vark]# 从表中往出抽不同参数\n",
    "    varc = list(df[varcianvar].unique())      # 列出该列的唯一值         \n",
    "    vard = sorted(varc)       \n",
    "    for varl in range(0,len(varc)):\n",
    "        x1=abs(df[df[varcianvar]==vard[varl]][xhor])                \n",
    "        y1=abs(df[df[varcianvar]==vard[varl]][yver]) \n",
    "        varcolorl=np.full((1,len(x1)), vard[varl]/max(vard))\n",
    "        plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "        plt.MultipleLocator(xmajloc) # x轴的主刻度设置\n",
    "        plt.MultipleLocator(ymajloc)  #x轴的主刻度设置\n",
    "        plt.MultipleLocator(xminloc) # x轴的副刻度设置\n",
    "        plt.MultipleLocator(yminloc) # y轴的副刻度设置\n",
    "        xticks(np.linspace(0,xlimdata,xfenshu,endpoint=True))# x轴标签\n",
    "        yticks(np.linspace(0,ylimdata,yfenshu,endpoint=True))# y轴标签   \n",
    "        plt.xlim((0, xlimdata))  \n",
    "        plt.ylim((0, ylimdata))\n",
    "        plt.tick_params(pad=paddist)# 更改刻度线、刻度标签和网格线的外观。\n",
    "#         plt.figaspect(aspectratio)\n",
    "        plt.xlabel('正则化长细比', fontproperties=font_setS,size=labelsize) \n",
    "        plt.ylabel('稳定系数', fontproperties=font_setS,size=labelsize)   \n",
    "        plt.scatter(x1,y1,alpha=1,s=pointsize,c=varcolorl, cmap=\"viridis\",vmin=0, vmax=1,label=str(varcianvar)+'='+str(vard[varl])) \n",
    "        plt.legend(fontsize=legendsize, markerscale=1, scatterpoints=1)   \n",
    "        plt.legend(bbox_to_anchor=(textx/xlimdata,texty/ylimdata))\n",
    "        if len(varc)>10:\n",
    "            plt.legend(ncol=2)  \n",
    "        else:\n",
    "            plt.legend(ncol=1) \n",
    "    pltsvgname=str('变')+geo_var[vark] #保存名字\n",
    "    plt.show()\n",
    "    plt.close()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2dfe93f",
   "metadata": {},
   "source": [
    "### 双因素颜色交互的小图（除了上述大图之外，在固定H，B等参数为唯一值之后显示及图形）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb27cf53",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-07T03:57:52.338597Z",
     "start_time": "2023-07-07T03:54:48.251492Z"
    }
   },
   "outputs": [],
   "source": [
    "#——————————————一些初始包的导入————————————————————\n",
    "# 图像设置\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis \n",
    "from pylab import mpl\n",
    "import matplotlib.ticker as ticker\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=10) # 字体设置宋体\n",
    "# font0 = FontProperties(family='serif', weight='bold',size=8)\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# plt.rcParams['figure.dpi']=600\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "pointsize=8\n",
    "textx=0.5# legend的水平位置\n",
    "texty=1.1# legend的垂直位置\n",
    "textsize=10\n",
    "labelsize=10\n",
    "legendsize=10\n",
    "xlimdata=3                \n",
    "ylimdata=1.2\n",
    "xfenshu=7\n",
    "yfenshu=7\n",
    "xmajloc=0.5\n",
    "ymajloc=0.2\n",
    "xminloc=0.25\n",
    "yminloc=0.1\n",
    "paddist=2.5\n",
    "\n",
    "figsizex= 2.2# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= figsizex*1.2\n",
    "labelgapsizex=1\n",
    "labelgapsizey=labelgapsizex-0.4\n",
    "movex=-0.04\n",
    "movey=-0.02\n",
    "aspectratio=3# 表示 y轴的单位刻度显示长度 是 x轴的单位刻度显示长度 的aspect倍\n",
    "padinchessize=1\n",
    "xhor=str('SLcf2f')# 横坐标\n",
    "yver=str('SFcf2f')#纵坐标\n",
    "colorltype=str('viridis')\n",
    "# 作图相关设置 \n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=15)\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# fig = plt.figure()\n",
    "# plt.rcParams['figure.dpi']=100\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "# s=5# 数据点的尺寸\n",
    "df=df.sort_values(by=[xhor])\n",
    "\n",
    "print('展示全部数据点')     # 展示全部数据点\n",
    "yall=abs(df[[yver]])\n",
    "xall=abs(df[[xhor]])\n",
    "\n",
    "plt.xlim((0, 3))\n",
    "plt.ylim((0, 1))\n",
    "plt.xlabel('正则化长细比', fontproperties=font_setS,size=12)\n",
    "plt.ylabel('稳定系数', fontproperties=font_setS,size=12)\n",
    "plt.scatter(xall,yall,s=10,c='blue',alpha=1,label='所有数据')\n",
    "plt.show()# 输出\n",
    "plt.close()\n",
    "standardvar=['H','B','T1','T2','L','n','L']\n",
    "# 'L','F','pbol','sfricn','yfss','Imperfectfactor'\n",
    "geo_var=standardvar \n",
    "\n",
    "# ——————————————色彩集和标注集————————————————————————————————\n",
    "colors=['r','g','b','y','c','m','tab:gray','tab:olive']\n",
    "markers=['^','x','+','s','v','o','*','D']            \n",
    "#             plt.subplots(picvertical,pichoriztal)  \n",
    "# ————————利用循环在子图上添加数据 ，参数的变化为3的倍数多几张图张图—————————————\n",
    "geo_varpicyu=len(geo_var)-(int(len(geo_var)/3)*3) # 余数   \n",
    "for vark in range(0,len(geo_var)):     \n",
    "    plt.figure(figsize=(5.7, 5.7))\n",
    "    varcianvar=geo_var[vark]# 从表中往出抽不同参数\n",
    "    varc = list(df[varcianvar].unique())      # 列出该列的唯一值         \n",
    "    vard = sorted(varc)       \n",
    "    for varl in range(0,len(varc)):\n",
    "        x1=abs(df[df[varcianvar]==vard[varl]][xhor])                \n",
    "        y1=abs(df[df[varcianvar]==vard[varl]][yver]) \n",
    "        varcolorl=np.full((1,len(x1)), vard[varl]/max(vard))\n",
    "        markers=['^','x','+','s','v','o','*','D']\n",
    "        plt.xlim((0, 3))\n",
    "        plt.ylim((0, 1))\n",
    "        plt.xlabel('正则化长细比', fontproperties=font_setS,size=12)\n",
    "        plt.ylabel('稳定系数', fontproperties=font_setS,size=12)\n",
    "        plt.scatter(x1,y1,alpha=1,s=5,c=varcolorl, cmap=\"viridis\",vmin=0, vmax=1,label=str(varcianvar)+'='+str(vard[varl])) \n",
    "        plt.legend(fontsize=10, markerscale=1, scatterpoints=1)     \n",
    "    plt.show()\n",
    "    plt.close()\n",
    "    #——————————————变量为固定值的单图————————————————————————————————\n",
    "for i in range(0,len(geo_var)):# 统计有多少个变量值\n",
    "    geo_var=standardvar # 重新刷新geo_var，以便排除后面remove的干扰\n",
    "    bianvar=geo_var[i]# 从表中往出抽不同参数\n",
    "    a = list(df[bianvar].unique())   # 列出该列的唯一值\n",
    "    len(a) # 统计变量中有多少个不一样的水平\n",
    "    b=sorted(a)\n",
    "    for j in range(0,len(a)):\n",
    "        plt.figure(figsize=(3.8, 3.8))\n",
    "        y=abs(df[df[bianvar]==b[j]][[yver]])\n",
    "        x=abs(df[df[bianvar]==b[j]][[xhor]])\n",
    "        plt.text(2.3,0.8, str(bianvar)+'='+str(b[j]), fontsize=10)\n",
    "        plt.xlim((0, 3))\n",
    "        plt.ylim((0, 1))\n",
    "#         print('下图为包括',bianvar,'=',b[j],'的所有数据')        \n",
    "        plt.xlabel('正则化长细比', fontproperties=font_setS,size=12)\n",
    "        plt.ylabel('稳定系数', fontproperties=font_setS,size=12)\n",
    "        plt.scatter(x,y,s=10,c='blue',alpha=1,label=str('的所有数据'))\n",
    "        dff1=df[df[str(bianvar)].isin([b[j]])]# 构造一级参数为恒定值的的数据表\n",
    "        dff=dff1.sort_values(by=[xhor])\n",
    "        geo_var=['H','B','T1','T2','L','n','L']# 重新刷新geo_var，以便排除后面remove的干扰,'L''pbol','sfricn','yfss','Imperfectfactor'\n",
    "        geo_var.remove(bianvar)#remove掉geo_var中的本级选项，为了第二因素后面的排列\n",
    "        geo_varexcl=geo_var\n",
    "        plt.show()\n",
    "        plt.close()      \n",
    "#——————————————subplot小图总画布行列数设置————————————————————————————————\n",
    "#             pichoriztal# 画布的分行，实际是列数\n",
    "# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，为了不重叠显示乘以二倍）\n",
    "#             picvertical# 画布的分列，实际是行数            \n",
    "            # 修改子图排布以在整体图右侧和顶部上留出足够的位置，以将数字显示完成整\n",
    "        if len(geo_varexcl)==1: # 一行1列\n",
    "            finalfigx=(figsizex+labelgapsizex)\n",
    "            finalfigy=(figsizey+labelgapsizex)   \n",
    "        if len(geo_varexcl)==2: # 一行2列\n",
    "            finalfigx=(figsizex*2+labelgapsizex*1)\n",
    "            finalfigy=(figsizey+labelgapsizey*0)\n",
    "        if len(geo_varexcl)==3:# 一行3列\n",
    "            finalfigx=(figsizex*3+labelgapsizex*3)\n",
    "            finalfigy=(figsizey+labelgapsizey*1)\n",
    "        if len(geo_varexcl)==4:# 两行2列\n",
    "            finalfigx=(figsizex*2+labelgapsizex*2)\n",
    "            finalfigy=(figsizey*2+labelgapsizey*2) \n",
    "        if len(geo_varexcl)==5:# 两行3列\n",
    "            finalfigx=(figsizex*3+labelgapsizex*3)\n",
    "            finalfigy=(figsizey*2+labelgapsizey*2)   \n",
    "        if len(geo_varexcl)==6:# 两行3列\n",
    "            finalfigx=figsizex*3+labelgapsizex*3\n",
    "            finalfigy=figsizey*2+labelgapsizey*2   \n",
    "        if len(geo_varexcl)==8:# 两行4列\n",
    "            finalfigx=figsizex*4+labelgapsizex*4\n",
    "            finalfigy=figsizey*2+labelgapsizey*2\n",
    "        if len(geo_varexcl)==9:# 三行3列\n",
    "            finalfigx=figsizex*3+labelgapsizex*2\n",
    "            finalfigy=figsizey+labelgapsizey*0\n",
    "        if len(geo_varexcl)>9:\n",
    "            finalfigx=figsizex*picvertical+labelgapsizex*1\n",
    "            finalfigy=figsizey*labelgapsizey*pichoriztal     \n",
    "#           色彩集和标注集\n",
    "        colors=['r','g','b','y','c','m','tab:gray','tab:olive']\n",
    "        markers=['^','x','+','s','v','o','*','D']            \n",
    "        # 利用循环在子图上添加数据  ， 参数的变化为3的倍数多几张图张图\n",
    "        fig=plt.figure(figsize=(finalfigx,finalfigy)) \n",
    "        for l in range(0,len(geo_varexcl)):  \n",
    "            cianvar=geo_varexcl[l]# 从表中往出抽不同参数\n",
    "            c = list(dff[cianvar].unique())      # 列出该列的唯一值 \n",
    "            print('c',c,'l',l)\n",
    "            d = sorted(c)       \n",
    "#             print('本轮中第一参数',cianvar,'=',d[l],'的所有数据')\n",
    "            lnum=l+1\n",
    "            if len(geo_varexcl)==1:      \n",
    "                axeslocatex=0\n",
    "                axeslocatey=0/1\n",
    "                axeswith=1\n",
    "                axesheight=1\n",
    "                print('show1')\n",
    "            if len(geo_varexcl)==2 :  \n",
    "                axeslocatex=l/2\n",
    "                axeslocatey=0/1\n",
    "                axeswith=1/2\n",
    "                axesheight=1\n",
    "                print('show2')\n",
    "            if len(geo_varexcl)==3: \n",
    "                axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "                axeslocatey=0/2+1*labelgapsizey/finalfigy\n",
    "                axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "                axesheight=(1/1)*(figsizey*1/finalfigy)\n",
    "                print(l)\n",
    "                print('show3')\n",
    "                print(axeswith,axesheight)\n",
    "                print(axeslocatex,axeslocatey)\n",
    "            if len(geo_varexcl)==4:\n",
    "                if l <2:\n",
    "                    axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(1*figsizey+(2)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/2)*((figsizex*2)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                if l >=2:\n",
    "                    axeslocatex=((l-2)*figsizex+(lnum-2)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(0*figsizey+(1)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/2)*((figsizex*2)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                print('show4')\n",
    "            if len(geo_varexcl)==5:   \n",
    "                if l <3:\n",
    "                    axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(1*figsizey+(2)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                if l >=3:\n",
    "                    axeslocatex=((l-3)*figsizex+(lnum-3)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(0*figsizey+(1)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                print('show5')\n",
    "            if len(geo_varexcl)==6:   \n",
    "                if l <3:\n",
    "                    axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(1*figsizey+(2)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                if l >=3:\n",
    "                    axeslocatex=((l-3)*figsizex+(lnum-3)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(0*figsizey+(1)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/3)*((figsizex*3)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                print('show6')\n",
    "            if len(geo_varexcl)==8:\n",
    "                if l <4:\n",
    "                    axeslocatex=(l*figsizex+(lnum)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(1*figsizey+(2)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/4)*((figsizex*4)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                if l >=4:\n",
    "                    axeslocatex=((l-4)*figsizex+(lnum-4)*labelgapsizex)/finalfigx\n",
    "                    axeslocatey=(0*figsizey+(1)*labelgapsizey)/finalfigy\n",
    "                    axeswith=(1/4)*((figsizex*4)/finalfigx)\n",
    "                    axesheight=(1/2)*(figsizey*2/finalfigy)\n",
    "                print('show8')\n",
    "                print(axeslocatex,axeslocatey,axeswith,axesheight)\n",
    "                print(axeslocatex+axeswith,axeslocatey+axesheight)\n",
    "            if len(geo_varexcl)==9:   \n",
    "                if l <3:\n",
    "                    axeslocatex=(l)/3+(l)*labelgapsizex/finalfigx\n",
    "                    axeslocatey=1/3+labelgapsizey/finalfigy\n",
    "                    axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "                    axesheight=(1/3)*(figsizey*3/finalfigy)\n",
    "                if 6 <= l <9:\n",
    "                    axeslocatex=(l-3)/3+(l-3)*labelgapsizex/finalfigx\n",
    "                    axeslocatey=0/3\n",
    "                    axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "                    axesheight=(1/3)*(figsizey*3/finalfigy)\n",
    "                if 6 <= l <9  :\n",
    "                    axeslocatex=(l-6)/3+(l-6)*labelgapsizex/finalfigx\n",
    "                    axeslocatey=0/3\n",
    "                    axeswith=(1/3)*(figsizex*3/finalfigx)\n",
    "                    axesheight=(1/3)*(figsizey*3/finalfigy)\n",
    "                print('show9')\n",
    "            if len(geo_varexcl)==10:   \n",
    "                if l < 5:\n",
    "                    axeslocatex=l/5\n",
    "                    axeslocatey=1/2\n",
    "                    axeswith=1/5\n",
    "                    axesheight=1/2\n",
    "                if l >= 5:\n",
    "                    axeslocatex=(l-5)/5\n",
    "                    axeslocatey=0/2\n",
    "                    axeswith=1/5\n",
    "                    axesheight=1/2\n",
    "                print('show10')        \n",
    "#———————————————————定位语句——————————————————     \n",
    "            # 定位图像 \n",
    "            axes=fig.add_axes([axeslocatex+movex,axeslocatey+movey,axeswith,axesheight])   \n",
    "            # 定位colorbar\n",
    "            cax=fig.add_axes([axeslocatex+movex+figsizex/finalfigx,axeslocatey+movey,0.02,axes.get_position().height])\n",
    "            # 定位legend\n",
    "            axes.text(textx+0.5,texty, \n",
    "                      str(bianvar)+'='+str(b[j]),\n",
    "                      fontsize=textsize,fontproperties=font_setS)# 添加图例名字\n",
    "            axes.text(textx+0.5,texty-0.1, \n",
    "                      str('变色参数')+str(cianvar),\n",
    "                      fontsize=textsize,fontproperties=font_setS)# 添加图例名字\n",
    "\n",
    "#———————————变第二参数数值颜色的———————————                \n",
    "            for colorl in range(0,len(d)):\n",
    "                x1=abs(dff[dff[cianvar]==d[colorl]][xhor])                \n",
    "                y1=abs(dff[dff[cianvar]==d[colorl]][yver]) \n",
    "#———————————对颜色参数进行处理，以方便构造colorbar———————————  \n",
    "                if len(d)!=1:\n",
    "                    minco=min(d)-((max(d)-min(d))/((len(d)-1)*2))\n",
    "                    maxco=max(d)+((max(d)-min(d))/((len(d)-1)*2))\n",
    "                if len(d)==1:          \n",
    "                    minco=min(d)\n",
    "                    maxco=max(d)\n",
    "                colorlmap=np.full((1,len(x1)), (d[colorl]-[minco])/maxco)\n",
    "                colorbarpara=[minco]+d+[maxco]\n",
    "#                 markers=['^','x','+','s','v','o','*','D']\n",
    "#————————————————单个图形的布局相关参数设置——————————— \n",
    "                axes.scatter(x1,y1,alpha=1,s=pointsize,c=colorlmap, cmap=colorltype,vmin=0, vmax=1,label=bianvar+'='+str(b[j]))         \n",
    "    #                 axes.legend(fontsize=legendsize, markerscale=1, scatterpoints=1) \n",
    "#                 plt.legend(frameon=False,handletextpad=0.01)\n",
    "#————————————————单个图形的布局相关参数设置——————————— \n",
    "                axes.set_xlim((0, xlimdata))  \n",
    "                axes.set_ylim((0, ylimdata))\n",
    "                axes.xaxis.set_major_locator(plt.MultipleLocator(xmajloc)) # x轴的主刻度设置\n",
    "                axes.yaxis.set_major_locator(plt.MultipleLocator(ymajloc))  #x轴的主刻度设置\n",
    "                axes.xaxis.set_minor_locator(plt.MultipleLocator(xminloc)) # x轴的副刻度设置\n",
    "                axes.yaxis.set_minor_locator(plt.MultipleLocator(yminloc)) # y轴的副刻度设置\n",
    "                xticks(np.linspace(0,xlimdata,xfenshu,endpoint=True))# x轴标签\n",
    "                yticks(np.linspace(0,ylimdata,yfenshu,endpoint=True))# y轴标签    \n",
    "                plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "                axes.tick_params(pad=paddist)# 更改刻度线、刻度标签和网格线的外观。\n",
    "                axes.set_aspect(aspect=aspectratio)\n",
    "                axes.set_xlabel('正则化长细比', fontproperties=font_setS,size=labelsize) \n",
    "                axes.set_ylabel('稳定系数', fontproperties=font_setS,size=labelsize) \n",
    " #——————————————colorbar设置————————————————————————————————\n",
    "            cmap = plt.get_cmap(colorltype) #获取颜色类型\n",
    "            #对颜色类型进行最大最小值正则化，这里的vmin和vmax指的是填充colorbar的区域\n",
    "            norm = mpl.colors.Normalize(vmin=min(colorbarpara), vmax= max(colorbarpara))\n",
    "#             print('colorbarpara',colorbarpara)\n",
    "#             norm = mpl.colors.BoundaryNorm(boundaries=np.linspace(0, 1, ndisc+1), ncolors=len(colorbarpara)-1) \n",
    "            scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)#提供一个可以映射颜色的对象\n",
    "            cb = fig.colorbar(scalarMap,cax=cax, orientation=\"vertical\") \n",
    "            labels=colorbarpara#指的是cb标签的数字\n",
    "            loc    =colorbarpara#指的是cb横线的位置\n",
    "            cb.set_ticks(loc) \n",
    "            cb.set_ticklabels(labels)  \n",
    "            for labels in cb.ax.yaxis.get_ticklabels()[::len(d)+1]:# 隐藏掉最大值和最小值\n",
    "                labels.set_visible(False)\n",
    "        pltsvgname=bianvar+str(b[j])+str('color') #保存名字\n",
    "#         plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\")#保存图                         \n",
    "        plt.show()# 分类相互作用输出       \n",
    "        plt.close()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a923e7e3",
   "metadata": {},
   "source": [
    "## 三维图"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "53833b2b",
   "metadata": {},
   "source": [
    "四参数（L和n作为分类参数，每类内进行分图大参，X一参，Y二参，色谱三参） "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f18db368",
   "metadata": {},
   "source": [
    " 主要思路：1、三维图形不存在自动循环过程；\n",
    "            2、指定x轴与y轴的配合性，即通常应为一类变量，与T1与T2，H与B等具有一定相关性的变量\n",
    "            3、由于利用到了颜色分类，因此颜色分类的参数指标选取比较重要；\n",
    "            4、为了使得三维图形最终展示的唯一性，Z3d的取值应为SL或者SW或者SF等唯一指标；\n",
    "            5、三维图形的循环选取可能多参数（其他因素fy，plbo等具有一定的指导意义）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0032e28a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# from matplotlib import pyplot as plt\n",
    "# import numpy as np\n",
    "# from matplotlib.font_manager import FontProperties\n",
    "# from pylab import mpl\n",
    "# from mpl_toolkits.mplot3d import Axes3D\n",
    "# import matplotlib.colors as colors\n",
    "# import matplotlib.cm as cm\n",
    "\n",
    "# font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=10)\n",
    "# plt.rc('font', family='Times New Roman')  # 全局字体为新罗马\n",
    "# plt.rcParams[\"font.sans-serif\"] = [\"simsun\"]  # 宋体\n",
    "# plt.rcParams['figure.dpi'] = 100\n",
    "# plt.rcParams['axes.unicode_minus'] = False\n",
    "\n",
    "# zver = str('SLcf2f')  # z坐标\n",
    "# print('Show Time')\n",
    "# # 标准参数序列\n",
    "# standardvar = ['H', 'B', 'L', 'T1', 'T2', 'n']\n",
    "# subplotpara = str('L')\n",
    "# colorpara = str('n')\n",
    "# x3daxis = str('T1')\n",
    "# y3daxis = str('T2')\n",
    "# colorltype = str('viridis')\n",
    "\n",
    "\n",
    "# def get_subplot_layout(num_subplots):\n",
    "#     if num_subplots == 1:\n",
    "#         return 1, 1\n",
    "#     elif num_subplots == 2:\n",
    "#         return 2, 1\n",
    "#     elif num_subplots <= 3:\n",
    "#         return 3, 1\n",
    "#     elif num_subplots <= 6:\n",
    "#         return 3, 2\n",
    "#     elif num_subplots <= 9:\n",
    "#         return 3, 3\n",
    "#     elif num_subplots <= 12:\n",
    "#         return 3, 4\n",
    "#     elif num_subplots <= 15:\n",
    "#         return 3, 5\n",
    "#     elif num_subplots <= 18:\n",
    "#         return 3, 6\n",
    "#     elif num_subplots <= 21:\n",
    "#         return 3, 7\n",
    "#     elif num_subplots <= 24:\n",
    "#         return 3, 8\n",
    "#     elif num_subplots <= 27:\n",
    "#         return 3, 9\n",
    "#     elif num_subplots <= 30:\n",
    "#         return 3, 10\n",
    "#     elif num_subplots <= 33:\n",
    "#         return 3, 11\n",
    "#     elif num_subplots <= 36:\n",
    "#         return 3, 12\n",
    "#     elif num_subplots <= 39:\n",
    "#         return 3, 13\n",
    "\n",
    "\n",
    "# # 假设df已经定义\n",
    "# # df = ...\n",
    "\n",
    "# # ————————dataframe分类循环，这部分都是对dataframe进行的操作，以便进行特定值筛选——————\n",
    "# # 主类参数一品类循环（L与n）\n",
    "# clarifylist = ['H', 'B']  # 这里的最后一个变量是颜色参数变量\n",
    "# geo_varmainl = clarifylist  # 循环参数列表\n",
    "# for gl in range(0, len(geo_varmainl)):\n",
    "#     lianvar = geo_varmainl[gl]  # 取出作为大参数的的变量\n",
    "#     aal = list(df[lianvar].unique())  # 列出所有的唯一值\n",
    "#     len(aal)  # 统计变量中有多少个不一样的水平\n",
    "#     bbl = sorted(aal)\n",
    "#     print('主类参数一品类循环')\n",
    "#     print('本轮分图主类参一为', lianvar)\n",
    "#     # 主类参数一数值循环（L与n）\n",
    "#     for glj in range(0, len(aal)):\n",
    "#         dfl = df[df[str(lianvar)].isin([bbl[glj]])]  # 构造除去参数恒定值的的df表\n",
    "#         print('本轮主类参数一分大类，以下图内', lianvar, '=', bbl[glj])\n",
    "#         # 主类参数二品类循环（L与n）\n",
    "#         geo_varmainlse = clarifylist  # 循环参数列表\n",
    "#         for glse in range(1, len(geo_varmainlse)):\n",
    "#             lianvarse = geo_varmainlse[glse]  # 大参数的\n",
    "#             aalse = list(df[lianvarse].unique())  # 列出该列的唯一值\n",
    "#             len(aalse)  # 统计变量中有多少个不一样的水平\n",
    "#             bblse = sorted(aalse)\n",
    "#             print('主类参数二品类循环，包含参数', geo_varmainlse)\n",
    "#             print('本轮分图主类参二', lianvarse)\n",
    "#             # 主类参数二数值循环\n",
    "#             for glsej in range(0, len(aalse)):\n",
    "#                 print('本轮品类参数二分图，以下图内', lianvarse, '=', bblse[glsej])\n",
    "#                 dflse = dfl[dfl[str(lianvarse)].isin([bblse[glsej]])]  # 构造除去参数恒定值的的df表\n",
    "#                 # —————————————分类参数结束，这里的dflse已经是经过分类完成的df——————————————————————\n",
    "#                 # 大参数循环，利用大参数的数值不同分类九宫格图形\n",
    "#                 aasubplotpara = list(dflse[subplotpara].unique())  # 列出大参数的唯一值\n",
    "#                 bbsubplotpara = sorted(aasubplotpara)  # 大参数的唯一值排序\n",
    "#                 pichoriztal3d, picvertical3d = get_subplot_layout(len(aasubplotpara))\n",
    "#                 if len(aasubplotpara) == 1:\n",
    "#                     fig, ax = plt.subplots(figsize=(1.9, 5.7 * (picvertical3d / 3)))\n",
    "#                 elif len(aasubplotpara) == 2:\n",
    "#                     fig, ax = plt.subplots(figsize=(3.8, 5.7 * (picvertical3d / 3)))\n",
    "#                 else:\n",
    "#                     fig, ax = plt.subplots(figsize=(5.7, 5.7 * (picvertical3d / 3)))\n",
    "#                 # 色彩集和标注集\n",
    "#                 colors3d = ['r', 'g', 'b', 'y', 'c', 'm', 'tab:gray', 'tab:olive']\n",
    "#                 markers3d = ['^', 'x', '+', 's', 'v', 'o', '*', 'D']\n",
    "#                 picyu3d = len(aasubplotpara) - (int(len(aasubplotpara) / 3) * 3)  # 余数\n",
    "#                 # 利用循环在子图上添加数据，参数的变化为3的倍数多几张图张图\n",
    "#                 print(\"九宫格分惨参数\", subplotpara, \"，总数\", len(bbsubplotpara), \"分别是，\", bbsubplotpara)\n",
    "#                 for subplotnum in range(0, len(bbsubplotpara)):  # 统计有多少个变量\n",
    "#                     dfo = dflse[dflse[subplotpara].isin([bbsubplotpara[subplotnum]])]  # 构造某大参数（九宫格分格参数）为恒定值的df表\n",
    "#                     ax3d = plt.subplot(pichoriztal3d, picvertical3d, subplotnum + 1, projection='3d')\n",
    "#                     if subplotnum in [0, 3, 6, 9, 12, 15, 18, 21]:\n",
    "#                         # 修改纵坐标的刻度\n",
    "#                         ax3d.set_zticklabels([])\n",
    "#                         # 修改坐标的范围\n",
    "#                     print(bbsubplotpara)\n",
    "#                     # X轴参数处理\n",
    "#                     a = list(dfo[x3daxis].unique())  # 列出该列的唯一值\n",
    "#                     b = sorted(a)\n",
    "#                     # Y轴参数处理\n",
    "#                     c = list(dfo[y3daxis].unique())  # 列出该列的唯一值\n",
    "#                     d = sorted(c)\n",
    "#                     # X轴数值循环\n",
    "#                     for j in range(0, len(a)):\n",
    "#                         dff = dfo[dfo[str(x3daxis)].isin([b[j]])]  # 构造除去参数恒定值的的df表\n",
    "#                         ax3d.set_xlabel(x3daxis, fontproperties=font_setS)\n",
    "#                         ax3d.set_ylabel(y3daxis, fontproperties=font_setS)\n",
    "#                         ax3d.set_zlabel(zver, rotation=90, fontproperties=font_setS)\n",
    "#                         ax3d.invert_xaxis()\n",
    "#                         # Y轴数值循环\n",
    "#                         for l in range(0, len(c)):\n",
    "#                             dfff = dff[dff[y3daxis].isin([d[l]])]  # 构造除去参数恒定值的的df表\n",
    "#                             # 三级参数品类循环（从第一级参数的第三个数开始）\n",
    "#                             geo_varthi = standardvar  # 循环变量列表\n",
    "#                             # 颜色参数的参数处理\n",
    "#                             e = list(dfff[colorpara].unique())  # 列出该列的唯一值\n",
    "#                             f = sorted(e)\n",
    "#                             print('e', e)\n",
    "#                             # 三级参数数值循环（颜色分类）本级别下已经具有了唯一性\n",
    "#                             for n in range(0, len(e)):\n",
    "#                                 dffff = dfff[dfff[colorpara].isin([f[n]])]  # 构造除去参数恒定值的的df表\n",
    "#                                 markers = ['^', 'x', '+', 's', 'v', 'o', '*', 'D']\n",
    "#                                 colorllist = np.array(f[n])  # 颜色分类参数\n",
    "#                                 colorl = np.full((1, len(dffff)), f[n] / max(e))\n",
    "#                                 x3d = b[j]  # 本级参数的值\n",
    "#                                 y3d = d[l]\n",
    "#                                 z3d = abs(dffff[dffff[colorpara] == f[n]][[zver]])\n",
    "#                                 ax3d.set_xlim(0, max(a))  # X轴范围\n",
    "#                                 ax3d.set_ylim(0, max(c))  # Y轴范围\n",
    "#                                 ax3d.set_zlim(0, 1)  # Z轴范围\n",
    "#                                 ax3d.invert_yaxis()\n",
    "#                                 sc = ax3d.scatter(x3d, y3d, z3d, c=colorl, cmap=colorltype, vmin=0, vmax=1,\n",
    "#                                                   alpha=1, s=10,\n",
    "#                                                   label=x3daxis + '=' + str(b[j]) + ', ' + y3daxis + '=' + str(\n",
    "#                                                       d[l]) +\n",
    "#                                                         colorpara + '=' + str(f[n]))\n",
    "#                                 plt.legend([], bbox_to_anchor=(0.8, 0.7),\n",
    "#                                            loc='center', prop={'size': 5}, frameon=False,\n",
    "#                                            title=str(subplotpara) + '=' + str(bbsubplotpara[subplotnum]))\n",
    "#                 # ——————————————colorbar设置————————————————————————————————\n",
    "#                 cmap = plt.get_cmap(colorltype, len(e))\n",
    "#                 norm = mpl.colors.Normalize(vmin=min(e), vmax=max(e))\n",
    "#                 scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n",
    "#                 levels = f\n",
    "#                 print(levels)\n",
    "#                 position = fig.add_axes([2 / 5, 0, 1 / 3, 1 / 3])  # [左下角横坐标,左下角纵坐标,相对整体宽度,相对整体高度]\n",
    "#                 cb = fig.colorbar(scalarMap, ax=position, label=colorpara, orientation=\"vertical\", shrink=1)\n",
    "#                 plt.axis(\"off\")\n",
    "#             plt.show()  # 分类相互作用输出，三次一循环"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "58490d70",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9e31b8b4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-07T04:00:36.674734Z",
     "start_time": "2023-07-07T04:00:29.852596Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.colors as colors\n",
    "import matplotlib.cm as cm\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=10)\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# cfont = FontProperties(fname=\"FangSong.ttc\", size=10)\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"simsun\"]#宋体\n",
    "plt.rcParams['figure.dpi']=100\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "\n",
    "zver=str('SLcf2f')#z坐标\n",
    "print('Show Time')\n",
    "# 标准参数序列\n",
    "standardvar=['H','B','L','T1','T2','n']\n",
    "subplotpara=str('L')\n",
    "colorpara=str('n')\n",
    "x3daxis=str('T1')\n",
    "y3daxis=str('T2')\n",
    "colorltype=str('viridis')\n",
    "# ————————dataframe分类循环，这部分都是对dataframe进行的操作，以便进行特定值筛选——————\n",
    "# 主类参数一品类循环（L与n）\n",
    "clarifylist=['H','B']# 这里的最后一个变量是颜色参数变量\n",
    "geo_varmainl=clarifylist #循环参数列表\n",
    "for gl in range(0,len(geo_varmainl)):\n",
    "    lianvar=geo_varmainl[gl]# 取出作为大参数的的变量\n",
    "    aal = list(df[lianvar].unique())   # 列出所有的唯一值\n",
    "    len(aal) # 统计变量中有多少个不一样的水平\n",
    "    bbl=sorted(aal)\n",
    "    print('主类参数一品类循环')\n",
    "    print('本轮分图主类参一为',lianvar)\n",
    "# 主类参数一数值循环（L与n）    \n",
    "    for glj in range(0,len(aal)):\n",
    "        dfl=df[df[str(lianvar)].isin([bbl[glj]])]# 构造除去参数恒定值的的df表  \n",
    "        print('本轮主类参数一分大类，以下图内',lianvar,'=',bbl[gl])\n",
    "#         print(dfl)\n",
    "# 主类参数二品类循环（L与n）\n",
    "        geo_varmainlse=clarifylist #循环参数列表\n",
    "        for glse in range(1,len(geo_varmainlse)):\n",
    "            lianvarse=geo_varmainlse[glse]# 大参数的\n",
    "            aalse = list(df[lianvarse].unique())   # 列出该列的唯一值\n",
    "            len(aalse) # 统计变量中有多少个不一样的水平\n",
    "            bblse=sorted(aalse)\n",
    "            print('主类参数二品类循环，包含参数',geo_varmainlse)\n",
    "            print('本轮分图主类参二',lianvarse)\n",
    "# 主类参数二数值循环\n",
    "            for glsej in range(0,len(aalse)):\n",
    "                print('本轮品类参数二分图，以下图内',lianvarse,'=',bblse[glsej])\n",
    "                dflse=dfl[dfl[str(lianvarse)].isin([bblse[glsej]])]# 构造除去参数恒定值的的df表                  \n",
    "# —————————————分类参数结束，这里的dflse已经是经过分类完成的df——————————————————————    \n",
    "# 大参数循环，利用大参数的数值不同分类九宫格图形\n",
    "                aasubplotpara = list(dflse[subplotpara].unique())   # 列出大参数的唯一值\n",
    "                bbsubplotpara=sorted(aasubplotpara) # 大参数的唯一值排序\n",
    "#                 print(\"bbsubplotpara\",bbsubplotpara)\n",
    "#                 print('大参数品类循环')\n",
    "#                 print('本轮九宫格分图大参',subplotpara)\n",
    "#——————————————行列数基础参数分析。总画布行列数设置————————————————————————————————\n",
    "#             pichoriztal# 画布的分行，实际是列数（博士论文的版面为两边各留3cm，中间haiyo）\n",
    "#             picvertical# 画布的分列，实际是行数            \n",
    "                if len(aasubplotpara) ==1:\n",
    "                    pichoriztal3d=1 \n",
    "                    picvertical3d=1   \n",
    "                elif len(aasubplotpara)==2:\n",
    "                    pichoriztal3d=2  \n",
    "                    picvertical3d=1 \n",
    "                elif len(aasubplotpara)==3:\n",
    "                    pichoriztal3d=3  \n",
    "                    picvertical3d=1 \n",
    "                elif 3<len(aasubplotpara)<=6:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=2\n",
    "                elif 6<len(aasubplotpara)<=9:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=3\n",
    "                elif 9<len(aasubplotpara)<=12:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=4\n",
    "                elif 12<len(aasubplotpara)<=15:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=5           \n",
    "                elif 15<len(aasubplotpara)<=18:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=6  \n",
    "                elif 18<len(aasubplotpara)<=21:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=7  \n",
    "                elif 21<len(aasubplotpara)<=24:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=8\n",
    "                elif 24<len(aasubplotpara)<=27:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=9\n",
    "                elif 27<len(aasubplotpara)<=30:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=10\n",
    "                elif 30<len(aasubplotpara)<=33:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=11           \n",
    "                elif 33<len(aasubplotpara)<=36:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=12  \n",
    "                elif 36<len(aasubplotpara)<=39:\n",
    "                    pichoriztal3d=3\n",
    "                    picvertical3d=13      \n",
    "                # 修改子图排布、\n",
    "                if len(aasubplotpara)==1:\n",
    "                    fig,ax = plt.subplots(figsize=(1.9, 5.7*(picvertical3d/3)))   \n",
    "                if len(aasubplotpara)==2:\n",
    "                    fig,ax = plt.subplots(figsize=(3.8, 5.7*(picvertical3d/3)))  \n",
    "                else:\n",
    "                    fig,ax = plt.subplots(figsize=(5.7, 5.7*(picvertical3d/3)))\n",
    "        #       色彩集和标注集\n",
    "                colors3d=['r','g','b','y','c','m','tab:gray','tab:olive']\n",
    "                markers3d=['^','x','+','s','v','o','*','D']            \n",
    "                picyu3d=len(aasubplotpara)-(int(len(aasubplotpara)/3)*3) # 余数# 利用循环在子图上添加数据，参数的变化为3的倍数多几张图张图\n",
    "# #——————————————具体参数———————————————————————————————— \n",
    "                ax3d=ax\n",
    "                print(\"九宫格分惨参数\",subplotpara,\"，总数\",len(bbsubplotpara),\"分别是，\",bbsubplotpara) \n",
    "                for subplotnum in range(0,len(bbsubplotpara)):# 统计有多少个变量\n",
    "                    dfo= dflse[dflse[subplotpara].isin([bbsubplotpara[subplotnum]])]# 构造某大参数（九宫格分格参数）为恒定值的df表      \n",
    "                    ax3d=plt.subplot(pichoriztal3d,picvertical3d,subplotnum+1, projection='3d')  \n",
    "#                     if l != 0 or 3 or 6 or 9 or 12 or 15 or 18 or 21:\n",
    "                        \n",
    "#                         ax3d.set_zticklabels([])   \n",
    "                    if l == 0 or 3 or 6 or 9 or 12 or 15 or 18 or 21:\n",
    "                    # 修改纵坐标的刻度\n",
    "                        ax3d.set_zticklabels([])\n",
    "                        # 修改坐标的范围\n",
    "                    print(bbsubplotpara)\n",
    "    #               X轴参数处理\n",
    "                    a = list(dfo[x3daxis].unique())   # 列出该列的唯一值\n",
    "                    b=sorted(a)\n",
    "    #               Y轴参数处理\n",
    "                    c = list(dfo[y3daxis].unique())      # 列出该列的唯一值         \n",
    "                    d=sorted(c)\n",
    "#                   X轴数值循环\n",
    "                    for j in range(0,len(a)):  \n",
    "                        dff=dfo[dfo[str(x3daxis)].isin([b[j]])]# 构造除去参数恒定值的的df表\n",
    "                        ax3d.set_xlabel(x3daxis, fontproperties=font_setS)\n",
    "                        ax3d.set_ylabel(y3daxis, fontproperties=font_setS)\n",
    "                        ax3d.set_zlabel(zver,rotation=90,fontproperties=font_setS)     \n",
    "                        ax3d.invert_xaxis()                        \n",
    "#                   Y轴数值循环\n",
    "                        for l in range(0,len(c)):  \n",
    "                            dfff=dff[dff[y3daxis].isin([d[l]])]# 构造除去参数恒定值的的df表\n",
    "            #       三级参数品类循环（从第一级参数的第三个数开始）\n",
    "                            geo_varthi=standardvar #循环变量列表\n",
    "#                   颜色参数的参数处理\n",
    "                            e = list(dfff[colorpara].unique())      # 列出该列的唯一值         \n",
    "                            f = sorted(e)\n",
    "                            print('e',e)\n",
    "#                             print('本轮三级参数品类环，色谱，变量',colorpara,'它所有可能的值数量：',len(f),'分别是',f)                                                   \n",
    "          # 三级参数数值循环（颜色分类）本级别下已经具有了唯一性\n",
    "                            for n in range(0,len(e)):   \n",
    "                                dffff=dfff[dfff[colorpara].isin([f[n]])]# 构造除去参数恒定值的的df表\n",
    "#                                 print('本轮三级参数数值循环，颜色。参数总数',len(e),'本组参数',colorpara,'=',f[n],'第',n,\"个\") \n",
    "#                                 print(dffff)\n",
    "                                markers=['^','x','+','s','v','o','*','D']  \n",
    "                                colorllist=   np.array(f[n])  # 颜色分类参数\n",
    "#                                 print('本组数值。真实值',f[n],'归一化后',f[n]/max(e))\n",
    "                                colorl=np.full((1,len(dffff)), f[n]/max(e))\n",
    "#                                 print(colorl)\n",
    "                                x3d=b[j]   # 本级参数的值                        \n",
    "                                y3d=d[l]                         \n",
    "                                z3d=abs(dffff[dffff[colorpara]==f[n]][[zver]])   \n",
    "                                ax3d.set_xlim(0,max(a))#X轴范围                                    \n",
    "                                ax3d.set_ylim(0,max(c))#Y轴范围   \n",
    "                                ax3d.set_zlim(0,1)#Z轴范围  \n",
    "                                \n",
    "                                ax3d.invert_yaxis()\n",
    "#                                 ax3d.zaxis.set_major_locator(IndexLocator(5,10))#刻度线\n",
    "#                                 ax3d.set_zticklabels(ax3d.get_zticks(), fontdict={'ha':'left'})\n",
    "                                sc = ax3d.scatter(x3d,y3d,z3d,c=colorl, cmap=colorltype,vmin=0, vmax=1,\n",
    "                                             alpha=1,s=10,\n",
    "                                             label=x3daxis+'='+str(b[j])+', '+y3daxis+'='+str(d[l])+\n",
    "                                             colorpara+'='+str(f[n]))\n",
    "                                plt.legend([], bbox_to_anchor=(0.8, 0.7),\n",
    "                                           loc='center', prop={'size': 5},frameon=False,\n",
    "                                           title=str(subplotpara)+'='+str(bbsubplotpara[subplotnum]))\n",
    "#                                                 plt.legend(fontsize=8, markerscale=1, scatterpoints=1)\n",
    "#                 cf = ax3d.contourf(x3d, y3d, z3d, zdir='z3d',offset=-2, cmap=plt.cm.jet)\n",
    "#                 im1 = ax1.scatter(x, y, c=y, cmap='magma')\n",
    "#                 divider = make_axes_locatable(ax1)\n",
    "# #                 cax = b.append_axes(\"right\", size=\"5%\", pad=.05)\n",
    "#                 position=fig.add_axes([0.15, 0.05, 0.7, 0.03])\n",
    "#                 plt.colorbar(ax3d, cax=position)\n",
    "#                 cNorm = colors.Normalize(vmin=0, vmax=1)\n",
    "                                ax3d.plot_surface(x3d,y3d,z3d,cmap=plt.cm.winter,rstride=10,cstride=10)\n",
    "# #——————————————colorbar设置———————————————————————————————— \n",
    "                cmap = plt.get_cmap(colorltype, len(e)) \n",
    "                norm = mpl.colors.Normalize(vmin=min(e), vmax= max(e)) \n",
    "                scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n",
    "                levels = f\n",
    "                print(levels) \n",
    "                position=fig.add_axes([2/5,0,1/3,1/3])#[左下角横坐标,左下角纵坐标,相对整体宽度,相对整体高度]\n",
    "                cb = fig.colorbar(scalarMap,ax=position,label=colorpara, orientation=\"vertical\",shrink=1)               \n",
    "                plt.axis(\"off\")                \n",
    "#                 cb.ax.yaxis.set_major_locator(MultipleLocator(500))# 这里的yaxis是由于是垂直bar\n",
    "            plt.show()# 分类相互作用输出，三次一循环                 "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "53a09bc9",
   "metadata": {},
   "source": [
    "## 整体截面中柱子曲线交互关系（三维）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "108bc505",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "# 字体设置\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=12)\n",
    "plt.rc('font', family='Times New Roman')  # 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"] = [\"simsun\"]  # 宋体\n",
    "plt.rcParams['figure.dpi'] = 100\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "\n",
    "# 假设 df 是一个 DataFrame\n",
    "import pandas as pd\n",
    "# 这里使用示例数据，你需要替换为实际数据\n",
    "\n",
    "dff = df_T.copy()\n",
    "\n",
    "print('展示全部数据点')  # 展示全部数据点\n",
    "geo_var = ['H', 'B', 'T1', 'T2', 'L', 'n']  # 循环变量列表\n",
    "\n",
    "for i in range(0, len(geo_var)):  # 统计有多少个变量值\n",
    "    bianvar = geo_var[i]  # 从表中往出抽不同参数\n",
    "    a = list(df[bianvar].unique())  # 列出该列的唯一值\n",
    "    b = sorted(a)\n",
    "\n",
    "    for j in range(1, len(a)):\n",
    "        dff = df[df[str(bianvar)].isin([b[j - 1]])]  # 构造除去参数恒定值的的 df 表\n",
    "        geo_var_copy = geo_var.copy()\n",
    "        geo_var_copy.remove(bianvar)\n",
    "        geo_varexcl = geo_var_copy\n",
    "\n",
    "        # 双因素交互图\n",
    "        for k in range(0, len(geo_varexcl)):\n",
    "            cianvar = geo_varexcl[k]  # 从表中往出抽不同参数\n",
    "            c = list(df[cianvar].unique())  # 列出该列的唯一值\n",
    "            d = sorted(c)\n",
    "\n",
    "            # 标记点\n",
    "            colors = ['r', 'g', 'b', 'y', 'c', 'm', 'tab:gray', 'tab:olive']\n",
    "            markers = ['^', 'x', '+', 's', 'v', 'o', '*', 'D']\n",
    "\n",
    "            ax3d = plt.axes(projection='3d')  # 重新构造画布\n",
    "            ax3d.set_ylim(0, max(d))\n",
    "            ax3d.set_xlim(0, 3)\n",
    "            ax3d.set_zlim(0, 1)\n",
    "            ax3d.set_xlabel('正则化长细比', fontproperties=font_setS)\n",
    "            ax3d.set_ylabel(bianvar, fontproperties=font_setS)\n",
    "            ax3d.set_zlabel('稳定系数', rotation=90, fontproperties=font_setS)\n",
    "\n",
    "            # 输出当前图的筛选条件和展示的数据信息\n",
    "            print(f\"当前图展示数据条件：{bianvar} = {b[j - 1]}, 与 {cianvar} 不同取值的关系\")\n",
    "\n",
    "            for l in range(0, len(c)):\n",
    "                z3d1 = abs(dff[dff[cianvar] == d[l]][['SFcf2f']])\n",
    "                x3d1 = abs(dff[dff[cianvar] == d[l]][['SLcf2f']])\n",
    "                y3d1 = d[l]\n",
    "                ax3d.scatter(x3d1, y3d1, z3d1, marker=markers[l], c=colors[l], alpha=1, s=1,\n",
    "                             label=bianvar + '=' + str(b[j - 1]) + ', ' + str(cianvar) + '=' + str(d[l]))\n",
    "            plt.legend(fontsize=8, markerscale=2, scatterpoints=1)\n",
    "            plt.show()  # 分类相互作用输出"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "74d2e65d",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e4512ff0",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-07T04:00:44.935130Z",
     "start_time": "2023-07-07T04:00:44.351659Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=12)\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "# cfont = FontProperties(fname=\"FangSong.ttc\", size=10)\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"simsun\"]#宋体\n",
    "plt.rcParams['figure.dpi']=100\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "#采用色卡区分不同因素的曲面\n",
    "ax3d = plt.axes(projection='3d')# 重新构造画布\n",
    "print('展示全部数据点')     # 展示全部数据点\n",
    "geo_var=['H','B','T1','T2','L','n'] #循环变量列表\n",
    "for i in range(0,len(geo_var)):# 统计有多少个变量值\n",
    "    bianvar=geo_var[i]# 从表中往出抽不同参数\n",
    "    a = list(df[bianvar].unique())   # 列出该列的唯一值\n",
    "    len(a) # 统计变量中有多少个不一样的水平\n",
    "    b=sorted(a)\n",
    "    for j in range(1,len(a)):\n",
    "#         z3d=abs(dff[dff[bianvar]==b[j]][['SFcf2f']])\n",
    "#         x3d=abs(dff[dff[bianvar]==b[j]][['SLcf2f']])    \n",
    "#         y3d=b[j]\n",
    "        geo_var=['H','B','T1','T2','L','n']\n",
    "#         plt.text(2.3,0.8, str(bianvar)+'='+str(b[j-1]), fontsize=10)\n",
    "#         plt.xlim((0, 3))\n",
    "#         plt.ylim((0, 1))\n",
    "#         print('下图为包括',bianvar,'=',b[j-1],'的所有数据')        \n",
    "#         ax3d.scatter(x3d,y3d,y3d)\n",
    "#         ax3d.set_xlabel('正则化长细比', fontproperties=font_setS,size=12)\n",
    "#         ax3d.set_ylabel('变量', fontproperties=font_setS,size=12)\n",
    "#         ax3d.set_zlabel('稳定系数', fontproperties=font_setS,size=12)\n",
    "        dff=df[df[str(bianvar)].isin([b[j-1]])]# 构造除去参数恒定值的的df表\n",
    "        geo_var=['H','B','T1','T2','L','n']\n",
    "        geo_var.remove(bianvar)\n",
    "        geo_varexcl=geo_var\n",
    "#         ax3d.set_xlim(0, 3)\n",
    "#         ax3d.set_ylim(0, max(a))\n",
    "#         ax3d.set_zlim(0, 1)\n",
    "#         ax3d.set_xticks(np.arange(0, 3, 0.5))\n",
    "#         ax3d.set_yticks(np.arange(0, max(a),max(a)/5))\n",
    "#         ax3d.set_zticks(np.arange(0,2, 0.5))\n",
    "#         ax3d.set_xlabel('正则化长细比', fontproperties=font_setS)\n",
    "#         ax3d.set_ylabel(bianvar, fontproperties=font_setS)\n",
    "#         ax3d.set_zlabel('稳定系数',fontproperties=font_setS)  \n",
    "        # 双因素交互图\n",
    "        for k in range(0,len(geo_varexcl)):\n",
    "            cianvar=geo_varexcl[k]# 从表中往出抽不同参数\n",
    "            c = list(df[cianvar].unique())      # 列出该列的唯一值         \n",
    "            print(len(c)) # 统计变量中有多少个不一样的水平\n",
    "            d=sorted(c)\n",
    "#             ax3d = plt.axes(projection='3d')# 重新构造画布\n",
    "## 优化坐标轴等显示参数    \n",
    "            # 标记点\n",
    "            colors=['r','g','b','y','c','m','tab:gray','tab:olive']\n",
    "            markers=['^','x','+','s','v','o','*','D']\n",
    "            ax3d = plt.axes(projection='3d')# 重新构造画布\n",
    "            ax3d.set_ylim(0, max(d))\n",
    "            ax3d.set_xlim(0, 3)\n",
    "            ax3d.set_zlim(0, 1)\n",
    "            ax3d.set_xlabel('正则化长细比', fontproperties=font_setS)\n",
    "            ax3d.set_ylabel(bianvar, fontproperties=font_setS)\n",
    "            ax3d.set_zlabel('稳定系数',rotation=90,fontproperties=font_setS)            \n",
    "            for l in range(0,len(c)):\n",
    "#                 ax3d = plt.axes(projection='3d')# 重新构造画布                    \n",
    "                z3d1=abs(dff[dff[cianvar]==d[l]][['SFcf2f']])\n",
    "                x3d1=abs(dff[dff[cianvar]==d[l]][['SLcf2f']])    \n",
    "                y3d1=d[l]\n",
    "                print('cianvar')\n",
    "                print(cianvar)\n",
    "                print(d[l])\n",
    "                ax3d.scatter(x3d1,y3d1,z3d1,marker=markers[l-1],c=colors[l-1],alpha=1,s=1,\n",
    "                           label=bianvar+'='+str(b[j-1])+', '+str(cianvar)+'='+str(d[l]))\n",
    "                plt.legend(fontsize=8, markerscale=2, scatterpoints=1)\n",
    "        plt.show()# 分类相互作用输出                "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "df138db4",
   "metadata": {},
   "source": [
    "# 理论计算和规范图"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "430d1cd2",
   "metadata": {},
   "source": [
    "## 按照轴压理论"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "df38f83b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T19:56:46.604502Z",
     "start_time": "2023-09-18T19:56:45.924604Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import operator\n",
    "import symfit as sf\n",
    "from symfit import variables, parameters, Fit, exp, Model\n",
    "from symfit.core.objectives import LogLikelihood\n",
    "# —————————规范图-中国规范轴压——————\n",
    "\n",
    "def plotcode_cn (a_cn,b_cns,b_cnl,c_cns,c_cnl,codecolor):\n",
    "    codeplotx1 = np.linspace(0, 0.215, 100)\n",
    "    codeploty1 =1-a_cn*(codeplotx1**2)\n",
    "    codeplotx2 = np.linspace(0.215,1.05, 100)\n",
    "    codeploty2 =  ((b_cns+c_cns*codeplotx2+codeplotx2**(2))-((b_cns+c_cns*codeplotx2+codeplotx2**(2))**(2)-\n",
    "                                                             4*(codeplotx2**(2)))**(0.5))*0.5/(codeplotx2**(2))\n",
    "    codeplotx3 = np.linspace(1.05,3, 100)\n",
    "    codeploty3 =  ((b_cnl+c_cnl*codeplotx3+codeplotx3**(2))-((b_cnl+c_cnl*codeplotx3+codeplotx3**(2))**(2)-\n",
    "                                                             4*(codeplotx3**(2)))**(0.5))*0.5/(codeplotx3**(2))\n",
    "    plt.plot(codeplotx1,codeploty1,codecolor,label='type',alpha = .5)    \n",
    "    plt.plot(codeplotx2,codeploty2,codecolor,label='type',alpha = .5) \n",
    "    plt.plot(codeplotx3,codeploty3,codecolor,label='type',alpha = .5)                                                                                                     \n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))   \n",
    "cn_list=[[0.41,0.986,0.986,0.152,0.152,'g'],\n",
    "         [0.65,0.965,0.965,0.3,0.3,'b'],\n",
    "         [0.73,0.906,1.216,0.595,0.302,'y'],\n",
    "         [1.35,0.868,1.372,0.915,0.432,'g']]\n",
    "for i in range(4):\n",
    "    print(i)\n",
    "#         print(cn_listpar)\n",
    "    cn_listpar=cn_list[i]\n",
    "    print(cn_listpar)       \n",
    "    plotcode_cn(cn_listpar[0],cn_listpar[1],cn_listpar[2],cn_listpar[3],cn_listpar[4],cn_listpar[5])\n",
    "plt.show()\n",
    "plt.close\n",
    "# # -----------------规范图-美国规范轴压---------------------\n",
    "plt.clf()\n",
    "def plotcode_us(alphausa_us,alphausb_us,codecolor_us):\n",
    "    codeplot_us_x1 = np.linspace(0, 1.5, 100)\n",
    "    codeplot_us_y1 = alphausa_us**(codeplot_us_x1*codeplot_us_x1)\n",
    "    codeplot_us_x2 = np.linspace(1.5,3, 100)\n",
    "    codeplot_us_y2 = alphausb_us/(codeplot_us_x2*codeplot_us_x2)\n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))  \n",
    "    plt.plot(codeplot_us_x1,codeplot_us_y1,codeplot_us_y1,label='type',alpha = .5)    \n",
    "    plt.plot(codeplot_us_x2,codeplot_us_y2,codeplot_us_y2,label= 'type',alpha = .5)           \n",
    "eu_list=[[0.658,0.877,'g']]\n",
    "for j in range(1):\n",
    "    us_listpar=eu_list[j]\n",
    "    print(us_listpar)\n",
    "    us_listpar[0]\n",
    "    us_listpar[1]\n",
    "    plotcode_us(us_listpar[0],us_listpar[1],us_listpar[2])\n",
    "plt.show()\n",
    "plt.close\n",
    "# ————————规范图-欧洲规范轴压———————————————\n",
    "plt.clf()\n",
    "def plotcode_eu(alphaeu,codecolor_eu):\n",
    "    codeplot_eu_x1 = np.linspace(0, 0.2, 100)\n",
    "    codeplot_eu_y1 = np.linspace(1, 1, num=100)\n",
    "    codeplot_eu_x2 = np.linspace(0.2,3, 100)\n",
    "    codeplot_eu_y2 = 1/((0.5*(1+alphaeu*(codeplot_eu_x2-0.2)+codeplot_eu_x2**(2)))\n",
    "                        +((0.5*(1+alphaeu*(codeplot_eu_x2-0.2)+codeplot_eu_x2**(2)))**(2)\n",
    "                         -codeplot_eu_x2**(2))**(0.5))\n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))   \n",
    "    plt.plot(codeplot_eu_x1,codeplot_eu_y1,codecolor_eu,label='type',alpha = .5)    \n",
    "    plt.plot(codeplot_eu_x2,codeplot_eu_y2,codecolor_eu,label= 'type',alpha = .5)        \n",
    "eu_list=[[0.13,'g'],\n",
    "         [0.21,'b'],\n",
    "         [0.34,'y'],\n",
    "         [0.49,'g'],         \n",
    "         [0.76,'y']]\n",
    "for k in range(5):\n",
    "    eu_listpar=eu_list[k]\n",
    "    print(eu_listpar)\n",
    "    eu_listpar[0]\n",
    "    eu_listpar[1]\n",
    "    plotcode_eu(eu_listpar[0],eu_listpar[1])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a0b55899",
   "metadata": {},
   "source": [
    "## 按照板件理论"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e9233866",
   "metadata": {},
   "source": [
    "### 导入包"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49804784",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T19:56:47.061341Z",
     "start_time": "2023-09-18T19:56:47.045388Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import operator\n",
    "import symfit as sf\n",
    "from symfit import variables, parameters, Fit, exp, Model\n",
    "from symfit.core.objectives import LogLikelihood\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.display import Latex"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "52ccc0ac",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-01-01T10:35:32.520664Z",
     "start_time": "2023-01-01T10:35:32.502741Z"
    }
   },
   "source": [
    "简支短边\t简支长边\n",
    "$4.00+\\frac{5.34}{\\alpha ^2}$\n",
    "\n",
    "简支长边\t简支短边\n",
    "$5.34+\\frac{4.00}{\\alpha ^2}$\n",
    "\n",
    "固支短边\t固支长边\n",
    "$5.6+\\frac{8.98}{\\alpha ^2}$\n",
    "\n",
    "固支长边\t固支短边\n",
    "$8.98+\\frac{5.6}{\\alpha ^2}$\n",
    "\n",
    "简支短边\t固支长边\n",
    "$\\frac{8.98}{\\alpha ^2}+5.61-1.99\\alpha $\n",
    "\n",
    "简支长边\t固支短边\n",
    "$5.34+\\frac{2.31}{\\alpha}-\\frac{3.44}{\\alpha ^2}+\\frac{8.39}{\\alpha ^3}$\n",
    "\n",
    "固支短边\t简支长边\n",
    "$\\frac{5.34}{\\alpha ^2}+\\frac{2.31}{\\alpha}-3.44+8.39\\alpha \\quad $\n",
    "\n",
    "固支长边\t简支短边\n",
    "$8.98+\\frac{5.61}{\\alpha ^2}-\\frac{1.99}{\\alpha ^3}$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10821aab",
   "metadata": {},
   "source": [
    "### 纯理论的受剪临界应力"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "361e0d00",
   "metadata": {},
   "source": [
    "#### 理论受剪板公式计算"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6c442456",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "\n",
    "# 定义全局参数\n",
    "linewidth = 2.5\n",
    "# 设置字体为宋体，大小为14\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=14)\n",
    "\n",
    "# 设置全局字体和绘图参数\n",
    "# 全局字体设置为新罗马字体\n",
    "plt.rc('font', family='Times New Roman')\n",
    "# 设置中文字体为宋体，防止中文显示乱码\n",
    "plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "# 解决负号显示问题\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "# 设置x轴刻度线向内显示\n",
    "plt.rcParams['xtick.direction'] = 'in'\n",
    "# 设置y轴刻度线向内显示\n",
    "plt.rcParams['ytick.direction'] = 'in'\n",
    "\n",
    "# 定义DataFrame的列名列表\n",
    "alpha_ks_list = ['alpha_ks', 'edge_a_length', 'edge_b_length', 'shoredge_condition', 'longedge_condition', '1/alpha_ks', 'ks']\n",
    "\n",
    "# 创建一个空的DataFrame，用于存储后续计算的数据\n",
    "df_alpha_ks_list = pd.DataFrame(columns=alpha_ks_list)\n",
    "\n",
    "# 生成不同的边长数据，这里a边和b边的长度都从1到100，均匀取100个值\n",
    "edge_a_lengths = np.linspace(1, 100, 100)\n",
    "edge_b_lengths = np.linspace(1, 100, 100)\n",
    "# 短边边界条件列表，0表示简支，1表示固接\n",
    "shoredge_condition_list = [0, 1]\n",
    "# 长边边界条件列表，0表示简支，1表示固接\n",
    "longedge_condition_list = [0, 1]\n",
    "\n",
    "# 遍历所有可能的a边长度\n",
    "for edge_a_length in edge_a_lengths:\n",
    "    # 遍历所有可能的b边长度\n",
    "    for edge_b_length in edge_b_lengths:\n",
    "        # 计算alpha_ks，它是a边长度与b边长度的比值\n",
    "        alpha_ks = edge_a_length / edge_b_length\n",
    "        # 找出短边的长度\n",
    "        shoredge_lenth = min(edge_a_length, edge_b_length)\n",
    "        # 找出长边的长度\n",
    "        longedge_lenth = max(edge_a_length, edge_b_length)\n",
    "\n",
    "        # 遍历短边的所有可能边界条件\n",
    "        for shoredge_condition in shoredge_condition_list:\n",
    "            # 遍历长边的所有可能边界条件\n",
    "            for longedge_condition in longedge_condition_list:\n",
    "                # 当alpha_ks小于等于1时，认为板件是狭长型\n",
    "                if alpha_ks <= 1:\n",
    "                    # 短边简支，长边简支的情况\n",
    "                    if shoredge_condition == 0 and longedge_condition == 0:\n",
    "                        # 根据公式计算ks值\n",
    "                        ks = 4 + 5.34 / (alpha_ks ** 2)\n",
    "                        # 定义该情况的标签，使用LaTeX语法显示数学公式\n",
    "                        label1 = r'$\\alpha\\leq1, 4.00+\\dfrac{5.34}{\\alpha ^2}$, SS'\n",
    "                    # 短边固接，长边固接的情况\n",
    "                    elif shoredge_condition == 1 and longedge_condition == 1:\n",
    "                        ks = 5.6 + 8.98 / (alpha_ks ** 2)\n",
    "                        label2 = r'$\\alpha\\leq1,5.6+\\dfrac{8.98}{\\alpha ^2}$, FF'\n",
    "                    # 短边简支，长边固接的情况\n",
    "                    elif shoredge_condition == 0 and longedge_condition == 1:\n",
    "                        ks = 8.98 / (alpha_ks ** 2) + 5.61 - 1.99 * alpha_ks\n",
    "                        label3 = r'$\\alpha\\leq1,\\dfrac{8.98}{\\alpha ^2}+5.61-1.99\\alpha$, SF'\n",
    "                    # 短边固接，长边简支的情况\n",
    "                    elif shoredge_condition == 1 and longedge_condition == 0:\n",
    "                        ks = 5.34 / (alpha_ks ** 2) + 2.31 / alpha_ks - 3.44 + 8.39 * alpha_ks\n",
    "                        label4 = r'$\\alpha\\leq1,\\dfrac{5.34}{\\alpha^2}+\\dfrac{2.31}{\\alpha}-3.44+8.39\\alpha$, FS'\n",
    "                # 当alpha_ks大于1时，认为板件是矮胖型\n",
    "                else:\n",
    "                    # 长边简支，短边简支的情况\n",
    "                    if longedge_condition == 0 and shoredge_condition == 0:\n",
    "                        ks = 5.34 + 4 / (alpha_ks ** 2)\n",
    "                        label5 = r'$\\alpha\\geq1,5.34+\\dfrac{4.00}{\\alpha ^2}$, SS'\n",
    "                    # 长边固接，短边固接的情况\n",
    "                    elif longedge_condition == 1 and shoredge_condition == 1:\n",
    "                        ks = 8.98 + 5.6 / (alpha_ks ** 2)\n",
    "                        label6 = r'$\\alpha\\geq1,8.98+\\dfrac{5.6}{\\alpha ^2}$, FF'\n",
    "                    # 长边简支，短边固接的情况\n",
    "                    elif longedge_condition == 0 and shoredge_condition == 1:\n",
    "                        ks = 5.34 + 2.31 / alpha_ks - 3.44 / (alpha_ks ** 2) + 8.39 / (alpha_ks ** 3)\n",
    "                        label7 = r'$\\alpha\\geq1,5.34+\\dfrac{2.31}{\\alpha}-\\dfrac{3.44}{\\alpha^2}+\\dfrac{8.39}{\\alpha^3}$, SF'\n",
    "                    # 长边固接，短边简支的情况\n",
    "                    elif longedge_condition == 1 and shoredge_condition == 0:\n",
    "                        ks = 8.98 + 5.61 / (alpha_ks ** 2) - 1.99 / (alpha_ks ** 3)\n",
    "                        label8 = r'$\\alpha\\geq1, 8.98+\\dfrac{5.61}{\\alpha ^2}-\\dfrac{1.99}{\\alpha^3}$, FS'\n",
    "\n",
    "                # 构造一个Series，包含当前计算的所有数据\n",
    "                se_alpha_ks = pd.Series([alpha_ks, edge_a_length, edge_b_length, shoredge_condition, longedge_condition, 1 / alpha_ks, ks], index=alpha_ks_list)\n",
    "                # 将Series转换为DataFrame并添加到主DataFrame中\n",
    "                df_alpha_ks_list = pd.concat([df_alpha_ks_list, se_alpha_ks.to_frame().T], ignore_index=True)\n",
    "\n",
    "# 添加一个新列Totalcondition，其值为b边长度减去a边长度\n",
    "df_alpha_ks_list.eval(\"\"\"Totalcondition = edge_b_length - edge_a_length\"\"\", inplace=True)\n",
    "\n",
    "# 对DataFrame按alpha_ks列进行排序，确保后续绘图时数据按顺序排列\n",
    "df_alpha_ks_list = df_alpha_ks_list.sort_values(by=['alpha_ks'])\n",
    "\n",
    "# 筛选出狭长型板件的数据，即alpha_ks小于1的数据\n",
    "dfks_slender = df_alpha_ks_list[df_alpha_ks_list['alpha_ks'] < 1]\n",
    "# 筛选出矮胖型板件的数据，即alpha_ks大于1的数据\n",
    "dfks_thick = df_alpha_ks_list[df_alpha_ks_list['alpha_ks'] > 1]\n",
    "\n",
    "# 进一步筛选狭长型板件中短边简支，长边简支的数据\n",
    "dfks1 = dfks_slender[(dfks_slender['shoredge_condition'] == 0) & (dfks_slender['longedge_condition'] == 0)]\n",
    "# 进一步筛选狭长型板件中短边固接，长边固接的数据\n",
    "dfks2 = dfks_slender[(dfks_slender['shoredge_condition'] == 1) & (dfks_slender['longedge_condition'] == 1)]\n",
    "# 进一步筛选狭长型板件中短边简支，长边固接的数据\n",
    "dfks3 = dfks_slender[(dfks_slender['shoredge_condition'] == 0) & (dfks_slender['longedge_condition'] == 1)]\n",
    "# 进一步筛选狭长型板件中短边固接，长边简支的数据\n",
    "dfks4 = dfks_slender[(dfks_slender['shoredge_condition'] == 1) & (dfks_slender['longedge_condition'] == 0)]\n",
    "\n",
    "# 进一步筛选矮胖型板件中长边简支，短边简支的数据\n",
    "dfks5 = dfks_thick[(dfks_thick['shoredge_condition'] == 0) & (dfks_thick['longedge_condition'] == 0)]\n",
    "# 进一步筛选矮胖型板件中长边固接，短边固接的数据\n",
    "dfks6 = dfks_thick[(dfks_thick['shoredge_condition'] == 1) & (dfks_thick['longedge_condition'] == 1)]\n",
    "# 进一步筛选矮胖型板件中长边简支，短边固接的数据\n",
    "dfks7 = dfks_thick[(dfks_thick['shoredge_condition'] == 1) & (dfks_thick['longedge_condition'] == 0)]\n",
    "# 进一步筛选矮胖型板件中长边固接，短边简支的数据\n",
    "dfks8 = dfks_thick[(dfks_thick['shoredge_condition'] == 0) & (dfks_thick['longedge_condition'] == 1)]\n",
    "\n",
    "# 定义绘图函数\n",
    "def plot_graph(dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8, label1, label2, label3, label4, label5, label6, label7, label8, xlim, ylim, title):\n",
    "    fig = plt.figure(figsize=[9, 9])\n",
    "    plt.tick_params(bottom=True, top=True, left=True, right=True)\n",
    "    if xlim[1] <= 1:\n",
    "        # 对于0到1的区间，使用7个点\n",
    "        xticks = np.linspace(xlim[0], xlim[1], 9, endpoint=True)\n",
    "    elif xlim[1] > 1 and xlim[1] <= 3:\n",
    "        # 对于1到3的区间，使用9个点\n",
    "        xticks = np.linspace(xlim[0], xlim[1], 11, endpoint=True)\n",
    "    else:\n",
    "        # 默认情况下使用12个点\n",
    "        xticks = np.linspace(xlim[0], xlim[1], 14, endpoint=True)\n",
    "        \n",
    "    plt.xticks(xticks, size=14)\n",
    "    plt.yticks(np.linspace(ylim[0], ylim[1], 9, endpoint=True), size=14)\n",
    "    plt.xlim(*xlim)\n",
    "    plt.ylim(*ylim)\n",
    "    plt.xlabel(r'${1}/ {\\alpha}$', fontsize=14)\n",
    "    plt.ylabel(r'$k$', fontsize=14)\n",
    "\n",
    "    # 绘制折线图\n",
    "    plt.plot(dfks1['1/alpha_ks'].values, dfks1['ks'].values, c='r', ls='-', linewidth=linewidth, label=label1)\n",
    "    plt.plot(dfks5['1/alpha_ks'].values, dfks5['ks'].values, c='r', ls='-', linewidth=linewidth, label=label5)\n",
    "    plt.plot(dfks2['1/alpha_ks'].values, dfks2['ks'].values, c='g', ls='--', linewidth=linewidth, label=label2)\n",
    "    plt.plot(dfks6['1/alpha_ks'].values, dfks6['ks'].values, c='g', ls='--', linewidth=linewidth, label=label6)\n",
    "    plt.plot(dfks3['1/alpha_ks'].values, dfks3['ks'].values, c='b', ls='-.', linewidth=linewidth, label=label3)\n",
    "    plt.plot(dfks7['1/alpha_ks'].values, dfks7['ks'].values, c='b', ls='-.', linewidth=linewidth, label=label7)\n",
    "    plt.plot(dfks4['1/alpha_ks'].values, dfks4['ks'].values, c='y', ls=':', linewidth=linewidth, label=label4)\n",
    "    plt.plot(dfks8['1/alpha_ks'].values, dfks8['ks'].values, c='y', ls=':', linewidth=linewidth, label=label8)\n",
    "\n",
    "    # 填充阴影\n",
    "    plt.fill_between(dfks2['1/alpha_ks'].values, dfks2['ks'].values, dfks4['ks'].values, color='lightgray', alpha=0.5)\n",
    "    plt.fill_between(dfks6['1/alpha_ks'].values, dfks6['ks'].values, dfks8['ks'].values, color='lightgray', alpha=0.5)\n",
    "\n",
    "    # 绘制垂直直线\n",
    "    plt.axvline(1.00, linestyle='-', c='grey')\n",
    "\n",
    "    # 设置边框\n",
    "    bwith = 1\n",
    "    TK = plt.gca()\n",
    "    TK.spines['bottom'].set_linewidth(bwith)\n",
    "    TK.spines['left'].set_linewidth(bwith)\n",
    "    TK.spines['top'].set_linewidth(bwith)\n",
    "    TK.spines['right'].set_linewidth(bwith)\n",
    "    TK.spines[:].set_color('black')\n",
    "\n",
    "    # 显示图例\n",
    "    plt.legend(fontsize=10, title_fontsize=10)\n",
    "\n",
    "    # 保存图片\n",
    "    plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PHDall\\matplotilibpic\\\\\" + title + \".svg\", bbox_inches='tight', pad_inches=0)\n",
    "    plt.show()\n",
    "    plt.clf()\n",
    "\n",
    "# 绘制全部参数受剪图\n",
    "plot_graph(dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8, label1, label2, label3, label4, label5, label6, label7, label8, (0, 3), (5, 45), '板件alph全部参数受剪')\n",
    "\n",
    "# 绘制alpha大于1受剪图\n",
    "plot_graph(dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8, label1, label2, label3, label4, label5, label6, label7, label8, (1, 3), (5, 45), '板件alph大于1受剪')\n",
    "\n",
    "# 绘制alpha小于1受剪图\n",
    "plot_graph(dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8, label1, label2, label3, label4, label5, label6, label7, label8, (0, 1), (5, 15), '板件alph小于1受剪')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7ef2ff6b",
   "metadata": {},
   "source": [
    "#### 三种板件放入理论的曲线"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "17dd7f09",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "from matplotlib.font_manager import FontProperties\n",
    "import latex\n",
    "import matplotlib.pyplot as plt\n",
    "bwith = 1\n",
    "general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f', 'n']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[355.61,     0.002       , 20     ,  0   , 1     ,0  ,1  ]# 面内受剪_分离面内\n",
    "\n",
    "# 固定标准参数general list和其值\n",
    "df_selected_del=dt_T.copy()\n",
    "for i in range (0,len(general_list)):\n",
    "    df_selected_del=df_selected_del[df_selected_del[general_list[i]]==general_list_number[i]].copy()\n",
    "\n",
    "\n",
    "dftype0=df_selected_del[(df_selected_del['type']==0)&(df_selected_del['n']==1)]# &为且关系\n",
    "dftype1=df_selected_del[(df_selected_del['type']==1)&(df_selected_del['n']==1)]\n",
    "dftype2=df_selected_del[(df_selected_del['type']==2)&(df_selected_del['n']==1)]\n",
    "\n",
    "    \n",
    "xname=str('KG_total_web')\n",
    "yname=str('k_taucr_fem2')\n",
    "xlabelname=r'${1}/{\\alpha}$'\n",
    "ylabelname=r'$k_{\\mathrm{s}}$'\n",
    "\n",
    "\n",
    "pointsize=10\n",
    "textsize=14\n",
    "figsizex= 6# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= 6\n",
    "labelss=str(r'$\\mathrm{SS}$ ')\n",
    "labelsf=str(r'$\\mathrm{SF}$ ')\n",
    "labelfs=str(r'$\\mathrm{FS}$ ')\n",
    "labelff=str(r'$\\mathrm{FF}$ ')\n",
    "labeldftype0=str(r'$S_{\\mathrm{T}}$ ')\n",
    "labeldftype1=str(r'$S_{\\mathrm{S}}$ ')\n",
    "labeldftype2=str(r'$S_{\\mathrm{B}}$ ')\n",
    "\n",
    "# ————————————第一张图,小于1————————————————\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.figure(figsize=[figsizex,figsizey])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "plt.grid(visible=True, which='major') \n",
    "linewidth=2\n",
    "\n",
    "\n",
    "plt.scatter(dftype0[xname].values,dftype0[yname].values,label=labeldftype0,marker='s',s=20,c='black',edgecolors='black',)#绘图命令\n",
    "plt.scatter(dftype1[xname].values,dftype1[yname].values,label=labeldftype1,marker='^',s=20,c='black',edgecolors='black')#绘图命令\n",
    "plt.scatter(dftype2[xname].values,dftype2[yname].values,label=labeldftype2,marker='+',s=20,c='black')#绘图命令\n",
    "\n",
    "\n",
    "xticks(np.linspace(0,1,11,endpoint=True),size=textsize)# x轴标签\n",
    "yticks(np.linspace(5,15,11,endpoint=True),size=textsize)# y轴标签  \n",
    "plt.xlim(0,1)\n",
    "plt.ylim(5,15)\n",
    "plt.xlabel(xlabelname,fontsize=textsize)\n",
    "plt.ylabel(ylabelname,fontsize=textsize)\n",
    "# ——阴影区——————\n",
    "\n",
    "plt.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=labelss)\n",
    "plt.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "         label=labelff)\n",
    "plt.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "         label=labelsf)\n",
    "plt.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':',linewidth=linewidth,\n",
    "         label=labelfs)\n",
    "\n",
    "\n",
    "TK = plt.gca()#获取边框\n",
    "TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "TK.spines[:].set_color('black')\n",
    "plt.legend(fontsize=textsize, title_fontsize=textsize)\n",
    "# plt.legend(fontsize=textsize) # using a size in points\n",
    "pltsvgname=str('板件alph拟合小于1受剪') #保存名字\n",
    "# plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "plt.show()\n",
    "plt.clf\n",
    "\n",
    "# ————————————第二张图————————————————\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.figure(figsize=[figsizex,figsizey])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "plt.grid(visible=True, which='major') \n",
    "linewidth=2\n",
    "plt.scatter(dftype0[xname].values,dftype0[yname].values,label=labeldftype0,marker='s',s=5,c='none',edgecolors='c',)#绘图命令\n",
    "# plt.scatter(dftype1['KG_quge_web'].values,dftype1['k_taucr_fem2_n'].values,label=labeldftype1,marker='^',s=5,c='none',edgecolors='m')#绘图命令\n",
    "# plt.scatter(dftype2['KG_quge_web'].values,dftype2['k_taucr_fem2_n'].values,label=labeldftype2,marker='o',s=5,c='none',edgecolors='k')#绘图命令\n",
    "plt.scatter(dftype1[xname].values,dftype1[yname].values,label=labeldftype1,marker='^',s=5,c='none',edgecolors='m')#绘图命令\n",
    "plt.scatter(dftype2[xname].values,dftype2[yname].values,label=labeldftype2,marker='o',s=5,c='none',edgecolors='m')#绘图命令\n",
    "\n",
    "\n",
    "\n",
    "xticks(np.linspace(1,3,11,endpoint=True),size=textsize)# x轴标签\n",
    "yticks(np.linspace(5,25,11,endpoint=True),size=textsize)# y轴标签  \n",
    "plt.xlim(1,3)\n",
    "plt.ylim(5,25)\n",
    "plt.xlabel(xlabelname,fontsize=textsize)\n",
    "plt.ylabel(ylabelname,fontsize=textsize)\n",
    "\n",
    "# ——阴影区——————\n",
    "plt.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=labelss)\n",
    "plt.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth,\n",
    "         label=labelff)\n",
    "plt.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "         label=labelsf)\n",
    "plt.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "         label=labelfs)\n",
    "\n",
    "plt.legend(fontsize=textsize) # using a size in points\n",
    "plt.axvline(1.00,linestyle='-',c='grey')\n",
    "bwith = 1 #边框宽度设置为2\n",
    "TK = plt.gca()#获取边框\n",
    "TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "TK.spines[:].set_color('black')\n",
    "\n",
    "\n",
    "\n",
    "pltsvgname=str('板件alph拟合大于1受剪') #保存名字\n",
    "# plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "425c9b3b",
   "metadata": {},
   "source": [
    "#### 单独整体截面板件放入理论的曲线"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f39674b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib.font_manager import FontProperties\n",
    "import latex\n",
    "import matplotlib.pyplot as plt\n",
    "# df2d_rela=df[(df['n']==1)]\n",
    "# # df2d_rela1=df2d_rela[(df2d_rela['KG_quge_web']==5.6)]ratio_alpha_tflange_to_tweb\n",
    "# print(len(df))\n",
    "pointsize=10\n",
    "textsize=14\n",
    "figsizex= 6# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= 6\n",
    "labelss=str(r'$\\mathrm{SS}$ ')\n",
    "labelsf=str(r'$\\mathrm{SF}$ ')\n",
    "labelfs=str(r'$\\mathrm{FS}$ ')\n",
    "labelff=str(r'$\\mathrm{FF}$ ')\n",
    "labeldftype0=str(r'$\\mathrm{S}_{\\mathrm{T}}$ ')\n",
    "labeldftype1=str(r'$\\mathrm{S}_{\\mathrm{S}}$ ')\n",
    "labeldftype2=str(r'$\\mathrm{S}_{\\mathrm{B}}$ ')\n",
    "\n",
    "general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f', 'type']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[355.61,     0.002       , 20     ,  0   , 1     ,0    , 0]# 面内受剪_分离面内\n",
    "df_selected_del=dt_T.copy()\n",
    "for i in range (0,len(general_list)):\n",
    "    df_selected_del=df_selected_del[df_selected_del[general_list[i]]==general_list_number[i]].copy()\n",
    "    \n",
    "df=df_selected_del\n",
    "\n",
    "\n",
    "# ————————————第一张图————————————————\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.figure(figsize=[figsizex,figsizey])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# plt.grid(b=1, which='major') \n",
    "linewidth=2\n",
    "\n",
    "plt.legend(fontsize=textsize, title_fontsize=textsize)\n",
    "\n",
    "\n",
    "plt.scatter(df['KG_total_web'].values,df['k_taucr_fem2'].values,label=labeldftype0,c='black',s=10)#绘图命令\n",
    "# plt.scatter(dftype2['KG_quge_web'].values,dftype2['k_taucr_fem2_n'].values,label=labeldftype0,c='black',s=10)#绘图命令\n",
    "\n",
    "xticks(np.linspace(0,3,13,endpoint=True),size=14)# x轴标签\n",
    "yticks(np.linspace(5,45,9,endpoint=True),size=14)# y轴标签  \n",
    "plt.xlim(0,3)\n",
    "plt.ylim(5,45)\n",
    "plt.xlabel(r'$\\frac{1}{\\alpha}$',fontsize=textsize)\n",
    "plt.ylabel(r'$k_{\\mathrm{s}}$',fontsize=textsize)\n",
    "# ——阴影区——————\n",
    "\n",
    "plt.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=labelss)\n",
    "plt.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "         label=labelff)\n",
    "plt.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "         label=labelsf)\n",
    "plt.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':',linewidth=linewidth,\n",
    "         label=labelfs)\n",
    "plt.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth)\n",
    "plt.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth)\n",
    "plt.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth)\n",
    "plt.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth)\n",
    "\n",
    "\n",
    "plt.axvline(1.00,linestyle='-',c='grey')\n",
    "bwith = 1 #边框宽度设置为2\n",
    "TK = plt.gca()#获取边框\n",
    "TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "TK.spines[:].set_color('black')\n",
    "plt.legend()\n",
    "\n",
    "pltsvgname=str('整体截面板件alph拟合受剪') #保存名字\n",
    "# plt.savefig(r\"R:\\PhDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "plt.show()\n",
    "plt.clf\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "be2ba4de-00d4-4e13-b697-5fb55ac2c91d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-08-07T09:28:38.169812Z",
     "start_time": "2023-08-07T09:28:35.502137Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "plt.xticks(np.linspace(0, 3, 13, endpoint=True), size=14)  # x轴标签\n",
    "plt.yticks(np.linspace(5, 45, 9, endpoint=True), size=14)  # y轴标签\n",
    "alpha_ks_list=['alpha_ks','edge_a_length','edge_b_length','shoredge_condition','longedge_condition','1/alpha_ks','ks']\n",
    "df_alpha_ks_list= pd.DataFrame(columns=alpha_ks_list)\n",
    "se_alpha_ks_list=['alpha_ks','edge_a_length','edge_b_length','shoredge_condition','longedge_condition','1/alpha_ks','ks']\n",
    "# edge_a_length，左右的\n",
    "# edge_b_length，上下的\n",
    "for edge_a_length in np.linspace(1, 100, 100):\n",
    "    for edge_b_length in np.linspace(1, 100, 100):\n",
    "        alpha_ks=edge_a_length/edge_b_length\n",
    "        shoredge_lenth=min(edge_a_length,edge_b_length)\n",
    "        longedge_lenth=max(edge_a_length,edge_b_length)\n",
    "# 边界条件\n",
    "        shoredge_condition_list=[0,1]#(0简支，1固接)\n",
    "        longedge_condition_list=[0,1]#(0简支，1固接)\n",
    "        for i in range(2):\n",
    "            shoredge_condition=shoredge_condition_list[i]\n",
    "            for j in range(2):\n",
    "                longedge_condition=longedge_condition_list[j]                          #        a边           b边    \n",
    "#               狭长型\n",
    "                if alpha_ks <=1 and shoredge_condition==0 and longedge_condition==0:#     α≤1简支短边\t简支长边\n",
    "                    ks=4+5.34/(alpha_ks**2)\n",
    "                    label1=str(r'$\\alpha\\leq1, 4.00+\\dfrac{5.34}{\\alpha ^2}$, SS')\n",
    "                \n",
    "                if alpha_ks <=1 and shoredge_condition==1 and longedge_condition==1:#     α≤1固支短边\t固支长边\n",
    "                    ks=5.6+8.98/(alpha_ks**2)            \n",
    "                    label2=str(r'$\\alpha\\leq1,5.6+\\dfrac{8.98}{\\alpha ^2}$, FF')\n",
    "                    \n",
    "                if alpha_ks <=1 and shoredge_condition==0 and longedge_condition==1:#     α≤1简支短边\t固支长边\n",
    "                    ks=8.98/(alpha_ks**2)+5.61-1.99*alpha_ks           \n",
    "                    label3=str(r'$\\alpha\\leq1,\\dfrac{8.98}{\\alpha ^2}+5.61-1.99\\alpha$, SF')\n",
    "                    \n",
    "                if alpha_ks <=1 and shoredge_condition==1 and longedge_condition==0:#     α≤1固支短边\t简支长边\n",
    "                    ks=5.34/(alpha_ks**2)+2.31/alpha_ks-3.44+8.39*alpha_ks\n",
    "                    label4=str(r'$\\alpha\\leq1,\\dfrac{5.34}{\\alpha^2}+\\dfrac{2.31}{\\alpha}-3.44+8.39\\alpha$, FS')\n",
    "#               矮胖型\n",
    "                if alpha_ks >=1 and longedge_condition==0 and shoredge_condition==0:#     α≥1简支长边\t简支短边\n",
    "                    ks=5.34+4/(alpha_ks**2)\n",
    "                    label5=str(r'$\\alpha\\geq1,5.34+\\dfrac{4.00}{\\alpha ^2}$, SS')\n",
    "                \n",
    "                if alpha_ks >=1 and longedge_condition==1 and shoredge_condition==1:#     α≥1固支长边\t固支短边\n",
    "                    ks=8.98+5.6/(alpha_ks**2)\n",
    "                    label6=str(r'$\\alpha\\geq1,8.98+\\dfrac{5.6}{\\alpha ^2}$, FF')\n",
    "                    \n",
    "                if alpha_ks >=1 and longedge_condition==0 and shoredge_condition==1:#     α≥1简支长边\t固支短边\n",
    "                    ks=5.34+2.31/alpha_ks-3.44/(alpha_ks**2)+8.39/(alpha_ks**3)\n",
    "                    label7=str(r'$\\alpha\\geq1,5.34+\\dfrac{2.31}{\\alpha}-\\dfrac{3.44}{\\alpha^2}+\\dfrac{8.39}{\\alpha^3}$, SF')\n",
    "                    \n",
    "                if alpha_ks >=1 and longedge_condition==1 and shoredge_condition==0:#     α≥1固支长边\t简支短边\n",
    "                    ks=8.98+5.61/(alpha_ks**2)-1.99/(alpha_ks**3)\n",
    "                    label8=str(r'$\\alpha\\geq1, 8.98+\\dfrac{5.61}{\\alpha ^2}-\\dfrac{1.99}{\\alpha^3}$, FS')\n",
    "# # ———————————Dataframe构造————————————\n",
    "                se_alpha_ks_list=pd.Series([alpha_ks,edge_a_length,edge_b_length,shoredge_condition,longedge_condition,1/alpha_ks,ks],index=alpha_ks_list)\n",
    "                df_alpha_ks_list=pd.concat([df_alpha_ks_list,se_alpha_ks_list.to_frame().transpose()],axis=0,ignore_index=True)\n",
    "df_alpha_ks_list.eval(\"\"\"Totalcondition = edge_b_length-edge_a_length\"\"\", inplace=True)\n",
    "\n",
    "\n",
    "# fig=plt.figure(dpi=600,figsize=[20,10])\n",
    "# ax1=fig.add_subplot(4,4,1)\n",
    "# ax2=fig.add_subplot(4,4,2)\n",
    "# ax3=fig.add_subplot(4,4,3)\n",
    "# ax4=fig.add_subplot(4,4,4)\n",
    "# ax5=fig.add_subplot(4,4,5)\n",
    "# ax6=fig.add_subplot(4,4,6)\n",
    "# ax7=fig.add_subplot(4,4,7)\n",
    "# ax8=fig.add_subplot(4,4,8)\n",
    "\n",
    "# # fig.legend() \n",
    "\n",
    "df_alpha_ks_list=df_alpha_ks_list.sort_values(by=['alpha_ks'])\n",
    "#狭长型\n",
    "dfks_slender=df_alpha_ks_list[(df_alpha_ks_list['alpha_ks']<1 )]                                     # a边    b边\n",
    "dfks1=dfks_slender[(dfks_slender['shoredge_condition']==0)&( dfks_slender['longedge_condition']==0)] #简短   简长\n",
    "dfks2=dfks_slender[(dfks_slender['shoredge_condition']==1)&( dfks_slender['longedge_condition']==1)] #固短   固长\n",
    "dfks3=dfks_slender[(dfks_slender['shoredge_condition']==0)&( dfks_slender['longedge_condition']==1)] #简短   固长\n",
    "dfks4=dfks_slender[(dfks_slender['shoredge_condition']==1)&( dfks_slender['longedge_condition']==0)] #固短   简长\n",
    "\n",
    "#矮胖型\n",
    "dfks_thick=df_alpha_ks_list[(df_alpha_ks_list['alpha_ks']>1 )]                                        #a边    b边\n",
    "dfks5=dfks_thick[(dfks_thick['shoredge_condition']==0 )&( dfks_thick['longedge_condition']==0)]      #简长    简短\n",
    "dfks6=dfks_thick[(dfks_thick['shoredge_condition']==1 )&( dfks_thick['longedge_condition']==1)]      #固长    固短\n",
    "dfks7=dfks_thick[(dfks_thick['shoredge_condition']==1 )&( dfks_thick['longedge_condition']==0)]      #简长    固短\n",
    "dfks8=dfks_thick[(dfks_thick['shoredge_condition']==0 )&( dfks_thick['longedge_condition']==1)]      #固长    简短\n",
    "\n",
    "# ax1.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r', label=label1)\n",
    "# ax2.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g', label=label2)\n",
    "# ax3.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b', label=label3)\n",
    "# ax4.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y', label=label4)\n",
    "# ax5.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r', label=label5)\n",
    "# ax6.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g', label=label6)\n",
    "# ax7.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b', label=label7)\n",
    "# ax8.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y', label=label8)\n",
    "\n",
    "\n",
    "\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=14) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "fig=plt.figure(figsize=[9,9])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# plt.grid(b=1, which='major') \n",
    "linewidth=2.5\n",
    "xticks(np.linspace(0,3,13,endpoint=True),size=14)# x轴标签\n",
    "yticks(np.linspace(5,45,9,endpoint=True),size=14)# y轴标签  \n",
    "plt.xlim(0,3)\n",
    "plt.ylim(5,45)\n",
    "plt.xlabel(r'${1}/ {\\alpha}$',fontsize=14)\n",
    "plt.ylabel(r'$k$',fontsize=14)\n",
    "\n",
    "\n",
    "# plt.plot(1/dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "#          label=label1)\n",
    "# plt.plot(1/dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "#          label=label5)\n",
    "\n",
    "# plt.plot(1/dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth,\n",
    "#          label=label2)\n",
    "# plt.plot(1/dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "#          label=label6)\n",
    "\n",
    "# plt.plot(1/dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "#          label=label3)\n",
    "# plt.plot(1/dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.',linewidth=linewidth,\n",
    "#          label=label7)\n",
    "\n",
    "# plt.plot(1/dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "#          label=label4)\n",
    "# plt.plot(1/dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "#          label=label8)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "plt.plot(dfks1['alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=label1)\n",
    "plt.plot(dfks5['alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=label5)\n",
    "\n",
    "plt.plot(dfks2['alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth,\n",
    "         label=label2)\n",
    "plt.plot(dfks6['alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "         label=label6)\n",
    "\n",
    "plt.plot(dfks3['alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "         label=label3)\n",
    "plt.plot(dfks7['alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.',linewidth=linewidth,\n",
    "         label=label7)\n",
    "\n",
    "plt.plot(dfks4['alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "         label=label4)\n",
    "plt.plot(dfks8['alpha_ks'].values,dfks8['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "         label=label8)\n",
    "\n",
    "# # ————————打阴影————————\n",
    "plt.fill_between(dfks2['1/alpha_ks'].values,dfks2['ks'].values,dfks4['ks'].values,  color='lightgray', alpha=0.5)\n",
    "plt.fill_between(dfks6['1/alpha_ks'].values,dfks6['ks'].values,dfks8['ks'].values,  color='lightgray', alpha=0.5)\n",
    "\n",
    "\n",
    "plt.axvline(1.00,linestyle='-',c='grey')\n",
    "bwith = 1 #边框宽度设置为2\n",
    "TK = plt.gca()#获取边框\n",
    "TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "TK.spines[:].set_color('black')\n",
    "plt.legend()\n",
    "pltsvgname=str('板件alph全部参数受剪') #保存名字\n",
    "plt.legend(fontsize=10, title_fontsize=10)\n",
    "plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PHDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "plt.show()\n",
    "plt.clf\n",
    "# ——————————前半段——————\n",
    "\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=14) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "fig=plt.figure(figsize=[6,6])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# plt.grid(b=1, which='major') \n",
    "linewidth=2\n",
    "xticks(np.linspace(0,1,11,endpoint=True),size=14)# x轴标签\n",
    "yticks(np.linspace(5,15,11,endpoint=True),size=14)# y轴标签  \n",
    "plt.xlim(0,1)\n",
    "plt.ylim(5,15)\n",
    "plt.xlabel(r'$\\dfrac{1}{\\alpha}$',fontsize=14)\n",
    "plt.ylabel(r'$k$',fontsize=14)\n",
    "\n",
    "\n",
    "\n",
    "plt.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=label5)\n",
    "plt.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "         label=label6)\n",
    "plt.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "         label=label7)\n",
    "plt.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':',linewidth=linewidth,\n",
    "         label=label8)\n",
    "\n",
    "plt.axvline(1.00,linestyle='-',c='grey')\n",
    "bwith = 1 #边框宽度设置为2\n",
    "TK = plt.gca()#获取边框\n",
    "TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "TK.spines[:].set_color('black')\n",
    "plt.legend()\n",
    "pltsvgname=str('板件alph大于1受剪') #保存名字\n",
    "plt.legend(fontsize=10, title_fontsize=10)\n",
    "plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PHDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "plt.show()\n",
    "plt.clf\n",
    "# ——————————后半段——————\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=14) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马\n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "fig=plt.figure(figsize=[6,6])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# plt.grid(b=1, which='major') \n",
    "linewidth=2\n",
    "xticks(np.linspace(1,3,11,endpoint=True),size=14)# x轴标签\n",
    "yticks(np.linspace(5,25,11,endpoint=True),size=14)# y轴标签  \n",
    "plt.xlim(1,3)\n",
    "plt.ylim(5,25)\n",
    "plt.xlabel(r'$\\dfrac{1}{\\alpha}$',fontsize=14)\n",
    "plt.ylabel(r'$k$',fontsize=14)\n",
    "\n",
    "\n",
    "plt.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "         label=label1)\n",
    "plt.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth,\n",
    "         label=label2)\n",
    "plt.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "         label=label3)\n",
    "plt.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "         label=label4)\n",
    "\n",
    "plt.axvline(1.00,linestyle='-',c='grey')\n",
    "bwith = 1 #边框宽度设置为2\n",
    "TK = plt.gca()#获取边框\n",
    "TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "TK.spines[:].set_color('black')\n",
    "plt.legend()\n",
    "\n",
    "\n",
    "pltsvgname=str('板件alph小于1受剪') #保存名字\n",
    "plt.legend(fontsize=10, title_fontsize=10)\n",
    "plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PHDall\\matplotilibpic\\\\\"+pltsvgname+\".svg\",bbox_inches='tight', pad_inches=0)#保存图     \n",
    "plt.show()\n",
    "plt.clf\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0db30f7d",
   "metadata": {},
   "source": [
    "#### 将拟合数据放入纯理论受剪板"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31993473",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-08-08T06:47:22.929783Z",
     "start_time": "2023-08-08T06:47:17.888391Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f','n','type']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[355.61,     0.002       , 20     ,  0   , 1     ,0    ,1,0]# 面内受剪_分离面内\n",
    "# 固定标准参数general list和其值\n",
    "labelss=str(r'$\\mathrm{SS}$ ')\n",
    "labelsf=str(r'$\\mathrm{SF}$ ')\n",
    "labelfs=str(r'$\\mathrm{FS}$ ')\n",
    "labelff=str(r'$\\mathrm{FF}$ ')\n",
    "df_basepara=dfdelpara.copy()\n",
    "for i in range (0,len(general_list)):\n",
    "    df_basepara=df_basepara[df_basepara[general_list[i]]==general_list_number[i]].copy()\n",
    "\n",
    "df=df_basepara\n",
    "# df.to_excel('df.xlsx')\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis \n",
    "pointsize=20\n",
    "figsizex=20# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= 20\n",
    "x_aixs_min=0\n",
    "x_aixs_max=1\n",
    "y_aixs_min=0\n",
    "y_aixs_max=15\n",
    "fontsize=14\n",
    "ticksize=12\n",
    "# font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\") # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马  \n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# dftype0=dfTn\n",
    "# dftype1=dfTn\n",
    "# dftype2=dfTn\n",
    "# df=df[(df['type']==para_without_paranum)]\n",
    "\n",
    "# ——————————散点图——————————\n",
    "def pic_ktaucr_stand_fem_x_scatter(df,para_without_para,para_without_paranum,div_colandlegend_para,x_aixs_para,y_aixs_para):\n",
    "#画图函数（不需要的参数，不需要的参数对应的值，分类的参数，x轴，y轴）\n",
    "    # 筛选拼接数量n，用的是函数中的第一个参数\n",
    "#     df_without=df[(df[para_without_para]==para_without_paranum)]# 这个df_pre已经筛选完了‘不需要的参数’和它“不需要的参数”\n",
    "    df_without=df\n",
    "    # 分类准备工作，这些都是针对‘颜色分类的参数’div_colandlegend_para\n",
    "    df_without=df_without.reset_index(drop=True)#去掉行名\n",
    "    div_pic=df_without[div_colandlegend_para].sort_values()#可能——数值排序\n",
    "    len_div_pic=len(div_pic.value_counts())#可能——不同数值的数量\n",
    "# ——————构造颜色数值对应关系——————————\n",
    "    coltocmap=df_without[div_colandlegend_para].values\n",
    "    coltocmap_unique=list(df_without[div_colandlegend_para].sort_values().unique())\n",
    "#     minco=min(coltocmap)-((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))\n",
    "#     maxco=max(coltocmap)+((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))\n",
    "    minco=min(coltocmap)\n",
    "    maxco=max(coltocmap) \n",
    "    \n",
    "    print('maxco',df_without,maxco,minco)\n",
    "# ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_div_pic in range(0,len_div_pic):\n",
    "        df_div_colandlegend=df_without[(df_without[div_colandlegend_para]==div_pic.unique()[num_div_pic])]\n",
    "        #上面是已经进行过颜色分选的df建立\n",
    "        df_div_colandlegend=df_div_colandlegend.reset_index(drop=True)#去掉行名    \n",
    "        #此处得到的df_div_colandlegend就是已经按照颜色分类过的dataframe\n",
    "        df_div_colandlegend=df_div_colandlegend.sort_values(by=div_colandlegend_para,ascending=False)#单拿出来并排序 \n",
    "        div_colandlegend_final=df_div_colandlegend.reset_index(drop=True)#去掉行名           \n",
    "        #  对本种颜色下进行循环构造画图的listdf，x轴从小到大\n",
    "        x_ks_plotlist =[]\n",
    "        y_ks_plotlist =[]\n",
    "#——————把每个点循环并赋予颜色（一行一行的绘制，即一个点一个点的绘制），构造出来需要的list——————\n",
    "        for num_ks in range(0,len(div_colandlegend_final)):  \n",
    "            x_ks=div_colandlegend_final.at[num_ks, x_aixs_para]\n",
    "            y_ks=div_colandlegend_final.at[num_ks, y_aixs_para]\n",
    "            z_ks=div_colandlegend_final.at[num_ks, div_colandlegend_para]\n",
    "            x_ks_plotlist.append(x_ks)\n",
    "            y_ks_plotlist.append(y_ks)\n",
    "#         print('x_ks_plotlist',max(x_ks_plotlist))\n",
    "        set_lst=set(x_ks_plotlist)\n",
    "        if len(set_lst)==len(x_ks_plotlist):\n",
    "            print('列表里的元素互不重复！')\n",
    "#             print(x_ks_plotlist)\n",
    "        else:\n",
    "            print('列表里有重复的元素！')\n",
    "            plt.clf\n",
    "            print(div_pic.unique()[num_div_pic])\n",
    "#             div_colandlegend_final.to_excel('div_colandlegend_final'+str(div_pic.unique()[num_div_pic])+'.xlsx')\n",
    "            plt.scatter(div_colandlegend_final[x_aixs_para],div_colandlegend_final['B'])\n",
    "\n",
    "       # ——阴影区——————\n",
    "\n",
    "        plt.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "                 label=labelss)\n",
    "        plt.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "                 label=labelff)\n",
    "        plt.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "                 label=labelsf)\n",
    "        plt.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':',linewidth=linewidth,\n",
    "                 label=labelfs)\n",
    "        plt.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth)\n",
    "        plt.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth)\n",
    "        plt.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth)\n",
    "        plt.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth)\n",
    "        plt.xlim(0,3)\n",
    "        plt.ylim(0,45)\n",
    "\n",
    "        plt.axvline(1.00,linestyle='-',c='grey')\n",
    "        bwith = 1 #边框宽度设置为2\n",
    "        TK = plt.gca()#获取边框\n",
    "        TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "        TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "        TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "        TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "        TK.spines[:].set_color('black')\n",
    "\n",
    "#             plt.show()\n",
    "        colorlmap_ks=(z_ks-minco)/maxco\n",
    "        colorlmap_ks_list=np.full((len(div_colandlegend_final),1),colorlmap_ks)\n",
    "# # ————————————————添加阴影区——————————————————\n",
    "\n",
    "#         plt.fill_between(dfks2['1/alpha_ks'].values,dfks2['ks'].values,dfks4['ks'].values,  color='lightgray', alpha=0.01)\n",
    "#         plt.fill_between(dfks6['1/alpha_ks'].values,dfks6['ks'].values,dfks8['ks'].values,  color='lightgray', alpha=0.01)\n",
    "#         plt.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "#                  label=label1)\n",
    "#         plt.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "#                  label=label5)\n",
    "#         plt.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth,\n",
    "#                  label=label2)\n",
    "#         plt.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "#                  label=label6)\n",
    "#         plt.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "#                  label=label3)\n",
    "#         plt.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "#                  label=label7)\n",
    "#         plt.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "#                  label=label4)\n",
    "#         plt.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':',linewidth=linewidth,\n",
    "#                  label=label8)\n",
    "#————————————————小图内每个颜色的绘制——————————————————\n",
    "        plt.scatter(x_ks_plotlist,y_ks_plotlist,c=colorlmap_ks_list, cmap=colorltype, vmin=0, vmax=1,s=pointsize)\n",
    "    \n",
    "\n",
    "# ———————————colorbar的位置———————————  \n",
    "    divider = make_axes_locatable(plt.gca()) \n",
    "    cax = divider.append_axes(\"right\", \"5 %\",  pad =\"0%\")  \n",
    "#———————————对颜色参数进行处理，以方便构造colorbar———————————  \n",
    "    if len(coltocmap_unique)!=1:\n",
    "        minco_colorbar=min(coltocmap_unique)-((max(coltocmap_unique)-min(coltocmap_unique))/((len(coltocmap_unique)-1)*2))\n",
    "        maxco_colorbar=max(coltocmap_unique)+((max(coltocmap_unique)-min(coltocmap_unique))/((len(coltocmap_unique)-1)*2))\n",
    "    if len(coltocmap_unique)==1:          \n",
    "        minco_colorbar=min(coltocmap_unique)\n",
    "        maxco_colorbar=max(coltocmap_unique)\n",
    "    colorbarparadiff=(maxco_colorbar-minco_colorbar)/10\n",
    "    #下面是采用平均的数值来构造colorbar\n",
    "    colorbarpara=[minco_colorbar]+[minco_colorbar+colorbarparadiff*1]+[minco_colorbar+colorbarparadiff*2]+[minco_colorbar+colorbarparadiff*3]+[minco_colorbar+colorbarparadiff*4]+[minco_colorbar+colorbarparadiff*5]+[minco_colorbar+colorbarparadiff*6]+[minco_colorbar+colorbarparadiff*7]+[minco_colorbar+colorbarparadiff*8]+[minco_colorbar+colorbarparadiff*9]+[maxco_colorbar]\n",
    "    #下面是采用实际的可能的数值来构造colorbar\n",
    "#     colorbarpara=[minco_colorbar]+coltocmap_unique+[maxco_colorbar]\n",
    "#——————————————colorbar设置————————————————————————————————\n",
    "    cmap = plt.get_cmap(colorltype) #获取颜色类型\n",
    "    #对颜色类型进行最大最小值正则化，这里的vmin和vmax指的是填充colorbar的区域\n",
    "    norm = mpl.colors.Normalize(vmin=min(colorbarpara), vmax= max(colorbarpara))\n",
    "    scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)#提供一个可以映射颜色的对象\n",
    "# #——————————————colorbar右侧数字的设置————————————————————————————————\n",
    "    cb = plt.colorbar(scalarMap,cax=cax, orientation=\"vertical\") \n",
    "#     if maxco_colorbar<1:\n",
    "    labels =np.round(colorbarpara,2)#指的是cb标签的数字\n",
    "    loc    =np.round(colorbarpara,2)#指的是cb横线的位置\n",
    "#     else:\n",
    "#         labels =np.round(colorbarpara)#指的是cb标签的数字\n",
    "#         loc    =np.round(colorbarpara)#指的是cb横线的位置\n",
    "    cb.set_ticks(loc) \n",
    "    cb.set_ticklabels(labels)  \n",
    "#     for labels in cb.ax.yaxis.get_ticklabels()[::len(coltocmap_unique)+1]:# 隐藏掉最大值和最小值\n",
    "#         labels.set_visible(False)\n",
    "    plt.colorbar\n",
    "# ——————————————def函数定义结束————————————————————————————————  \n",
    "\n",
    "# ——————————预设信息设置————————\n",
    "# ['B',  'H', 'L', 'T1', 'T2', 'EigenValue','Pucf2f', 'Pu_fy_f12', 'P_ycf2f',\n",
    "#   'Bcf2f', 'SLcf2f',  'SFcf2f','CWcf2f', 'KG_quge_web',\n",
    "#        'KH_quge_web', 'KG_total_web', 'KH_total_web', 'KG_consedge_flange',\n",
    "#        'KH_consedge_flange', 'KG_midstiff_flange', 'KH_midstiff_flange',\n",
    "#        'I_single_ix', 'I_single_iy', 'I_web_quge_ix', 'I_web_quge_iy',\n",
    "#        'I_flange_consedge_ix', 'I_flange_consedge_iy', 'I_flange_midstiff_ix',\n",
    "#        'I_flange_midstiff_iy', 'I_total_webix', 'I_total_webiy', 'J_web',\n",
    "#        'J_consedge_half', 'J_midstiff_half', 'J_consedge', 'J_midstiff',\n",
    "#        'ratio_alpha_tflange_to_tweb', 'ratio_alpha_Bflange_to_Hn', 'tau_fem',\n",
    "#        'k_taucr_fem', 'ratio_axial_to_Pu_fy_f13', 'ratio_eta_GJdivbyDL']\n",
    "# ['B',  'H', 'L', 'T1', 'T2', 'EigenValue','Pucf2f', 'Pu_fy_f12', 'P_ycf2f','Bcf2f', 'SLcf2f',  'SFcf2f','CWcf2f', 'KG_quge_web','KH_quge_web', 'KG_total_web', 'KH_total_web', 'KG_consedge_flange','KH_consedge_flange', 'KG_midstiff_flange', 'KH_midstiff_flange','I_single_ix', 'I_single_iy', 'I_web_quge_ix', 'I_web_quge_iy','I_flange_consedge_ix', 'I_flange_consedge_iy', 'I_flange_midstiff_ix','I_flange_midstiff_iy', 'I_total_webix', 'I_total_webiy', 'J_web','J_consedge_half', 'J_midstiff_half', 'J_consedge', 'J_midstiff','ratio_alpha_tflange_to_tweb', 'ratio_alpha_Bflange_to_Hn', 'tau_fem','k_taucr_fem', 'ratio_axial_to_Pu_fy_f13', 'ratio_eta_GJdivbyDL']\n",
    "\n",
    "# 筛选n的参数\n",
    "para_without_para=str('n')\n",
    "para_without_paranum=1\n",
    "# 图内颜色分类型参数（变色或者变形状）,  'H', 'L', 'T1', 'T2', 'n'\n",
    "# div_colandlegend_para_list=['H','B', 'L', 'T1', 'T2', 'n']\n",
    "\n",
    "# div_colandlegend_para_list=['KG_quge_web','KH_quge_web']\n",
    "div_colandlegend_para_list=['KH_quge_web']\n",
    "# div_colandlegend_para_list=df.columns\n",
    "# div_colandlegend_para_list=['B',  'H', 'L', 'T1', 'T2', \n",
    "#                             'ratio_alpha_Bflange_to_Hn',\n",
    "#                             'KH_quge_web', 'KH_total_web',\n",
    "#                             'ratio_alpha_tflange_to_tweb', \n",
    "#                             'ratio_alpha_Bflange_to_Hn']\n",
    "# # ['B',  'H', 'L', 'T1', 'T2', 'EigenValue','Pucf2f', 'Pu_fy_f2', 'P_ycf2f','Bcf2f', 'SLcf2f',  'SFcf2f','CWcf2f', 'KG_quge_web','KH_quge_web', 'KG_total_web', 'KH_total_web', 'KG_consedge_flange','KH_consedge_flange', 'KG_midstiff_flange', 'KH_midstiff_flange','I_single_ix', 'I_single_iy', 'I_web_quge_ix', 'I_web_quge_iy','I_flange_consedge_ix', 'I_flange_consedge_iy', 'I_flange_midstiff_ix','I_flange_midstiff_iy', 'I_total_webix', 'I_total_webiy', 'J_web','J_consedge_half', 'J_midstiff_half', 'J_consedge', 'J_midstiff','ratio_alpha_tflange_to_tweb', 'ratio_alpha_Bflange_to_Hn', 'tau_fem','k_taucr_fem', 'ratio_axial_to_Pu_fy_f13', 'ratio_eta_GJdivbyDL']\n",
    "# div_colandlegend_para_list= ['B',  'H', 'L', 'T1', 'T2', 'EigenValue','Pucf2f', 'Pu_fy_f2', 'P_ycf2f',\n",
    "# 'Bcf2f', 'SLcf2f',  'SFcf2f','CWcf2f', 'KG_quge_web','KH_quge_web', 'KG_total_web', 'KH_total_web', \n",
    "# 'KG_consedge_flange','KH_consedge_flange', 'KG_midstiff_flange', 'KH_midstiff_flange',\n",
    "# 'I_single_ix', 'I_single_iy', 'I_web_quge_ix', 'I_web_quge_iy','I_flange_consedge_ix', \n",
    "# 'I_flange_consedge_iy', 'I_flange_midstiff_ix','I_flange_midstiff_iy', 'I_total_webix', 'I_total_webiy', \n",
    "# 'J_web','J_consedge_half', 'J_midstiff_half', 'J_consedge', 'J_midstiff',\n",
    "# 'ratio_alpha_tflange_to_tweb', 'ratio_alpha_Bflange_to_Hn', 'tau_fem','k_taucr_fem', \n",
    "# 'ratio_axial_to_Pu_fy_f13', 'ratio_eta_GJdivbyDL']\n",
    "\n",
    "#————x_轴——————————————————\n",
    "x_aixs_paralist=['KG_total_web']\n",
    "# x_aixs_paralist=['beta2']\n",
    "# x_aixs_paralist=['ratio_alpha_tflange_to_tweb']\n",
    "# ———y_轴——————————————————\n",
    "y_aixs_para=str('k_taucr_fem2_n')\n",
    "#——————————基础参数——————————\n",
    "colorltype=str('viridis')\n",
    "#----------------------这里决定是否采用预选——————————\n",
    "for i in range(0,len(x_aixs_paralist)):\n",
    "    x_aixs_para=x_aixs_paralist[i]\n",
    "    plt.figure(figsize=(figsizex,figsizex))\n",
    "    num_diff_divpic=len(div_colandlegend_para_list)#共有多少个颜色类型不同数值的数量\n",
    "\n",
    "#——————每一张大图内一点一点画小图，主要作用——————————————————\n",
    "    for j in range(0,len(div_colandlegend_para_list)):\n",
    "        div_colandlegend_para=div_colandlegend_para_list[j]\n",
    "        #  构造小图排布所需要的的画布布局\n",
    "        xint=int(num_diff_divpic**0.5)+1#图纸分布x\n",
    "        yint=int(num_diff_divpic**0.5)+1#图纸分布y   \n",
    "        axes_sub_fig=plt.subplot(xint,yint,j+1)# 小图排布\n",
    "        print('div_colandlegend_para',div_colandlegend_para)\n",
    "        pic_ktaucr_stand_fem_x_scatter(df,para_without_para,para_without_paranum,div_colandlegend_para,x_aixs_para,y_aixs_para)\n",
    "        axes_sub_fig.set_xlabel(x_aixs_para)\n",
    "        axes_sub_fig.set_ylabel(y_aixs_para)        \n",
    "        axes_sub_fig.text(0.5,0.9,div_colandlegend_para,transform=axes_sub_fig.transAxes)\n",
    "#-----------------------单独的图纸设置--------------------------------------------\n",
    "#         axes_sub_fig.text(1.00,1.03,str(r'$\\alpha_{\\mathrm{BtHn}}$'),fontsize=fontsize,transform=axes_sub_fig.transAxes)\n",
    "# #         axes_sub_fig.set_xlabel(str(r'$\\frac{t_{\\mathrm{f}}}{t_{\\mathrm{w}}}$'),fontsize=fontsize)\n",
    "#         axes_sub_fig.set_xlabel(str(r'$t_\\mathrm{f}/t_\\mathrm{w}$'),fontsize=fontsize)\n",
    "#         axes_sub_fig.set_ylabel(str(r'$k_{\\mathrm{fem}}$'),fontsize=fontsize)  \n",
    "#         axes_sub_fig.grid(b=9, which='major') \n",
    "#         axes_sub_fig.tick_params(bottom=True,top=True,left=True,right=False)# 显示上部和右侧刻度线\n",
    "#         区格宽高比$k_{\\mathrm{fem}}$，区格宽厚比\\alpha_{\\mathrm{wKH}}\n",
    "\n",
    "#         plt.axvline(1.00,linestyle='-',c='grey')\n",
    "#         bwith = 1 #边框宽度设置为2\n",
    "#         TK = axes_sub_fig\n",
    "#         TK.spines['bottom'].set_linewidth(bwith)#图框下边\n",
    "#         TK.spines['left'].set_linewidth(bwith)#图框左边\n",
    "#         TK.spines['top'].set_linewidth(bwith)#图框上边\n",
    "#         TK.spines['right'].set_linewidth(bwith)#图框右边\n",
    "#         TK.spines[:].set_color('black')\n",
    "#         linewidth=2\n",
    "#         axes_sub_fig.tick_params(axis='x', labelsize=ticksize)\n",
    "#         axes_sub_fig.tick_params(axis='y', labelsize=ticksize)\n",
    "#         axes_sub_fig.set_xticks(np.linspace(0,7,15,endpoint=True))# x轴标签\n",
    "#         axes_sub_fig.set_yticks(np.linspace(0,26,14,endpoint=True))# y轴标签  \n",
    "#         axes_sub_fig.set_xticks(np.linspace(0,3,13,endpoint=True),size=14)# x轴标签\n",
    "#         axes_sub_fig.set_yticks(np.linspace(5,45,9,endpoint=True),size=14)# y轴标签  \n",
    "        # 设置 x 轴刻度位置\n",
    "        axes_sub_fig.set_xticks(np.linspace(0, 3, 13, endpoint=True))\n",
    "        # 设置 x 轴刻度标签字体大小\n",
    "        axes_sub_fig.tick_params(axis='x', labelsize=14)\n",
    "\n",
    "        # 设置 y 轴刻度位置\n",
    "        axes_sub_fig.set_yticks(np.linspace(5, 45, 9, endpoint=True))\n",
    "        # 设置 y 轴刻度标签字体大小\n",
    "        axes_sub_fig.tick_params(axis='y', labelsize=14)\n",
    "        axes_sub_fig.set_xlim(0,3)\n",
    "        axes_sub_fig.set_ylim(5,45)\n",
    "#         axes_sub_fig.set_xlim(0,3)\n",
    "#         axes_sub_fig.set_ylim(0,45)\n",
    "#     # ————————lee线————————\n",
    "#         axes_sub_fig.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values/5+4*dfks3['ks'].values/5,c='b',ls='-', linewidth=2,\n",
    "#                  label='lee')\n",
    "#         axes_sub_fig.plot(dfks6['1/alpha_ks'].values,3*dfks6['ks'].values/5+2*dfks7['ks'].values/5,c='b',ls='-', linewidth=2,\n",
    "#                  label='lee')\n",
    " \n",
    "\n",
    "    plt.tight_layout()\n",
    "#     plt.savefig(r'R:\\PhDall\\matplotilibpic\\\\'+str('colors')+x_aixs_para+'.svg')#保存图   \n",
    "    plt.show()\n",
    "#     plt.clf\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4321294f",
   "metadata": {},
   "source": [
    "### 图片文件夹制作"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "826cfd7c",
   "metadata": {},
   "outputs": [],
   "source": [
    "dt_T_n1 = dt_T[dt_T['n'] == 1].copy()\n",
    "dt_T_n2 = dt_T[dt_T['n'] == 2].copy()\n",
    "dt_T_n3 = dt_T[dt_T['n'] == 3].copy()\n",
    "dt_T_n4 = dt_T[dt_T['n'] == 4].copy()\n",
    "dt_T_n5 = dt_T[dt_T['n'] == 5].copy()\n",
    "print(len(dt_T_n1))\n",
    "# dt_T_n1.to_excel('dt_T_n1.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c1f777ea",
   "metadata": {},
   "source": [
    "#### 从ori文件夹移动图像到目标文件夹oride（为了安全手工复制图片到ori文件夹）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e2460875",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import os\n",
    "# import shutil\n",
    "# import pandas as pd\n",
    "# import re\n",
    "# from collections import defaultdict\n",
    "\n",
    "\n",
    "# def build_file_index(source_folder, columns_mapping, need_f_param):\n",
    "#     \"\"\"构建文件索引\"\"\"\n",
    "#     file_index = defaultdict(list)\n",
    "#     unmatched_files = []\n",
    "#     for root, _, files in os.walk(source_folder):\n",
    "#         for file in files:\n",
    "#             if file.lower().endswith('.tiff'):\n",
    "#                 filepath = os.path.join(root, file)\n",
    "#                 values = extract_values_from_filename(file, columns_mapping, need_f_param)\n",
    "#                 if values:  # 确保从文件名中成功提取了值\n",
    "#                     if not need_f_param:\n",
    "#                         # 不考虑 F 列时，从键中移除 F 列\n",
    "#                         values.pop('F', None)\n",
    "#                     key = tuple(values.items())\n",
    "#                     file_index[key].append(filepath)\n",
    "#                 else:\n",
    "#                     unmatched_files.append(file)  # 记录未能匹配到任何列的文件\n",
    "#     return file_index, unmatched_files\n",
    "\n",
    "\n",
    "# def extract_values_from_filename(filename, columns_mapping, need_f_param):\n",
    "#     \"\"\"从文件名中提取映射列对应的值\"\"\"\n",
    "#     values = {}\n",
    "#     for col, mapped_col in columns_mapping.items():\n",
    "#         if col == 'F' and not need_f_param:\n",
    "#             values[col] = None\n",
    "#             continue\n",
    "#         pattern = f\"{mapped_col}([0-9]+\\.?[0-9]*)\"\n",
    "#         match = re.search(pattern, filename)\n",
    "#         if match:\n",
    "#             value = match.group(1)\n",
    "#             values[col] = float(value) if '.' in value else int(value)\n",
    "#         elif col == 'F':\n",
    "#             values[col] = None\n",
    "#     return values if values else None  # 如果没有找到匹配项，则返回None\n",
    "\n",
    "\n",
    "# def match_and_copy_photos(source_folder, target_folder, df, columns_mapping, need_f_param):\n",
    "#     \"\"\"\n",
    "#     根据DataFrame中的参数查找匹配的照片，并将这些照片复制到新文件夹。\n",
    "#     同时生成两个DataFrame：一个包含未能找到匹配照片的情况，另一个包含文件中存在但不在DataFrame中的照片。\n",
    "#     \"\"\"\n",
    "#     if not os.path.exists(target_folder):\n",
    "#         os.makedirs(target_folder)\n",
    "\n",
    "#     # 构建文件索引并获取未匹配的照片名称\n",
    "#     print(\"Building file index...\")\n",
    "#     file_index, unmatched_files = build_file_index(source_folder, columns_mapping, need_f_param)\n",
    "\n",
    "#     missing_photos = []\n",
    "#     matched_files_count = 0\n",
    "\n",
    "#     # 过滤掉DataFrame中不存在的列\n",
    "#     valid_columns = [col for col in columns_mapping.keys() if col in df.columns]\n",
    "\n",
    "#     # 遍历DataFrame中的每一行\n",
    "#     for index, row in df.iterrows():\n",
    "#         row_dict = row[valid_columns].to_dict()\n",
    "#         if 'F' in row_dict:\n",
    "#             if pd.isna(row_dict['F']):\n",
    "#                 row_dict['F'] = None\n",
    "#             if not need_f_param:\n",
    "#                 # 不考虑 F 列时，从字典中移除 F 列\n",
    "#                 row_dict.pop('F', None)\n",
    "#         key = tuple(row_dict.items())\n",
    "\n",
    "#         if key in file_index:\n",
    "#             source_file = file_index[key][0]  # 假设每个键最多对应一个文件，取第一个匹配的文件\n",
    "#             target_file = os.path.join(target_folder, os.path.basename(source_file))\n",
    "#             shutil.copy2(source_file, target_file)\n",
    "#             matched_files_count += 1\n",
    "#             print(f\"Copied {source_file} to {target_file}\")\n",
    "#         else:\n",
    "#             missing_photos.append(row_dict)\n",
    "\n",
    "#     # 创建一个新的DataFrame来记录未能找到匹配照片的情况\n",
    "#     missing_photos_df = pd.DataFrame(missing_photos)\n",
    "\n",
    "#     # 处理文件中存在的但DataFrame中不存在的照片\n",
    "#     existing_photos_df = pd.DataFrame(\n",
    "#         [extract_values_from_filename(f, columns_mapping, need_f_param) for f in unmatched_files])\n",
    "\n",
    "#     print(f\"Total {matched_files_count} files copied.\")\n",
    "\n",
    "#     return missing_photos_df, existing_photos_df\n",
    "\n",
    "\n",
    "# if __name__ == \"__main__\":\n",
    "#     source_folder = r'R:\\NAS_DRIVE\\SynologyDrive\\pictestori\\ori2'\n",
    "#     target_folder = r'R:\\NAS_DRIVE\\SynologyDrive\\pictest\\oride2'\n",
    "#     columns_mapping = {\n",
    "#         'H': 'A', 'B': 'B', 'T1': 'C', 'T2': 'D',\n",
    "#         'L': 'L', 'n': 'E', 'cf1f': 'cf1f',\n",
    "#         'cf2f': 'cf2f', 'cf3f': 'cf3f', 'F': 'F'\n",
    "#     }\n",
    "\n",
    "#     # 假设df_S是您的原始DataFrame\n",
    "#     # df_S = pd.read_csv('your_dataframe.csv')  # 请替换为你的实际数据加载方式\n",
    "#     df_copypictofolder = df_B  # 直接赋值给df_copypictofolder用于处理\n",
    "\n",
    "#     need_f_param = 'ori2' in source_folder\n",
    "#     missing_photos_df, existing_photos_df = match_and_copy_photos(\n",
    "#         source_folder, target_folder, df_copypictofolder, columns_mapping, need_f_param\n",
    "#     )\n",
    "\n",
    "#     # 将缺失的照片信息保存为CSV文件\n",
    "#     missing_photos_df.to_csv('missing_photos.csv', index=False)\n",
    "#     # 将文件中存在但DataFrame中不存在的照片信息保存为CSV文件\n",
    "#     existing_photos_df.to_csv('existing_photos_not_in_df.csv', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f438199",
   "metadata": {},
   "source": [
    "#### 将文件夹中的图片名与df对应，并将文件名整理进df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6b4439c4",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import pandas as pd\n",
    "import re\n",
    "from typing import Dict, List\n",
    "\n",
    "# ====================== 配置参数 ======================\n",
    "IMAGE_BASE_DIR = r'R:\\NAS_DRIVE\\SynologyDrive\\pictest'  # 图片根目录\n",
    "SUBFOLDER_MAPPING = {                # 子文件夹与数据类型映射\n",
    "    'oride0': 0,\n",
    "    'oride1': 1,\n",
    "    'oride2': 2\n",
    "}\n",
    "COLUMN_MAPPING = {                   # 数据列与图片标识映射\n",
    "    'H': 'A',    'B': 'B', \n",
    "    'T1': 'C',   'T2': 'D',\n",
    "    'n': 'E',    'L': 'L',\n",
    "    'cf1f': 'cf1f', 'cf2f': 'cf2f', 'cf3f': 'cf3f', 'F': 'F'\n",
    "}\n",
    "COMPARE_COLUMNS = ['H', 'B', 'T1', 'T2', 'L', 'n', 'F']  # 需要比对的列\n",
    "# =====================================================\n",
    "\n",
    "def validate_dataframe_structure(df: pd.DataFrame) -> None:\n",
    "    \"\"\"验证数据框是否包含必要列\"\"\"\n",
    "    required_columns = set(COMPARE_COLUMNS) | {'type'}\n",
    "    if not required_columns.issubset(df.columns):\n",
    "        missing = required_columns - set(df.columns)\n",
    "        raise ValueError(f\"DataFrame缺少必要列: {missing}\")\n",
    "\n",
    "def build_image_registry() -> Dict[int, pd.DataFrame]:\n",
    "    \"\"\"\n",
    "    构建图片注册表\n",
    "    返回: 字典 {数据类型: 图片DataFrame}\n",
    "    \"\"\"\n",
    "    registry = {}\n",
    "    \n",
    "    for folder_name, data_type in SUBFOLDER_MAPPING.items():\n",
    "        folder_path = os.path.join(IMAGE_BASE_DIR, folder_name)\n",
    "        if not os.path.exists(folder_path):\n",
    "            print(f\"警告: 目录不存在 {folder_path}\")\n",
    "            continue\n",
    "\n",
    "        # 收集图片文件信息\n",
    "        records = []\n",
    "        for root, _, files in os.walk(folder_path):\n",
    "            for file in files:\n",
    "                if not file.lower().endswith(('.tiff', '.png')):\n",
    "                    continue\n",
    "                \n",
    "                # 从文件名提取特征值\n",
    "                features = {'data_type': data_type, 'filename': file}\n",
    "                for col, code in COLUMN_MAPPING.items():\n",
    "                    match = re.search(fr'{code}(\\d+(?:\\.\\d+)?)', file)\n",
    "                    features[f'pic_{col}'] = float(match.group(1)) if match else None\n",
    "                \n",
    "                records.append(features)\n",
    "        \n",
    "        # 创建数据框并存储\n",
    "        if records:\n",
    "            df = pd.DataFrame(records)\n",
    "            registry[data_type] = df\n",
    "            print(f\"已注册 {len(df)} 张图片到类型 {data_type} ({folder_name})\")\n",
    "        else:\n",
    "            print(f\"警告: 未找到有效图片 {folder_path}\")\n",
    "    \n",
    "    return registry\n",
    "\n",
    "def match_data(df_main: pd.DataFrame, image_registry: Dict[int, pd.DataFrame]) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    执行数据匹配主逻辑\n",
    "    返回: 包含匹配结果的新DataFrame\n",
    "    \"\"\"\n",
    "    # 初始化结果列\n",
    "    result_df = df_main.copy()\n",
    "    result_df['matched_files'] = [[] for _ in range(len(result_df))]\n",
    "    result_df['match_status'] = '未匹配'\n",
    "    \n",
    "    # 记录未匹配的图片\n",
    "    all_images = pd.concat(image_registry.values())\n",
    "    matched_images = set()\n",
    "    \n",
    "    for data_type, img_df in image_registry.items():\n",
    "        # 获取当前类型的待匹配数据\n",
    "        mask = (df_main['type'] == data_type)\n",
    "        type_df = df_main[mask].copy()\n",
    "        if type_df.empty:\n",
    "            print(f\"信息: 类型 {data_type} 无待匹配数据\")\n",
    "            continue\n",
    "        \n",
    "        print(f\"\\n正在处理类型 {data_type} ({len(type_df)} 行数据)...\")\n",
    "        \n",
    "        # 确定是否考虑 F 参数\n",
    "        if data_type in [0, 1]:\n",
    "            columns_to_compare = [col for col in COMPARE_COLUMNS if col != 'F']\n",
    "        else:\n",
    "            columns_to_compare = COMPARE_COLUMNS\n",
    "        \n",
    "        # 执行特征匹配\n",
    "        for idx, row in type_df.iterrows():\n",
    "            # 构建匹配条件\n",
    "            conditions = [\n",
    "                img_df[f'pic_{col}'] == row[col]\n",
    "                for col in columns_to_compare\n",
    "            ]\n",
    "            combined_cond = pd.Series(True, index=img_df.index)\n",
    "            for cond in conditions:\n",
    "                combined_cond &= cond\n",
    "            \n",
    "            # 获取匹配结果\n",
    "            matches = img_df[combined_cond]\n",
    "            if not matches.empty:\n",
    "                # 更新匹配结果\n",
    "                matched_files = matches['filename'].tolist()\n",
    "                result_df.at[idx, 'matched_files'] = matched_files\n",
    "                result_df.at[idx, 'match_status'] = '已匹配'\n",
    "                matched_images.update(matched_files)\n",
    "                \n",
    "                # 输出匹配详情\n",
    "                print(f\"匹配成功 - 行 {idx}\")\n",
    "                print(f\"数据特征: {row[columns_to_compare].to_dict()}\")\n",
    "                print(f\"匹配文件: {matched_files}\")\n",
    "        \n",
    "        # 统计匹配情况\n",
    "        matched_count = sum(len(files) > 0 for files in result_df[mask]['matched_files'])\n",
    "        print(f\"类型 {data_type} 匹配统计: {matched_count}/{len(type_df)}\")\n",
    "    \n",
    "    # 处理未匹配图片\n",
    "    unmatched_images = all_images[~all_images['filename'].isin(matched_images)]\n",
    "    print(f\"\\n全局未匹配图片数量: {len(unmatched_images)}\")\n",
    "    \n",
    "    return result_df, unmatched_images\n",
    "\n",
    "def analyze_matching(result_df: pd.DataFrame) -> None:\n",
    "    \"\"\"分析匹配结果\"\"\"\n",
    "    print(\"\\n匹配结果分析:\")\n",
    "    \n",
    "    # 按类型统计\n",
    "    type_stats = result_df.groupby('type')['match_status'].value_counts().unstack()\n",
    "    print(type_stats.fillna(0).astype(int))\n",
    "    \n",
    "    # 检查多重匹配\n",
    "    multi_matches = result_df[result_df['matched_files'].apply(len) > 1]\n",
    "    if not multi_matches.empty:\n",
    "        print(f\"\\n发现 {len(multi_matches)} 个多重匹配:\")\n",
    "        print(multi_matches[['type'] + COMPARE_COLUMNS + ['matched_files']])\n",
    "    else:\n",
    "        print(\"\\n未发现多重匹配\")\n",
    "\n",
    "# ====================== 执行流程 ======================\n",
    "if __name__ == \"__main__\":\n",
    "    # 假设 df_all 是已加载的主数据\n",
    "    # 这里需要替换为实际加载数据的代码，例如：\n",
    "    # df_all = pd.read_csv('your_data.csv')\n",
    "    # 为了测试，这里简单创建一个示例数据框\n",
    "\n",
    "    validate_dataframe_structure(df_all)\n",
    "    \n",
    "    # 构建图片注册表\n",
    "    print(\"正在构建图片注册表...\")\n",
    "    image_registry = build_image_registry()\n",
    "    \n",
    "    # 执行数据匹配\n",
    "    print(\"\\n开始数据匹配流程...\")\n",
    "    matched_df, unmatched_images = match_data(df_all, image_registry)\n",
    "    \n",
    "    # 分析匹配结果\n",
    "    analyze_matching(matched_df)\n",
    "    \n",
    "    # 输出未匹配图片\n",
    "    print(\"\\n未匹配图片详细信息:\")\n",
    "    print(unmatched_images[['data_type', 'filename'] + [f'pic_{col}' for col in COMPARE_COLUMNS]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1cc0e62a",
   "metadata": {},
   "outputs": [],
   "source": [
    "matched_df"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "791f2a04",
   "metadata": {},
   "source": [
    "#### 点击输出"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02ec3647",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 步骤1：提取列表中的文件名（如果列存储的是列表）\n",
    "if isinstance(matched_df['matched_files'].iloc[0], list):\n",
    "    matched_df['matched_files'] = matched_df['matched_files'].str[0]\n",
    "\n",
    "# 步骤2：强制转换为字符串类型并清理数据\n",
    "matched_df['matched_files'] = (\n",
    "    matched_df['matched_files']\n",
    "    .astype(str)  # 确保所有内容转为字符串\n",
    "    .str.replace(r\"[\\[\\]']\", \"\", regex=True)  # 移除方括号和引号\n",
    "    .str.strip()  # 去除首尾空格\n",
    ")\n",
    "\n",
    "# 验证处理结果\n",
    "print(\"处理后的样例文件名：\")\n",
    "print(matched_df['matched_files'].head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "87e6ddc4",
   "metadata": {},
   "outputs": [],
   "source": [
    "from ipywidgets import Output\n",
    "from matplotlib.lines import Line2D\n",
    "from IPython.display import display\n",
    "from matplotlib.font_manager import FontProperties\n",
    "%matplotlib widget\n",
    "\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.display import display, clear_output\n",
    "from PIL import Image as PILImage  # 引入PIL库的Image类\n",
    "import os\n",
    "import numpy as np\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "\n",
    "pointsize=10\n",
    "textsize=14\n",
    "figsizex= 6# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= 6\n",
    "labelss=str(r'$\\mathrm{SS}$ ')\n",
    "labelsf=str(r'$\\mathrm{SF}$ ')\n",
    "labelfs=str(r'$\\mathrm{FS}$ ')\n",
    "labelff=str(r'$\\mathrm{FF}$ ')\n",
    "labeldftype0=str(r'$\\mathrm{S}_{\\mathrm{T}}$ ')\n",
    "labeldftype1=str(r'$\\mathrm{S}_{\\mathrm{S}}$ ')\n",
    "labeldftype2=str(r'$\\mathrm{S}_{\\mathrm{B}}$ ')\n",
    "\n",
    "# 设置全局字体为新罗马\n",
    "plt.rc('font', family='Times New Roman')\n",
    "\n",
    "# 设置中文显示字体为宋体\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=14)\n",
    "font = FontProperties(fname=r\"C:/Windows/Fonts/simhei.ttf\", size=14) \n",
    "plt.rcParams[\"font.sans-serif\"] = [\"SimSun\"]\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "# plt.figure(figsize=[figsizex,figsizey])\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "# plt.grid(b=1, which='major') \n",
    "linewidth=2\n",
    "\n",
    "plt.legend(fontsize=textsize, title_fontsize=textsize)\n",
    "\n",
    "# 全局配置部分\n",
    "LABEL_SS = r'$\\mathrm{SS}$ '\n",
    "LABEL_SF = r'$\\mathrm{SF}$ '\n",
    "LABEL_FS = r'$\\mathrm{FS}$ '\n",
    "LABEL_FF = r'$\\mathrm{FF}$ '\n",
    "\n",
    "POINT_SIZE = 20\n",
    "COLOR_MAP_TYPE = 'viridis'\n",
    "\n",
    "\n",
    "# 数据来源df\n",
    "# dt_df=matched_df\n",
    "# 新增数据预处理：将字符串列表转为实际文件名\n",
    "dt_df=matched_df[(matched_df['type']==0)&(matched_df['n']==1)]\n",
    "# 筛选 type 列为 1 或者 2 的行\n",
    "# dt_df = matched_df[(matched_df['type'] == 1) | (matched_df['type'] == 2)]\n",
    "\n",
    "# dt_df.to_excel('dt_df.xlsx')\n",
    "    \n",
    "# 创建图片显示区域（核心改进点1：使用Output动态刷新）\n",
    "img_output = Output()\n",
    "display(img_output)\n",
    "\n",
    "def plot_single_scatter(ax, df, div_col, x_axis_col, y_axis_col, dfks_list):\n",
    "    \"\"\"\n",
    "    优化后的散点图绘制函数\n",
    "    \"\"\"\n",
    "    # 数据预处理\n",
    "    df = df.reset_index(drop=True)\n",
    "    unique_div_values = df[div_col].unique()\n",
    "    \n",
    "    # 颜色映射\n",
    "    min_color = df[div_col].min()\n",
    "    max_color = df[div_col].max()\n",
    "    norm = plt.Normalize(min_color, max_color)\n",
    "    \n",
    "    # 绘制基础线（核心改进点2：简化重复代码）\n",
    "    # 绘制基础线（核心改进点2：简化重复代码）\n",
    "    line_styles = [\n",
    "        ('r', '-', LABEL_SS), ('g', '--', LABEL_FF),\n",
    "        ('b', '-.', LABEL_SF), ('y', ':', LABEL_FS),\n",
    "        ('r', '-', LABEL_SS), ('g', '--', LABEL_FF),\n",
    "        ('b', '-.', LABEL_SF), ('y', ':', LABEL_FS)\n",
    "    ]\n",
    "    assert len(dfks_list) == 8, \"dfks_list must have length 8\"\n",
    "    for i, (color, ls, label) in enumerate(line_styles):\n",
    "        ax.plot(dfks_list[i]['1/alpha_ks'], dfks_list[i]['ks'], \n",
    "                c=color, ls=ls, linewidth=2)\n",
    "\n",
    "    # 手动向图 Legend 添加代表某一系列的标签，确保每种样式只添加一次\n",
    "    styles_seen = set()\n",
    "    unique_custom_lines = []\n",
    "    for color, ls, label in line_styles:\n",
    "        if (color, ls) not in styles_seen:\n",
    "            unique_custom_lines.append(Line2D([0], [0], color=color, lw=2, linestyle=ls, label=label))\n",
    "            styles_seen.add((color, ls))\n",
    "\n",
    "    # 添加自定义图例\n",
    "    ax.legend(handles=unique_custom_lines)\n",
    "    # 坐标轴设置\n",
    "    ax.set(xlim=(0, 1), ylim=(0, 15))\n",
    "    ax.axvline(1.0, c='grey', lw=1)\n",
    "    \n",
    "    # 绘制散点（核心改进点3：直接记录全局索引）\n",
    "    scatter_info = []\n",
    "    for value in unique_div_values:\n",
    "        mask = df[div_col] == value\n",
    "        sub_df = df[mask]\n",
    "        scatter = ax.scatter(\n",
    "            sub_df[x_axis_col], sub_df[y_axis_col],\n",
    "            c=sub_df[div_col], cmap=COLOR_MAP_TYPE,\n",
    "            norm=norm, s=POINT_SIZE\n",
    "        )\n",
    "        # 记录散点对象和对应的全局索引\n",
    "        scatter_info.append( (scatter, sub_df.index.tolist()) )\n",
    "    \n",
    "    # 颜色条(对于数值设置)\n",
    "    divider = make_axes_locatable(ax)\n",
    "    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n",
    "    color_bar = plt.colorbar(scatter, cax=cax)\n",
    "    \n",
    "        # 颜色条(对于汉字设置)\n",
    "    color_bar = plt.colorbar(scatter, cax=cax)\n",
    "\n",
    "#     color_bar.set_ticks([1, 2])\n",
    "#     color_bar.set_ticklabels(['单独\\n截面', '螺栓\\n截面'], fontproperties=font)  \n",
    "    return scatter_info\n",
    "# 数据预处理部分\n",
    "try:\n",
    "    dt_df = dt_df[dt_df['matched_files'].str.strip() != ''].copy()\n",
    "    \n",
    "    # 新增关键处理：移除方括号和引号\n",
    "#     dt_df['matched_files'] = dt_df['matched_files'].str.replace(r\"[\\[\\]']\", \"\", regex=True).str.strip()\n",
    "    \n",
    "    dt_df = dt_df.dropna(subset=['matched_files'])\n",
    "    print(f\"处理后有效数据量: {len(dt_df)}\")\n",
    "    print(f\"样例文件名: {dt_df['matched_files'].iloc[0]}\")  # 验证格式\n",
    "except NameError:\n",
    "    print(\"Error: dt_df未定义\")\n",
    "    raise\n",
    "    \n",
    "image_folder = 'R:\\\\NAS_DRIVE\\\\SynologyDrive\\\\pictest\\\\show'\n",
    "\n",
    "# 创建画布\n",
    "fig, ax = plt.subplots()\n",
    "\n",
    "# 假设 dfks_list 已经正确定义，长度为 8\n",
    "try:\n",
    "    dfks_list = [dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8]  # 请确保这八个变量已定义\n",
    "except NameError:\n",
    "    print(\"Error: One or more of dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8 are not defined.\")\n",
    "    raise\n",
    "\n",
    "\n",
    "\n",
    "# 点击事件处理（核心改进点4：精确索引匹配）\n",
    "def on_click(event):\n",
    "    if event.inaxes != ax: return\n",
    "    \n",
    "    for scatter, global_indices in scatter_info:\n",
    "        if not scatter.contains(event)[0]: continue\n",
    "        \n",
    "        ind = scatter.contains(event)[1]['ind'][0]\n",
    "        global_idx = global_indices[ind]\n",
    "        pic_name = dt_df.iloc[global_idx]['matched_files']\n",
    "        pic_path = os.path.join(image_folder, pic_name)\n",
    "        \n",
    "        # 调试信息（点击后会在输出区域显示完整路径）\n",
    "        print(f\"[Debug] 正在尝试访问图片路径: {pic_path}\") \n",
    "        \n",
    "        with img_output:\n",
    "            clear_output(wait=True)\n",
    "            # 显示图片文件名\n",
    "            print(f\"图片文件名: {pic_name}\")\n",
    "            # 临时修改pandas显示选项\n",
    "#             with pd.option_context('display.max_rows', None, 'display.max_columns', None, 'display.width', None):\n",
    "#                 print(\"这一行DataFrame的信息:\")\n",
    "#                 print(dt_df.iloc[global_idx])\n",
    "            if os.path.exists(pic_path):\n",
    "                try:\n",
    "                    pil_img = PILImage.open(pic_path)\n",
    "                    display(pil_img)\n",
    "                except Exception as e:\n",
    "                    print(f\"图片加载失败: {str(e)}\")\n",
    "            else:\n",
    "                print(f\"文件不存在: {pic_path}\")\n",
    "        return\n",
    "    # 绘制散点图\n",
    "scatter_info = plot_single_scatter(\n",
    "    ax, dt_df, 'ratio_eta_GJdivbyDL', 'KG_quge_web', 'k_taucr_fem2',\n",
    "    dfks_list)\n",
    "# 绑定事件\n",
    "fig.canvas.mpl_connect('button_press_event', on_click)\n",
    "\n",
    "\n",
    "ax.set_xlabel(r'$1/\\alpha$', fontsize=textsize)\n",
    "ax.set_ylabel(r'$k_{\\mathrm{s}}$', fontsize=textsize)\n",
    "\n",
    "# 添加竖向斜体的n\n",
    "ax.text(1.1,7.5, r'$\\gamma$',  # 使用斜体\n",
    "                  rotation=0, fontsize=12, fontstyle='italic',  # 垂直文本\n",
    "                  ha='center', va='center')  # 垂直居中对齐文字\n",
    "# ax.text(3.3, 22.5, '类型', fontsize=12, fontstyle='italic', fontproperties=font)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# # 资源清理\n",
    "# def cleanup():\n",
    "#     plt.close(fig)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fa6ef1f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# # import matplotlib.pyplot as plt\n",
    "\n",
    "# # # 绘制n和F的分布\n",
    "# dt_df.hist(['KG_quge_web', 'ratio'], bins=10, figsize=(10, 6))\n",
    "# # plt.suptitle('Distribution of n and F')\n",
    "# # plt.show()\n",
    "# dt_df['ratio_alpha_tflange_to_tweb'].max\n",
    "# max(dt_df['KG_total_web'])\n",
    "# dt_df = dt_df[(dt_df['ratio_alpha_tflange_to_tweb'] >= 0.5) & (dt_df['ratio_alpha_tflange_to_tweb'] <= 2.0)]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3fc790bc",
   "metadata": {},
   "source": [
    "#### Lee方法放在理论k图中"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "faea0fb4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-08-07T09:28:44.740806Z",
     "start_time": "2023-08-07T09:28:41.891400Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from ipywidgets import Output\n",
    "from matplotlib.lines import Line2D\n",
    "from IPython.display import display\n",
    "from matplotlib.font_manager import FontProperties\n",
    "%matplotlib widget\n",
    "\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.display import display, clear_output\n",
    "from PIL import Image as PILImage  # 引入PIL库的Image类\n",
    "import os\n",
    "import numpy as np\n",
    "from pylab import mpl\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "\n",
    "pointsize = 10\n",
    "textsize = 14\n",
    "figsizex = 26\n",
    "figsizey = 26\n",
    "labelss = str(r'$\\mathrm{SS}$ ')\n",
    "labelsf = str(r'$\\mathrm{SF}$ ')\n",
    "labelfs = str(r'$\\mathrm{FS}$ ')\n",
    "labelff = str(r'$\\mathrm{FF}$ ')\n",
    "labeldftype0 = str(r'$\\mathrm{S}_{\\mathrm{T}}$ ')\n",
    "labeldftype1 = str(r'$\\mathrm{S}_{\\mathrm{S}}$ ')\n",
    "labeldftype2 = str(r'$\\mathrm{S}_{\\mathrm{B}}$ ')\n",
    "\n",
    "# 设置全局字体为新罗马\n",
    "plt.rc('font', family='Times New Roman')\n",
    "\n",
    "# 设置中文显示字体为宋体\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize)\n",
    "font = FontProperties(fname=r\"C:/Windows/Fonts/simhei.ttf\", size=textsize)\n",
    "plt.rcParams[\"font.sans-serif\"] = [\"SimSun\"]\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "plt.rcParams['xtick.direction'] = 'in'  # x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'  # y刻度向内侧显示\n",
    "plt.tick_params(bottom=True, top=True, left=True, right=True)  # 显示上部和右侧刻度线\n",
    "linewidth = 2\n",
    "\n",
    "plt.legend(fontsize=textsize, title_fontsize=textsize)\n",
    "\n",
    "# 全局配置部分\n",
    "LABEL_SS = r'$\\mathrm{SS}$ '\n",
    "LABEL_SF = r'$\\mathrm{SF}$ '\n",
    "LABEL_FS = r'$\\mathrm{FS}$ '\n",
    "LABEL_FF = r'$\\mathrm{FF}$ '\n",
    "\n",
    "POINT_SIZE = 20\n",
    "COLOR_MAP_TYPE = 'viridis'\n",
    "# 定义 m_plot\n",
    "mincolorbar = 0.5\n",
    "maxcolorbar = 6\n",
    "norm_plot = plt.Normalize(mincolorbar, maxcolorbar)\n",
    "m_plot = cm.ScalarMappable(norm=norm_plot, cmap=COLOR_MAP_TYPE)\n",
    "# 定义 cmap_plot\n",
    "cmap_plot = cm.get_cmap(COLOR_MAP_TYPE)\n",
    "\n",
    "# 数据来源df\n",
    "# dt_df=matched_df\n",
    "# 新增数据预处理：将字符串列表转为实际文件名\n",
    "# dt_df=matched_df[(matched_df['type']!=0)&(matched_df['n']==1)]\n",
    "# 筛选 type 列为 1 或者 2 的行\n",
    "# dt_df = matched_df[(matched_df['type'] == 1) | (matched_df['type'] == 2)]\n",
    "\n",
    "\n",
    "# 创建图片显示区域（核心改进点1：使用Output动态刷新）\n",
    "img_output = Output()\n",
    "display(img_output)\n",
    "\n",
    "\n",
    "def plot_single_scatter(ax, df, div_col, x_axis_col, y_axis_col, dfks_list):\n",
    "    \"\"\"\n",
    "    优化后的散点图绘制函数\n",
    "    \"\"\"\n",
    "    # 数据预处理\n",
    "    df = df.reset_index(drop=True)\n",
    "    unique_div_values = df[div_col].unique()\n",
    "\n",
    "#     # 颜色映射(按照散点映射)\n",
    "#     min_color = df[div_col].min()\n",
    "#     max_color = df[div_col].max()\n",
    "#     norm = plt.Normalize(min_color, max_color)\n",
    "    # 颜色映射(按手工设置的上下界映射)\n",
    "    norm=plt.Normalize(mincolorbar, maxcolorbar)\n",
    "    # 绘制基础线（核心改进点2：简化重复代码）\n",
    "    line_styles = [\n",
    "        ('r', '-', LABEL_SS), ('g', '--', LABEL_FF),\n",
    "        ('b', '-.', LABEL_SF), ('y', ':', LABEL_FS),\n",
    "        ('r', '-', LABEL_SS), ('g', '--', LABEL_FF),\n",
    "        ('b', '-.', LABEL_SF), ('y', ':', LABEL_FS)\n",
    "    ]\n",
    "    assert len(dfks_list) == 8, \"dfks_list must have length 8\"\n",
    "    for i, (color, ls, label) in enumerate(line_styles):\n",
    "        ax.plot(dfks_list[i]['1/alpha_ks'], dfks_list[i]['ks'],\n",
    "                c=color, ls=ls, linewidth=2)\n",
    "\n",
    "    # 手动向图 Legend 添加代表某一系列的标签，确保每种样式只添加一次\n",
    "    styles_seen = set()\n",
    "    unique_custom_lines = []\n",
    "    for color, ls, label in line_styles:\n",
    "        if (color, ls) not in styles_seen:\n",
    "            unique_custom_lines.append(Line2D([0], [0], color=color, lw=2, linestyle=ls, label=label))\n",
    "            styles_seen.add((color, ls))\n",
    "\n",
    "    # 添加自定义图例\n",
    "    ax.legend(handles=unique_custom_lines)\n",
    "    # 坐标轴设置\n",
    "    ax.set(xlim=(0, 3), ylim=(0, 45))\n",
    "    #     ax.axvline(1.0, c='grey', lw=1)\n",
    "\n",
    "    # 绘制散点（核心改进点3：直接记录全局索引）\n",
    "    scatter_info = []\n",
    "    for value in unique_div_values:\n",
    "        mask = df[div_col] == value\n",
    "        sub_df = df[mask]\n",
    "        scatter = ax.scatter(\n",
    "            sub_df[x_axis_col], sub_df[y_axis_col],\n",
    "            c=sub_df[div_col], cmap=COLOR_MAP_TYPE,\n",
    "            norm=norm, s=POINT_SIZE\n",
    "        )\n",
    "        # 记录散点对象和对应的全局索引\n",
    "        scatter_info.append((scatter, sub_df.index.tolist()))\n",
    "\n",
    "#     # 颜色条(对于数值设置)\n",
    "#     divider = make_axes_locatable(ax)\n",
    "#     cax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n",
    "#     color_bar = plt.colorbar(scatter, cax=cax)\n",
    "\n",
    "#     # 颜色条(对于汉字设置)\n",
    "    color_bar = plt.colorbar(scatter, cax=cax)\n",
    "\n",
    "    #     color_bar.set_ticks([1, 2])\n",
    "    #     color_bar.set_ticklabels(['单独\\n截面', '螺栓\\n截面'], fontproperties=font)\n",
    "    return scatter_info\n",
    "\n",
    "\n",
    "# 数据预处理部分\n",
    "try:\n",
    "    dt_df = dt_df[dt_df['matched_files'].str.strip() != ''].copy()\n",
    "\n",
    "    # 新增关键处理：移除方括号和引号\n",
    "    #     dt_df['matched_files'] = dt_df['matched_files'].str.replace(r\"[\\[\\]']\", \"\", regex=True).str.strip()\n",
    "\n",
    "    dt_df = dt_df.dropna(subset=['matched_files'])\n",
    "    print(f\"处理后有效数据量: {len(dt_df)}\")\n",
    "    print(f\"样例文件名: {dt_df['matched_files'].iloc[0]}\")  # 验证格式\n",
    "except NameError:\n",
    "    print(\"Error: dt_df未定义\")\n",
    "    raise\n",
    "\n",
    "image_folder = 'R:\\\\NAS_DRIVE\\\\SynologyDrive\\\\pictest\\\\show'\n",
    "\n",
    "# 创建画布\n",
    "fig, ax = plt.subplots()\n",
    "\n",
    "# 假设 dfks_list 已经正确定义，长度为 8\n",
    "try:\n",
    "    dfks_list = [dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8]  # 请确保这八个变量已定义\n",
    "except NameError:\n",
    "    print(\"Error: One or more of dfks1, dfks2, dfks3, dfks4, dfks5, dfks6, dfks7, dfks8 are not defined.\")\n",
    "    raise\n",
    "\n",
    "# 假设 dfks1, dfks4, dfks5, dfks8 等数据帧已经定义好\n",
    "for tftotw in np.linspace(0.5, 2.1, 100):\n",
    "    if 0.5 < tftotw < 2:\n",
    "        # 计算曲线并绘制\n",
    "        for dfks_a, dfks_b in [(dfks1, dfks4), (dfks5, dfks8)]:\n",
    "            plt.plot(dfks_a['1/alpha_ks'].values,\n",
    "                     dfks_a['ks'].values + 4 / 5 * (dfks_b['ks'].values - dfks_a['ks'].values) * (\n",
    "                             1 - 2 / 3 * (2 - tftotw)),\n",
    "                     c=m_plot.to_rgba(tftotw), ls='-', linewidth=2)\n",
    "    else:\n",
    "        # 对于 tftotw > 2 的情况\n",
    "        for dfks_a, dfks_b in [(dfks1, dfks4), (dfks5, dfks8)]:\n",
    "            plt.plot(dfks_a['1/alpha_ks'].values,\n",
    "                     dfks_a['ks'].values + 4 / 5 * (dfks_b['ks'].values - dfks_a['ks'].values),\n",
    "                     c='black', ls='-', linewidth=2)\n",
    "\n",
    "# 设置坐标轴范围和标签\n",
    "plt.xlim(0, 3)\n",
    "plt.ylim(5, 45)\n",
    "plt.xlabel(r'$1/\\alpha$', fontsize=textsize)\n",
    "plt.ylabel(r'$k$', fontsize=textsize)\n",
    "\n",
    "# 添加文本注释\n",
    "ax.text(1.02, 1.02, r'$t_{\\rm f}/t_{\\rm w}$', fontsize=14, transform=ax.transAxes)\n",
    "\n",
    "# 只显式四个标签\n",
    "labels = [str(r'$K_{\\mathrm{SS}}$'), str(r'$K_{\\mathrm{FF}}$'),\n",
    "          str(r'$K_{\\mathrm{SF}}$'), str(r'$K_{\\mathrm{FS}}$')]\n",
    "colors = ['r', 'r', 'g', 'g', 'b', 'b', 'y', 'y']\n",
    "styles = ['-', '-', '--', '--', '-.', '-.', ':', ':']\n",
    "# 假设 dfks1 到 dfks8 是已经定义好的 DataFrame\n",
    "dfs = [dfks1, dfks5, dfks2, dfks6, dfks3, dfks7, dfks4, dfks8]\n",
    "\n",
    "for i, df in enumerate(dfs):\n",
    "    # 每两个一组对应一个标签\n",
    "    label_index = i // 2\n",
    "    if i % 2 == 0:\n",
    "        # 每组的第一个设置标签\n",
    "        plt.plot(df['1/alpha_ks'].values, df['ks'].values, c=colors[i], ls=styles[i],\n",
    "                 linewidth=1.5, label=labels[label_index])\n",
    "    else:\n",
    "        # 每组的第二个不设置标签\n",
    "        plt.plot(df['1/alpha_ks'].values, df['ks'].values, c=colors[i], ls=styles[i],\n",
    "                 linewidth=1.5)\n",
    "\n",
    "# 绘制垂直直线\n",
    "plt.axvline(1.00, linestyle='-', c='grey')\n",
    "# 添加颜色条\n",
    "divider = make_axes_locatable(ax)\n",
    "cax = divider.append_axes(\"right\", \"5%\", pad=\"0%\")\n",
    "cb = plt.colorbar(m_plot, cax=cax, orientation=\"vertical\")\n",
    "cb.set_ticks(np.round(np.linspace(mincolorbar, maxcolorbar, 6), 1))\n",
    "\n",
    "# 设置边框样式\n",
    "for spine in ax.spines.values():\n",
    "    spine.set_linewidth(1)\n",
    "    spine.set_color('black')\n",
    "\n",
    "\n",
    "# 点击事件处理（核心改进点4：精确索引匹配）\n",
    "def on_click(event):\n",
    "    if event.inaxes != ax: return\n",
    "\n",
    "    for scatter, global_indices in scatter_info:\n",
    "        if not scatter.contains(event)[0]: continue\n",
    "\n",
    "        ind = scatter.contains(event)[1]['ind'][0]\n",
    "        global_idx = global_indices[ind]\n",
    "        pic_name = dt_df.iloc[global_idx]['matched_files']\n",
    "        pic_path = os.path.join(image_folder, pic_name)\n",
    "\n",
    "        # 调试信息（点击后会在输出区域显示完整路径）\n",
    "        print(f\"[Debug] 正在尝试访问图片路径: {pic_path}\")\n",
    "\n",
    "        with img_output:\n",
    "            clear_output(wait=True)\n",
    "            # 显示图片文件名\n",
    "            print(f\"图片文件名: {pic_name}\")\n",
    "            #             临时修改pandas显示选项\n",
    "            with pd.option_context('display.max_rows', None, 'display.max_columns', None, 'display.width', None):\n",
    "                print(\"这一行DataFrame的信息:\")\n",
    "                print(dt_df.iloc[global_idx])\n",
    "            if os.path.exists(pic_path):\n",
    "                try:\n",
    "                    pil_img = PILImage.open(pic_path)\n",
    "                    display(pil_img)\n",
    "                except Exception as e:\n",
    "                    print(f\"图片加载失败: {str(e)}\")\n",
    "            else:\n",
    "                print(f\"文件不存在: {pic_path}\")\n",
    "        return\n",
    "\n",
    "\n",
    "# 绘制散点图\n",
    "scatter_info = plot_single_scatter(\n",
    "    ax, dt_df, 'ratio_alpha_tflange_to_tweb', 'KG_total_web', 'k_taucr_fem2',\n",
    "    dfks_list)\n",
    "# 绑定事件\n",
    "fig.canvas.mpl_connect('button_press_event', on_click)\n",
    "\n",
    "ax.set_xlabel(r'$1/\\alpha$', fontsize=textsize)\n",
    "ax.set_ylabel(r'$k_{\\mathrm{s}}$', fontsize=textsize)\n",
    "\n",
    "# 添加竖向斜体的n\n",
    "# ax.text(1.1, 7.5, r'$\\gamma$',  # 使用斜体\n",
    "#         rotation=0, fontsize=textsize, fontstyle='italic',  # 垂直文本\n",
    "#         ha='center', va='center')  # 垂直居中对齐文字\n",
    "# ax.text(3.3, 22.5, '类型', fontsize=12, fontstyle='italic', fontproperties=font)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# 资源清理\n",
    "def cleanup():\n",
    "    plt.close(fig)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "061508bf",
   "metadata": {},
   "source": [
    "#### Lee方法3D图、以及2D图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1febd3fa",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-08-07T07:21:09.593901Z",
     "start_time": "2023-08-07T07:21:08.498695Z"
    },
    "code_folding": []
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib as mpl\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "df_selected=dt_df\n",
    "scatter_df=dt_df\n",
    "# 设置绘图的基本参数\n",
    "def setup_plot_parameters():\n",
    "    \"\"\"\n",
    "    设置绘图的基本参数，如点大小、图形大小、字体大小等。\n",
    "    :return: 点大小、图形的宽度和高度、字体大小、刻度大小以及字体属性\n",
    "    \"\"\"\n",
    "    point_size = 20\n",
    "    fig_width, fig_height = 6, 6\n",
    "    font_size, tick_size = 14, 12\n",
    "    font_properties = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=16)\n",
    "    plt.rc('font', family='Times New Roman')\n",
    "    plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "    plt.rcParams['axes.unicode_minus'] = False\n",
    "    plt.rcParams['xtick.direction'] = 'in'\n",
    "    plt.rcParams['ytick.direction'] = 'in'\n",
    "    plt.tick_params(bottom=True, top=True, left=True, right=True)\n",
    "    return point_size, fig_width, fig_height, font_size, tick_size, font_properties\n",
    "\n",
    "# 定义 k_Lee 计算函数\n",
    "def calculate_k_Lee(x_3d, y_3d):\n",
    "    \"\"\"\n",
    "    根据输入的 x_3d 和 y_3d 计算 k_Lee 的值。\n",
    "    :param x_3d: 输入的 x_3d 值\n",
    "    :param y_3d: 输入的 y_3d 值\n",
    "    :return: 计算得到的 k_Lee 值\n",
    "    \"\"\"\n",
    "    if 0.5 <= y_3d < 2:\n",
    "        if x_3d <= 1:\n",
    "            return (4 + 5.34 / (x_3d ** 2)) + (4 / 5 * ((5.34 / (x_3d ** 2) + 2.31 / x_3d - 3.44 + 8.39 * x_3d) - (4 + 5.34 / (x_3d ** 2)))) * (1 - 2 / 3 * (2 - y_3d))\n",
    "        else:\n",
    "            return (5.34 + 4 / (x_3d ** 2)) + (4 / 5 * ((8.98 + 5.61 / (x_3d ** 2) - 1.99 / (x_3d ** 3)) - (5.34 + 4 / (x_3d ** 2)))) * (1 - 2 / 3 * (2 - y_3d))\n",
    "    elif y_3d >= 2:\n",
    "        if x_3d <= 1:\n",
    "            return (4 + 5.34 / (x_3d ** 2)) + (4 / 5 * ((5.34 / (x_3d ** 2) + 2.31 / x_3d - 3.44 + 8.39 * x_3d) - (4 + 5.34 / (x_3d ** 2))))\n",
    "        else:\n",
    "            return (5.34 + 4 / (x_3d ** 2)) + (4 / 5 * ((8.98 + 5.61 / (x_3d ** 2) - 1.99 / (x_3d ** 3)) - (5.34 + 4 / (x_3d ** 2))))\n",
    "\n",
    "# 绘制 2D 散点图和折线图\n",
    "def plot_2d_scatter_and_lines(df_selected, color_parameter):\n",
    "    \"\"\"\n",
    "    绘制 2D 散点图和折线图，散点颜色根据指定参数区分。\n",
    "    :param df_selected: 筛选后的数据 DataFrame\n",
    "    :param color_parameter: 用于区分散点颜色的参数\n",
    "    \"\"\"\n",
    "    point_size, fig_width, _, _, _, font_properties = setup_plot_parameters()\n",
    "    color_map = 'viridis'\n",
    "\n",
    "    # 清空当前图形\n",
    "    plt.clf()\n",
    "    plt.figure(figsize=(fig_width, fig_width))\n",
    "    plt.xlabel(r'$t_{\\rm f}/t_{\\rm w}$', fontproperties=font_properties)\n",
    "    plt.ylabel(r'$k_{\\rm Lee}$', fontproperties=font_properties)\n",
    "    plt.xlim(0, 4)\n",
    "    plt.ylim(0, 45)\n",
    "\n",
    "    # 确定折线图 x_3d 的范围\n",
    "    x_3d_min = 0.5\n",
    "    x_3d_max = 6\n",
    "    norm = mpl.colors.Normalize(vmin=x_3d_min, vmax=x_3d_max)\n",
    "    cmap = cm.get_cmap(color_map)\n",
    "    scalar_mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n",
    "\n",
    "    # 绘制折线图\n",
    "    x_3d_values = []\n",
    "    for x_3d in np.linspace(x_3d_min, x_3d_max, 100):\n",
    "        y_3d_values = []\n",
    "        k_Lee_values = []\n",
    "        for y_3d in np.linspace(0.5, 4, 100):\n",
    "            k_Lee = calculate_k_Lee(x_3d, y_3d)\n",
    "            y_3d_values.append(y_3d)\n",
    "            k_Lee_values.append(k_Lee)\n",
    "        plt.plot(y_3d_values, k_Lee_values, c=scalar_mappable.to_rgba(x_3d), ls='-', linewidth=2)\n",
    "        x_3d_values.append(x_3d)\n",
    "\n",
    "    df_processed = df_selected.reset_index(drop=True)\n",
    "    color_values = df_processed[color_parameter].values\n",
    "    min_color = min(color_values)\n",
    "    max_color = max(color_values)\n",
    "\n",
    "    for i in range(len(df_processed)):\n",
    "        x_scatter = df_processed.at[i, x_axis_parameter]\n",
    "        y_scatter = df_processed.at[i, y_axis_parameter]\n",
    "        color_value = df_processed.at[i, color_parameter]\n",
    "        # 将颜色值映射到 x_3d 的范围\n",
    "        color_mapping = np.interp(color_value, [min_color, max_color], [x_3d_min, x_3d_max])\n",
    "        plt.scatter(x_scatter, y_scatter, c=[scalar_mappable.to_rgba(color_mapping)], cmap=color_map,\n",
    "                    vmin=x_3d_min, vmax=x_3d_max, s=point_size)\n",
    "\n",
    "    # 添加 colorbar\n",
    "    divider = make_axes_locatable(plt.gca())\n",
    "    cax = divider.append_axes(\"right\", \"5 %\", pad=\"0%\")\n",
    "    cb = plt.colorbar(scalar_mappable, cax=cax, orientation=\"vertical\")\n",
    "    cb.set_label(fr'${color_parameter}$', fontproperties=font_properties)\n",
    "\n",
    "#     file_name_2d = f'combined_2d_{color_parameter}'\n",
    "#     plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PhDall\\matplotilibpic\\\\\" + file_name_2d + \".svg\",\n",
    "#                 bbox_inches='tight', pad_inches=0)\n",
    "    plt.show()\n",
    "    plt.close()\n",
    "color_map = 'viridis'\n",
    "# 绘制 3D 图\n",
    "def plot_3d_graph(df_selected, color_parameter):\n",
    "    \"\"\"\n",
    "    绘制 3D 图，包括曲面和散点，散点颜色根据指定参数区分。\n",
    "    :param df_selected: 筛选后的数据 DataFrame\n",
    "    :param color_parameter: 用于区分散点颜色的参数\n",
    "    \"\"\"\n",
    "    # 开启交互模式\n",
    "    plt.ion()\n",
    "    point_size, fig_width, _, _, _, font_properties = setup_plot_parameters()\n",
    "    # 清空当前图形\n",
    "    plt.clf()\n",
    "    fig = plt.figure(figsize=(fig_width, fig_width))\n",
    "    ax = fig.add_subplot(111, projection='3d')\n",
    "    # 生成 1/X 的值，范围从一个非常小的正数到 3，共 100 个点\n",
    "    one_over_X = np.linspace(1e-10, 3, 100)\n",
    "\n",
    "# 对 1/X 的值取倒数得到 X 的值\n",
    "    X = 1 / one_over_X\n",
    "#     X = np.linspace(0, 3, 100)  # 对应 2D 图的横坐标     \n",
    "    Y = np.linspace(0.5,6, 100)  # 对应 2D 图中的 x_3d,tf/tw\n",
    "    X, Y = np.meshgrid(X,Y)\n",
    "    \n",
    "    Z = np.vectorize(calculate_k_Lee)(X, Y)\n",
    "\n",
    "    # 绘制 3D 曲面\n",
    "    surf = ax.plot_surface( Y,one_over_X,Z, cmap=color_map, alpha=0.5)\n",
    "#     surf = ax.plot_trisurf(Y, one_over_X, Z, color='lightblue', alpha=0.5)\n",
    "    df_processed = df_selected.reset_index(drop=True)\n",
    "    color_values = df_processed[color_parameter].values\n",
    "    \n",
    "    min_color = min(color_values)\n",
    "    max_color = max(color_values)\n",
    "\n",
    "    norm = mpl.colors.Normalize(vmin=min_color, vmax=max_color)\n",
    "    cmap = cm.get_cmap(color_map)\n",
    "    scalar_mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n",
    "\n",
    "    for i in range(len(df_processed)):\n",
    "        x_scatter = df_processed.at[i, color_parameter]  # 3D 图的 x 轴对应 2D 图中的 x_3d 相关值\n",
    "        y_scatter = df_processed.at[i, x_axis_parameter]  # 3D 图的 y 轴对应 2D 图的横坐标\n",
    "        z_scatter = df_processed.at[i, y_axis_parameter]  # 3D 图的 z 轴对应 2D 图的纵坐标\n",
    "        color_value = df_processed.at[i, color_parameter]\n",
    "        ax.scatter(x_scatter, y_scatter, z_scatter, c=[scalar_mappable.to_rgba(color_value)], cmap=color_map)\n",
    "\n",
    "#     fig.colorbar(surf, shrink=0.5, aspect=5, label=fr'${color_parameter}$')\n",
    "    ax.zaxis.set_rotate_label(False)\n",
    "    ax.set_xlabel(r'$t_{\\rm f}/t_{\\rm w}$', fontproperties=font_properties)\n",
    "    ax.set_ylabel(r'$1/\\alpha$', fontproperties=font_properties)\n",
    "    ax.set_zlabel(r'$k_{\\rm s}$', fontproperties=font_properties)\n",
    "    # 限制坐标轴范围\n",
    "    ax.set_xlim(0, 8)  # 设置 X 轴范围从 0 到 5\n",
    "    ax.set_ylim(0, 1)  # 设置 Y 轴范围从 0 到 2\n",
    "    ax.set_zlim(0, 15)  # 设置 Z 轴范围从 0 到 40\n",
    "# 设置相机视角\n",
    "    ax.view_init(elev=25, azim=310)  # 这里可以根据需要调整仰角和方位角\n",
    "#     ax.view_init(elev=0, azim=-90)  # 这里可以根据需要调整仰角和方位角\n",
    "\n",
    "    plt.show()\n",
    "    plt.ioff()\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # 绘制散点\n",
    "    x_axis_parameter = 'KG_total_web'\n",
    "    y_axis_parameter = 'k_taucr_fem2_n'\n",
    "    # 定义两个分色参数\n",
    "#     color_parameters = ['KG_total_web', 'ratio_alpha_Bflange_to_Hn']\n",
    "    color_parameters = [ 'ratio_alpha_tflange_to_tweb']\n",
    "#     # 绘制 2D 图\n",
    "    for color_parameter in color_parameters:\n",
    "        plot_2d_scatter_and_lines(df_selected, color_parameter)\n",
    "\n",
    "    # 绘制 3D 图\n",
    "    for color_parameter in color_parameters:\n",
    "        plot_3d_graph(df_selected, color_parameter)\n",
    "# 以上代码我想截去三维图纸坐标以外的数据和曲面\n",
    "plt.tight_layout"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "299a676a",
   "metadata": {},
   "source": [
    "#### 理论加劲板"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "76a77aaa",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.291944Z",
     "start_time": "2023-07-04T14:49:09.291944Z"
    },
    "code_folding": []
   },
   "outputs": [],
   "source": [
    "alpha_ks_stiffener_list=['beta','gamma','ks']\n",
    "df_alpha_ks_stiffener_list= pd.DataFrame(columns=alpha_ks_stiffener_list)\n",
    "se_alpha_ks_stiffener_list=['beta','gamma','ks']\n",
    "for beta in np.linspace(0.01, 30, 100):\n",
    "    for gamma in np.linspace(0.01, 30, 100):\n",
    "        if 1<= beta <=5 and 0<gamma<=4*(7*beta**2-5):\n",
    "            ks=5.34+(5.5*beta**2-0.6)*(gamma/(4*(7*beta**2-5)))**(1/3)\n",
    "            se_alpha_ks_stiffener_list=pd.Series([beta,gamma,ks],index=alpha_ks_stiffener_list)\n",
    "            df_alpha_ks_stiffener_list=pd.concat([df_alpha_ks_stiffener_list,se_alpha_ks_stiffener_list.to_frame().transpose()],axis=0,ignore_index=True)  \n",
    "        else:\n",
    "            k=4.74+5.5*beta**2\n",
    "            se_alpha_ks_stiffener_list=pd.Series([beta,gamma,ks],index=alpha_ks_stiffener_list)\n",
    "            df_alpha_ks_stiffener_list=pd.concat([df_alpha_ks_stiffener_list,se_alpha_ks_stiffener_list.to_frame().transpose()],axis=0,ignore_index=True)\n",
    "#             df_alpha_ks_stiffener_list.eval(\"\"\"Totalcondition = edge_b_length-edge_a_length\"\"\", inplace=True)\n",
    "\n",
    "df_alpha_ks_stiffener_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2639d392",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.292943Z",
     "start_time": "2023-07-04T14:49:09.292943Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 创建4x4子图布局，但仅使用第一个子图ax1\n",
    "# fig = plt.figure(dpi=600, figsize=[20, 10])\n",
    "fig = plt.figure()\n",
    "ax1 = fig.add_subplot(1, 1, 1)\n",
    "\n",
    "# 删除未使用的子图\n",
    "unused_axes = [fig.add_subplot(4, 4, i) for i in range(2, 9)]\n",
    "for ax in unused_axes:\n",
    "    ax.set_visible(False)\n",
    "\n",
    "# 数据排序和预处理\n",
    "df_ks_sort = df_alpha_ks_stiffener_list.sort_values(by=['beta'])\n",
    "\n",
    "# 提取gamma值并计算颜色范围\n",
    "d = df_ks_sort['gamma'].values\n",
    "minco = min(d) - ((max(d) - min(d)) / ((len(d) - 1) * 2))\n",
    "maxco = max(d) + ((max(d) - min(d)) / ((len(d) - 1) * 2))\n",
    "\n",
    "# 向量化数据准备（避免循环）\n",
    "x_ks = df_ks_sort['beta'].values\n",
    "y_ks = df_ks_sort['ks'].values\n",
    "z_ks = df_ks_sort['gamma'].values\n",
    "colors = (z_ks - minco) / (maxco - minco)  # 正确归一化\n",
    "\n",
    "# 绘制散点图\n",
    "sc = ax1.scatter(x_ks, y_ks, c=colors, cmap='viridis', \n",
    "                 vmin=0, vmax=1, label='Short edge simply supported')\n",
    "\n",
    "# 添加颜色条和图例\n",
    "cbar = fig.colorbar(sc, ax=ax1)\n",
    "ax1.legend(loc='upper right')\n",
    "\n",
    "# 调整布局\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4afb343a",
   "metadata": {},
   "source": [
    "#### 童根书方法（门槛）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b81c6e9b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "E = 2.06e5\n",
    "nu = 0.3\n",
    "\n",
    "# 假设 df_Tong 是已有的 DataFrame，包含 'n', 'H', 'L', 'T1' 列\n",
    "df_Tong = df_basepara_Tong.copy()\n",
    "\n",
    "# 计算条件\n",
    "condition = df_Tong['n'] * df_Tong['H'] / df_Tong['L'] < 1\n",
    "\n",
    "# 计算分母部分\n",
    "denominator = (np.pi**2 * E * (df_Tong['T1'] / df_Tong['L'])**2) / (12 * (1 - nu**2))\n",
    "\n",
    "# 计算分子和结果\n",
    "numerator1 = 4 + 5.34 / (df_Tong['n'] * df_Tong['H'] / df_Tong['L'])**2\n",
    "result1 = denominator * numerator1  # 修正为乘以分子\n",
    "\n",
    "numerator2 = 5.34 + 4 / (df_Tong['n'] * df_Tong['H'] / df_Tong['L'])**2\n",
    "result2 = denominator * numerator2\n",
    "\n",
    "df_Tong['tau2_elastic'] = np.where(condition, result1, result2)\n",
    "# 计算归一化后的 tau2\n",
    "df_Tong['tau2_normalized'] = df_Tong['tau2_elastic'] * (12 * (1 - nu**2) * df_Tong['L']**2) / (np.pi**2 * E * df_Tong['T1']**2)\n",
    "\n",
    "# 计算自变量 x = n*H/L\n",
    "df_Tong['x'] = df_Tong['n'] * df_Tong['H'] / df_Tong['L']\n",
    "\n",
    "\n",
    "x_theory = np.linspace(df_Tong['x'].min() * 0.9, df_Tong['x'].max() * 1.1, 1000)\n",
    "k_theory = np.where(x_theory < 1, 4 + 5.34 / (x_theory**2), 5.34 + 4 / (x_theory**2))\n",
    "\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.scatter(df_Tong['x'], df_Tong['tau2_normalized'], color='blue', label='Data Points', alpha=0.6)\n",
    "plt.plot(x_theory, k_theory, color='red', label='Theoretical Curve')\n",
    "plt.xlabel('nH/L')\n",
    "plt.ylabel('Normalized tau2_elastic')\n",
    "plt.title('Theoretical Curve vs Data Points')\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "95bb7429",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from matplotlib.colors import Normalize\n",
    "from matplotlib.cm import ScalarMappable\n",
    "\n",
    "# 数据准备 -----------------------------------------------------------------\n",
    "# 假设 dfdelpara 已经定义\n",
    "# dfdelpara = pd.read_csv('your_data.csv')  # 这里需要根据实际情况读取数据\n",
    "dfdelpara = df_T\n",
    "\n",
    "# 固定标准参数\n",
    "general_list = ['yfss', 'Imperfectfactor', 'meshsz', 'cf1f', 'cf2f', 'cf3f', 'type']\n",
    "general_list_number = [355.61, 0.002, 20, 0, 1, 0, 0]\n",
    "\n",
    "df_basepara_Tong = dfdelpara.copy()\n",
    "for i in range(len(general_list)):\n",
    "    df_basepara_Tong = df_basepara_Tong[df_basepara_Tong[general_list[i]] == general_list_number[i]].copy()\n",
    "\n",
    "# 理论计算\n",
    "E = 2.06e5\n",
    "Pai = np.pi\n",
    "df_Tong = df_basepara_Tong\n",
    "\n",
    "condition = df_Tong['n'] * df_Tong['H'] / df_Tong['L'] < 1\n",
    "denominator = (Pai**2 * E * (df_Tong['T1']/df_Tong['L'])**2)/(12 * (1 - 0.3**2))\n",
    "\n",
    "numerator1 = (4 + 5.34/((df_Tong['n']*df_Tong['H']/df_Tong['L'])**2))\n",
    "result1 = denominator *denominator\n",
    "\n",
    "numerator2 = (5.34 + 4/((df_Tong['n']*df_Tong['H']/df_Tong['L'])**2))\n",
    "result2 = numerator2 * denominator\n",
    "\n",
    "df_Tong['tau2_elastic'] = np.where(condition, result1, result2)\n",
    "df_Tong['normalized_stress'] = df_Tong.eval('tau_fem2/tau2_elastic')\n",
    "\n",
    "# 可视化设置 --------------------------------------------------------------\n",
    "# 核心参数设置\n",
    "color_param = \"H\"         # 连续型参数（颜色映射）\n",
    "symbol_param = \"n\"        # 分类型参数（标记符号）\n",
    "cmap_name = \"viridis\"     # 色图类型：viridis/plasma/inferno等\n",
    "symbols = ['o', 's', '^', 'D', 'v', '*', 'p', 'X']  # 学术常用符号集\n",
    "\n",
    "# 创建画布\n",
    "plt.figure(figsize=(12, 7), dpi=100)\n",
    "ax = plt.gca()\n",
    "\n",
    "# 数据过滤（可选）\n",
    "valid_data = df_Tong[\n",
    "    (df_Tong[\"gamma\"] > 0) & \n",
    "    (df_Tong[\"normalized_stress\"] > 0) &\n",
    "    (df_Tong[color_param] < 500)  # 过滤异常值\n",
    "].copy()\n",
    "\n",
    "# 颜色映射设置\n",
    "norm = Normalize(vmin=valid_data[color_param].min(), \n",
    "                vmax=valid_data[color_param].max())\n",
    "cmap = plt.get_cmap(cmap_name)\n",
    "\n",
    "# 符号映射设置\n",
    "unique_symbols = valid_data[symbol_param].unique()\n",
    "if len(unique_symbols) > len(symbols):\n",
    "    raise ValueError(\"分类参数类别数超过可用符号数量，请增加symbols列表长度\")\n",
    "\n",
    "symbol_dict = {val: sym for val, sym in zip(sorted(unique_symbols), symbols)}\n",
    "\n",
    "# 分图层绘制（确保颜色条正确）\n",
    "scatters = []\n",
    "for sym_val in sorted(unique_symbols):\n",
    "    subset = valid_data[valid_data[symbol_param] == sym_val]\n",
    "    sc = ax.scatter(\n",
    "        x=subset[\"gamma\"],\n",
    "        y=subset[\"normalized_stress\"],\n",
    "        c=subset[color_param],\n",
    "        cmap=cmap,\n",
    "        norm=norm,\n",
    "        marker=symbol_dict[sym_val],  # 关键修改：不同符号\n",
    "        s=60,                         # 固定符号大小\n",
    "        edgecolors=\"k\",               # 黑色边框增强对比\n",
    "        linewidth=0.8,\n",
    "        alpha=0.9,\n",
    "        label=f\"{symbol_param} = {sym_val}\",\n",
    "        zorder=2\n",
    "    )\n",
    "    scatters.append(sc)\n",
    "\n",
    "# 添加理论解\n",
    "aisc_prediction = 1.0\n",
    "ax.axhline(\n",
    "    aisc_prediction, \n",
    "    color=\"red\", \n",
    "    linestyle=\"--\", \n",
    "    linewidth=2, \n",
    "    zorder=1,\n",
    "    label=\"AISC Prediction\"\n",
    ")\n",
    "\n",
    "# 颜色条设置\n",
    "cbar = plt.colorbar(scatters[0], pad=0.02)  # 使用第一个散点对象创建颜色条\n",
    "cbar.set_label(f\"{color_param} (mm)\", fontsize=12, labelpad=10)\n",
    "cbar.ax.tick_params(labelsize=10)\n",
    "\n",
    "# 坐标轴设置\n",
    "ax.set_xlabel(\"Stiffness Ratio $\\gamma$\", fontsize=14, labelpad=10)\n",
    "ax.set_ylabel(r\"$\\tau_{cr,e}/\\tau_{cl,e}$\", fontsize=14, labelpad=10)\n",
    "ax.set_title(\"Normalized Elastic Buckling Stress Analysis\", fontsize=16, pad=20)\n",
    "\n",
    "# ax.set_xlim(0, 500)\n",
    "# ax.set_ylim(0, 1)\n",
    "\n",
    "ax.tick_params(axis=\"both\", which=\"major\", labelsize=12)\n",
    "ax.grid(True, linestyle=\"--\", alpha=0.4, zorder=0)\n",
    "\n",
    "# 信息标注\n",
    "text_box = dict(boxstyle=\"round\", facecolor=\"white\", alpha=0.8)\n",
    "ax.text(\n",
    "    0.05, 0.95,\n",
    "    f\"Parameters:\\n\"\n",
    "    f\"α = 0.5\\n\"\n",
    "    f\"Color by: {color_param}\\n\"\n",
    "    f\"Symbol by: {symbol_param}\",\n",
    "    transform=ax.transAxes,\n",
    "    fontsize=10,\n",
    "    verticalalignment=\"top\",\n",
    "    bbox=text_box\n",
    ")\n",
    "\n",
    "# 图例设置（分两列显示）\n",
    "ax.legend(\n",
    "    loc=\"upper right\",\n",
    "    fontsize=10,\n",
    "    title=\"Legend\",\n",
    "    title_fontsize=11,\n",
    "    framealpha=0.9,\n",
    "    ncol=2  # 分两列显示符号图例\n",
    ")\n",
    "\n",
    "# 保存输出\n",
    "plt.tight_layout()\n",
    "plt.savefig(\n",
    "    \"Academic_Symbol_Analysis.png\",\n",
    "    dpi=300,\n",
    "    bbox_inches=\"tight\",\n",
    "    facecolor=\"white\"\n",
    ")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8760391d",
   "metadata": {},
   "source": [
    "#### 自定公式"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "195c9fb6",
   "metadata": {},
   "source": [
    "##### 各参数范围"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "415f22bc",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "\n",
    "# 设置全局字体\n",
    "plt.rcParams['font.sans-serif'] = ['SimSun']  # 使用宋体\n",
    "plt.rcParams['font.serif'] = ['Times New Roman']  # 英文和数字使用 Times New Roman\n",
    "plt.rcParams['axes.unicode_minus'] = False  # 解决负号显示问题\n",
    "\n",
    "# 假设 dt_T 是你的 DataFrame\n",
    "# 筛选 n=1 的数据\n",
    "dt_T_n1 = dt_T[dt_T['n'] == 1].copy()\n",
    "\n",
    "# 检查数据是否为空\n",
    "if dt_T_n1.empty:\n",
    "    print(\"筛选后的数据为空，请检查输入数据！\")\n",
    "else:\n",
    "    # 1. 绘制 GH_quge_web 的数值分布\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    n, bins, patches = plt.hist(dt_T_n1['GH_quge_web'], bins=20, alpha=0.7, color='blue', edgecolor='black')\n",
    "    \n",
    "    # 在柱子上方添加数值标签\n",
    "    for i in range(len(patches)):\n",
    "        plt.text(patches[i].get_x() + patches[i].get_width()/2, patches[i].get_height(),\n",
    "                 int(n[i]), ha='center', va='bottom', fontsize=8)\n",
    "    \n",
    "    plt.xlabel('GH_quge_web', fontsize=12)\n",
    "    plt.ylabel('频数', fontsize=12)\n",
    "    plt.title('GH_quge_web 的数值分布', fontsize=14)\n",
    "    plt.xticks(fontsize=10)\n",
    "    plt.yticks(fontsize=10)\n",
    "    plt.savefig('GH_quge_web_distribution.png', dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "    # 2. 绘制 T2/T1 的数值分布\n",
    "    dt_T_n1['T2_T1_ratio'] = dt_T_n1['T2'] / dt_T_n1['T1']\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    n, bins, patches = plt.hist(dt_T_n1['T2_T1_ratio'], bins=20, alpha=0.7, color='green', edgecolor='black')\n",
    "    \n",
    "    # 在柱子上方添加数值标签\n",
    "    for i in range(len(patches)):\n",
    "        plt.text(patches[i].get_x() + patches[i].get_width()/2, patches[i].get_height(),\n",
    "                 int(n[i]), ha='center', va='bottom', fontsize=8)\n",
    "    \n",
    "    plt.xlabel('T2/T1', fontsize=12)\n",
    "    plt.ylabel('频数', fontsize=12)\n",
    "    plt.title('T2/T1 的数值分布', fontsize=14)\n",
    "    plt.xticks(fontsize=10)\n",
    "    plt.yticks(fontsize=10)\n",
    "    plt.savefig('T2_T1_ratio_distribution.png', dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "    # 3. 绘制 (H - T1*2)/L 的数值分布\n",
    "    dt_T_n1['H_L_adjusted'] = (dt_T_n1['H'] - dt_T_n1['T1'] * 2) / dt_T_n1['L']\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    n, bins, patches = plt.hist(dt_T_n1['H_L_adjusted'], bins=20, alpha=0.7, color='red', edgecolor='black')\n",
    "    \n",
    "    # 在柱子上方添加数值标签\n",
    "    for i in range(len(patches)):\n",
    "        plt.text(patches[i].get_x() + patches[i].get_width()/2, patches[i].get_height(),\n",
    "                 int(n[i]), ha='center', va='bottom', fontsize=8)\n",
    "    \n",
    "    plt.xlabel('(H - T1*2)/L', fontsize=12)\n",
    "    plt.ylabel('频数', fontsize=12)\n",
    "    plt.title('(H - T1*2)/L 的数值分布', fontsize=14)\n",
    "    plt.xticks(fontsize=10)\n",
    "    plt.yticks(fontsize=10)\n",
    "    plt.savefig('H_L_adjusted_distribution.png', dpi=300, bbox_inches='tight')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7bb6a420",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6dfb47f8",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib as mpl\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "\n",
    "# 设置绘图的基本参数\n",
    "def setup_plot_parameters():\n",
    "    \"\"\"\n",
    "    此函数用于设置绘图的基本参数，包括点的大小、图形的宽度和高度、字体大小、刻度大小以及字体属性等。\n",
    "    返回值:\n",
    "    point_size (int): 绘图中点的大小。\n",
    "    fig_width (float): 图形的宽度。\n",
    "    fig_height (float): 图形的高度。\n",
    "    font_size (int): 字体大小。\n",
    "    tick_size (int): 刻度大小。\n",
    "    font_properties (FontProperties): 字体属性对象。\n",
    "    \"\"\"\n",
    "    point_size = 20\n",
    "    fig_width, fig_height = 6, 6\n",
    "    font_size, tick_size = 14, 12\n",
    "    # 设置中文字体为宋体，字号为16\n",
    "    font_properties = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=16)\n",
    "    # 设置默认英文字体为Times New Roman\n",
    "    plt.rc('font', family='Times New Roman')\n",
    "    # 设置中文字体为宋体\n",
    "    plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "    # 解决负号显示问题\n",
    "    plt.rcParams['axes.unicode_minus'] = False\n",
    "    # 设置x轴刻度向内\n",
    "    plt.rcParams['xtick.direction'] = 'in'\n",
    "    # 设置y轴刻度向内\n",
    "    plt.rcParams['ytick.direction'] = 'in'\n",
    "    # 设置四个边框都显示刻度\n",
    "    plt.tick_params(bottom=True, top=True, left=True, right=True)\n",
    "    return point_size, fig_width, fig_height, font_size, tick_size, font_properties\n",
    "\n",
    "\n",
    "# 定义6.49拟合公式\n",
    "def calculate_k_649(k_so, k_sf, alpha, beta, tf_tw, d_o_D):\n",
    "    \"\"\"\n",
    "    根据6.49公式计算k值。\n",
    "    参数:\n",
    "    k_so (float): 基础屈曲系数。\n",
    "    k_sf (float): 法兰约束修正后的屈曲系数。\n",
    "    alpha (float): 法兰约束修正系数。\n",
    "    beta (float): 翼缘 - 腹板厚度比修正系数。\n",
    "    tf_tw (float): t_f/t_w。\n",
    "    d_o_D (float): d_o/D。\n",
    "    返回值:\n",
    "    k (float): 根据公式计算得到的k值。\n",
    "    \"\"\"\n",
    "    # 计算加劲肋间距修正函数\n",
    "    gamma_d_o_D = 1 - 0.15 * np.log(d_o_D)\n",
    "    return k_so + alpha * (k_sf - k_so) * (1 - beta * (2 - tf_tw)) * gamma_d_o_D\n",
    "\n",
    "\n",
    "# 绘制2D散点图和折线图\n",
    "def plot_2d_scatter_and_lines(df_selected, x_axis_param, y_axis_param, color_parameter):\n",
    "    \"\"\"\n",
    "    绘制2D散点图和折线图，散点颜色根据指定参数区分。\n",
    "    参数:\n",
    "    df_selected (DataFrame): 筛选后的数据DataFrame。\n",
    "    x_axis_param (str): x轴对应的参数名称。\n",
    "    y_axis_param (str): y轴对应的参数名称。\n",
    "    color_parameter (str): 用于区分散点颜色的参数。\n",
    "    \"\"\"\n",
    "    point_size, fig_width, fig_height, font_size, tick_size, font_properties = setup_plot_parameters()\n",
    "    color_map = 'viridis'\n",
    "\n",
    "    # 清空当前图形\n",
    "    plt.clf()\n",
    "    plt.figure(figsize=(fig_width, fig_height))\n",
    "    # 设置x轴标签，使用传入的参数名称\n",
    "    plt.xlabel(rf'${x_axis_param}$', fontproperties=font_properties)\n",
    "    # 设置y轴标签为k_649\n",
    "    plt.ylabel(r'$k_{649}$', fontproperties=font_properties)\n",
    "    # 根据数据动态设置x轴范围，在数据的最小值和最大值基础上各扩展10%\n",
    "    x_min, x_max = df_selected[x_axis_param].min(), df_selected[x_axis_param].max()\n",
    "    x_range = x_max - x_min\n",
    "    plt.xlim(x_min - 0.1 * x_range, x_max + 0.1 * x_range)\n",
    "    # 根据数据动态设置y轴范围，在数据的最小值和最大值基础上各扩展10%\n",
    "    y_min, y_max = df_selected[y_axis_param].min(), df_selected[y_axis_param].max()\n",
    "    y_range = y_max - y_min\n",
    "    plt.ylim(y_min - 0.1 * y_range, y_max + 0.1 * y_range)\n",
    "\n",
    "    # 确定折线图自变量的范围\n",
    "    x_param_min = df_selected[x_axis_param].min()\n",
    "    x_param_max = df_selected[x_axis_param].max()\n",
    "    norm = mpl.colors.Normalize(vmin=x_param_min, vmax=x_param_max)\n",
    "    cmap = cm.get_cmap(color_map)\n",
    "    scalar_mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n",
    "\n",
    "    # 绘制折线图\n",
    "    x_values = []\n",
    "    for x in np.linspace(x_param_min, x_param_max, 100):\n",
    "        y_values = []\n",
    "        k_values = []\n",
    "        for y in np.linspace(y_min, y_max, 100):\n",
    "            # 假设其他参数固定值，这里可根据实际情况修改\n",
    "            k_so_value = 4.0\n",
    "            k_sf_value = 8.98\n",
    "            alpha_value = 0.8\n",
    "            beta_value = 0.25\n",
    "            # 根据自变量名称确定传入calculate_k_649函数的参数\n",
    "            if x_axis_param == 'tf_tw':\n",
    "                tf_tw_value = x\n",
    "                d_o_D_value = y\n",
    "            else:\n",
    "                tf_tw_value = y\n",
    "                d_o_D_value = x\n",
    "            k = calculate_k_649(k_so_value, k_sf_value, alpha_value, beta_value, tf_tw_value, d_o_D_value)\n",
    "            y_values.append(y)\n",
    "            k_values.append(k)\n",
    "        plt.plot(y_values, k_values, c=scalar_mappable.to_rgba(x), ls='-', linewidth=2)\n",
    "        x_values.append(x)\n",
    "\n",
    "    # 绘制散点图\n",
    "    df_processed = df_selected.reset_index(drop=True)\n",
    "    color_values = df_processed[color_parameter].values\n",
    "    min_color = min(color_values)\n",
    "    max_color = max(color_values)\n",
    "\n",
    "    for i in range(len(df_processed)):\n",
    "        x_scatter = df_processed.at[i, x_axis_param]\n",
    "        y_scatter = df_processed.at[i, y_axis_param]\n",
    "        color_value = df_processed.at[i, color_parameter]\n",
    "        # 将颜色值映射到自变量的范围\n",
    "        color_mapping = np.interp(color_value, [min_color, max_color], [x_param_min, x_param_max])\n",
    "        plt.scatter(x_scatter, y_scatter, c=[scalar_mappable.to_rgba(color_mapping)], cmap=color_map,\n",
    "                    vmin=x_param_min, vmax=x_param_max, s=point_size)\n",
    "\n",
    "    # 添加colorbar\n",
    "    divider = make_axes_locatable(plt.gca())\n",
    "    cax = divider.append_axes(\"right\", \"5 %\", pad=\"0%\")\n",
    "    cb = plt.colorbar(scalar_mappable, cax=cax, orientation=\"vertical\")\n",
    "    cb.set_label(fr'${color_parameter}$', fontproperties=font_properties)\n",
    "\n",
    "    file_name_2d = f'combined_2d_{x_axis_param}_{y_axis_param}_{color_parameter}'\n",
    "    plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PhDall\\matplotilibpic\\\\\" + file_name_2d + \".svg\",\n",
    "                bbox_inches='tight', pad_inches=0)\n",
    "    plt.show()\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "# 绘制3D图\n",
    "def plot_3d_graph(df_selected, x_axis_param, y_axis_param, z_axis_param, color_parameter):\n",
    "    \"\"\"\n",
    "    绘制3D图，包括曲面和散点，散点颜色根据指定参数区分。\n",
    "    参数:\n",
    "    df_selected (DataFrame): 筛选后的数据DataFrame。\n",
    "    x_axis_param (str): x轴对应的参数名称。\n",
    "    y_axis_param (str): y轴对应的参数名称。\n",
    "    z_axis_param (str): z轴对应的参数名称。\n",
    "    color_parameter (str): 用于区分散点颜色的参数。\n",
    "    \"\"\"\n",
    "    # 开启交互模式\n",
    "    plt.ion()\n",
    "\n",
    "    point_size, fig_width, fig_height, font_size, tick_size, font_properties = setup_plot_parameters()\n",
    "    color_map = 'viridis'\n",
    "\n",
    "    # 清空当前图形\n",
    "    plt.clf()\n",
    "    fig = plt.figure(figsize=(fig_width, fig_height))\n",
    "    ax = fig.add_subplot(111, projection='3d')\n",
    "\n",
    "    # 根据数据动态设置自变量范围\n",
    "    x_min, x_max = df_selected[x_axis_param].min(), df_selected[x_axis_param].max()\n",
    "    x_range = x_max - x_min\n",
    "    X = np.linspace(x_min - 0.1 * x_range, x_max + 0.1 * x_range, 100)\n",
    "    y_min, y_max = df_selected[y_axis_param].min(), df_selected[y_axis_param].max()\n",
    "    y_range = y_max - y_min\n",
    "    Y = np.linspace(y_min - 0.1 * y_range, y_max + 0.1 * y_range, 100)\n",
    "    X, Y = np.meshgrid(X, Y)\n",
    "    Z = np.zeros_like(X)\n",
    "    for i in range(len(X)):\n",
    "        for j in range(len(Y)):\n",
    "            # 假设其他参数固定值，这里可根据实际情况修改\n",
    "            k_so_value = 4.0\n",
    "            k_sf_value = 8.98\n",
    "            alpha_value = 0.8\n",
    "            beta_value = 0.25\n",
    "            # 根据自变量名称确定传入calculate_k_649函数的参数\n",
    "            if x_axis_param == 'tf_tw':\n",
    "                tf_tw_value = X[i, j]\n",
    "                d_o_D_value = Y[i, j]\n",
    "            else:\n",
    "                tf_tw_value = Y[i, j]\n",
    "                d_o_D_value = X[i, j]\n",
    "            Z[i, j] = calculate_k_649(k_so_value, k_sf_value, alpha_value, beta_value, tf_tw_value, d_o_D_value)\n",
    "\n",
    "    # 绘制3D曲面\n",
    "    surf = ax.plot_surface(X, Y, Z, cmap=color_map)\n",
    "\n",
    "    # 绘制散点图\n",
    "    df_processed = df_selected.reset_index(drop=True)\n",
    "    color_values = df_processed[color_parameter].values\n",
    "    min_color = min(color_values)\n",
    "    max_color = max(color_values)\n",
    "\n",
    "    norm = mpl.colors.Normalize(vmin=min_color, vmax=max_color)\n",
    "    cmap = cm.get_cmap(color_map)\n",
    "    scalar_mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n",
    "\n",
    "    for i in range(len(df_processed)):\n",
    "        x_scatter = df_processed.at[i, x_axis_param]\n",
    "        y_scatter = df_processed.at[i, y_axis_param]\n",
    "        z_scatter = df_processed.at[i, z_axis_param]\n",
    "        color_value = df_processed.at[i, color_parameter]\n",
    "        ax.scatter(x_scatter, y_scatter, z_scatter, c=[scalar_mappable.to_rgba(color_value)], cmap=color_map)\n",
    "\n",
    "    fig.colorbar(surf, shrink=0.5, aspect=5, label=fr'${color_parameter}$')\n",
    "\n",
    "    ax.set_xlabel(rf'${x_axis_param}$', fontproperties=font_properties)\n",
    "    ax.set_ylabel(rf'${y_axis_param}$', fontproperties=font_properties)\n",
    "    ax.set_zlabel(r'$k_{649}$', fontproperties=font_properties)\n",
    "\n",
    "    file_name_3d = f'combined_3d_{x_axis_param}_{y_axis_param}_{z_axis_param}_{color_parameter}'\n",
    "    plt.savefig(r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\PhDall\\matplotilibpic\\\\\" + file_name_3d + \".svg\",\n",
    "                bbox_inches='tight', pad_inches=0)\n",
    "\n",
    "    plt.show()\n",
    "    plt.ioff()\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # 示例测试数据，这里可根据实际情况替换为真实数据\n",
    "    data = {\n",
    "        'D_tw': [100, 200, 300],\n",
    "        'tf_tw': [0.5, 1.0, 1.5],\n",
    "        'd_o_D': [0.5, 1.0, 1.5],\n",
    "        'k_649': [None, None, None]  # 用于存储计算结果\n",
    "    }\n",
    "    df_selected = pd.DataFrame(data)\n",
    "\n",
    "    # 计算k_649\n",
    "    for i in range(len(df_selected)):\n",
    "        D_tw = df_selected.at[i, 'D_tw']\n",
    "        tf_tw = df_selected.at[i, 'tf_tw']\n",
    "        d_o_D = df_selected.at[i, 'd_o_D']\n",
    "        # 假设其他参数固定值，这里可根据实际情况修改\n",
    "        k_so_value = 4.0\n",
    "        k_sf_value = 8.98\n",
    "        alpha_value = 0.8\n",
    "        beta_value = 0.25\n",
    "        df_selected.at[i, 'k_649'] = calculate_k_649(k_so_value, k_sf_value, alpha_value, beta_value, tf_tw, d_o_D)\n",
    "\n",
    "    # 灵活设置横纵坐标自变量\n",
    "    x_axis_parameter = 'tf_tw'\n",
    "    y_axis_parameter = 'd_o_D'\n",
    "    z_axis_parameter = 'k_649'\n",
    "    color_parameters = ['D_tw']\n",
    "\n",
    "    # 绘制2D图\n",
    "    for color_parameter in color_parameters:\n",
    "        plot_2d_scatter_and_lines(df_selected, x_axis_parameter, y_axis_parameter, color_parameter)\n",
    "\n",
    "    # 绘制3D图\n",
    "    for color_parameter in color_parameters:\n",
    "        plot_3d_graph(df_selected, x_axis_parameter, y_axis_parameter, z_axis_parameter, color_parameter)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "20b751a9",
   "metadata": {},
   "source": [
    "### 按照各国规范"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d0b5172",
   "metadata": {},
   "source": [
    "#### 中国钢板剪力墙规范"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a52de068",
   "metadata": {},
   "source": [
    "#### 中国规范受剪临界应力"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6667f02b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.293940Z",
     "start_time": "2023-07-04T14:49:09.293940Z"
    }
   },
   "outputs": [],
   "source": [
    "#—————————中国规范受剪临临界应力的计算————————\n",
    "# 基本DF构造\n",
    "geo_var=['H','B','T1','T2','n','L','tangential_cr','lamuda_ns','fai_s']\n",
    "dfresult_cn_tangential= pd.DataFrame(columns=geo_var)\n",
    "\n",
    "# 自变量构造\n",
    "for ii in range (100,1000,300):\n",
    "    H=ii\n",
    "    for ij in range (1,500,99):\n",
    "        B=ij\n",
    "        for ik in range (5,30,10):\n",
    "            T1=ik\n",
    "            for il in range (1,30,9):\n",
    "                T2=il\n",
    "                for im in range (1,5,1):\n",
    "                    n=im\n",
    "                    for iin in range (1000, 3000, 500):\n",
    "                        L=iin\n",
    "                        print(H,B,T1,T2,n,L)\n",
    "# ———————————————————基本参数计算——————————————————————\n",
    "                        E=205000#加劲肋的弹性模量\n",
    "                        I_sy=B**3*T2/3#竖向加劲肋的惯性矩\n",
    "                        D=E*T2**3/(12*(1-0.3**2))#单位宽度的弯曲刚度\n",
    "                        a1=H# 剪力墙板区格宽度\n",
    "                        Hn=L#钢板剪力墙的净高度\n",
    "                        I_tsy=(T2/2)*((B/2)**3)*(16/3-3.36*(T2/2)/(B/2)*(1-(T2/2)**4/(12*(B/2)**4)))\n",
    "                        fyss=355\n",
    "                        #竖向加劲胁自由扭转常数\n",
    "                        a1=B/2#\n",
    "                        b=T2/2#\n",
    "                        Hn=L\n",
    "                        tw=T2\n",
    "                        beta=qugeGKB = L/H\n",
    "# ———————————竖向加劲肋真实刚度参数计算———————————————————————\n",
    "                        eta_y=E*I_sy/(D*a1)\n",
    "# ———————————竖向加劲肋门槛刚度参数计算———————————————————————\n",
    "                        eta_k=0.42+0.58/((1+5.42*(I_tsy/I_sy)**2.6)**0.77)\n",
    "                        eta_tangential_th=6*eta_k*(7*beta**2-5)                        \n",
    "\n",
    "                        if qugeGKB<0.8:\n",
    "                            qugeGKB =0.8\n",
    "                        if qugeGKB>5:\n",
    "                            qugeGKB =5\n",
    "\n",
    "                        if eta_tangential_th <10:\n",
    "                            eta_tangential_th=10\n",
    "# ——————————竖向加劲肋的刚度参数与门槛刚度参数对比—————————\n",
    "                        if Hn/a1 >= 1:\n",
    "                            k_tangentialp=1.0*(5.34+4/((Hn/a1)**2))# 这部分放到前面是因为后面eta_y < eta_tangential_th也需要这个参数\n",
    "                        if Hn/a1 <1 :\n",
    "                            k_tangentialp=1.0*(4+5.34/((Hn/a1)**2))\n",
    "\n",
    "                        if eta_y >= eta_tangential_th:#大于门槛刚度\n",
    "\n",
    "                            tangential_cr=tangential_crp=k_tangentialp* 3.141593**2*D/((a1)**2*tw) \n",
    "                        if eta_y < eta_tangential_th:#小于门槛刚度\n",
    "                            Hn=L\n",
    "                            Ln=n*H    \n",
    "                            if Hn/Ln >= 1:\n",
    "                                k_ss0=6.5+5/((Hn/Ln)**2)\n",
    "                            if Hn/Ln <1 :\n",
    "                                k_ss0=5+6.5/((Hn/Ln)**2)\n",
    "                            kss=k_ss0*(a1/Ln)**2+(k_tangentialp-k_ss0*(a1/Ln)**2)*(eta_y/eta_tangential_th)**0.6\n",
    "                            tangential_cr=kss*(3.141593**2)*D/((a1**2)*tw)\n",
    "                            print(D/((a1**2)*tw))                          \n",
    "# ———————————区格自身刚度参数计算（按照四边固支的平钢板）——————————————\n",
    "                        eta_tangential_quegeth=(8.96+5.6*(L/H))*((3.141593*3.141593*E)/(12*(1-0.3**2)))*(T1/H)**2\n",
    "#                         plt.plot(H,eta_tangential_quegeth,'r')\n",
    "# ———————————对应的长细比计算——————————————\n",
    "                        lamuda_ns=(fyss*0.58/tangential_cr)**0.5\n",
    "# ———————————对应的稳定系数计算——————————————\n",
    "                        fai_s =1/(0.738+lamuda_ns** 6) ** (1 / 3) \n",
    "# ———————————Dataframe构造————————————\n",
    "                        se_cn_tangential=pd.Series([H,B,T1,T2,n,L,tangential_cr,lamuda_ns,fai_s],index=geo_var)\n",
    "                        dfresult_cn_tangential=pd.concat([dfresult_cn_tangential,se_cn_tangential.to_frame().transpose()],axis=0,ignore_index=True)\n",
    "#                         print(H)\n",
    "#                         print(se_cn_tangential)\n",
    "#                         plt.scatter(H,tangential_cr) \n",
    "#                         plt.plot(L,eta_tangential_quegeth,'r')\n",
    "#                         plt.show()\n",
    "\n",
    "print(dfresult_cn_tangential)\n",
    "# sns.pairplot(data=dfresult_cn_tangential, kind='scatter', diag_kind='kde')\n",
    "# ax1.scatter( dfresult_cn_tangential['H'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# ax2.scatter( dfresult_cn_tangential['B'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# ax3.scatter( dfresult_cn_tangential['T1'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax4.scatter( dfresult_cn_tangential['T2'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax5.scatter( dfresult_cn_tangential['n'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax6.scatter( dfresult_cn_tangential['L'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# plt.show()\n",
    "# plt.close\n",
    "# fig=plt.figure()\n",
    "# ax1=fig.add_subplot(2,3,1)\n",
    "# ax2=fig.add_subplot(2,3,2)\n",
    "# ax3=fig.add_subplot(2,3,3)\n",
    "# ax4=fig.add_subplot(2,3,4)\n",
    "# ax5=fig.add_subplot(2,3,5)\n",
    "# ax6=fig.add_subplot(2,3,6)\n",
    "# ax1.scatter( dfresult_cn_tangential['H'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "# ax2.scatter( dfresult_cn_tangential['B'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "# ax3.scatter( dfresult_cn_tangential['T1'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "# ax4.scatter( dfresult_cn_tangential['T2'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "# ax5.scatter( dfresult_cn_tangential['n'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "# ax6.scatter( dfresult_cn_tangential['L'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "# plt.show()\n",
    "# plt.close\n",
    "plt.scatter(dfresult_cn_tangential['lamuda_ns'].values,dfresult_cn_tangential['fai_s'].values)\n",
    "lamuda_ns_plot = np.arange(0, 4, 0.001) \n",
    "fai_s_plot = fai_s =1/(0.738+lamuda_ns_plot** 6) ** (1 / 3) \n",
    "plt.plot(lamuda_ns_plot,fai_s_plot)\n",
    "# mat = dfresult_cn_tangential.corr(method='pearson')\n",
    "# sns.heatmap(data=mat, cmap='RdYlGn', annot=True) \n",
    "# print(dfresult_cn_tangential)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c29f9a69",
   "metadata": {},
   "source": [
    "#### 中国规范对于H型钢腹板受剪的拟合"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4dc248f2",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.294937Z",
     "start_time": "2023-07-04T14:49:09.294937Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import operator\n",
    "import symfit as sf\n",
    "from symfit import variables, parameters, Fit, exp, Model\n",
    "from symfit.core.objectives import LogLikelihood\n",
    "#-----------------------目标函数拟合方法\n",
    "\n",
    "# ————————————————————————\n",
    "# 数值拟合方法（中国规范）分段连续函数的拟合\n",
    "def tangential_cr_code_cnfit(tw,ho,tangential_cr_code_cn):\n",
    "# -----------基本参数————————\n",
    "    E=205000#加劲肋的弹性模量\n",
    "    I_sy=B**3*T2/3#竖向加劲肋的惯性矩\n",
    "    D=E*T2**3/(12*(1-0.3**2))#单位宽度的弯曲刚度\n",
    "    a1=H# 剪力墙板区格宽度\n",
    "    Hn=L#钢板剪力墙的净高度\n",
    "    I_tsy=(T2/2)*((B/2)**3)*(16/3-3.36*(T2/2)/(B/2)*(1-(T2/2)**4/(12*(B/2)**4)))\n",
    "    fyss=355\n",
    "    #竖向加劲胁自由扭转常数\n",
    "    a1=B/2#\n",
    "    b=T2/2#\n",
    "    Hn=L\n",
    "    tw=T2\n",
    "    k_web=8.96+5.6*(L/H)\n",
    "    chi=\n",
    "    beta=qugeGKB = L/H\n",
    "# ————————长边和短边的放置关系判断————————\n",
    "    alpha_tangential_cr=\n",
    "    if \n",
    "    alpha_tangential_cr=\n",
    "    tw, ho,tangential_cr_code_cn = variables('x, y')\n",
    "#     x0 = sf.Parameter('x0', 0.216, min=0.2159, max=0.2161)\n",
    "#     x1 = sf.Parameter('x1', 1.05, min=1.04, max=1.06)\n",
    "    x0 =0.216\n",
    "    x1 =1.05\n",
    "    alphaa = sf.Parameter('alphaa',  min=0, max=1)\n",
    "    alphabs = sf.Parameter('alphabs', min=0, max=1)#尾号s和l代表该参数小于和大于分界点x1（1.05的对应参数）\n",
    "    alphabl = sf.Parameter('alphabl', min=0, max=1)\n",
    "    alphacs = sf.Parameter('alphacs', min=0, max=1)\n",
    "    alphacl = sf.Parameter('alphacl', min=0, max=1)\n",
    "    tangential_cr_code_cn=chi*k_web*((3.141593*3.141593*E)/(12*(1-0.3**2)))*(T1/H)**2\n",
    "    model = Model({y: Piecewise((y1, x <= x0),\n",
    "                                (y2, x <= x1),\n",
    "                                (y3, x >  x1))})   \n",
    "    cons = [Eq(y1.diff(x).subs({x: x0}), y2.diff(x).subs({x: x0})),#x0处斜率连续\n",
    "            Eq(y1.subs({x: x0}), y2.subs({x: x0})),#x0处数值连续\n",
    "            Eq(y2.diff(x).subs({x: x1}), y3.diff(x).subs({x: x1})),#x1处斜率连续\n",
    "            Eq(y2.subs({x: x1}), y3.subs({x: x1})),#x1处数值连续\n",
    "            sympy.GreaterThan(alphabl,alphabs),#alphabs<alphabl\n",
    "            sympy.GreaterThan(alphacl,alphacs)]#alphacs<alphacl\n",
    "# 数据\n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values                  \n",
    "# 拟合\n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=cons)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "#      作图\n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))   \n",
    "    plt.plot(xdata, model(x=xdata, **fit_result.params).y,alpha = .5)\n",
    "    plt.scatter(xdata,ydata)\n",
    "\n",
    "\n",
    "\n",
    "#—————————中国规范受剪临临界应力的计算————————\n",
    "# 基本DF构造\n",
    "geo_var=['H','B','T1','T2','n','L','tangential_cr','lamuda_ns','fai_s']\n",
    "dfresult_cn_tangential= pd.DataFrame(columns=geo_var)\n",
    "\n",
    "# 自变量构造\n",
    "for ii in range (100,1000,300):\n",
    "    H=ii\n",
    "    for ij in range (1,500,99):\n",
    "        B=ij\n",
    "        for ik in range (5,30,10):\n",
    "            T1=ik\n",
    "            for il in range (1,30,9):\n",
    "                T2=il\n",
    "                for im in range (1,5,1):\n",
    "                    n=im\n",
    "                    for iin in range (1000, 3000, 500):\n",
    "                        L=iin\n",
    "                        print(H,B,T1,T2,n,L)\n",
    "# ———————————————————基本参数计算——————————————————————\n",
    "                        E=205000#加劲肋的弹性模量\n",
    "                        I_sy=B**3*T2/3#竖向加劲肋的惯性矩\n",
    "                        D=E*T2**3/(12*(1-0.3**2))#单位宽度的弯曲刚度\n",
    "                        a1=H# 剪力墙板区格宽度\n",
    "                        Hn=L#钢板剪力墙的净高度\n",
    "                        I_tsy=(T2/2)*((B/2)**3)*(16/3-3.36*(T2/2)/(B/2)*(1-(T2/2)**4/(12*(B/2)**4)))\n",
    "                        fyss=355\n",
    "                        #竖向加劲胁自由扭转常数\n",
    "                        a1=B/2#\n",
    "                        b=T2/2#\n",
    "                        Hn=L\n",
    "                        tw=T2\n",
    "                        k_web=8.96+5.6*(L/H)\n",
    "                        chi=\n",
    "                        beta=qugeGKB = L/H\n",
    "                        if \n",
    "                        alpha_tangential_cr=\n",
    "# ———————————区格自身刚度参数计算（按照四边固支的平钢板）——————————————\n",
    "                        tangential_cr_code_cn=chi*k_web*((3.141593*3.141593*E)/(12*(1-0.3**2)))*(T1/H)**2\n",
    "#                         plt.plot(H,eta_tangential_quegeth,'r')\n",
    "\n",
    "print(dfresult_cn_tangential)\n",
    "# sns.pairplot(data=dfresult_cn_tangential, kind='scatter', diag_kind='kde')\n",
    "# ax1.scatter( dfresult_cn_tangential['H'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# ax2.scatter( dfresult_cn_tangential['B'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# ax3.scatter( dfresult_cn_tangential['T1'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax4.scatter( dfresult_cn_tangential['T2'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax5.scatter( dfresult_cn_tangential['n'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax6.scatter( dfresult_cn_tangential['L'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# plt.show()\n",
    "# plt.close\n",
    "# fig=plt.figure()\n",
    "# ax1=fig.add_subplot(2,3,1)\n",
    "# ax2=fig.add_subplot(2,3,2)\n",
    "# ax3=fig.add_subplot(2,3,3)\n",
    "# ax4=fig.add_subplot(2,3,4)\n",
    "# ax5=fig.add_subplot(2,3,5)\n",
    "# ax6=fig.add_subplot(2,3,6)\n",
    "# ax1.scatter( dfresult_cn_tangential['H'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "# ax2.scatter( dfresult_cn_tangential['B'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "# ax3.scatter( dfresult_cn_tangential['T1'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "# ax4.scatter( dfresult_cn_tangential['T2'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "# ax5.scatter( dfresult_cn_tangential['n'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "# ax6.scatter( dfresult_cn_tangential['L'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "# plt.show()\n",
    "# plt.close\n",
    "plt.scatter(dfresult_cn_tangential['lamuda_ns'].values,dfresult_cn_tangential['fai_s'].values)\n",
    "lamuda_ns_plot = np.arange(0, 4, 0.001) \n",
    "fai_s_plot = fai_s =1/(0.738+lamuda_ns_plot** 6) ** (1 / 3) \n",
    "plt.plot(lamuda_ns_plot,fai_s_plot)\n",
    "# mat = dfresult_cn_tangential.corr(method='pearson')\n",
    "# sns.heatmap(data=mat, cmap='RdYlGn', annot=True) \n",
    "# print(dfresult_cn_tangential)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21ee5329",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.295935Z",
     "start_time": "2023-07-04T14:49:09.295935Z"
    }
   },
   "outputs": [],
   "source": [
    "fig=plt.figure()\n",
    "ax1=fig.add_subplot(2,3,1)\n",
    "ax2=fig.add_subplot(2,3,2)\n",
    "ax3=fig.add_subplot(2,3,3)\n",
    "ax4=fig.add_subplot(2,3,4)\n",
    "ax6=fig.add_subplot(2,3,6)\n",
    "# sns.pairplot(data=dfresult_cn_tangential, kind='scatter', diag_kind='kde')\n",
    "# ax1.scatter( dfresult_cn_tangential['H'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# ax2.scatter( dfresult_cn_tangential['B'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# ax3.scatter( dfresult_cn_tangential['T1'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax4.scatter( dfresult_cn_tangential['T2'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax5.scatter( dfresult_cn_tangential['n'].values,dfresult_cn_tangential['tangential_cr'].values)  \n",
    "# ax6.scatter( dfresult_cn_tangential['L'].values,dfresult_cn_tangential['tangential_cr'].values)   \n",
    "# plt.show()\n",
    "# plt.close\n",
    "# fig=plt.figure()\n",
    "# ax1=fig.add_subplot(2,3,1)\n",
    "# ax2=fig.add_subplot(2,3,2)\n",
    "# ax3=fig.add_subplot(2,3,3)\n",
    "# ax4=fig.add_subplot(2,3,4)\n",
    "# ax5=fig.add_subplot(2,3,5)\n",
    "# ax6=fig.add_subplot(2,3,6)\n",
    "ax1.scatter( dfresult_cn_tangential['H'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "ax2.scatter( dfresult_cn_tangential['B'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "ax3.scatter( dfresult_cn_tangential['T1'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "ax4.scatter( dfresult_cn_tangential['T2'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "ax5.scatter( dfresult_cn_tangential['n'].values,dfresult_cn_tangential['lamuda_ns'].values)  \n",
    "ax6.scatter( dfresult_cn_tangential['L'].values,dfresult_cn_tangential['lamuda_ns'].values)   \n",
    "plt.show()\n",
    "plt.close\n",
    "plt.scatter(dfresult_cn_tangential['lamuda_ns'].values,dfresult_cn_tangential['fai_s'].values)\n",
    "lamuda_ns_plot = np.arange(0, 4, 0.001) \n",
    "fai_s_plot = fai_s =1/(0.738+lamuda_ns_plot** 6) ** (1 / 3) \n",
    "plt.plot(lamuda_ns_plot,fai_s_plot)\n",
    "mat = dfresult_cn_tangential.corr(method='pearson')\n",
    "sns.heatmap(data=mat, cmap='RdYlGn', annot=True) \n",
    "# print(dfresult_cn_tangential)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ead3411",
   "metadata": {},
   "source": [
    "#### 中国规范受剪柱子曲线"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fc3bdbef",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.296932Z",
     "start_time": "2023-07-04T14:49:09.296932Z"
    }
   },
   "outputs": [],
   "source": [
    "# —————————规范图-中国规范受剪—————————————\n",
    "# —————————中国规范受剪临界应力和稳定系数关系——————\n",
    "# # def plotcodesw_cn (a_cn,b_cns,b_cnl,c_cns,c_cnl,codecolor):\n",
    "# lamuda_ns = np.linspace(0, 3, 100)\n",
    "# fai_s =1/(0.738+lamuda_ns** 6) ** (1 / 3) \n",
    "# lamuda_nxgm = np.linspace(0, 3, 100)\n",
    "# fai_xgm = 1/(1+lamuda_nxgm** 2.4) ** (5 / 6)\n",
    "# lamuda_bs = np.linspace(0, 3, 100)\n",
    "# fai_nb =  1/(0.738+lamuda_bs** 6) ** (1 / 3)\n",
    "# plt.plot(lamuda_ns,fai_s,'r',label='type',alpha = .5)    \n",
    "# plt.plot(lamuda_nxgm,fai_xgm,'b',label='type',alpha = .5) \n",
    "# plt.plot(lamuda_bs,fai_nb,'y',label='type',alpha = .5)                                                                                                     \n",
    "# plt.ylim((0, 1.2))\n",
    "# plt.xlim((0, 3))   \n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "93c5d808",
   "metadata": {},
   "source": [
    "### 美国规范"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fe3fdf41",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.297930Z",
     "start_time": "2023-07-04T14:49:09.297930Z"
    }
   },
   "outputs": [],
   "source": [
    "# —————————规范图-中国规范受剪—————————————\n",
    "# —————————中国规范受剪临界应力和稳定系数关系——————\n",
    "# # def plotcodesw_cn (a_cn,b_cns,b_cnl,c_cns,c_cnl,codecolor):\n",
    "# lamuda_ns = np.linspace(0, 3, 100)\n",
    "# fai_s =1/(0.738+lamuda_ns** 6) ** (1 / 3) \n",
    "# lamuda_nxgm = np.linspace(0, 3, 100)\n",
    "# fai_xgm = 1/(1+lamuda_nxgm** 2.4) ** (5 / 6)\n",
    "# lamuda_bs = np.linspace(0, 3, 100)\n",
    "# fai_nb =  1/(0.738+lamuda_bs** 6) ** (1 / 3)\n",
    "# plt.plot(lamuda_ns,fai_s,'r',label='type',alpha = .5)    \n",
    "# plt.plot(lamuda_nxgm,fai_xgm,'b',label='type',alpha = .5) \n",
    "# plt.plot(lamuda_bs,fai_nb,'y',label='type',alpha = .5)                                                                                                     \n",
    "# plt.ylim((0, 1.2))\n",
    "# plt.xlim((0, 3))   \n",
    "# plt.show()\n",
    "#—————————中国规范受剪临临界应力的计算————————\n",
    "# # 参数计算\n",
    "# geo_var=['H','B','T1','T2','n','L','tangential_cr','lamuda_ns']\n",
    "# dfresult_cn_tangential= pd.DataFrame(columns=geo_var)\n",
    "# fig=plt.figure()\n",
    "# ax1=fig.add_subplot(2,3,1)\n",
    "# ax2=fig.add_subplot(2,3,2)\n",
    "# ax3=fig.add_subplot(2,3,3)\n",
    "# ax4=fig.add_subplot(2,3,4)\n",
    "# ax5=fig.add_subplot(2,3,5)\n",
    "# ax6=fig.add_subplot(2,3,6)\n",
    "\n",
    "for ii in range (500,1000,200):\n",
    "    H=ii\n",
    "    for ij in range (50,400,100):\n",
    "        B=ij\n",
    "        for ik in range (5,30,10):\n",
    "            T1=ik\n",
    "            for il in range (5,30,10):\n",
    "                T2=il\n",
    "                for im in range (1,5,1):\n",
    "                    n=im\n",
    "                    for iin in range (1000, 3000, 500):\n",
    "                        L=iin\n",
    "                        print(H,B,T1,T2,n,L)\n",
    "# ——————————竖向加劲肋的刚度参数 与门槛刚度参数之间的判断————————\n",
    "                        E=205000#加劲肋的弹性模量\n",
    "                        I_sy=B**3*T2/3#竖向加劲肋的惯性矩\n",
    "                        D=E*T2**3/(12*(1-0.3**2))#单位宽度的弯曲刚度\n",
    "                        a1=H# 剪力墙板区格宽度\n",
    "                        Hn=L#钢板剪力墙的净高度\n",
    "                        I_tsy=(T2/2)*((B/2)**3)*(16/3-3.36*(T2/2)/(B/2)*(1-(T2/2)**4/(12*(B/2)**4)))\n",
    "                        fyss=355\n",
    "                        #竖向加劲胁自由扭转常数\n",
    "                        a1=B/2#\n",
    "                        b=T2/2#\n",
    "                        Hn=L\n",
    "                        tw=T2\n",
    "                        beta=qugeGKB = L/H\n",
    "                        \n",
    "                        eta_tangential_quegeth=(8.96+5.6*(L/H))*((3.141593*3.141593*E)/(12*(1-0.3**2)))*(T1/H)**2\n",
    "                        plt.plot(H,eta_tangential_quegeth,'r')\n",
    "                        plt.show()\n",
    "                        if qugeGKB<0.8:\n",
    "                            qugeGKB =0.8\n",
    "                        if qugeGKB>5:\n",
    "                            qugeGKB =5\n",
    "                        eta_k=0.42+0.58/((1+5.42*(I_tsy/I_sy)**2.6)**0.77)\n",
    "                        eta_y=E*I_sy/(D*a1)\n",
    "                        eta_tangential_th=6*eta_k*(7*beta**2-5)\n",
    "\n",
    "                        if eta_tangential_th <10:\n",
    "                            eta_tangential_th=10\n",
    "\n",
    "                        \n",
    "# ——————————————弹性剪切屈曲临界应力计算——————————\n",
    "                        if eta_y >= eta_tangential_th:\n",
    "                            if Hn/a1 >= 1:\n",
    "                                k_tangentialp=1.0*(5.34+4/((Hn/a1)**2))\n",
    "                            if Hn/a1 <1 :\n",
    "                                k_tangentialp=1.0*(4+5.34/((Hn/a1)**2))\n",
    "                            tangential_cr=tangential_crp=k_tangentialp* 3.141593**2*D/((a1)**2*tw) \n",
    "                        if eta_y < eta_tangential_th:\n",
    "                            Hn=L\n",
    "                            Ln=n*H    \n",
    "                            if Hn/Ln >= 1:\n",
    "                                k_ss0=6.5+5/((Hn/Ln)**2)\n",
    "                            if Hn/Ln <1 :\n",
    "                                k_ss0=5+6.5/((Hn/Ln)**2)\n",
    "                            kss=k_ss0*(a1/Ln)**2+(k_tangentialp-k_ss0*(a1/Ln)**2)*(eta_y/eta_tangential_th)**0.6\n",
    "                            tangential_cr=kss*(3.141593**2)*D/((a1**2)*tw)\n",
    "                            print(D/((a1**2)*tw))\n",
    "                            lamuda_ns=(fyss*0.58/tangential_cr)**0.5\n",
    "                            print(lamuda_ns)\n",
    "                            fai_s =1/(0.738+lamuda_ns** 6) ** (1 / 3) \n",
    "# res\n",
    "                            se_cn_tangential=pd.Series([H,B,T1,T2,n,L,tangential_cr,lamuda_ns],index=geo_var)\n",
    "                            dfresult_cn_tangential=pd.concat([dfresult_cn_tangential,se_cn_tangential.to_frame().transpose()],axis=0,ignore_index=True)\n",
    "#                             print(H)\n",
    "#                             print(se_cn_tangential)\n",
    "#                             plt.scatter(H,tangential_cr) \n",
    "#                         plt.plot(L,eta_tangential_quegeth,'r')\n",
    "#                         plt.show()\n",
    "#                             ax2.scatter(L,lamuda_ns)    \n",
    "#                             ax3.scatter(n,lamuda_ns)  \n",
    "#                             ax4.scatter(T1,lamuda_ns)  \n",
    "#                             ax5.scatter(T2,lamuda_ns) \n",
    "#                             ax6.scatter(B,lamuda_ns)      \n",
    "\n",
    "# print(dfresult_cn_tangential)\n",
    "#                         plt.show()\n",
    "#                         plt.close\n",
    "# #—————————————— 轴压临界应力————————\n",
    "# for ii in range (500,1000,200):\n",
    "#     H=ii\n",
    "#     for ij in range (50,400,100):\n",
    "#         B=ij\n",
    "#         for ik in range (5,30,10):\n",
    "#             T1=ik\n",
    "#             for il in range (5,30,10):\n",
    "#                 T2=il\n",
    "#                 for im in range (2,3,1):\n",
    "#                     n=im\n",
    "#                     for iin in range (2000, 3000, 1000):\n",
    "#                         L=iin\n",
    "#                         E=205000#加劲肋的弹性模量\n",
    "#                         I_sy=B**3*T2/3#竖向加劲肋的惯性矩\n",
    "#                         D=E*T2**3/(12*(1-0.3**2))#单位宽度的弯曲刚度\n",
    "#                         a1=H# 剪力墙板区格宽度\n",
    "#                         Hn=L#钢板剪力墙的净高度\n",
    "#                         Ln=n*H#钢板剪力墙的净高度\n",
    "#                         I_tsy=(T2/2)*((B/2)**3)*(16/3-3.36*(T2/2)/(B/2)*(1-(T2/2)**4/(12*(B/2)**4)))\n",
    "#                         fyss=355\n",
    "#                         #竖向加劲胁自由扭转常数\n",
    "#                         a1=B/2#\n",
    "#                         b=T2/2#\n",
    "#                         Hn=L\n",
    "#                         tw=T2\n",
    "#                         n_v=n-1\n",
    "#                         beta=Hn/a1\n",
    "\n",
    "#                         k_pan=4*1.0\n",
    "#                         k_sigma0=1.0*(Ln/Hn+Hn/Ln)**2\n",
    "#                         eta_sigma_th=1.5*(1+1/n_v)*(k_pan*(n_v+1)**2-k_sigma0)*(Hn/Ln)**2\n",
    "\n",
    "#                         # 弹性受压屈曲临界应力计算\n",
    "#                         if eta_y >= eta_sigma_th:\n",
    "#                             sigma_cr=sigma_crp=k_pan*3.141593*3.141593*D/(a1**2*tw)\n",
    "#                         if eta_y < eta_sigma_th:\n",
    "#                             sigma_cr=sigma_cr0+(sigma_crp-sigma_cr0)*eta_y/eta_sigma_th\n",
    "#                             sigma_cr0=3.141593*3.141593*k_sigma0*D/(Ln**2*tw)\n",
    "#                         plt.scatter(H,sigma_cr) \n",
    "                        \n",
    "# #                         plt.scatter(L,sigma_cr)    \n",
    "# #                         plt.scatter(n,sigma_cr)  \n",
    "# #                         plt.scatter(T1,sigma_cr)  \n",
    "# #                         plt.scatter(T2,sigma_cr) \n",
    "# #                         plt.scatter(B,sigma_cr) \n",
    "#                 plt.show()\n",
    "# #                 plt.close\n",
    "# cn_list=[[0.41,0.986,0.986,0.152,0.152,'g'],\n",
    "#          [0.65,0.965,0.965,0.3,0.3,'b'],\n",
    "#          [0.73,0.906,1.216,0.595,0.302,'y'],\n",
    "#          [1.35,0.868,1.372,0.915,0.432,'g']]\n",
    "# for i in range(4):\n",
    "#     print(i)\n",
    "#     cn_listpar=cn_list[i]\n",
    "#     print(cn_listpar)       \n",
    "#     plotcode_cn(cn_listpar[0],cn_listpar[1],cn_listpar[2],cn_listpar[3],cn_listpar[4],cn_listpar[5])\n",
    "\n",
    "# plt.show()\n",
    "# plt.close\n",
    "# # —————————规范图-欧洲规范受剪——————\n",
    "\n",
    "# def plotcode_eu (a_cn,b_cns,b_cnl,c_cns,c_cnl,codecolor):\n",
    "#     kv==5\n",
    "#     Cv=1.1*sqrt(kv*(2.05*10**5)/fyss)/(h/T1)\n",
    "#     Vn = 0.6*Fy*Aw*Cv\n",
    "#     lamuda_ns = np.linspace(0, 0.215, 100)\n",
    "#     fai_s =1/(0.738+lamuda_ns** 6) ** (1 / 3) \n",
    "#     lamuda_nxgm = np.linspace(0.215,1.05, 100)\n",
    "#     fai_xgm = 1/(1+lamuda_nxgm** 2.4) ** (5 / 6)\n",
    "#     lamuda_bs = np.linspace(1.05,3, 100)\n",
    "#     fai_nb =  1/(1+lamuda_bs** 6) ** (1 / 3)\n",
    "#     plt.plot(lamuda_ns,fai_s,codecolor,label='type',alpha = .5)    \n",
    "#     plt.plot(lamuda_nxgm,fai_xgm,codecolor,label='type',alpha = .5) \n",
    "#     plt.plot(lamuda_bs,fai_nb,codecolor,label='type',alpha = .5)                                                                                                     \n",
    "#     plt.ylim((0, 1.2))\n",
    "#     plt.xlim((0, 3))   \n",
    "# cn_list=[[0.41,0.986,0.986,0.152,0.152,'g'],\n",
    "#          [0.65,0.965,0.965,0.3,0.3,'b'],\n",
    "#          [0.73,0.906,1.216,0.595,0.302,'y'],\n",
    "#          [1.35,0.868,1.372,0.915,0.432,'g']]\n",
    "# for i in range(4):\n",
    "#     print(i)\n",
    "#     cn_listpar=cn_list[i]\n",
    "#     print(cn_listpar)       \n",
    "#     plotcode_cn(cn_listpar[0],cn_listpar[1],cn_listpar[2],cn_listpar[3],cn_listpar[4],cn_listpar[5])\n",
    "# plt.show()\n",
    "# plt.close"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57951a42",
   "metadata": {},
   "source": [
    "### 欧洲规范"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a321b8b0",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "f9a2907c",
   "metadata": {},
   "source": [
    "### 精度图像"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d33e55bd",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.298927Z",
     "start_time": "2023-07-04T14:49:09.298927Z"
    }
   },
   "outputs": [],
   "source": [
    "def fitaccur(x_fitaccurori,y_fitaccurori):\n",
    "    # 预测值（x）\n",
    "    x_fitaccur=x_fitaccurori\n",
    "    # 对比值（y）\n",
    "    y_fitaccur=y_fitaccurori\n",
    "    # 拟合点\n",
    "    plt.scatter(x_fitaccur,y_fitaccur)\n",
    "    # 精度数据\n",
    "\n",
    "    x_5=np.linspace(int(min(x_fitaccur))-1, int(min(x_fitaccur))+5,  num=100)\n",
    "    y_pos5=x_5*0.95\n",
    "    y_neg5=x_5*1.05\n",
    "    # 正5%\n",
    "    plt.plot(x_5,y_pos5)\n",
    "    # 负5%\n",
    "    plt.plot(x_5,y_neg5)\n",
    "    plt.show\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "53ae7348",
   "metadata": {},
   "source": [
    "# 结果"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f89d3e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pylab import mpl\n",
    "from matplotlib.ticker import MultipleLocator, FormatStrFormatter\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis\n",
    "from matplotlib.colors import Normalize\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib.ticker as mtick\n",
    "import numpy as np\n",
    "from matplotlib.font_manager import FontProperties"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ecd6f6a0",
   "metadata": {},
   "source": [
    "## 2D图（均是带颜色的）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f65fc17b",
   "metadata": {},
   "source": [
    "### 多图合一，循环式\n",
    "两层抽取，X轴同图，颜色重新循环"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "34c5f755",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "from scipy import stats\n",
    "from sklearn.linear_model import LinearRegression\n",
    "import pandas as pd\n",
    "\n",
    "# ==================== 学术图表规范配置 ====================\n",
    "# 设置 matplotlib 的字体和其他参数，以满足学术图表规范\n",
    "plt.rcParams.update({\n",
    "    'font.family': 'serif',\n",
    "    'font.serif': ['Times New Roman'],\n",
    "    'font.size': 11,\n",
    "    'axes.titlesize': 12,\n",
    "    'axes.labelsize': 11,\n",
    "    'pdf.fonttype': 42,\n",
    "    'ps.fonttype': 42\n",
    "})\n",
    "\n",
    "# ==================== 数据预处理（动态提取家族） ====================\n",
    "def preprocess_data(df):\n",
    "    \"\"\"\n",
    "    动态识别所有出现的模型家族，并对数据进行预处理。\n",
    "    包括转换层级标签、区分模型类型、提取模型家族、转换时间单位和解析随机种子。\n",
    "\n",
    "    参数:\n",
    "    df (pandas.DataFrame): 输入的原始数据\n",
    "\n",
    "    返回:\n",
    "    pandas.DataFrame: 预处理后的数据\n",
    "    \"\"\"\n",
    "    print(\"开始数据预处理...\")\n",
    "    # 转换 stack_level 列的值为字符串格式，前面添加 'L'，例如 1 转换为 'L1'\n",
    "    df['stack_level'] = 'L' + df['stack_level'].astype(str)\n",
    "    print(\"已完成 stack_level 列的转换。\")\n",
    "\n",
    "    # 区分模型类型，根据模型名称中是否包含 'Ensemble' 来判断是集成模型还是基础模型\n",
    "    df['Model Type'] = df['model'].apply(\n",
    "        lambda x: 'Ensemble' if 'Ensemble' in x else 'Base Model'\n",
    "    )\n",
    "    print(\"已完成模型类型的区分。\")\n",
    "\n",
    "    # 动态提取模型家族（基于常见家族关键词匹配，支持扩展）\n",
    "    # 定义常见模型家族及其对应的正则表达式模式\n",
    "    common_families = {\n",
    "        'CatBoost': r'CatBoost',\n",
    "        'LightGBM': r'LightGBM',\n",
    "        'XGBoost': r'XGBoost',\n",
    "        'RandomForest': r'RandomForest',\n",
    "        'KNeighbors': r'KNeighbors'\n",
    "    }\n",
    "\n",
    "    def extract_family(model_name):\n",
    "        \"\"\"\n",
    "        根据模型名称提取模型家族。\n",
    "\n",
    "        参数:\n",
    "        model_name (str): 模型名称\n",
    "\n",
    "        返回:\n",
    "        str: 模型家族名称\n",
    "        \"\"\"\n",
    "        for family, pattern in common_families.items():\n",
    "            if pd.notna(pd.Series(model_name).str.match(pattern).iloc[0]):\n",
    "                return family\n",
    "        return model_name  # 保留未匹配的原始名称作为家族\n",
    "\n",
    "    df['Family'] = df['model'].apply(extract_family)\n",
    "    print(\"已完成模型家族的提取。\")\n",
    "\n",
    "    # 转换时间单位，将 fit_time_marginal 和 pred_time_test_marginal 列的值从秒转换为分钟\n",
    "    time_columns = ['fit_time_marginal', 'pred_time_test_marginal']\n",
    "    df[time_columns] = df[time_columns] / 60\n",
    "    print(\"已完成时间单位的转换。\")\n",
    "\n",
    "    # 解析随机种子，从模型名称中提取 _r 后面的数字作为随机种子\n",
    "    df['Random Seed'] = df['model'].str.extract(r'_r(\\d+)', expand=False)\\\n",
    "                                   .fillna(0).astype(int)\n",
    "    print(\"已完成随机种子的解析。\")\n",
    "\n",
    "    # 按 stack_level 和 score_test 列排序数据，stack_level 升序，score_test 降序\n",
    "    sorted_df = df.sort_values(['stack_level', 'score_test'], ascending=[True, False])\n",
    "    print(\"数据已按 stack_level 和 score_test 排序。\")\n",
    "    print(\"数据预处理完成。\")\n",
    "    return sorted_df\n",
    "\n",
    "# ==================== 核心图表绘制函数 ====================\n",
    "def plot_stack_level_performance(df):\n",
    "    \"\"\"\n",
    "    绘制按 stack_level 分组的模型性能对比条形图。\n",
    "\n",
    "    参数:\n",
    "    df (pandas.DataFrame): 预处理后的数据\n",
    "    \"\"\"\n",
    "    print(\"开始绘制按 stack_level 分组的模型性能对比图...\")\n",
    "    plt.figure(figsize=(14, 8))\n",
    "    # 绘制条形图，x 轴为 score_test，y 轴为 model，按 stack_level 分组着色\n",
    "    ax = sns.barplot(\n",
    "        x='score_test', y='model', hue='stack_level',\n",
    "        data=df, palette='viridis', dodge=False, edgecolor='white'\n",
    "    )\n",
    "\n",
    "    # 找到最高的 score_test 值\n",
    "    best_score = df['score_test'].max()\n",
    "    # 绘制垂直虚线标记最高分\n",
    "    ax.axvline(best_score, color='#ff4747', linestyle='--', linewidth=1)\n",
    "    # 在图上标注最高分\n",
    "    ax.text(best_score + 0.002, 0.5,\n",
    "            f\"Best: {best_score:.4f}\", color='#ff4747', va='center', fontsize=10)\n",
    "\n",
    "    plt.xlabel('R² Score (Test Set)', fontsize=12)\n",
    "    plt.ylabel('')\n",
    "    plt.title('A. Model Performance by Stack Level', loc='left', weight='bold')\n",
    "    # 设置图例位置\n",
    "    plt.legend(title='Stack Level', bbox_to_anchor=(1, 1), frameon=False)\n",
    "    plt.tight_layout()\n",
    "    # 保存图表为 PDF 文件\n",
    "    plt.savefig('stack_level_performance.pdf', dpi=300)\n",
    "    plt.close()\n",
    "    print(\"按 stack_level 分组的模型性能对比图已保存为 stack_level_performance.pdf。\")\n",
    "\n",
    "def plot_family_performance(df):\n",
    "    \"\"\"\n",
    "    绘制不同模型家族的性能分布小提琴图和散点图。\n",
    "\n",
    "    参数:\n",
    "    df (pandas.DataFrame): 预处理后的数据\n",
    "    \"\"\"\n",
    "    print(\"开始绘制不同模型家族的性能分布对比图...\")\n",
    "    plt.figure(figsize=(12, 6))\n",
    "    # 动态获取家族顺序，按出现频率排序\n",
    "    family_order = df['Family'].value_counts().index.tolist()\n",
    "    # 绘制小提琴图，展示不同模型家族的 score_test 分布\n",
    "    sns.violinplot(\n",
    "        x='Family', y='score_test', data=df,\n",
    "        inner='quartile', palette='Set3', order=family_order\n",
    "    )\n",
    "    # 绘制散点图，展示每个模型的 score_test 值\n",
    "    sns.swarmplot(\n",
    "        x='Family', y='score_test', data=df,\n",
    "        color='black', size=3, alpha=0.8\n",
    "    )\n",
    "\n",
    "    # 绘制水平虚线标记 score_test 的中位数\n",
    "    plt.axhline(df['score_test'].median(), color='red', linestyle='--', alpha=0.7)\n",
    "    plt.xlabel('Algorithm Family', fontsize=12)\n",
    "    plt.ylabel('Test R² Score', fontsize=12)\n",
    "    plt.xticks(rotation=45, ha='right')\n",
    "    plt.title('C. Algorithm Family Performance Distribution', loc='left', weight='bold')\n",
    "    # 显示图表\n",
    "    plt.show()\n",
    "    print(\"不同模型家族的性能分布对比图已显示。\")\n",
    "\n",
    "# ==================== 执行流程 ====================\n",
    "if __name__ == \"__main__\":\n",
    "    # 加载用户提供的 leaderboard 数据\n",
    "\n",
    "\n",
    "    # 对数据进行预处理\n",
    "    processed_df = preprocess_data(leaderboard)\n",
    "    # 绘制按 stack_level 分组的模型性能对比图\n",
    "    plot_stack_level_performance(processed_df)\n",
    "    # 绘制不同模型家族的性能分布对比图\n",
    "    plot_family_performance(processed_df)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7598f574",
   "metadata": {},
   "source": [
    "### 多图合一，罗列式\n",
    "可控抽取层数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "0f9875e3",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2891 df数据量\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>H</th>\n",
       "      <th>B</th>\n",
       "      <th>T1</th>\n",
       "      <th>T2</th>\n",
       "      <th>L</th>\n",
       "      <th>n</th>\n",
       "      <th>cf1f</th>\n",
       "      <th>cf2f</th>\n",
       "      <th>cf3f</th>\n",
       "      <th>type</th>\n",
       "      <th>...</th>\n",
       "      <th>meshsz</th>\n",
       "      <th>F</th>\n",
       "      <th>pbol</th>\n",
       "      <th>sfricn</th>\n",
       "      <th>yfss</th>\n",
       "      <th>Bcf2f</th>\n",
       "      <th>Pucf2f</th>\n",
       "      <th>SFcf2f</th>\n",
       "      <th>KG_sing_web</th>\n",
       "      <th>KH_sing_flange</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>41386</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>2327950.0</td>\n",
       "      <td>727939.0</td>\n",
       "      <td>0.738653</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41446</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>1549440.0</td>\n",
       "      <td>485504.0</td>\n",
       "      <td>0.738975</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41448</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>230000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>1551900.0</td>\n",
       "      <td>485191.0</td>\n",
       "      <td>0.738498</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41449</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>1551870.0</td>\n",
       "      <td>485166.0</td>\n",
       "      <td>0.738460</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>41503</th>\n",
       "      <td>200.0</td>\n",
       "      <td>200.0</td>\n",
       "      <td>8.0</td>\n",
       "      <td>12.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>10.0</td>\n",
       "      <td>125000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>754790.0</td>\n",
       "      <td>242271.0</td>\n",
       "      <td>0.737510</td>\n",
       "      <td>0.066667</td>\n",
       "      <td>16.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66411</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>230000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61760300.0</td>\n",
       "      <td>22960300.0</td>\n",
       "      <td>0.980978</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66412</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61159500.0</td>\n",
       "      <td>22958200.0</td>\n",
       "      <td>0.980889</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66413</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>3.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61632400.0</td>\n",
       "      <td>22208000.0</td>\n",
       "      <td>0.948836</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66414</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>4.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>61756700.0</td>\n",
       "      <td>22962400.0</td>\n",
       "      <td>0.981068</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>66415</th>\n",
       "      <td>1000.0</td>\n",
       "      <td>300.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>36.0</td>\n",
       "      <td>3000.0</td>\n",
       "      <td>6.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>2.0</td>\n",
       "      <td>...</td>\n",
       "      <td>40.0</td>\n",
       "      <td>5.0</td>\n",
       "      <td>280000.0</td>\n",
       "      <td>0.35</td>\n",
       "      <td>355.61</td>\n",
       "      <td>65334600.0</td>\n",
       "      <td>22959200.0</td>\n",
       "      <td>0.980931</td>\n",
       "      <td>0.333333</td>\n",
       "      <td>8.333333</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>2891 rows × 22 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            H      B    T1    T2       L    n  cf1f  cf2f  cf3f  type  ...  \\\n",
       "41386   200.0  200.0   8.0  12.0  3000.0  3.0   0.0   1.0   0.0   2.0  ...   \n",
       "41446   200.0  200.0   8.0  12.0  3000.0  2.0   0.0   1.0   0.0   2.0  ...   \n",
       "41448   200.0  200.0   8.0  12.0  3000.0  2.0   0.0   1.0   0.0   2.0  ...   \n",
       "41449   200.0  200.0   8.0  12.0  3000.0  2.0   0.0   1.0   0.0   2.0  ...   \n",
       "41503   200.0  200.0   8.0  12.0  3000.0  1.0   0.0   1.0   0.0   2.0  ...   \n",
       "...       ...    ...   ...   ...     ...  ...   ...   ...   ...   ...  ...   \n",
       "66411  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66412  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66413  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66414  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "66415  1000.0  300.0  19.0  36.0  3000.0  6.0   0.0   1.0   0.0   2.0  ...   \n",
       "\n",
       "       meshsz     F      pbol  sfricn    yfss       Bcf2f      Pucf2f  \\\n",
       "41386    40.0   8.0  125000.0    0.35  355.61   2327950.0    727939.0   \n",
       "41446    40.0  10.0  125000.0    0.35  355.61   1549440.0    485504.0   \n",
       "41448    40.0   4.0  230000.0    0.35  355.61   1551900.0    485191.0   \n",
       "41449    40.0   4.0  280000.0    0.35  355.61   1551870.0    485166.0   \n",
       "41503    40.0  10.0  125000.0    0.35  355.61    754790.0    242271.0   \n",
       "...       ...   ...       ...     ...     ...         ...         ...   \n",
       "66411    40.0   5.0  230000.0    0.35  355.61  61760300.0  22960300.0   \n",
       "66412    40.0   1.0  280000.0    0.35  355.61  61159500.0  22958200.0   \n",
       "66413    40.0   3.0  280000.0    0.35  355.61  61632400.0  22208000.0   \n",
       "66414    40.0   4.0  280000.0    0.35  355.61  61756700.0  22962400.0   \n",
       "66415    40.0   5.0  280000.0    0.35  355.61  65334600.0  22959200.0   \n",
       "\n",
       "         SFcf2f  KG_sing_web  KH_sing_flange  \n",
       "41386  0.738653     0.066667       16.666667  \n",
       "41446  0.738975     0.066667       16.666667  \n",
       "41448  0.738498     0.066667       16.666667  \n",
       "41449  0.738460     0.066667       16.666667  \n",
       "41503  0.737510     0.066667       16.666667  \n",
       "...         ...          ...             ...  \n",
       "66411  0.980978     0.333333        8.333333  \n",
       "66412  0.980889     0.333333        8.333333  \n",
       "66413  0.948836     0.333333        8.333333  \n",
       "66414  0.981068     0.333333        8.333333  \n",
       "66415  0.980931     0.333333        8.333333  \n",
       "\n",
       "[2891 rows x 22 columns]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "自动使用参数配置：x=F, y=SFcf2f, color=n\n",
      "筛选后有效数据量: 672\n",
      "过滤后剩余子图数量: 16\n",
      "\n",
      "绘制子图 1/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=100.0, B=100.0, T1=6.0, T2=8.0\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 2/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=200.0, B=100.0, T1=6.0, T2=8.0\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 3/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=200.0, B=200.0, T1=8.0, T2=12.0\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 4/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=300.0, B=150.0, T1=6.0, T2=9.0\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 5/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=300.0, B=300.0, T1=10.0, T2=15.0\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 6/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=400.0, B=150.0, T1=8.0, T2=13.0\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 7/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=400.0, B=200.0, T1=8.0, T2=13.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 8/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=400.0, B=400.0, T1=13.0, T2=21.0\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 9/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=488.0, B=300.0, T1=11.0, T2=18.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 10/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=500.0, B=200.0, T1=10.0, T2=16.0\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 11/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=588.0, B=300.0, T1=12.0, T2=20.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 12/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=600.0, B=200.0, T1=11.0, T2=17.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 13/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=700.0, B=300.0, T1=13.0, T2=24.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 14/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=800.0, B=300.0, T1=14.0, T2=26.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 15/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=900.0, B=300.0, T1=16.0, T2=28.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n",
      "\n",
      "绘制子图 16/16\n",
      "\n",
      "当前子图总数据量: 42 行\n",
      "筛选参数: L=3000.0, meshsz=40.0, sfricn=0.35, pbol=125000.0, yfss=355.61, Imperfectfactor=0.002, cf1f=0.0, cf2f=1.0, cf3f=0.0\n",
      "分组参数: H=1000.0, B=300.0, T1=19.0, T2=36.0\n",
      "\n",
      "颜色组 n=6.0: 7 行数据\n",
      "颜色组 n=6.0 未发现重复x值\n",
      "\n",
      "颜色组 n=5.0: 7 行数据\n",
      "颜色组 n=5.0 未发现重复x值\n",
      "\n",
      "颜色组 n=3.0: 7 行数据\n",
      "颜色组 n=3.0 未发现重复x值\n",
      "\n",
      "颜色组 n=2.0: 7 行数据\n",
      "颜色组 n=2.0 未发现重复x值\n",
      "\n",
      "颜色组 n=4.0: 7 行数据\n",
      "颜色组 n=4.0 未发现重复x值\n",
      "\n",
      "颜色组 n=1.0: 7 行数据\n",
      "颜色组 n=1.0 未发现重复x值\n",
      "\n",
      "================================================================================\n",
      "数据检查通过：当前子图未发现重复x值对应多y值的情况\n",
      "================================================================================\n",
      "text $n$=1\n",
      "text $n$=2\n",
      "text $n$=3\n",
      "text $n$=4\n",
      "text $n$=5\n",
      "text $n$=6\n"
     ]
    },
    {
     "data": {
      "image/png": "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fn6+LrzwQu3YsaNUp3xKSoqmT5+u4447TvPnz9c///lP7dy5Uz6fTzExMWrRooUef/xx9e3bN7COZVm66aabdN999+mnn37S5ZdfrmeeeSbovG3atEnvvfeeTjjhBJ177rlVzisAoO6lpaVp5syZVS7n9/v16aefSpLOO++8UreF8z16zZo1gcvUM+GtZyI1V9WpZ4YPH64+ffoEzUs9AwCoCnVMaO/NZeep5JFTSqpsnqT6Ucf8+c9/1ssvv6yNGzfqtttu0x133KGxY8fKsqxymZ577jn5/X7deeed5W4LZx0TTjExMXrmmWeC7k9ZxV8Q9+jRI6T7CAAQfsuWLdN//vMfpaSk6Iknnih3O98vVV9WVpaSk5Pldrv1zjvv6LPPPtO2bdvk8XiUnZ2t9u3b68ILL9To0aMVExP8q+1orWOi8ful4qMZHThwoMp5khQ4Javb7db27dsjctouoD7hCDtAEH/88UfgcvF5rytT8rBxZQ/nv3HjxsDlkm/4FSl+05akzZs3l7pt/Pjx+vrrr/Xwww8HrrvtttsCBYIkzZw5U19++aViYmJ0ySWX6LvvvqvVYupInyuPxxPYx8TERG3atEkjR47UsmXL9OCDD+p///ufPvvsM73wwgvatGmTxo0bp0cffTRo3oSEBH3yySdavHhxoOhOSkrSV199Fej4vuCCC/TZZ5/p6quvVqNGjTR//nx9+umnQT8UGj58uK6//npJ0ooVK3TBBRfo2WefLVVkZWRk6IorrlDnzp01derUkDumAQD28NFHH2nHjh1q0KCBLrvsslK3Henv0eF0pM9VdeuZq666KuiHjhL1DAAgfKhjQlPZPEn1Y67i4uL08ssvKy0tTR6PR0888YRGjhypb7/9NrCMMUZTpkzR3Llzdd9996lfv37lxgl3HRNp27ZtC5y245prrqnjNABQv3i9Xv3222968skndeWVV+qMM87QnDlzgp4Oqz68N4dbdna23G63LrnkEu3YsUMPPvigPvroI33yySf63//+p1NOOUWPPfaYRo0aFWgeKSsa5ypav18qPipUySanihQUFGjRokWB33Nzc6tcB0D18EknEER2dnbgcijng46Pjw9czsnJOayxSh7auOxYxUaOHKnzzz9fkrRkyZJyt7/99tvq2LGj7r777pD+Oudw1OVcVTZWscOdq127dgW6lT0ej6666ipddtllmjx5sjp37hxYrlu3bnr99dfVpk0bvfHGG3rrrbcqzJ2amqrJkycrNjZWWVlZ+vXXX0vdnpOTo3nz5un+++9Xx44dK5kB6ZZbbtE//vEPNWvWTAUFBfrXv/6lAQMG6IEHHtCUKVP0l7/8RYMGDdJbb72lpk2bVjoWAMBe8vLy9M9//lOSNGHCBLVu3brU7eF8Xy3+a6FQx6KeCX2sSMxVTeqZ//znP9QzAIBaQx0TmqrmSTryP5cp1rZtW7399tuBowwtX75cY8eO1bBhw/T6669r9OjRWrhwof79739r5MiRleYOZx0TSX//+9/l8Xh0zjnnVHkaNQBA+Fx33XXq1auXLrroIr366qu64oor9MQTTygtLS3o8kf6Zwy1ISsrS48++qguv/xy3XHHHaWOkJOUlKTbbrtNV1xxhVasWKEbbrhBfr+/3BjRWMdE6/dLxaca37Vrl5YuXVrhtiTp2WefVUFBQeB3GnaA8KNhBwii5BtOyTftipRcpuybVcnf4+Liqhyr5DKVvfHdd999Sk5O1ldffaUPP/wwcP0ff/yhqVOn6sknnwxpe4ertubqcMcq6XDmquS4M2fO1CmnnKLhw4cHXTY5OVl33HGHJGnq1KnKy8urMFOXLl00btw4SdL9999f6hCGjz/+uHr27KmLLrqowvVLGjRokAYPHqyGDRsqNjZWubm5mjlzpp5//nmdcMIJGj9+fLlz3AMA7O+RRx7R1q1bNW7cuKB/bU09E7q6rGciMVfUMwCAaEMdE5qq5qlsxiPxc5mSmjdvriuvvFKtW7dWSkqKpKLTTDz++ONatWqVbr75Zp144olVjiOFt46JhPfee08ff/yxevfurcmTJ9d1HACoV1544QWtWLFCn3zyiZ544gl99dVXOvvsszVr1qygy1PHVF9MTIxOP/30St97b7jhBiUmJuqHH37Q3Llzy90ejXVMtH4eM2DAAJ1wwgmB5Sva1syZM/XNN99o8ODBgetcLleF4wKoGRp2gCBKdsJWdA7xkkp285btoq3uWCWXqexw/6mpqYHzcT/22GPav3+/fD6f7r77bl111VXq1q1bldsKh7qcq5Jj1dZclSyoYmJidPvtt1ea6ayzzlLDhg2VlZUVOExxRa6//np16NBBa9as0csvvyxJWrx4sb744gs99NBDla5bbP369Ro2bJiWLFmiefPmadGiRbr22mvVoEGDwHgXXnhh0O5vAIB9vf7665ozZ46uuuoq/e1vfwu6DPVM6I70uapuPXPmmWdSzwAAag11TGj+/e9/VzlP0pH/uUzJPM8995wuueQSjR49WkuWLNG0adN0/PHHS5IKCwt100036a677ir1V+CVCUcdEwk///yzHnzwQfXp00cvvvgiTcwAUAcsy1Lbtm01ZMgQvfPOOxowYIAmTpxY6pRJJZctVl/rmOpatGhRqdNNBZOYmKgzzjhDkoIegSYa65ho/X7Jsiw9//zzOumkk7R69WpddtllWrZsWWDe1q1bp3vuuUfvv/++Xn311VL7kZiYWOnYAKqPhh0giJKHywvlf/ILCwuDrlv295LL1WSssi6++GL17t1be/fu1eTJk/Xyyy/LsixdffXVVW4nXGprrg53rLJqOlclC7shQ4YE/oKrIi6XS127dpUU/BCJJcXFxQUKp3/961/66aefdP/99+uxxx5T48aNK11XktauXatLLrlEHo9Hb775ptq2basWLVrotttu06JFizR06FBJ0p49e3T11VeXOs8oAMC+5s2bp8mTJ2vChAmBDwyCoZ4JHfVMaS6XS126dJFEPQMACC/qmNB88MEHIc1T2YxHYh1TbNKkSZo6daruvfdejR8/Xg6HQ2eccYbefvttPf/882rRooWkosfYddddJ7fbXeWYh1vHRMLvv/+ua665RqeddppefvnlkE7xAQCoXU6nUw8++KDatGmjN998U7Nnzy51e32vY2rTcccdJ0n69ddfyx0VJxrrmGj+fqlJkyaaMWOGnnvuObVv317333+/zjrrLF188cV69tlnddZZZ2nGjBlq0qSJ9u/fH1ivqn0AUH007ABBlOwQreywc8Xy8/MDlxs1ahS2sULpVH3kkUcUFxenOXPm6OWXX9bkyZPldDqrXC9cjvS5KlmohfoXTKmpqZKkjRs3Vrls3759NWzYMLndbl1++eUaMGCA+vfvX+V6hYWFuvHGG5WVlaUpU6aUm8smTZro73//u55++mnFxcXJ4/HojjvuUEZGRkj7AACITnPnztV9992nBx98UOPHj6902XC+R5f8PVreo8OJeqa8pk2bSqKeAQCED3VMaD744AM98MADmjRpUpXzVDbjkVjHSNLs2bM1c+ZMnXPOObrkkkvK3T5w4EC9//776tu3ryRp2bJlevLJJ6scV6p5HRMJv/32m8aOHaszzzxTzz77LKegAIAo4nK5NHLkSEnSs88+K6/XG7itPrw315W0tDRJks/n09atW0vdFo1zFa3fLxVzOBwaNGiQnnnmGX300Uf69NNPNWvWLD333HMaOHBg4MhDW7ZskSQ1a9YsapqagSMJDTtAEB07dgxc3rFjR5XL79q1K3C5Q4cOpW4r+fvOnTurNVbJHBXp0KGDrrnmGklFna2tWrWqcp1wqq25CmWs3bt3B81RkZrMVVJSUuByZecxLan4fKWhLn/XXXcpJSVFHo9HPXr0CGmdefPmaePGjerfv3+g4zqYwYMH6+mnn5ZlWcrLy9PUqVNDGh8AEH1mzZqliRMn6oknntCIESOqXJ56JnR1Wc9EYq6oZwAAdY06JjTvvvuuJk2apEcffTSkeSqb8UisY/x+f+C9v3jdYFJSUjR9+vTAKbJmzZoVcpNvTeqY2rZixQqNGTNG559/vh5//PGo/vIUAOqrE044QVLR++H3338fuL6+1jGRUHzqbEnKzs4udVs01jHR+nlMdXi93kDDTvHRmAGEFw07QBBHHXVU4HyXxW9ElSn55p+enl7qtpK/V2esxo0bB/6yuSq//vqrnE6nNm/erGnTpoW0TrjU5VwVF6i1OVctW7YMFIFlO7YrUnwoxVAPU7x582bl5ubKsiw99dRTyszMrHKdTz/9VJJ0wQUXVLnswIEDA6eT+OSTT+Tz+ULKBQCIHrNmzdJDDz2kp556ShdeeGFI64TzPfroo48OXKaesV/tRz0DAKhL1DGhmT17th577DH9/e9/1+DBg0Ne70j/XGb16tXavn27OnTooGOPPbbSZePi4vTkk0/K6XTK7/eHfCrNmtQxtWnlypW68sorNXToUD3wwAOB+xcAEF1KvvetXr06cPlI/4wh3Nxut2bNmqVPPvmkymVLnsaqZPOOFJ11TLR+HlMdGzduDBxB6pRTTgnr2ACK0LADBNGwYcPAhwArV66scvniYiw1NVWdOnUqddvxxx+v2NhYSdKqVatCHqtPnz4hZZ0zZ45++OEHvfrqq4qLi9P06dP1xx9/hLRuONTWXIUy1m+//SapdufKsqxA1/D69etD2k5OTo6kotM4VKWwsFB/+9vf9Ne//lV/+ctftH//fv3jH/+ocr3NmzdLktq1axdSpuIvuHJycur8gycAQPW8//77euihh/T000/r3HPPrXA5j8cjj8cT+D3c79ExMTGSqGek8NYzkZirmtQzxX/JRT0DADgc1DGhKZ6nJ598UoMGDapwubLzJB35dcymTZskSe3btw9pG23btg0c8aC41qhMTeuY2rJmzRqNGzdOw4YN0z333FPhcn6/v9SXlgCA8Dhw4ICuvfZaXXrppaWOwBJMyT8k8fv9gct8v1Q999xzjyZOnKgbbrhBv/zyS6XLHjhwIHC5bJNNNNYx0fr9UnV89913gcvnnXdeWMcGUISGHaACxR8krV69OvAGWZHly5dLks4666zAOR2LJScnB7pOf/jhh0rH2bt3b6Dzt7IPaIpt27ZNjz32mB566CH16dNH119/vdxutyZNmlTluuFUG3O1bNmySsfZu3dvoCO5tueq+JyfW7duDXxQVJniXFX95ZckPfXUU4qPj9fNN9+su+66S6mpqZozZ46WLl1a6XrFh0IOtcu6WbNmgcuhnisVAFD3vvjiC91777164oknqny/e/DBB/W///2v1HXhfI/u27evJOoZKbz1TKTmqrr1zLZt2yRRzwAAao46JjTF8/T4449r4MCBlS4bbJ6kI7uOqW69IBV94SlJ8fHxVS5b0zqmNmzbtk3jxo3Tueeeq7vvvrvSZT/44AM9/vjjEUoGAPXH1KlT9dlnn2nZsmWaMWNGpcvu3bs3cLlt27albuP7pdAVH31XkrZv317pshs2bJBU9PlA8+bNS90WjXWMFJ3fLxXz+XxVHsH4yy+/lCT169dPaWlpIY0LoHpo2AEqMHToUDVo0EBer1cfffRRhctt2LBB69evl2VZuuSSS4Iuc+mll0qSfvnll0r/uqf4Q5cWLVpU+SGNMUb33HOPzj777EDxN27cOKWnp+u7777T3LlzK10/nMI5V5dddpmkoiK1suKl+LDGkZirwYMHBz4gmj9/fqXL5uTkBAq90047rdJlv/vuO82aNUtPPfWUXC6XkpOTde+990qSJk2aJLfbXeG6xcVaqN3uxYfC7NChgxITE0NaBwBQt9atW6dbb71V99xzT5Wnj/D7/VqyZEm5c52H8z169OjRkorqmcreo6lnQq9nIjlX1DMAgEiijgmtjgnHPElH9ucy3bp1k2VZ1fpr/+JTXFT1Rdfh1DHhlpeXp2uvvVYnnXRSSF/+ff311+rYsWMEkgFA/VLy+5vi/4euyK+//iqpqEH01FNPLXUb3y+FrrgpNzU1tdw8llV8tJczzzwz6O3RVsdI0fl5jFT0+O3Tp49OPfXUwB9tlbV9+3Z98cUXkqRbb7210vEA1BwNO0AFUlNTdfXVV0uSZsyYUeqQhiXNnDlTknTBBReoa9euQZfp379/4LB6FXVlG2P0zjvvSJJuuukmxcXFVZpvxowZ2rJliyZOnBi4LjY2Vo888ogcDocmT56s/fv3VzpGuIR7roq7oF9//fWgyxhj9O6770qSbrzxxlqfq3bt2mn48OGSpH//+9+lDrtY1hdffCGv16vjjz9evXr1qnC5nJwc3XPPPbrjjjvUuXPnwPWDBw9W//79tWHDBr300ksVrv/Xv/5VsbGxmj17doXLlLRw4UJJh4p7AEB0y8rK0nXXXadRo0aF9Nr91ltvaevWreVOFRDO9+jTTz89UM9U9h5NPRN6PTNr1ixJkZkr6hkAQKRQx4T23hyueZLq9nOZ2p6rtm3b6pxzztHq1au1YsWKSrcjFTXr/PLLL2rRokWFX+ZJh1/HhNs999yjxMRETZ48udzRFcr67bff9OGHHwZt3gIAHJ6S/w9cfFrmihQ3X1xxxRXl/qiE75dCV3yEmwsuuKDSP85Zv369li9fLqfTWWHtFG11jBSdn8dIRaf4ys7O1r59+/TZZ58FXeZf//qXfD6fRo8erR49elQ6HoCao2EH9UZxh2jxX9mEYvz48Tr11FP1+++/B31zX79+vf7zn/+offv2euCBByod6/HHH1fz5s01e/bsoOfhnDNnjn799Vedc845uvjiiysda8OGDXrmmWf05JNPlitgevXqpZEjRyozM1OTJ08OYS9LK/7L5erMkxTeuZo8ebJatGihmTNnBp2ruXPnatWqVTr77LMjNle33367jjrqKO3fv1/33ntv0AI7Ly9PU6dOVXJysh577LFKx3v88cfVsWPHQMd3SZMmTVJcXJymTZtW4V+Qde3aVffdd58WL16s1157rdJtLV++XLNmzVK/fv34ggsAbOKRRx5RTEyM/vKXv2j9+vUV/vz000/65z//qccee0zNmjULeqqA2qhn3nnnHeqZMNQzkZ6rUOuZ559/XklJSdQzAIAaoY4J7b257Dxt2LCh3E+o8yTVzecykZqrBx98UOnp6brjjju0e/fuCpfz+/169NFH5XA49Oijj1Z6Cs3DrWMqUvJUHsU1aVXmzJmjxYsX65ZbblFGRkaFz5nVq1frrbfe0tixY+X1eoM2bwEADs/ll18eaIiMjY2tcLkZM2bo119/Ve/evXXDDTcEXYbvl0Jz8803q02bNlq3bl2Fy3i9Xj300EPy+/0aN26cunTpUuGy0VbHSNH3/ZJ06BSiUvBTkS1YsEDvvPOOTjrpJN13332V5gFwmAxQiby8PLNs2bLAT2ZmZl1HKsfv95vCwsLAj9/vL3f7e++9Z7p06WLS09NNenq6mTZtmiksLAxp/OzsbDN+/HjTtWtX8+qrrxqPx2OMMeb77783AwYMMIMHDzabNm0KKeOqVavMoEGDTN++fc0XX3xhjDHG5/OZ2bNnm+7du5sbb7zR5OXlVTrW77//bs4991zTq1cv43a7gy6zePHiwL5OnTq1wuXKZjyceTImPHNVbO3atUHnatasWaZ79+7m+uuvN/v37y93f5cU7rnasWOHGT16tElPTzdXX3212bhxY+C2lStXmpEjR5qzzz7b/P777xU+JgsLC83UqVNNenq6efHFFyvc1vDhw016ero599xzzZo1aypc7r///a/p06ePueWWW8yKFStKbWv37t3m1VdfNb169TJ33323yc/PL7VuVc+daFD2Naiq50ddsENGY+yRszgjEC52qGOMKf96nJWVFXhvqs7PZZddVuE2Dvc9umTGaK1n/H6/KSgoMLNnz47aesbv95v8/Hzz9ttvm+7du5sbbrgh4nMVaj3z66+/VlgjREM9Qx0TPnbIaaeMQDjZoZahjqnZe3N2dnbY5ykcc1VSsM9lvF5voI65/vrrTW5ubq3PVbF9+/aZm266yZx66qnm7bffNgcOHAjc5vF4zPfff2/++te/mn79+pkvv/wyYnVMSTt27DCXXHJJYH8GDx5s1q1bF3TZko/Liy66qNqPhW7dugXu39pip/ffaM5ojD1yUssg3OxQxxgT/P8td+7caUaNGmXOO+88s2jRolKvtxs3bjQPP/yw6dKli7n11lurfD7Xl++XinPU9POYnTt3mssuu8xcf/315uuvvy61zbVr15orr7zSdOnSxTz66KMh/f9/tNUxxkTf90sHDhwwgwcPNunp6ebiiy8O3Ff79u0z//d//2e6du0a9HslY/hMJpzskNNOGe3KMsaYum4a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unWrzjrrLA0fPlyffPJJoxwDAAAgFHIMAACwMrIMAACwKnIMAADNEw07UeZyuTRx4kQ5nU598MEHWrduXcDzM2bM0LJly9S5c2f97W9/C9p/2rRpWrx4sXbv3q177723UY4BAAAQCjkGAABYGVkGAABYFTkGAIDmiYadRtC/f389+uijstlsuvTSS/X1119r3bp1mjJliv7+97+rV69eeuGFF5STkxO0r81mC7kczWMAAADUhhwDAACsjCwDAACsihwDAEDzYzNN04x3EU3V6tWr9dRTT+m7777Tzp071aNHD51xxhkaPXq0nE5nyH22b9+uK6+8UmvXrtU999yjUaNGRf0YAAAA9SHHAAAAKyPLAAAAqyLHAADQfNCwAwAAAAAAAAAAAAAAAMQQt8QCAAAAAAAAAAAAAAAAYoiGHQAAAAAAAAAAAAAAACCGHPEuAIlt27Ztmjt3rnbs2KG8vDyNHDlSGRkZ8S7LclavXq0ff/xRO3bsUEZGhvr376+BAwfKbk+cnrktW7bom2++0ZYtW5Samqp+/fppyJAhCVUjGt/atWu1cOFCbdu2TV6vV5dddlm8S0po5eXlmj9/vlatWqWysjLl5ORo4MCB6tu3b7xLC2AYhn744QetXLlSJSUl6tixow499FBlZWXFu7SILFq0SAsWLJAk9evXTwceeGCcK0KiI8dEBzkGVkGOiQw5JvbIMogUWSY6yDKwCrJMZMgysUWOQaTIMdFBjoFVkGMiQ46JvUTOMjbTNM14F4HEYxiGHnvsMU2ZMkVdu3ZVv379tGjRIm3evFm33nqrzjrrrHiXGOSXX37RlClTtHPnTk2dOjXe5UiStm7dqttvv12zZ88Oei4/P1933XWXhg4dGvvCqvH5fJo4caJefvlleb3egOf69OmjSZMmqVu3bnGqrn633nqr3nnnHV199dW65ppr4l2O33XXXaePP/641uenTp2qESNGxLCi2hUVFWnq1Kl67733ZJqmRo0apf3331/dunVT9+7dY1qLz+fTkUceqS1btoS9z9y5c9W2bdtGrCq0N954Q//+97/ldrs1ePBgtWnTRmvXrtWCBQvUp08f3X///erTp0/M66rpiy++0D333COPx6NDDjlEBQUF+u677+Tz+XT55ZfryiuvjOl/nhryWr1x40b97W9/04IFC3TooYcqIyNDn3/+ubp27aqHH344oV+jEB/kmOggx8RGImYZckzDkGOiL9FyjESWQWyQZaKDLNP4EjHHSGSZhiLLRF+iZRlyDGKBHBMd5JjYSMQsQ45pGHJM9CVajpGabpZhhh0EMU1T48aN04wZM3TuuefqjjvukN1ul2EYuummm3Tbbbdp586dCdMdOX/+fD399NOaO3euJGnYsGFxrqjS1q1bNXr0aG3YsEEdO3ZU9+7dVVZWpp9//llut1vLly/X2LFjNXnyZB111FFxq/P222/XO++8o379+ql9+/basGGDfvnlF0mVL3wXXHCBPvjgA7Vs2TJuNdZm5syZeuedd+JdRpBVq1bp008/rfX5vn37Jkyg+uyzz3T77beroqJC48eP1znnnKOkpKS41TN79uyIAlWPHj3iEqgeeeQRPfXUUzryyCN1//33B3x/LFq0SJdffrnGjBmjqVOnauDAgTGvr8prr72mu+66S6NGjdKDDz6o1NRUSdK6det0xRVXaPLkyVq9erUefvhh2Wy2Rq2loa/Va9eu1ZgxY1RYWKjnnnvO/72zfv16nXPOOTr33HP18ssvq2fPno1WO6yFHBMd5JjYSMQsQ45pOHJMdCVSjpHIMogdskx0kGUaXyLmGIkssy/IMtGVSFmGHINYIcdEBzkmNhIxy5BjGo4cE12JlGOkpp9laNhBkKeeekozZsxQly5dNGHCBH93nN1u15133qk5c+boX//6l/r27atDDz00bnUahqG7775bLpdLRUVFcaujNnfffbckacqUKRo5cqR//datW3XLLbdo3rx58ng8Gj9+vD7++GO1adMm5jW++eabWrx4sf773/+qV69e/vVfffWVrrvuOhUVFWnbtm16+umndeutt8a8vrps3LhRd9xxR7zLCGnKlCnKyspSixYtQj5/+eWXx7iiYKZp6j//+Y+efPJJdezYUdOmTVOPHj3iXZbefPNNSZWvN23atPGHgJp2796tXbt26cQTT4xleZIqQ9PTTz+tNm3a6N///rdSUlICnh84cKBuvvlm/f3vf9ctt9yijz76KOY1StIPP/ygu+++W3l5eZo4cWJAnZ06ddKjjz6q008/XdOnT1efPn10ySWXNEod+/Ja7Xa79de//lXbtm3TNddcE/CfkY4dO+rGG2/Urbfeqr/+9a/68MMPg74WaJ7IMdFBjml8iZplyDENR46JnkTJMRJZBrFHlokOskzjStQcI5Fl9gVZJnoSJcuQYxBr5JjoIMc0vkTNMuSYhiPHRE+i5BipGWUZE6hm/fr1Zr9+/cz8/HzzhRdeCLnN7bffbubn55tHHnmkWVZWFtsCa1FYWGj27t3bzM/PN88777x4l2OuXr3aPPjgg801a9aEfL6iosI844wzzPz8fDM/P998+OGHY1yhaZaUlJjnnXeeWVhYGPL5Dz/80F/fySefHOPq6ub1es0xY8aYxx9/vL/GyZMnx7ss0zRNc+3atWbfvn3Nr7/+Ot6l1GnixIlmfn6+ecghh5hr166NdzmmaZrmpk2bzL59+5oPPvigWVBQUOe2l19+uZmfn2/+/vvvsSmumjvvvNPMz883r7/++lq32bx5s//f5sqVK2NY3V4nn3yymZ+fbz7yyCO1bnPzzTeb+fn5Zr9+/czNmzc3ek2RvlY/9dRTZn5+vtmnTx9zx44dQc9XVFSYQ4cONfPz882HHnqoMUqGxZBjooMc0/gSNcuQYxqOHBNdiZhjTJMsg8ZHlokOskzjStQcY5pkmX1BlomuRMwy5Bg0NnJMdJBjGl+iZhlyTMORY6IrEXOMaTbtLBPbG4sh4T333HPyeDySpCOOOCLkNocffrgkacOGDZoxY0asSqtTZmamsrKy4l2G36xZs3T11Verc+fOIZ93uVwaN26c//F3330Xq9IC/POf/1RmZmbI50aNGuXvJky035B48skntXLlSt13333xLiXIM888owEDBuiggw6Kdym1eumll/Tss88qKSlJjz76qDp16hTvkiRJb731lm6//XbdfPPNdX4/FxYWat68eerXr5+6dOkSuwL3WLdunaTK32ioTfXvq6rX1FiaP3++li9fLqlymszanH766ZIqa4zF/Zkjea2uqKjQ888/L6myszw3NzdoG5fL5Z/68JVXXlFJSUn0ioUlkWOigxzT+BI1y5BjGo4cEz2JmmMksgwaH1kmOsgyjStRc4xEltkXZJnoSdQsQ45BYyPHRAc5pvElapYhxzQcOSZ6EjXHSE07y9CwAz+3263p06dLkjIyMrTffvuF3G7AgAH+5bfeeismtYUjkd74O3furDPOOKPObYYNG6bk5GRJlW8SsZaWlqa8vLxan3c6nf43hoMPPjhWZdVrwYIFevLJJ/WPf/wjLveXrMuWLVv07rvv6qyzzop3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IklasWKF3nnnHR100EHKyclRWlpa0H42my3kcpVPP/1UN954ozwej6ZPn67p06fXW8u11167D2cCAACaG3IMAACwMrIMAACwKnIMAADNCw07jWTcuHGaPXt2wDrDMHTrrbdKki699FKNHz8+aL8LLrhA33zzjdauXasJEyYEPLdo0SJdf/31/mkQw5GXl6cRI0ZEfgIAAKDZIscAAAArI8sAAACrIscAANC80LDTSJ5++ukG7deqVSu99dZbIZ8bOHCgli1bti9lAQAA1IscAwAArIwsAwAArIocAwBA82KPdwEAAAAAAAAAAAAAAABAc8IMO2jSvvrqK7377rtavny53G63CgoKlJOTo2HDhum8885Tfn5+WOMYhqGPPvpIb775ptavXy+bzaasrCydfPLJGj16tDIyMsKuqbi4WO+8844++ugjFRQUyGazqWPHjjr77LN10kknhby/bGOrfp0qKipUWFio7OxsDR8+PKLrJEX/Wr322mtB1+qMM87QCSecEJdrVaW0tFS//vqr3n33XW3ZskXPPPNMxGNE81pFm8fj0Zo1a/TJJ59o2rRp+vbbb8Pe1+v1ql+/fmFvn5aWph9//FF2Oz2kABCujz/+WNddd53GjRunyy67rN7tm3qWqVJaWqrly5fr/fff17Zt2yJ6f/7666910UUXhb39yJEjNWXKlDq3qZllJKljx44688wzdcIJJ4R9rGhavHix3n77bS1YsEDl5eWSJJ/Pp06dOumoo47SWWedpbS0tLjUZpqmNm/erK+++kpPPfWUHn74YQ0ePDiiMVauXKnXX3/df367d++W0+nUoEGDdOaZZ2rkyJGNUzwAIGzkmEA7d+7Um2++qS+++EI7duyQ1+uV2+1W165ddfDBB2v06NFq2bJlWGM19Z/JkGPIMQCQCMgy4Yn0OkmNm2Wk+P9Mpsq+fr7k8Xj03//+Vx9//LE2bdqk0tJSlZSUqGPHjho5cqT+/Oc/h50fo8ntdmv69OmaMWOGfv/9d0lSeXm5WrVqpQMPPFDnnHOOevbsGdGY0fgsDkh0NOygSdq9e7fGjx8v0zR13XXXacCAAbLZbPJ6vfrqq69077336u2339aNN96oSy65pM6xioqKdOONN+rLL7/UuHHjdOGFF8rpdGrRokX629/+prfffltPPPGEunXrVm9dK1eu1HXXXaeCggJNnDhRRxxxhEzT1IwZMzRhwgRNnz5dDz/8cMwaNWpep/79+8vr9crr9errr7/WP//5z7CvkxTda7VixQpdddVVKigo0IMPPui/Vh999JFuv/12zZw5U//85z+Vk5MThSsRngkTJmj+/PmqqKjQ1q1b5fV6JUmHHnpoxGNF81pFy5tvvqkXXnhBHo9HO3fuVGlpqSTJ5XJFNE5hYWFE2/ft25dmHQCIwK5du3TPPfeEvX1TzjJS9N6fI33/qq85NVSWMQxDH374oe666y7NnDlTDz/8sDIzMyM6bkN5PB7de++9+u9//6urr75a11xzjVq1aiWp8gdiCxYs0EMPPaQXXnhBkyZNUv/+/WNS16+//qrrr79ePp9PhYWF2r17d4PGMQxD//rXvzRr1iz97W9/08033+zPML/++qv++c9/6rLLLtPxxx+vhx56KOJ8AwCIDnJMoNdff12PPfaYRo8erSeffNJ/7IKCAn3wwQf697//rZdeekmTJk3SIYccUudYTflnMs0hxzz00EPkGACwALJMeCK9TlLjZ5l4/kxGit7Pr3799Vddd911GjlypO644w516tRJUmWD0n//+189+OCDeuWVV/TII4/o4IMPjvp51Gb+/Pm65ZZbNHToUN1yyy3q3r27JKmiokJffPGF/vGPf+jVV1/VDTfcoEsvvbTOsaL5WRxgCSZQh9LSUnP+/Pn+Pzt37ox3SUEMwzArKir8fwzDMM877zwzPz/f3L17d8h9Nm7caB5wwAFmfn6++corr9Q6ttfrNS+66CIzPz/ffPLJJ4OeX79+vbn//vubRx55pLljx446a9ywYYN56KGHmr179za///77oG3+97//mfn5+ebll19u+ny+MM5839W8TjWv5YYNG8K6TqYZvWtlmqa5detW/7X64YcfAp4zDMOcMWOGmZ+fb1566aWm1+uN8KyjY/fu3eZxxx1n5ufnmxdffHFQjTX/TVYXzWu1L+qq0+v1mjfeeKOZn59v9u/fP6Jx//jjDzM/P99cvny5uXLlynr/bNmypUE1Joqar5OlpaXxLikkK9RZVSMQLVbIMaYZ+Wtd1etzfn6++fTTT9e5bVPPMjVr3Lp1a63vz/V58803zT/96U9hvXetXLnSLCwsrHWs2rJM1de6KstcdtllMbtW48aNM3v37m1+/fXXtW5TXl5unnHGGebgwYPN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ACC6iouLdccdd+jOO+8M+z/ZzSXLRFM03r8izTJV172xr9UhhxwiqfIDwf/97391brt582Zt3LhR3bp18//wygrsdrs6depU52/ff/nll3K73UpLS9MJJ5wQw+oAoPkix4Q2ZswYDR48WC1btqz3N9CrzqlDhw7+WyJVaQ4/kyHHVCLHAEB8kGXCU1xcrLvvvlsTJkxQixYtwt4vnlkmVj+TibacnBy1atWqzm0+//xzSZW3/mrs20kddNBBOuGEE5Sbm1vnDEmStGLFCv9yt27dGrUuwEoc8S4AiIf58+fr1VdfVU5Ojh544IGg51esWOHv9OzUqVO947Vt29a/vHz5cv+0fJL022+/+Zfra46R9k4JV1RUpM2bNwdMETdlyhRNnTpV27dv969zOBwaNWqUJk2aJEk655xztHr1ahUWFkqq7BQ+8MAD9fjjj9d77Jp+/PHHOq+T1HjXKpKxEuFahSOa1+rbb7/VLbfcok2bNgV0Jbdr185/L/P7779fM2fO9M+SlJqaqlatWunDDz8M+iFfNBUWFvpnKPj888/1wQcfaNWqVfJ6vdq1a5dyc3N11FFH6ZJLLokovANAc/Xggw9q8ODBGjVqVNj7kGUiV/X+5Xa79eabb+qLL77Qxo0b5fF4VFRUpP3220+nnHKKzj33XDkcof8bFWmWidW1OvXUU/Xss8/qjz/+0A033KDx48dr7NixIX9oM3nyZBmGoZtuuinoubKyMp1yyinavHlzwG+y5eTkaMqUKRo0aJCmT5+uf/3rX9qyZYt8Pp8cDofatm2rf/zjHxoxYkS916SxbN++XQ888IDsdrvuuecetWzZMm61AEBzQo4J/d6cl5enN954o956DMPwf+ASqkmjOfxMhhxDjgGAeCLLhPczmQcffFCDBg2K6FZYUnyzjFV/flWf5557TkuXLlW/fv101VVXhdxmXz9fSklJ8e/jcDj0yCOPhNUYVDVBwIABA8L6GgHNBTPsoNnwer369ddfNXHiRF188cU64ogj9O6774acRvb333/3L7dv377esdu0aeNfrroPeZU//vjDv1z9Db82rVu39i+vXbs24LnLLrtMX331le655x7/uhtuuMEfECTpjTfe0JdffimHw6ExY8bou+++iyggeL1e/fbbb5o0aVK910lq3tcqUtG8ViNGjNAXX3yhN998UxkZGZKkkSNH+sOUJN12222aN2+ehgwZogEDBujrr7/WZ5991qjNOlJlwM3IyNBNN92k9957TxdeeKGmT5+ujz/+WPPmzdPll1+u119/XSeeeKKWLFnSqLUAgNV98803mjVrlu64446I9uP9OXJFRUVyu90aM2aMNm/erLvuukszZ87UZ599pv/973866KCDdP/992v06NHatWtXyDES9VolJyfr2WefVV5enjwejx544AGdc845+vbbb/3bmKapyZMn6/3339cdd9yhQw89NGic1NRUffbZZ5o9e7b/h2JZWVmaN2+e/7fXTj75ZH3xxRe69NJLlZmZqenTp+vzzz+P24dc69at07Rp03T66acrOztbL730kk455ZS41AIAzQ05Zt9zzMyZM7V582alpaXpvPPOC3q+OVwrcgw5BgDihSwTXpb55ptv9Pnnn+u2226rt76amtu1aixlZWX69ttvde211+qxxx7TxRdfrFdeeSXgdlXVxePzpY0bN/pvP3b55Zc3aAygqaJhB83ClVdeqcGDB+u0007TCy+8oIsuukgPPPCA8vLyQm5fVFTkXw7nPorVu0mLi4v3aazqb3Y1x6pyzjnn6MQTT5RUGYZqev3119W1a1f9/e9/j2i6u7/+9a868MADddZZZ2nq1Kn1XicpvteqrrGqNNa1aojGOL+BAwdq/PjxkqQlS5YEHEOSFi9erOXLl2vixIm1hrNoKyws1Guvvabk5GQ9+uijGjJkiP85p9Op008/Xf/617+0c+dO/eUvf/HfTxUAEKikpES33Xabbr/99ojvN91cs8y+KCws1H333afzzz9f48ePD/hNn6ysLN1www266KKLtHjxYl111VUyDCNojETOMp06ddLrr7/u/+38hQsXauzYsTrzzDM1depUnXvuufr0/9m77/ioqvz/4+97p6Q3CDWhCAhIs2PvWNaKHSygYnct37VXLLuuupbfWlZddXVXXQsqooirq669IKgUkS4tdEIS0qbd+/tjkjGTmSSTMCmXvJ6PR2TmlnM/59y5Mx8zn5z74Yf617/+pfHjxzcad35+vu6//355PB6VlZXp559/jlpfXl6uadOm6fbbb9dOO+3UaFut5ZlnntFuu+2mMWPG6I9//KNGjhypxx9/XHvvvXe7xAMAnQ15zPbnMZWVlXrooYckSddee6169+4ds01n+Z0MeQx5DAC0NXKZxHKZuuPUktn0O0su01r8fr8OPPBA7b777po4caK+/vpr3XXXXbruuusSKqxpy++X7rvvPgUCAR199NHNnokJ2NFRsINO4cknn9S8efP00Ucf6c9//rO+/PJLHXnkkZoyZUrc7SsqKiKP635oN6TuNnX3rf88JSWlybbqblO/rbpuvfVW5eTk6Msvv9R7770XWf7rr7/q8ccf1wMPPJDQ8er629/+ph9++EHvv/++7rnnnibHqX6MyRyr7W2rrtYYq5Zorf6NGzdOe+65p7Zs2aK//OUvkeV+v1833XSTrr322ja9H6jL5VKXLl10++23N7jNoYceqtGjR6ukpCSqKh0A8JuHHnpII0eOjHv7g6Z01lxme7jdbh188ME66aSTGtzmiiuuUGZmpmbPnq233347Zn1Hz2W6d++uCy64QL1791Zubq6k8C9k7r33Xi1YsEBXXXWV9tprrybbkaQhQ4Zo0qRJkqTbb7896tYS9957r0aNGtXoWLa2iy66SD/99JO++eYbPf300/J4PDryyCN1//33y+fztVtcANBZkMdsfx5zzz33qKioSJMmTYo7u079GHf038mQx5DHAEBbIpdJ7PO5dpyOOeaYJreNpzPlMq3B6/Xqyy+/1Pz58zVt2jRdeumlevDBBzV27FjNnj07oTba4vulqVOn6oMPPtDo0aN1//33b1dbwI6Igh10GoZhqE+fPho7dqxef/11HXbYYbrtttuiprSru22tuvdvbEjdv7CuX0Xb3LbqbmOaDV+i+fn5kXty/+lPf1JJSYlCoZBuuukmXXjhhRo2bFiTx4rHMAwVFhbqxBNP1GuvvdboONVuHy/2hiRzrOq21R5j1VzJHKv67d5zzz3yeDx6/fXXNWvWLEnSI488op49e+qss87ajqib77777tN///vfJpPU448/XpI0ffr0yH1eAQBh33//vf7zn/9o8uTJLdq/M+cyLfXxxx83WUSamZmpQw89VJL0yiuvxKzvyLmMbdt67LHHdNZZZ2n8+PGRL4BqZ8Lz+Xy68sordcMNN6i6urrJ9qTw7Iz9+/fX4sWL9eyzz0qSPv30U33++ee66667EmqjtXXp0kWHHnqoHn30Ud199936xz/+oXPPPbfRX8YBALYPecz25zEvvfSSpk6dqgsvvFA33HBDg9t1lt/JkMeQxwBAWyKXSezzeXvHSeo8uUxrc7vdGjp0qC688EJNmzZNHo9HEydO1PTp05vct7W/X/rpp5905513ap999tFTTz3V4ltqATsyCnbQKblcLt15550qLCzUyy+/rDfeeCNqfd3p8hL5H/26f91Sf6q9us8T+SuYxtqq7/TTT9fo0aO1ZcsW3X///Xr22WdlGIYuuuiiJo+TiKbGqX6MyRyr7W2rvtYeq0S0Zv8GDhyoSy65RLZt6/bbb9c333yjqVOn6t57722XqRgTUXuP+EAgoB9//LGdowGAjqO6ulq33nqrbrvttmZPu1yLXKb11H5+/fzzzzFflnTkXGby5Ml6/PHHdcstt+jiiy+WaZo69NBD9eqrr+qJJ55Qjx49JEnTpk3TRRddJL/f32SbKSkpkS+0/va3v+nHH3/U7bffrj/96U8tmgq7tZ1yyik6/vjjNWfOnA7zRRwA7GjIY7Y/j3n33Xf14IMP6tprr418OdSQzvI7GfIY8hgAaCvkMol9PidjnOrHuCPnMm0pLy9Pf/nLXxQKhXTzzTdr2bJlTe7TWt8vLVq0SJdccokOOuggPfvsswndqgzojCjYQafl9Xp15plnSpL++te/KhgMRtZlZmZGHldWVjbZVlVVVeRxVlZW1Lrtaavuvg255557lJKSorfeekvPPvus7r//frlcrib3S1Rj41Q/xs4+Vk1J5ljFc8kll2jgwIFavny5LrroIt1+++2RX1p1RIWFhZHHq1evbsdIAKBjeeSRRzR06NDIPbJbgs/n1lNQUCBJCoVCKioqilrXUcfqjTfe0Guvvaajjz467l9GjRkzRu+884723XdfSeG/knvggQeabFeS9t13X5166qny+/0699xzddhhh+mQQw5JaN/2cO6550qS3nnnHS1durSdowGAHQ95zPblMe+++67uuOMO3XbbbQl9AdQZxoo85jfkMQDQ+shlEvt8TsY41Y9xRx2r9jBw4EDtv//+8vv9euyxxxLaJ9nfLy1cuFATJ07U4Ycfrr/+9a/yer0tbgvY0VGwg05tjz32kCRt3LhR33//fWT5TjvtFHm8fv36JtvZuHFj5HH//v2j1tV9vmHDhma1VTeOhvTv31+XXHKJJCk3N1e9evVqcp/mamic6seYzLFKpK1NmzbFjaMhbTFWjeYtY+EAAQAASURBVEnmWMXj9Xojf2VlWZZ22WWX5gfZhupOfbht27Z2jAQAOo6ffvpJ06dP367phCVymdaUnp4eeVz/86u5uUxbjJVlWXr88cclKbJvPLm5ufr73/8eubXElClTEi6ovfHGG5Wbm6tAIKCRI0cmtE97GTFihDwej2zbTmhqaABA4shjti+PmTJliiZPnqw//vGPOu200xLaZ0f/nQx5TDTyGABoXeQyiX0+//jjj3r33Xe3e5zqx9jWucyO/vur2u/1Pvroo6jipIYk8/ulefPmacKECTr22GN17733dtjCJqCjcLd3AEB76tq1a+TxL7/8ov3220+SNGjQIBmGIdu2tWbNmibbqfvhP3jw4Kh1dZ+vWbNGI0aMSKitvLy8qPga8/PPP8vlcmnVqlV6+umndeWVVya0X6IaGiepdcdq1KhRjbZVm6B2pLFqTDLHqiG1/QuFQpo8ebJefPHFFsfbUp988ok2btyoU089VR6Pp8Ht6k45yX1LASDszTfflMvl0tlnn93odrWfgc8//7zeeuutyPLLL79cJ554IrlMM/n9fk2bNk15eXkaM2ZMo9vW/fyqW7wjdcxc5pdfftG6devUv39/DR8+vNFtU1JS9Je//EVHH320QqGQPv74Y5133nlNxrRq1SpVVFTIMAw9+OCDOuKII7ZrSuzW5Ha7lZubq02bNmnhwoXtHQ4A7FDIY1qex0yZMkV333237rvvPh111FEJ77ej/06GPCYaeQwAtC5ymcQ+n19//fW442TbduSxYRhNjpO04+cy7Sk/P1+SFAgEtGzZsiZfO1Jyvl+aP3++LrjgAp1yyim6+eabm70/0Bkxww52OKWlpbr00kt19tlnR1XIxhMKhSKPLcuKPM7IyIj8ImD+/PlNHvOXX36RFP4AHDBgQNS63XffPVK0sGDBgoTb2meffZrcVpLeeustzZ49W88//7xSUlL097//Xb/++muT+yVjnKTWG6tE2qr95URrj1WyJHOs4lm2bJkeeeQRPfrooxo4cKBmzpypqVOnbl/QzfTaa6/psssu0+TJk/XPf/6z0W3Lysoij2uTRwDo7O655x59/vnn+s9//tPoT+2UtOeff37U8tpfeHSGXCaZbr75Zt1222264oorNHfu3Ea3LS0tjTyu/wud5uYybTFWK1eulCT169cvoWP06dNHe+65p6TwF1hN8fl8uuGGG3TeeefplFNOUUlJif7yl78kdKxkuu+++3TiiSdq5syZTW5bm9vWz2sBANuHPKZlecw777yju+66Sw899FCjxTqBQECBQCBq2Y7+O5nOksf85S9/0UknnUQeAwDtjFwmsc/nP//5z/riiy+i+v7+++/r3Xffjfy8//77TY6T1L65jBN/f/XLL7/o1FNP1U033dRkLhAMBiOPE8kbkvH90uLFizVp0iSdeuqpjRbrWJYV9QdxQGdHwQ52OI8//rj+97//adasWU1Wf27ZsiXyuE+fPlHrjjnmGEnhD8Dy8vJG25kzZ44k6YgjjpBpRl9WOTk5kRlpZs+e3WQ8tVXEifxF1dq1a/WnP/1Jd911l/bZZx9dfvnl8vv9CU1F+NhjjyVlnKTWGatZs2Y1GVNRUZGk1h+rZErWWNUXDAZ144036tRTT9WYMWN09913yzAM3X///dq6dWtygk/AJ598Enm8bt26Rrddvnx55HFTfykHAGi+HT2XSaaWfH5169ZN3bt3j1rX3FymLcaqdtrhjIyMJo9Rq1u3bpKk1NTUJrd98MEHlZqaqquuuko33nij8vPz9dZbbyX0hVOyfPzxx3rhhRe0aNEiPfTQQ41uGwgEIkXD8fJaAEDH0FnymM8//1y33HKL/vznPzd5zDvvvFP//e9/Y5bvyL+T6Sx5zL/+9S/yGADYwXSWXCYZ2iuXceJY3XjjjZo/f76mTp2qr776qtFti4uLJYVnOyosLGx022R8v7R27VpNmjRJxxxzjG666aZGt3333Xd17733JtQu0BlQsIMdTt2/oGnqvog///yzpPD/xB9wwAFR604++WSlp6crGAzq/fffb7CN5cuXa9myZTIMQ2eddVbcbWqnBpw7d26jf+FT+4uXHj16NHk7Btu2dfPNN+vII4+MJDSTJk3S4MGD9d133+ntt99udP9kjZOU3LE655xzJIUTr9q/pIrn448/ltQ2Y5VMyRyrup566ilVVFTohhtukCTttddeOuOMM7R161Y98MADSYu/KZmZmZLCSeBJJ53U6LbfffedpPD9YRO5RywAoHl29FwmmWq/BMrPz4+b69RV+/l1+OGHx13f0XKZYcOGyTCMZv3VV+0U000V1H733XeaMmWKHnzwQXm9XuXk5OiWW26RJE2ePFl+vz/hY26P5uS1ixYtivyV2RFHHNGqcQEAWq4z5DFLly7VNddco5tvvlknnHBCo9talqVvvvlG/fv3j1m3I/9OhjwmGnkMADhHZ8hlkmVHzmWSre75d7vdjW5b+73e7rvv3uTtPrf3+6XKykpdeuml2muvvRIqYvrqq6/4Tgiog4Id7HB22223yOOTTz650W2nT58uKTwlX22hQa38/HxddNFFkqQXX3yxwSnjXnvtNUnS8ccfr6FDh8bd5pBDDolMq9fQbDa2bev111+XJF155ZVKSUlpNPYXX3xRa9as0W233RZZ5vF4dM8998g0Td1///0qKSlpcP9kjZOU/LGqrYJu6JZKtm3rzTfflCT9/ve/b/WxSqZkjlWt+fPn69lnn438ZVit66+/Xt26ddPUqVP1/fffJ6kHjTvyyCMlSbvsskuj94j1+/169913JUnnnntum8QGAJ3Njp7LJFPtX1Mdf/zxcXOdWsuWLdOcOXMavad9c3OZ1h6rPn366Oijj9Yvv/yiefPmNXocKXwP97lz56pHjx4NFiVJUnl5uW6++WZdd911GjhwYGT5cccdp0MOOUTLly/XM8880+TxkmHXXXeNPG4qr63NP/baay/tv//+rRoXAKDldvQ8pqysTJdddpnGjRvXYE5R1yuvvKKioqK4t4bakX8nQx4TjTwGAJxjR89lkqk9cxmnjVXt93q9evVq9FZexcXFkRl4rrrqqkbbTMb3SzfffLMyMzN1//33N3m3iIULF+q9996LW4gOdFYU7GCHc+6550be6GvvVxnPiy++qJ9//lmjR4/WFVdcEXebiy++WAcccIAWLVoU98N92bJl+ve//61+/frpjjvuaDSue++9V927d9cbb7yhuXPnxqx/66239PPPP+voo4/W6aef3mhby5cv1yOPPKIHHngg5kul3XbbTWeeeaaKi4t1//33N9jGhAkTkjZOUnLH6v7771ePHj302muvxR2rt99+WwsWLNCRRx7ZJmPVkLVr10oK/0KoOZI5Vn6/XzfeeKMuu+yymL8ey8rK0i233CLbtjV58uRm3xO0tn9+vz8yfWJTjjnmGI0ZM0br1q1rdPrKJ598UkVFRdp99901fvz4ZsUFAFDkPb2p9/YdOZdpSO1fVTfn8/mqq65SYWGhli5d2uA2wWBQd911lyzL0qRJkzRkyJAGt000l2mrsbrzzjs1ePBgXXfdddq0aVOD21mWpXvuuUeGYeiPf/yj0tLSGtz23nvv1U477RT567W6Jk+erJSUFD399NPNvp973VuS1Z7Lpuyxxx469thjJTWe186bN08vv/yy8vPz9eCDDzYrLgBA8pDHSPfcc4/cbrdOOeUULVu2TMuWLdPy5ctjfn788Uc99NBD+tOf/qRu3bo1eGuoHfl3Mp0hj6n9a33yGABwBnKZxCQ6TlL75DLtPVYt+X7phhtuUEpKirxeb4PbWJalO++8U36/X5deemmkgCmeZHy/9NZbb+nTTz/V1VdfrdWrV0dy2/o/v/zyi1555RVNnDhRwWAwbiF6Q1r6XRzgGDbQiMrKSnvWrFmRn+Li4vYOKYZlWbbP54v8WJZlb9iwwR43bpz9u9/9zv7444/tQCAQ2X7FihX23XffbQ8ZMsS+5ppr7MrKykbb37Ztm33xxRfbQ4cOtZ9//vlIW99//7192GGH2ccdd5y9cuXKhGJcsGCBfdRRR9n77ruv/fnnn9u2bduhUMh+44037BEjRti///3vm4xn0aJF9jHHHGPvtttutt/vj7vNp59+ag8ePNgePHiw/fjjjze4Xf1x8vv9kXFcsmSJfddddyU8TradnLGqtWTJkrhjNWXKFHvEiBH25ZdfbpeUlNiWZTXYRjLHqi7LsuypU6faQ4YMiez79NNP2z6fL7K+/muyvmSM1ZYtW+wrrrjCHjx4sP3DDz/E3aaysjIS52WXXRZ1DTcW59y5c+399tsv0r+rr7464evf7/fbd955p33iiSfa06dPt8vKyiLrNm3aZN977732kCFD7HPOOccuLS1ttK1ExrK91X+fTORaaQ9OiLM2RiBZnJDH2Hbz3+vqfnYdd9xx9saNGxvdfkfOZeqqjaOhz+embNiwwT7nnHPsyy+/3P7qq6+ijrlkyRL7ggsusIcMGWL/8Y9/TOjzKF4uEwwG7VdffTWSy1RUVDTaRjLHauvWrfaVV15pH3DAAfarr74a9RkcCATs77//3j7vvPPsAw880P76668bfE36fD778ccftwcPHmw/9dRTDcZ+2mmn2YMHD7aPOeYYe/HixY32s9b69evts846K+r1vXTp0rjb1r9ufD6fffvtt9t77bWX/dJLL9nbtm2LbLtlyxb7+eeft3fffXf7xBNPtFetWpVQPNvLCZ+9tu2MOJ0UI5BMTshlyGMa72O8z+Zt27ZF1jfn55xzzmn1sarV0X4ns6PlMbYdfe2Ul5fbt912W4fKY2zbWZ+/HTlG23ZGnOQySDYn5DG2TS7TVB+b851J3XH83//+16xxsu3Wz2Xa83cydW3v90uzZs2yDz74YPuSSy6x58yZE1keCoXs2bNn2+eff749fPhw++mnn240ju35fqlujCeddFKz89phw4ZFfW/b0rFqat+O/t2SbTsrR3BCjE5l2LZtt3fREDquqqoqLViwIPJ8wIABysvLa8eIYtm2rUAgEHnu8XhkGIZs29aHH36oadOmaeHChTJNU5ZlKSUlRXvvvbdOPvlk7b777gkf47333tPrr7+uVatWyTRNZWdn64QTTtD48eOVnp6ecIyVlZV64403NH36dJWWlkqSCgsLNX78+MhfBsfz1ltv6dFHH9X69etVe9nm5eXp8ccf11577SUpPKXvySefrI0bN6q6ujqyb05Oju666y797ne/ixtb3XEyDCNqnE455ZSExykZY1VXRUWFXnnllZixOv3006P++sgwjDYZq5tvvlkzZ87Uli1bVFVVFbPe6/WqW7duSktL09SpUyPL48W4PWO1bNkyXXLJJVq/fn3kdZWenq4rrrhCF154YWS7Sy+9VD/++GPUdIwpKSk6++yzdeONN8ZcO2+++ab+8Y9/qLS0NDLedblcLuXn5yslJUWPPvqodtlll7jx1frll1/06quvaubMmaqqqpLH45FlWRoxYoSOO+64yO1HGtPQ9d2R1H+fHDZsWKN/yddenBBnbYx77rlne4eCHYQT8hgpsfe6yZMn6+uvv9a2bdu0devWqHUul0vdu3dXamqq/vOf/zR4jB01l2nO5/N7773XZD//97//6e2339b8+fMlSYZhyOv1au+999YZZ5yhESNGNNpGXfFymYKCAp1xxhk65phjGvxca62xkqQffvhBb731ln744QcFg0HZti3LsrTTTjvp8MMP19ixY5WWlhb3NXnyySdrxYoVqqyslBS+X/rhhx+uxx57LLLtk08+qVdeeSXqr54Mw9Buu+2mV199NSaeX375RVdddZWqqqq0efNmxfvf0y5duigzM1OTJk3SuHHjJDV83cydO1evvvqqZs+erVAoFJlKe8SIETrmmGN0zDHHNDk9c7I44bNXckacToqRPAbJ5IRchjym+Z/NZWVl2nvvvRuNOZ4zzjhD99xzT5N93VF/JyPtOHmMFP/amTdvXofJYyRn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KvXMutSBOwBA7plxSSzGZFIwJmOuAQMGqEaNGgoJCVGbNm2yXTf19alVq5ZHa7ruuuvUqVMnlStXLttZBSRp//79rtuZ1bV582ZJUs2aNXNsmkv9WZDs9T0EAE9LHdPOz2dCxmTSY0wGZpo1a5aCg4PVvXt3b5cCmCbA2wUAnjZ+/Hg1bdrUdR1ydz399NNauXKlIiIi9PDDD+vtt992DRilFR8fr+nTp6tMmTJ69tlnMyx3OBzq37+/hg0bpr/++ktPPPGEJk+enGngO3r0qL755hs1b95cnTt3zrB85syZmj17tuuML0kKCAhQp06dNGnSJElSjx49dOjQIV28eFFSSqdwy5Yt9f777+fq+UspQeXLL79UmTJl9Oabb2a6zv79+11n+LhzSYBKlSq5bu/bt881haEk7d2713U7N9uKiorS6dOn000NbPVrZbVffvlFQ4YM0alTp9KdYVW5cmWtX79ekvTGG29o+fLlrjPyihYtqvLly2vJkiUZgrFZunXrpo8//lhHjhzRiy++qEGDBumxxx7L9HqlU6ZMkdPp1KuvvuqRWgDAzi5evOgaZF+zZo2+++47HTx4UElJSTp//rzKlSunW265RU899VSmZ4B76vic0x+VpP+mOvb08blq1aqaP3++637a42FaTqdTa9askSTdfvvtGZZ7M8tY9VqZxczXKr9ZpkiRIqY8p8vt3LlTklyXKYmPj9f333+v77//XqdPn1ZSUpKcTqeaNm2q+++/P8cp0gGgMMpvjpEYk5EYk/GEtm3bunXZi8OHD7v+CNilS5cMy80ckwkICNDEiRMVGBiY6dhJWqkNXI0bN87wPXI6na6ac5NDpfSNQABQ2JnxmZAxmf8wJuObfHVMJicRERH65JNPNGjQIAUE0OKAgoMZdlCgbd68WatXr9bIkSNz/dg6depo2rRpCgoK0r///qvHH39cAwcOTHdmV2xsrPr166fw8HDNmDFDFStWzHRb9957r/r27SspJfDdeeedeu+99xQZGela5/jx43r88cdVu3ZtTZs2TX5+GX89+/Tpo02bNum1115zfe3FF190BQRJmj9/vn766ScFBATooYce0q+//pqrgJCUlKS9e/dq0qRJeuKJJ3TzzTdr8eLFWU69fPjwYdft1Ot7Zyfta5R6ndNUaV/btOEoK6mhWZKOHTuWbpkVr5U3tWnTRmvXrtWCBQtcU3PedNNNrjAlScOGDdPGjRvVrFkzNW7cWD///LN+/PFHjzXrSClnCH788ceqWrWqEhMT9eabb6pHjx765ZdfXOsYhqEpU6bo22+/1ciRI9WuXTuP1QMAdhUVFaUSJUro5Zdf1jfffKP//e9/Wrp0qVasWKGNGzeqb9++mjdvnrp06eIaTEqL4/N/li9frtOnT6tYsWJ65JFHMizntXKfma+VL2aZxMRE13MsUaKEjh49qh49emjLli0aPXq0fvjhB61du1Yffvihjh49qieffFKvv/66R2oBADvLb46RGJNhTMa7Zs2aJUlq0KBBpn+I9UaO+eeff1yX7Ej9eU7rzJkzrhmk3PlZKFmypOuPbZd//wCgsDLrMyHH5/8wJuObfHFMxh0zZsyQv7+/7r77bq/VAHgCDTsosGJiYjRs2DCNGDEiV5fCSuumm27SF198oYYNG0qSli5dqi5duuiZZ57RZ599pi5dusjf31/ffPONmjZtmu22+vXrpzfffFPly5fXpUuX9MEHH6h9+/YaOXKkpkyZonvuuUcdO3bUV199pSuuuCLbbfXo0cN1hk/qdLdpzZs3T1dddZVeffXVHM/OSevZZ59Vy5Ytdd9992n27Nl6/PHH9eabb6pq1apZPiYqKsp1O7Prj14ubedtdHS0x7aVylOvla9o0qSJBg0aJCll4DHtayhJO3bs0L59+zRhwoR015X1pGrVqmnevHmujvlt27bpscce07333qvZs2frwQcf1KpVqzRnzhw99NBDltQEAHZz8eJFffXVVwoODtbUqVPVrFkz17LAwEB1795d77zzjiIiIvTkk0/q7Nmz6R7vzeNz2g/u3j4+x8bG6p133pEkDRw4UFWqVMmwDlnGfZ54fr6UZc6ePavExERJKQO1Tz31lB555BGNHz9etWvXdq3XoEEDzZ49WyEhIZo7d66++OILj9YFAHaT3xyTijEZxmS8Yc+ePVq0aJECAwP1+uuvy9/fP8t1rcwxb731lhITE9WpU6dMLz2Sena/5N73T/rvexgTE5Ov2gCgoAgPDzflMyFjMikYk/F9vjQmk5OzZ8/qq6++Uvfu3b1eC2A2GnZQYL3zzjtq3LhxptPs5UaTJk3Uq1cvFSlSRKVKlVJycrLWrFmjN998U0FBQXrxxRczDRqZ6dChg26//XYVL15cgYGBiomJ0fz58/X++++refPm6tOnj9vdqcOGDVPp0qW1ceNGLVu2zPX1w4cPa9q0aZowYYKCg4Nz9Vw/+OADbd26VcuXL9fYsWO1ceNG3Xbbbfr666+zfEzaD/XuTIOXdp3LBwTM3FZannitfEnPnj3VokULnTt3Tm+//bbr6wkJCXr11Vc1cOBAj19z/XIVK1bUE088oSpVqqhMmTKSUgLfuHHjtHv3bj3//PO69tprLa0JAOzE399f5cqV04gRI7Jc5+abb1arVq104cKFdGf4SJ47PrtzvEy7jrePz2PHjtXJkyf15JNPZnom1+U1kmWy56nn5ytZJm2N8+fP13XXXaf77rsv03VLly7tGtR67733+EMXAKSR3xyTFmMyjMlYKS4uTi+//LIk6d1333U1i2XHihzzzTffaOXKlWrVqpXGjx+f6Tq5zewSDTsAcDmzPhMyJpOCMRl78JUxmZx88sknio+P11133eXtUgDT0bCDAun333/XihUrNGrUqHxtJzo6Ws8++6zefPNNTZs2TRs2bNCYMWNcZzcdPXpU9957rz777LMct3Xo0CH17NlTv/76q7799lutXr1aTz/9tKsTdN26dbrzzjsz7dLNTPny5V2DCG+88YYuXLig5ORkvfrqq3rqqafUoEGDPD1nh8OhkJAQdevWTfPnz1f79u01fPjwdFP/Xb5+qqyuU5qW0+nM9LH53VZm01Wn8tRr5SscDofGjh2rwMBALViwQFu2bJEkTZ48WZUrV7Z8FhvDMDR16lQ99NBDevDBB7V582bNmDHDdVZlfHy8+vfvr8GDB+vSpUuW1gYAdvHWW2/phx9+yPED/x133CEp5YzztGfVevP4nHYdbx6f58yZo8WLF+upp57S4MGDs1yPLOM+M1+ry7frC1km7QBdQECAXnrppWzXv/XWW1W8eHFFRkZq+fLlni4PAGwjvzkmFWMyjMlYyel0avDgwTp69KjeffdddejQwa3HeTrH/PXXXxo9erRat26t6dOnZ9lUltvvn/Tf99COMwIAgCeY9ZmQMRnGZOzEV8ZkshMZGakFCxaoRo0aaty4sbfLAUxHww4KnEuXLmnYsGEaPnx4ni+FJaWEs169emnjxo369NNPdeONN6po0aLq2bOnVqxYoUGDBik4OFiJiYl68803NXHixCy3tX//fvXq1UuJiYn67LPPVK1a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448/rqNHj6pHjx6KiIhwX7KofPnyevLJJ/XMM89ku+3LefKdiZk5xop99corr6hbt246evSonnrqqSv2VZcuXdSzZ89st50brszuSV6X/s3siYmJOnnyZLrfxS+++ELTpk3zq3ycWeb78ccfc5z5ACswww4KnIkTJyowMFAPPfRQpmMOHTrkvl2pUqVs15l22rijR4+mW/bPP/+4b6c94Gcm7cH/yJEj6ZY988wzWr16td544w33z15++WX3QU+Spk+frj/++ENBQUHq2rWr1q9fn6ODXnJysvbs2aMxY8aoR48euv322zVr1qxMp5UryPvKTHFxcVq3bp1efPFFTZgwQT169NC0adPSTYuc1o033qhly5ZpxowZ7ss13Hbbbe4PhSRp8ODBWrVqlRo3bqz69etrzZo1WrJkSbpmnZw4ceKEe0rH3r17Zzt+7dq1Wrp0qYYNG5ar7QFAQRUaGqovvvhClStXVlJSkt5991116tRJ69atc48xDEPjxo3TL7/8omHDhunWW29Nt46CfHx2ZZn33nuPLONln3zyiUqXLq0uXbrk+LH+mGWSkpLcvw/FihXT4cOH1alTJ23atEkjRozQb7/9pmXLlunTTz/V4cOH9fTTT+utt97KVS0AkF+lPcM17Yw5mZk/f777dtovMQry8Zks470sk/Z3snjx4lq5cqUee+wxJScn64svvtDixYu1YsUK9evXTwsXLtSDDz7ovpzC5fwxy0jmvJcAAOSNvx6bXevyZD1p13Xs2LF0zamS9PHHH2vt2rXpvmf78ssv9fjjj0tKbZhZsmSJPv30U0nS2LFj9ccff+SoWSen35nYaV9988037ks+Xb6vxowZo6VLl3qtWUf6N7OnbXLKTHx8vJYuXeq+HxMTk255z549tWrVKq/n4927d2v06NEe5eO0ma9YsWJatWqVOnXqlKvMB1iBhh0UKBEREfr+++/VoUOHTA/qUmpHrUtG14O+XNqzYtJ+wJSbdaV90375ulw6deqke++9V1L6qflcfvjhB1133XV6/fXXc3Rpgueee07NmjXTI488oilTpuipp57Su+++q8qVK2f6GF/uq6zW5eKtfWWWxMREtWrVSo0bN1b37t21Zs0ajRw5Uv379/foA5wGDRqof//+klLPCE+7D6XUy1Ts3btXo0ePzvJ33hP/+9//lJSUpLZt2+ru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nqxHUrrjQ3bHn4EDB6p06dJat26dZs+erSFDhuiRRx4xbTY3T74z8cZ+9+a+WrNmjX7++WcNHjzY1H3lqTJlymjq1KkaP368rrnmGg0dOlR33nmnHn30UX300Ue68847NXXqVJUpUybTzJ4Rf8jHaTPfE088ke06c5L5AG+gYQcFxowZMyRJN954Y7Zj03aIZjYVXFpxcXHu28WLFzdtXZ5007755psKDQ3VrFmz9MUXX2jUqFEKDAzM9nGeCgkJUadOnSSlThecnJycbjn7yjuqVaumm2++WYmJiRo/frxHj+ndu7eqVaumgwcPqlevXho6dKj7Q5jc2L17t7p376477rhDH330UZZTHbqMHTtWtWrVsuQ6qwCQX82cOVPTp09X27ZtMzwb96677tKcOXPcmWbDhg169913043h+Pwvsox5XB+Mvfjii6ZcCutyvs4yaT9Uy+7MdZeyZctKSr0mOgAgvUqVKum///2vvv/+ey1btkxz587Vt99+q5dfftn9+p72UgA1atRw3zbz+Jz2vh2Pz2QZ8+T0WB8SEuLeR54c632dZaTUExbz+l4CAJA3/npsdq3b00s6u7YXFBSU7XGzdOnS7plVRowYodOnT+ull17yaDueyu47E7vsqzJlyuj111+XJA0dOtQr+8pTAQEBatOmjcaOHauFCxfq999/148//qjx48frrrvucs8WdOzYMUlSuXLlVLp06WzX6+t87O3MB5iNhh0UCDt27NA///wjSR5NuXbddde5b586dSrb8REREe7b1157bbplae+fPn06R+tKW0dmrr32WvXu3VtSamdrpUqVsn1MTrmuZRkREaGNGzemW+atfeXJus6cOZNhHZmxYl+ZybXflyxZki48ZiYkJMR9DVSn05npNTk9sW3bNnXr1k333nuv3nnnHY/C1F9//aW5c+dyKSwAyAOn06kJEyZIkvuYlZFSpUpp0qRJ7mntf/jhh3RTtpJl0vPXLOOP+yorkydPVuHChfX44497Zf2+zjIlSpRw3/b0QznXtdc9HQ8ASM/1WY0k96xlElnmcmQZc6T9EtQbx3pfZxmz3ksAAPLGX3OMa12erCftuq655hqPZot74IEH1KJFCyUnJ6tmzZoeNZrmVFbfmZiZY7y9rzp06KAbb7xRSUlJXttXZklOTnY37NSsWdOjx/g6H3s78wFmo2EH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AAAAAAAAAAAAAAAgjwjsAAAAAAAAAAAAAAAAAHlEYAcAAAAAAAAAAAAAAADIIwI7AAAAAAAAAAAAAAAAQB4R2AEAAAAAAAAAAAAAAADyiMAOAAAAAAAAAAAAAAAAkEcEdgAAAAAAAAAAAAAAAIA8IrADAAAAAAAAAAAAAAAA5BGBHQAAAAAAAAAAAAAAACCPCOwAAAAAAAAAAAAAAAAAeURgBwAAAAAAAAAAAAAAAMgjAjsAAAAAAAAAAAAAAABAHhHYAQAAAAAAAAAAAAAAAPKIwA4AAAAAAAAAAAAAAACQRwR2AAAAAAAAAAAAAAAAgDwisAMAAAAAAAAAAAAAAADkEYEdAAAAAAAAAAAAAAAAII8I7AAAAAAAAAAAAAAAAAB5RGAHAAAAAAAAAAAAAAAAyCMCOwAAAAAAAAAAAAAAAEAeEdgBAAAAAAAAAAAAAAAA8ojADgAAAAAAAAAAAAAAAJBHBHYAAAAAAAAAAAAAAACAPCKwAwAAAAAAAAAAAAAAAOQRgR0AAAAAAAAAAAAAAAAgjwjsAAAAAAAAAAAAAAAAAHlEYAcAAAAAAAAAAAAAAADIIwI7AAAAAAAAAAAAAAAAQB4R2AEAAAAAAAAAAAAAAADyiMAOAAAAAAAAAAAAAAAAkEcEdgAAAAAAAAAAAAAAAIA8IrADAAAAAAAAAAAAAAAA5BGBHQAAAAAAAAAAAAAAACCPCOwAAAAAAAAAAAAAAAAAeURgBwAAAAAAAAAAAAAAAMgjAjsAAAAAAAAAAAAAAABAHhHYAQAAAAAAAAAAAAAAAPKIwA4AAAAAAAAAAAAAAACQRwR2AAAAAAAAAAAAAAAAgDwisAMAAAAAAAAAAAAAAADkEYEdAAAAAAAAAAAAAAAAII8I7AAAAAAAAAAAAAAAAAB5RGAHAAAAAAAAAAAAAAAAyCMCOwAAAAAAAAAAAAAAAEAeEdgBAAAAAAAAAAAAAAAA8ojADgAAAAAAAAAAAAAAAJBHBHYAAAAAAAAAAAAAAACAPCKwAwAAAAAAAAAAAAAAAOQRgR0AAAAAAAAAAAAAAAAgjwjsAAAAAAAAAAAAAAAAAHlEYAcAAAAAAAAAAAAAAADIIwI7AAAAAAAAAAAAAAAAQB4R2AEAAAAAAAAAAAAAAADyiMAOAAAAAAAAAAAAAAAAkEcEdgAAAAAAAAAAAAAAAIA8IrAD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aLks7ORRjx49ory8PCIi5s6du9X7gM6ZMyd7fOKJJ5bcawAALY+OAQDSTMsAAGmlYwCg5bKwk2fnnntuRERUVlbGa6+9Vuc5r7/+ekREtGrVKgYPHlySrwEAtDw6BgBIMy0DAKSVjgGAlsnCTp597Wtfi549e0ZExJQpU+o857nnnouIiDPOOCN7brUPP/wwvv71r8cRRxwRzz77bEFeAwCgLjoGAEgzLQMApJWOAYCWycJOnrVr1y5GjRoVbdu2jaeeeioWLFhQ6/mKioqYPXt29OjRI6688sotvv6RRx6JN954Iz755JO46aabCvIaAAB10TEAQJppGQAgrXQMALRMFnYK4IADDohx48ZFWVlZnH/++fHSSy/FggUL4r777ouf/OQn0bt373jooYeic+fOW3xtWVlZncf5fA0AgK3RMQBAmmkZACCtdAwAtDxlmUwmU+whmqt58+bF+PHj45VXXonly5dHr1694swzz4zBgwdH27Zt6/yajz76KC666KKYP39+3HjjjTFo0KC8vwYAwLboGAAgzbQMAJBWOgYAWg4LOwAAAAAAAAAAkCC3xAIAAAAAAAAAgARZ2AEAAAAAAAAAgAS1KfYAlLalS5fGiy++GMuWLYtu3brFcccdFx06dCj2WKkzb968+Nvf/hbLli2LDh06xAEHHBD9+/ePVq1KZ2duyZIl8fLLL8eSJUuiffv20a9fvzjkkENKakYKb/78+TFjxoxYunRpbNiwIS644IJij1TSPvvss3jttddi7ty5sXbt2ujcuXP0798/+vbtW+zRaqmqqopXX3015syZE2vWrInu3bvHMcccE506dSr2aDmZOXNmTJ8+PSIi+vXrF4cffniRJ6LU6Zj80DGkhY7JjY5JnpYhV1omP7QMaaFlcqNlkqVjyJWOyQ8dQ1romNzomOSVcsuUZTKZTLGHoPRUVVXFnXfeGffdd1/ss88+0a9fv5g5c2YsXrw4rr766vj6179e7BG38NZbb8V9990Xy5cvjwkTJhR7nIiI+PDDD+O6666LqVOnbvFceXl5/PSnP43DDjss+cFq2LhxY4waNSomTZoUGzZsqPVcnz59YvTo0bHvvvsWabptu/rqq+PJJ5+MSy65JIYNG1bscbIuu+yy+MMf/rDV5ydMmBBHHnlkghNt3apVq2LChAnxX//1X5HJZGLQoEFx6KGHxr777hs9e/ZMdJaNGzfGwIEDY8mSJQ3+mhdffDF23XXXAk5Vt8cffzxuv/32WL9+fRx88MGxyy67xPz582P69OnRp0+f+NnPfhZ9+vRJfK7NPf/883HjjTdGZWVlHH300bFixYp45ZVXYuPGjTF06NC46KKLEv3hqTHv1f/85z/jyiuvjOnTp8cxxxwTHTp0iP/5n/+JffbZJ2677baSfo+iOHRMfuiYZJRiy+iYxtEx+VdqHROhZUiGlskPLVN4pdgxEVqmsbRM/pVay+gYkqBj8kPHJKMUW0bHNI6Oyb9S65iI5tsyrrDDFjKZTAwfPjwqKiri7LPPjpEjR0arVq2iqqoqrrjiirjmmmti+fLlJbMd+dprr8W9994bL774YkREDBgwoMgTbfLhhx/G4MGDY9GiRdG9e/fo2bNnrF27Nl5//fVYv359vPPOO3HeeefF2LFj40tf+lLR5rzuuuviySefjH79+sXuu+8eixYtirfeeisiNr3xnXvuufHUU0/F5z73uaLNuDVTpkyJJ598sthjbGHu3Lnx3HPPbfX5vn37lkxQ/fGPf4zrrrsu1q1bF5dffnmcddZZ0bp166LNM3Xq1JyCqlevXkUJqjFjxsT48eNj4MCB8bOf/azW98fMmTNj6NChMWTIkJgwYUL0798/8fmq/frXv46f/vSnMWjQoLjllluiffv2ERGxYMGCuPDCC2Ps2LExb968uO2226KsrKygszT2vXr+/PkxZMiQWLlyZTzwwAPZ752FCxfGWWedFWeffXZMmjQp9ttvv4LNTrromPzQMckoxZbRMY2nY/KrlDomQsuQHC2TH1qm8EqxYyK0TFNomfwqpZbRMSRFx+SHjklGKbaMjmk8HZNfpdQxEc2/ZSzssIXx48dHRUVF7L333nHttddmt+NatWoV119/fbzwwgvxy1/+Mvr27RvHHHNM0easqqqKG264Idq1axerVq0q2hxbc8MNN0RExH333RfHHXdc9tc//PDDuOqqq2LatGlRWVkZl19+efzhD3+IXXbZJfEZf/Ob38Qbb7wR//3f/x29e/fO/vqf//znuOyyy2LVqlWxdOnSuPfee+Pqq69OfL76/POf/4yRI0cWe4w63XfffdGpU6fo0qVLnc8PHTo04Ym2lMlk4o477oh77rknunfvHo888kj06tWr2GPFb37zm4jY9H6zyy67ZCNgc5988kl8/PHHccoppyQ5XkRsiqZ77703dtlll7j99ttj++23r/V8//79Y8SIEfGTn/wkrrrqqnjmmWcSnzEi4tVXX40bbrghunXrFqNGjao155577hnjxo2LM844IyZPnhx9+vSJ73//+wWZoynv1evXr48f/OAHsXTp0hg2bFitH0a6d+8eP/7xj+Pqq6+OH/zgB/H0009v8e+ClknH5IeOKbxSbRkd03g6Jn9KpWMitAzJ0zL5oWUKq1Q7JkLLNIWWyZ9SaRkdQ9J0TH7omMIr1ZbRMY2nY/KnVDomogW1TAZqWLhwYaZfv36Z8vLyzEMPPVTnOdddd12mvLw8M3DgwMzatWuTHXArVq5cmdl///0z5eXlmW9/+9vFHiczb968zBe+8IXM+++/X+fz69aty5x55pmZ8vLyTHl5eea2225LeMJMZs2aNZlvf/vbmZUrV9b5/NNPP52d79RTT014uvpt2LAhM2TIkMxJJ52UnXHs2LHFHiuTyWQy8+fPz/Tt2zfz0ksvFXuUeo0aNSpTXl6eOfroozPz588v9jiZTCaT+eCDDzJ9+/bN3HLLLZkVK1bUe+7QoUMz5eXlmffeey+Z4Wq4/vrrM+Xl5Zkf/vCHWz1n8eLF2f8258yZk+B0/3LqqadmysvLM2PGjNnqOSNGjMiUl5dn+vXrl1m8eHHBZ8r1vXr8+PGZ8vLyTJ8+fTLLli3b4vl169ZlDjvssEx5eXnm1ltvLcTIpIyOyQ8dU3il2jI6pvF0TH6VYsdkMlqGwtMy+aFlCqtUOyaT0TJNoWXyqxRbRsdQaDomP3RM4ZVqy+iYxtMx+VWKHZPJNO+WSfbGYpS8Bx54ICorKyMi4vjjj6/znGOPPTYiIhYtWhQVFRVJjVavjh07RqdOnYo9Rtaf/vSnuOSSS6JHjx51Pt+uXbsYPnx49vErr7yS1Gi1/Md//Ed07NixzucGDRqU3SYstb8hcc8998ScOXPi5ptvLvYoW/jVr34VBx54YBx11FHFHmWrJk6cGPfff3+0bt06xo0bF3vuuWexR4qIiCeeeCKuu+66GDFiRL3fzytXroxp06ZFv379Yu+9905uwP9vwYIFEbHpbzRsTc3vq+r31CS99tpr8c4770TEpstkbs0ZZ5wREZtmTOL+zLm8V69bty4efPDBiNi0Wd61a9ctzmnXrl320oePPvporFmzJn/Dkko6Jj90TOGVasvomMbTMflTqh0ToWUoPC2TH1qmsEq1YyK0TFNomfwp1ZbRMRSajskPHVN4pdoyOqbxdEz+lGrHRDTvlrGwQ9b69etj8uTJERHRoUOH2Guvveo878ADD8weP/HEE4nM1hCl9MHfo0ePOPPMM+s9Z8CAAbHddttFxKYPiaTtsMMO0a1bt60+37Zt2+wHwxe+8IWkxtqm6dOnxz333BM///nPi3J/yfosWbIkfve738XXv/71Yo+yVTNmzIhf/OIXERFx3nnnxSGHHFLkif7l0EMPjcGDB2/zvOeeey4qKyvjq1/9agJTban6g3369Onx9ttv13nOnDlzIiKiS5cuse+++yY2W7VXX301e7y1H5wiIg4++OBo27ZtRGz6YTAJDX2vfv755+OTTz6JiIgDDjhgq+dV38f1008/LZkf9CkOHZM/OqawSrVldEzT6Jj8KeWOidAyFI6WyR8tUzil2jERWqaptEz+lHLL6BgKRcfkj44prFJtGR3TNDomf0q5YyKab8tY2CFrxowZsWLFioiI6NatW5SVldV53q677ho77rhj9mvWrl2b2Iz1ad26dbFHyDrxxBOzwbQ1bdq0yW4CFuMeo9vy2WefxbJly6Jr165x3nnnFXuciIhYtWpVXH755XH22WfHl7/85WKPs4X7778/Kisr45prroljjjkmhg8fHi+88EJUVVUVe7SI2HRv0Ztvvjmqqqqiffv2cf755xd7pFqOPvroBp1XUVERZWVlRbnHaMS//iZIVVVVDB8+PPu+WdOvf/3riIi4+OKLo127donOFxGxePHi7HF979Ht27fPvv/84x//iOXLlxd8toa+V7/wwgvZ4+7du2/1vJrR+pe//KXxg5F6OiZ/dEzhlHLL6Jim0TH5U8odE6FlKBwtkz9apjBKuWMitExTaZn8KeWW0TEUio7JHx1TOKXcMjqmaXRM/pRyx0Q035axsEPWjBkzsse77bZbvefuvPPOERGxcePGmD17dkHnas6q34wPOuigIk+ypSlTpkTr1q1j9OjRdV4qrBhGjhwZHTt2jBEjRhR7lC0sX7681t8KWLp0aUyePDkuuOCCOOOMM0rih9annnoqZs6cGRERp59+esn8e83F8uXL4y9/+UsceuihsfvuuxdlhpNOOil69eoVERHvvvtuDB48ON57773s87///e/jd7/7XQwZMiTOOeecoszYqtW/Pt4/+OCDes/t3Llz9njp0qWFGiln1f+tRkS9f9vh85//fPb4jTfeKOhMlDYdkzwdk7tSbRkdkwwd0zDNoWMitAy50zLJ0zK5KdWOidAySdEyDdMcWkbHkCsdkzwdk7tSbRkdkwwd0zDNoWMi0tcyFnbImj9/fva4Opq2puZlsKrvuUdu3nnnnVi/fn1ERNEuv7Y1ixYtittvvz3Gjx9fMvfLfPLJJ+P555+P0aNHF2WrdFteeuml2H///WOvvfbKXgau2ttvvx3f/e5349577y3SdJs88sgj2eOvfOUrUVFREcOHD49TTjkljjrqqDjxxBPj2muvjffff7+IU9ZvypQpsXHjxqJ+z7Rt2zbuvvvu7PvkvHnz4hvf+Ea88MIL8fvf/z5uuOGGGDlyZFx//fVFm7HmxnDNH5jrsm7duuzx6tWrCzZTLjKZTK3Plvo+k2res3TBggWRyWQKOhulS8ckS8fkrpRbRsckQ8c0TNo7JkLL0DhaJllaJjel3DERWiYpWqZh0t4yOobG0DHJ0jG5K+WW0THJ0DENk/aOiUhny1jYIavm9tsOO+xQ77k1P9CKcY/M5qD6nn5f/OIXY//99y/yNJtkMpn4wx/+EP/+7/8eixcvjocffnir91FM0j/+8Y+4+eab45prromePXsWe5w6nXrqqfGf//mf8dxzz8X06dPjkUceqXVZvaqqqhg9enTcd999RZnvgw8+iDfffDP7+Kabboo333wzzjnnnLj99ttj2LBhsWrVqnjiiSfitNNOi2effbYoc25LRUVFtG7dOk466aSizrHXXnvFpEmTsvfqXbVqVVx44YVxww03xOOPPx7f+ta3ijpf9aUVIyL++Mc/1htLH330Ufa4+pK0xbZy5cpasVffXDU/j6qqqmLNmjUFnY3SpWOSpWNyU+oto2OSoWMaJu0dE6FlaBwtkywt03Cl3jERWiYpWqZh0t4yOobG0DHJ0jG5KfWW0THJ0DENk/aOiUhny1jYIeuzzz7LHm+//fYN/rpS2ppLi/Xr18djjz0Wbdq0icsvv7zY40RExG233RYnnXRSXHbZZfHxxx9HRMT//u//xllnnRV//etfizZXZWVlDB8+PI4//vj4xje+UbQ5ctGuXbsYMGBAjBkzJh577LHYZ599ss+NGTOmKKFa899hnz594tFHH40RI0bEwQcfHOXl5TFkyJB47LHHYscdd4x169bF8OHDa10yrhQsWbIk/va3v8WRRx4Zn/vc54o9Tuy9997x29/+NhtWVVVV8emnn8b1119fK1SKYb/99otBgwZFRMSaNWti9OjRdZ730UcfxSeffJJ9XN+lAZNU8/MoIrZ53+aafCa1XDomOTomN2lrGR1TGDqm4dLeMRFahsbRMsnRMg2Xto6J0DKFomUaLu0to2NoDB2THB2Tm7S1jI4pDB3TcGnvmIh0toyFHbJq3peuTZs29Z67YcOG7PHml2hj2x599NH48MMP4/vf/37JbEBfdtllMWHChLj11lvj8MMPz/762rVr48ILL4wlS5YUZa4xY8bExx9/HDfeeGNRXr+pDjvssHjkkUdi7733johNH7zFuHzhvHnzsscHH3xwnZeA22effeIHP/hBRGwK2V/84heJzdcQU6ZMiUwmU2u7vJjWr18ft956a+y+++5xzTXXZN8Lp0+fHt/85jdr/ZkXw8033xwHHHBARGx6z7nllluyAbV48eKYMGFCnHnmmdnzu3XrFl26dCnGqFuo+XkUUf/nTGVlZYPPpXnTMcnRMblJc8vomPzRMblJc8dEaBkaR8skR8s0XJo7JkLL5JOWyU2aW0bH0Bg6Jjk6Jjdpbhkdkz86Jjdp7piIdLaMhR2yal4Sqvr+l1tTczutQ4cOBZupOfrggw9i7Nixccghh8SwYcOKPU5W27ZtY7fddovTTz89Jk2aFKNHj85uHa5ZsyYmTZqU+EwvvfRSTJw4MUaPHl3r3rZps/POO8cDDzyQvRzoCy+8kPh9EKs32yPq33Q966yzasXBBx98UPDZGuqZZ56Jtm3bxoknnljsUWLNmjXxve99L2bMmBG/+tWv4txzz42JEydG165dI2LTvXrPOeecWvdvTlqnTp3i0UcfjUsuuSR23XXXePDBB+OII46II444Iq666qpo3759nHzyydnzv/jFLxZt1s1tfonC+j6Tal7asK6vpeXQMcnQMblpDi2jY/JDx+QmzR0ToWVoHC2TDC3TcM2hYyK0TL5omdykuWV0DI2hY5KhY3LTHFpGx+SHjslNmjsmIp0tY2GHrN133z17vHbt2nrPrXlv0T322KNgMzU3lZWV8aMf/Sg6deoUY8eO3ea2eTF99atfjauuuir7+NVXX0309ZcvXx4jRoyIYcOGxcEHH5zoaxdC9+7ds/eeXL16da3ISUJZWVn2uL4fhDp27BgHHXRQ9vFbb71V0LkaasGCBTFz5sw45phjolOnTkWdpaqqKi699NJ49dVX46abbsrG8qGHHhqPP/54dO/ePSI2XRLwhz/8YWzcuLFos26//fYxbNiwePHFF+Pll1+OP//5z/Hyyy/HQw89FN/85jfjxRdfzJ57+umnF23Oze2www6x0047ZR9/+umnWz13xYoV2eOuXbvmdNldmhcdU3g6JjfNqWV0TNPomMZJa8dEaBkaR8sUnpZpuObUMRFapqm0TOOktWV0DI2hYwpPx+SmObWMjmkaHdM4ae2YiHS2jIUdsvbbb7/s8bYuUVfzA6FXr14Fm6m5ueWWW+Ldd9+Ne++9N3bZZZdij7NN3/zmN7P3c0w6Ah5//PFYunRpjB49Onr37l3nP1/+8pez5995553ZXx83blyiszZUzcvtJR3UNe/Lufkl3jZX83t6zZo1BZspFxUVFRERceqppxZ5koinn346pk2bFuXl5XHYYYfVeq5Hjx4xceLE7A+ps2bNiueee64YY26ha9eu8fnPfz57OcBp06ZlL614+OGHb/H/pdga+pnk84hqOqbwdExumlvL6JjG0zFNl7aOidAy5E7LFJ6Wabjm1jERWqYptEzTpa1ldAy50jGFp2Ny09xaRsc0no5purR1TET6WsbCDlkDBgzIHi9cuHCr5y1dujR72cLddtstunXrVvDZmoOJEyfG448/HnfddVfJ3Ft0W1q3bh3HHHNMRETilwyseS/b5mLfffeNiE2Xk0t6k7dHjx7Z42390NS5c+c6j4vpmWeeifbt28eXvvSlYo+SvYTnIYccUufz3bp1i3HjxmXj5fnnn09stoaqqqqK0aNHR8Sm7/MRI0YUeaIt1bzfcX2fSTWfK8UwJDk6prB0TO6aW8vomMbTMfmVho6J0DLkTssUlpbJTXPrmAgt0xRaJr/S0DI6hlzpmMLSMblrbi2jYxpPx+RXGjomIn0tU7rXTCNxPXr0iPLy8njnnXdi7ty5sX79+mjXrt0W582ZMyd7XAr3+0uDZ599NkaNGhW33XZbHHnkkcUeJyfV96Q84IADEn3db33rW7W2huvy4Ycfxne+853s+dWXBezSpUuhx2uU6kisubmdlGOPPTZatWoVVVVV8frrr9d7bvX9HMvKyqJfv34JTFe/uXPnxttvvx0nn3xy9hKBxfTuu+9GRP3/nR144IFx7LHHxtSpU2PZsmVJjdZgDz/8cMyaNSsiIs4///zo379/kSfa0le+8pW45557IiJi9uzZWz2v5mfSoEGDCj4XpUvHFI6OaZzm1jI6pnF0TP6loWMitAy50zKFo2Vy19w6JkLLNJaWyb80tIyOIVc6pnB0TOM0t5bRMY2jY/IvDR0Tkb6WcYUdajn33HMjYtNlzV577bU6z6l+Q27VqlUMHjw4qdFSa+rUqTF8+PC49tpr46STTtrqeZlMJsGpGq76A+G0005L9HW7du0aPXv2rPefPffcM3t+ly5dsr/etWvXRGdtqDfffDNat26djcAkde3aNY499tjsHEuXLt3quYsWLYqIiKOPProk/iyfeeaZiNh079tSUH2f1o8++qje86ovn1dqlyh97bXXshvQAwcOjMsuu6zIE9WtX79+2Y3mV155ZavvkdWfSYccckj06dMnqfEoUTom/3RM4zW3lnJ7B38AAA1BSURBVNExjaNj8istHROhZWgcLZN/WqZxmlvHRGiZxtIy+ZWWltExNIaOyT8d03jNrWV0TOPomPxKS8dEpK9lLOxQy9e+9rXo2bNnRERMmTKlznOq75l3xhlnZM8tBRs3boyITZfjKhV//vOfY9iwYXHppZfWG6AbNmyIiy66KFasWJHgdNu2du3amDp1apx44okua5oHDzzwQFxwwQVFu2zl8OHDo3Xr1rFhw4bspfc29+mnn8ZLL70UrVq1imHDhiU8Yd0qKiqiY8eOcdxxxxV7lIiI7KUTp02bVu+lNRcvXhwRxdl635oZM2bEhRdeGJWVlTFw4MC44447spdXTEou79U/+tGPoqysLBYvXhz/93//t8Xzf//73+P999/Pngs6Jr90DDXpmMbRMflTCh0ToWUoLC2TX1qGmrRM42iZ/CmFltExFJKOyS8dQ006pnF0TP6UQsdENN+WsbBDLe3atYtRo0ZF27Zt46mnnooFCxbUer6ioiJmz54dPXr0iCuvvLJIU9Zt1apVtf632F544YW46KKL4sQTT4wvf/nLMXfu3C3+mTVrVkyZMiXOOeec2HHHHWOnnXZKbL4PPvggRo0aFRMmTKjzz6yqqiquv/762H333ePmm29ObK40Wr58eYwYMSKuuuqqeO+99+o854477ohdd921qBun5eXlccUVV0RExEMPPRQzZ87c4pxRo0bFqlWr4uKLL46DDz444Qm3NHv27HjvvffihBNOqPMyqsVw8cUXR5cuXWLx4sUxbty4Os9544034tlnn40vfOELccIJJyQ84Zaqqqrisccei3POOSdWr14d3/ve9+LOO++M7bbbLvFZcnmvPvzww7N/a+Duu++utQWdyWRizJgxERHxne98J4444oj8D0vq6Jj80TEth44pHB2TH6XUMRFahsLSMvmjZVoOLVM4WiY/SqlldAyFpGPyR8e0HDqmcHRMfpRSx0Q035ZpU9RXpyQdcMABMW7cuPjhD38Y559/fowcOTL23HPPmDJlStx5553Ru3fvuPvuu6Nz587FHjVWr14dH3/8cVRUVMSaNWsiYtM9AJ988sk46qijonPnzkW5L+Fzzz0XP/7xj6OysjImT54ckydP3ubXXHrppQlM9i8TJ06MBx98MCIi7rrrrjj33HNj4MCB8fnPfz7mzZsX999/f+yyyy7xyCOPlMS9HUvZO++8E0899VREbLrEXvX9UXfeeefsc4cffnhJXB7uu9/9bnzyyScxfvz4GDp0aAwfPjyOOOKIWLVqVTz44IPxzDPPxIUXXhiXXHJJsUeNiH9dsnBb95tN0q677hoPPvhgDB06NMaPHx8LFy6MIUOGRPfu3WPJkiUxderUeOCBB2LAgAExduzYosy4YcOGmD9/fixZsiRefvnlmDx5cixatCh69+4dV199deL3O27Ke/UVV1wRK1asiN/97ndx9dVXx/e///1Yu3Zt3HnnnTF16tQ477zzSu6HfIpLxzSdjmlZdEzh6JjGKbWOidAyJEvLNJ2WaVm0TOFomcYptZbRMSRJxzSdjmlZdEzh6JjGKbWOiWgZLVOWKdWbG1J08+bNi/Hjx8crr7wSy5cvj169esWZZ54ZgwcPjrZt2xZ7vIiIGDp0aEydOnWrz59//vlx+eWXJzdQRMycOTMGDx6cvSxXQ3Tr1i3+9Kc/RVlZWQEnq2358uXx85//PP7617/GsmXLoqysLDp37hzdu3ePI444Ik477bTsfRJL1cKFC7OXhLvkkkuKepm9J598MiZNmhTvvfdebNiwIXbeeefYd999Y9CgQXHSSSdFp06dijZbXV5++eV4+OGH4/XXX49PP/00dt555xgwYEAMGTIk+vfvX+zxsr70pS/Fp59+GtOmTYs2bUprx3T16tUxadKk+NOf/hT/+Mc/Yu3atbHTTjvFgQceGF/72tdi0KBBRbkkYETEW2+9FWeccUbssMMOsccee8RBBx0UJ598chx99NFFmSkf79VTpkyJiRMnxrvvvhtlZWUxYMCA+N73vueSqmyVjmkcHZOsUmkZHVMYOqZxSq1jIrQMxaFlGkfLJKdUOiZCyxSKlmmcUmsZHUMx6JjG0THJKpWW0TGFoWMap9Q6JqJltIyFHQAAAAAAAAAASFBxVqEAAAAAAAAAAKCFsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJsrADAAAAAAAAAAAJalPsAQDSbvXq1fFv//ZvkclkmvT7jBkzJk455ZQ8TQUA0DBaBgBIKx0DAKSZlgFcYQegiWbNmtXkmIqI6N+/fx6mAQDIjZYBANJKxwAAaaZlAAs7AE00a9asJv8en/vc56J79+55mAYAIDdaBgBIKx0DAKSZlgHcEgugiTYPqquuuipOOOGEnH6Pdu3a5XMkAIAG0zIAQFrpGAAgzbQMYGEHoIk2D6ojjzzSNjMAkBpaBgBIKx0DAKSZlgHcEgugCdasWRPvv/9+9vF2220XvXr1KuJEAAANp2UAgLTSMQBAmmkZIMLCDkCTvPXWW1FVVZV93Lt372jTxsXLAIB00DIAQFrpGAAgzbQMEGFhB6BJNr9cYb9+/Yo0CQBA7rQMAJBWOgYASDMtA0RY2AFoEkEFAKSZlgEA0krHAABppmWACAs7AE0ye/bsWo8FFQCQJloGAEgrHQMApJmWASIs7AA02tq1a2PevHnZx23bto399tuviBMBADSclgEA0krHAABppmWAahZ2ABrp73//e2zcuDH7uLy8PNq2bVvEiQAAGk7LAABppWMAgDTTMkC1NsUeACCtNr+/6KxZs6J3794N/vrTTz89br311nyPBQDQIFoGAEgrHQMApJmWAaq5wg5AI20eVLk66KCD8jQJAEDutAwAkFY6BgBIMy0DVLOwA9BITQ2q/v3752kSAIDcaRkAIK10DACQZloGqOaWWACNsG7dupg7d2728Q477BBPP/10Tr/HHnvske+xAAAaRMsAAGmlYwCANNMyQE0WdgAa4e23344NGzZkH++///7RvXv3Ik4EANBwWgYASCsdAwCkmZYBanJLLIBGePPNN2s97tOnT5EmAQDInZYBANJKxwAAaaZlgJos7AA0wuzZs2s9FlQAQJpoGQAgrXQMAJBmWgaoycIOQCPMmjWr1uO+ffsWaRIAgNxpGQAgrXQMAJBmWgaoycIOQI7Wr18f7777bvZxmzZtYr/99iviRAAADadlAIC00jEAQJppGWBzFnYAcvTOO+9EZWVl9nHPnj2jXbt2RZwIAKDhtAwAkFY6BgBIMy0DbM7CDkCONr+/qMsVAgBpomUAgLTSMQBAmmkZYHMWdgBy9Oabb9Z6vP/++xdpEgCA3GkZACCtdAwAkGZaBtichR2AHNmABgDSTMsAAGmlYwCANNMywOYs7ADkYMOGDfH222/X+rU+ffoUaRoAgNxoGQAgrXQMAJBmWgaoi4UdgBzMmTMn1q9fn33cvXv36NixYxEnAgBoOC0DAKSVjgEA0kzLAHWxsAOQg83vL+pyhQBAmmgZACCtdAwAkGZaBqiLhR2AHGx+f1GXKwQA0kTLAABppWMAgDTTMkBdLOwA5GDWrFm1HgsqACBNtAwAkFY6BgBIMy0D1KUsk8lkij0EAAAAAAAAAAC0FK6wAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACbKwAwAAAAAAAAAACfp/JMRBQ5W9Q54AAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 2250x2250 with 16 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.ticker import MultipleLocator, ScalarFormatter\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from matplotlib.font_manager import FontProperties\n",
    "# ==================== 三、字体与样式配置（学术版） ====================\n",
    "from matplotlib.font_manager import FontProperties, FontManager, findfont, FontProperties\n",
    "# 仅保留一次字体设置\n",
    "plt.rc('font', family='Times New Roman', serif=['Times New Roman'])\n",
    "plt.rcParams.update({\n",
    "    'axes.unicode_minus': False,\n",
    "    'xtick.direction': 'in',\n",
    "    'ytick.direction': 'in',\n",
    "    'axes.linewidth': 0.8,\n",
    "    'lines.linewidth': 1.0\n",
    "})\n",
    "\n",
    "# ==================== 一、参数配置区 ====================\n",
    "# 1.1 基础筛选参数（固定值）\n",
    "FILTER_PARAMS = {\n",
    "    'L': {'value': 3000, 'unit': 'mm', 'name': '长度 $L$'},\n",
    "    'meshsz': {'value': 40, 'unit': 'mm', 'name': '网格尺寸'},\n",
    "    'sfricn': {'value': 0.35, 'unit': '', 'name': '摩擦系数'},\n",
    "#     'F': {'value': 1, 'unit': '', 'name': '螺栓数量'},\n",
    "    'pbol': {'value': 125000.0, 'unit': '', 'name': '预紧力'},\n",
    "    'yfss': {'value': 355.61, 'unit': 'MPa', 'name': '屈服强度'},\n",
    "    'Imperfectfactor': {'value': 0.002, 'unit': '', 'name': '初始缺陷系数'},\n",
    "    'cf1f': {'value': 0, 'unit': '', 'name': '系数1'},\n",
    "    'cf2f': {'value': 1, 'unit': '', 'name': '系数2'},\n",
    "    'cf3f': {'value': 0, 'unit': '', 'name': '系数3'}\n",
    "}\n",
    "#  {'meshsz', 'cf1f', 'Pcf1ff', 'cf3f', 'yfss', 'n', 'T2', 'Pucf1f', 'type', 'yuss', 'Pucf3f', 'pbol', 'Pcf1f', \n",
    "#   'L', 'B', 'cf2f', 'Pcf3f', \n",
    "#   'Imperfectfactor', 'yfsn', 'EigenValue', 'H', 'Pcf2ff', 'sfricn', 'Pcf3ff', 'T1', 'Pcf2f', 'Pucf2f', 'yusn'}\n",
    "# 1.2 分组参数（用于创建子图）\n",
    "SUBPLOT_PARAMS = {\n",
    "    'H': {'name': '高度 $H$', 'unit': 'mm'},\n",
    "    'B': {'name': '宽度 $B$', 'unit': 'mm'},\n",
    "    'T1': {'name': '厚度 $T_1$', 'unit': 'mm'},\n",
    "    'T2': {'name': '厚度 $T_2$', 'unit': 'mm'}\n",
    "}\n",
    "\n",
    "# 1.3 绘图参数（X轴、Y轴、颜色映射）\n",
    "PLOT_PARAMS = {\n",
    "    'F': {\n",
    "        'name': '$F$',\n",
    "        'unit': '',\n",
    "        'ticks': [0,1,2,3,4,5,6,7,8,9,10]\n",
    "    },\n",
    "#     'Imperfectfactor': {\n",
    "#         'name': 'Imperfectfactor',\n",
    "#         'unit': '',\n",
    "#         'ticks': [0.002, 0.005, 0.01, 0.02]\n",
    "#     },\n",
    "#     'sfricn': {\n",
    "#         'name': 'sfricn',\n",
    "#         'rate_name': '$\\\\mu$',\n",
    "#         'unit': '',\n",
    "#         'ticks': [0.3, 0.35, 0.4, 0.45]\n",
    "#     },\n",
    "#     'yfss': {\n",
    "#         'name': 'yfss',\n",
    "#         'rate_name': '$f_\\mathrm{y}$',\n",
    "#         'unit': 'MPa',\n",
    "#         'ticks': [355.61, 461.03]\n",
    "#     },\n",
    "#     'Pucf2f': {\n",
    "#         'name': '承载力 $P_{\\\\mathrm{ucf2f}}$',\n",
    "#         'rate_name': '承载力变化率',\n",
    "#         'unit': 'kN',\n",
    "#         'rate_unit': '%',\n",
    "#         'ticks': []\n",
    "#     },\n",
    "    'SFcf2f': {\n",
    "        'name': '$\\\\alpha$',\n",
    "        'rate_name': '稳定系数变化率',\n",
    "        'unit': '',\n",
    "        'rate_unit': '%',\n",
    "        'ticks': [0,0.5,1.0,1.2],\n",
    "#         'ticks': []\n",
    "        \n",
    "    },\n",
    "#     'Bcf2f': {\n",
    "#         'name': '屈曲荷载 $B_{\\\\mathrm{cf2f}}$',\n",
    "#         'rate_name': 'Bcf2f变化率',\n",
    "#         'unit': 'kN',\n",
    "#         'rate_unit': '%',\n",
    "#         'ticks': []\n",
    "#     },\n",
    "#     'SLcf2f': {\n",
    "#         'name': '$\\\\lambda$',\n",
    "#         'rate_name': '正则化长细比变化率',\n",
    "#         'unit': '',\n",
    "#         'rate_unit': '%',\n",
    "#         'ticks': [0, 0.2,0.4,0.6,0.8,1.0],\n",
    "# #         'ticks': []\n",
    "        \n",
    "#     },\n",
    "    'n': {\n",
    "        'name': '$n$',\n",
    "        'unit': '',\n",
    "        'ticks': [1, 2, 3, 4, 5, 6]\n",
    "    }\n",
    "}\n",
    "\n",
    "param_config = {**FILTER_PARAMS, **SUBPLOT_PARAMS, **PLOT_PARAMS}\n",
    "# ==================== 二、全局绘图参数 ====================\n",
    "plot_params = {\n",
    "    'pointsize': 6,          # 散点大小\n",
    "    'textsize': 10,          # 基础字体大小\n",
    "    'label_size': 10,        # 轴标签字体大小\n",
    "    'tick_size': 8,          # 刻度标签字体大小\n",
    "    'legend_size': 9,        # 图例字体大小\n",
    "    'figsizex': 7.5,         # 宽度\n",
    "    'figsizey': 7.5,           # 高度\n",
    "    'color_map': 'plasma',   # 学术配色\n",
    "    'subplot_rows': 4,\n",
    "    'subplot_cols': 4,\n",
    "    'dpi': 300,              # 打印分辨率\n",
    "    'alpha': 0.9,            # 散点透明度\n",
    "    'border_pad': 0.5,       # 子图边距\n",
    "    'buffer_ratio': 0.1      # 自动刻度时的缓冲比例\n",
    "}\n",
    "\n",
    "# ==================== 三、字体与样式配置（学术版） ====================\n",
    "# 中文字体（宋体-学术论文标准字体）\n",
    "font_standard = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=plot_params['textsize'])\n",
    "# 西文字体（Times New Roman-学术常用）\n",
    "plt.rc('font', family='serif', serif='Times New Roman')\n",
    "plt.rcParams.update({\n",
    "    'axes.unicode_minus': False,    # 正确显示负号\n",
    "    'xtick.direction': 'in',        # 刻度向内\n",
    "    'ytick.direction': 'in',\n",
    "    'axes.linewidth': 0.8,          # 坐标轴粗细\n",
    "    'lines.linewidth': 1.0          # 连线粗细\n",
    "})\n",
    "\n",
    "\n",
    "# ==================== 四、数据检查函数 ====================\n",
    "def check_duplicate_x(sub_df, div_colandlegend_para, x_aixs_para, y_aixs_para, rate_mode):\n",
    "    \"\"\"检查同一颜色组内是否存在重复x值对应多个y值的情况\"\"\"\n",
    "    duplicate_found = False\n",
    "    tolerance = 1e-5\n",
    "    \n",
    "    # 打印当前子图的总数据量\n",
    "    print(f\"\\n当前子图总数据量: {len(sub_df)} 行\")\n",
    "    \n",
    "    # 打印筛选参数值\n",
    "    filter_values = []\n",
    "    for param in FILTER_PARAMS:\n",
    "        if param in sub_df.columns and len(sub_df[param].unique()) == 1:\n",
    "            value = sub_df[param].iloc[0]\n",
    "            filter_values.append(f\"{param}={value}\")\n",
    "    print(f\"筛选参数: {', '.join(filter_values)}\")\n",
    "    \n",
    "    # 打印分组参数值\n",
    "    group_values = []\n",
    "    for param in SUBPLOT_PARAMS:\n",
    "        if param in sub_df.columns and len(sub_df[param].unique()) == 1:\n",
    "            value = sub_df[param].iloc[0]\n",
    "            group_values.append(f\"{param}={value}\")\n",
    "    print(f\"分组参数: {', '.join(group_values)}\")\n",
    "    \n",
    "    for color_value in sub_df[div_colandlegend_para].unique():\n",
    "        color_group = sub_df[sub_df[div_colandlegend_para] == color_value].copy()\n",
    "        \n",
    "        # 打印当前颜色组数据量\n",
    "        print(f\"\\n颜色组 {div_colandlegend_para}={color_value}: {len(color_group)} 行数据\")\n",
    "        \n",
    "        # 浮点数精度处理\n",
    "        if pd.api.types.is_float_dtype(color_group[x_aixs_para]):\n",
    "            color_group['x_rounded'] = color_group[x_aixs_para].round(5)\n",
    "            x_col = 'x_rounded'\n",
    "        else:\n",
    "            x_col = x_aixs_para\n",
    "            \n",
    "        if rate_mode:\n",
    "            min_x_idx = color_group[x_aixs_para].idxmin()\n",
    "            color_reference_value = color_group.at[min_x_idx, y_aixs_para]\n",
    "            color_group['y_rate'] = ((color_group[y_aixs_para] - color_reference_value) / \n",
    "                                    (color_reference_value + 1e-10)) * 100  # 避免除零\n",
    "            check_y = 'y_rate'\n",
    "        else:\n",
    "            check_y = y_aixs_para\n",
    "\n",
    "        x_groups = color_group.groupby(x_col)\n",
    "        group_duplicates = False\n",
    "        \n",
    "        for x_val, group in x_groups:\n",
    "            if len(group) > 1:\n",
    "                duplicate_found = True\n",
    "                group_duplicates = True\n",
    "                print(f\"\\n{'='*80}\")\n",
    "                print(f\"警告：颜色组 {div_colandlegend_para}={color_value} 中发现重复x值 (x={x_val:.4f})\")\n",
    "                print(f\"重复数据量: {len(group)} 行\")\n",
    "                print(f\"重复数据摘要:\")\n",
    "                \n",
    "                # 显示关键列信息\n",
    "                display_cols = [x_aixs_para, y_aixs_para] + list(FILTER_PARAMS.keys()) + list(SUBPLOT_PARAMS.keys())\n",
    "                display_cols = [col for col in display_cols if col in group.columns]\n",
    "                \n",
    "                # 打印重复数据摘要\n",
    "                print(group[display_cols].head(2))\n",
    "                \n",
    "                # 打印导致差异的参数\n",
    "                diff_params = []\n",
    "                for col in group.columns:\n",
    "                    if col not in [x_aixs_para, div_colandlegend_para] and len(group[col].unique()) > 1:\n",
    "                        unique_vals = group[col].unique()\n",
    "                        diff_params.append(f\"{col}: {unique_vals}\")\n",
    "                \n",
    "                if diff_params:\n",
    "                    print(\"\\n导致差异的参数:\")\n",
    "                    for param in diff_params:\n",
    "                        print(f\"  {param}\")\n",
    "                else:\n",
    "                    print(\"\\n未发现明显导致差异的参数，请检查数据源\")\n",
    "                \n",
    "                print(f\"{'='*80}\")\n",
    "        \n",
    "        if not group_duplicates:\n",
    "            print(f\"颜色组 {div_colandlegend_para}={color_value} 未发现重复x值\")\n",
    "    \n",
    "    if not duplicate_found:\n",
    "        print(f\"\\n{'='*80}\")\n",
    "        print(f\"数据检查通过：当前子图未发现重复x值对应多y值的情况\")\n",
    "        print(f\"{'='*80}\")\n",
    "    \n",
    "    return duplicate_found\n",
    "\n",
    "# ==================== 五、散点图绘制函数 ====================\n",
    "def draw_scatter_subplot(ax, sub_df, x_key, y_key, color_key, rate_mode, vmin, vmax):\n",
    "    x_param = param_config[x_key]\n",
    "    y_param = param_config[y_key]\n",
    "    color_param = param_config[color_key]\n",
    "    buffer_ratio = plot_params['buffer_ratio']\n",
    "    \n",
    "    # 根据模式选择不同的标签参数\n",
    "    # 根据模式选择不同的标签参数\n",
    "    if rate_mode:\n",
    "        # 比率模式：Y轴和颜色使用 rate 相关参数\n",
    "        y_label = f\"{y_param['rate_name']} ({y_param['rate_unit']})\" if 'rate_unit' in y_param and y_param['rate_unit'] else y_param['rate_name']\n",
    "\n",
    "    else:\n",
    "        # 非比率模式：Y轴和颜色使用基础参数\n",
    "        y_label = f\"{y_param['name']} ({y_param['unit']})\" if y_param['unit'] else y_param['name']\n",
    "    color_label_name = color_param['name']\n",
    "\n",
    "    # X轴：无论何种模式，都使用基础的 name 和 unit（更清晰、统一）\n",
    "    x_label = f\"{x_param['name']} ({x_param['unit']})\" if x_param['unit'] else x_param['name']\n",
    "    unique_colors = sorted(sub_df[color_key].unique())\n",
    "    all_y_data = []\n",
    "    \n",
    "    # ---------------------- X轴刻度处理 ----------------------\n",
    "    x_ticks = x_param.get('ticks', [])\n",
    "    # 判断是否使用自定义刻度（ticks存在且非空）\n",
    "    if x_ticks and len(x_ticks) >= 2:\n",
    "        # 自定义刻度：完全使用原始值，不做放大缩小和格式转换\n",
    "        ax.set_xlim(min(x_ticks), max(x_ticks))  # 直接使用刻度的最小最大值\n",
    "        ax.xaxis.set_major_locator(plt.FixedLocator(x_ticks))  # 强制使用设定的刻度值\n",
    "        # 移除固定小数位数设置，保持原始数值格式\n",
    "        # （matplotlib会自动根据原始数据类型显示，整数保持整数，小数保持原精度）\n",
    "    else:\n",
    "        # 自动计算刻度（根据数据）\n",
    "        x_data = sub_df[x_key].values\n",
    "        if x_data.size > 0:\n",
    "            x_min, x_max = x_data.min(), x_data.max()\n",
    "            x_lim_min = x_min - (x_max - x_min) * buffer_ratio if x_max != x_min else x_min * (1 - buffer_ratio)\n",
    "            x_lim_max = x_max + (x_max - x_min) * buffer_ratio if x_max != x_min else x_max * (1 + buffer_ratio)\n",
    "            ax.set_xlim(x_lim_min, x_lim_max)\n",
    "        else:\n",
    "            ax.set_xlim(0, 1)\n",
    "    \n",
    "    # ---------------------- Y轴刻度处理 ----------------------\n",
    "    # 获取y轴数据（区分模式）\n",
    "    if rate_mode:\n",
    "        # 比率模式：使用计算后的变化率数据\n",
    "        for n_val in unique_colors:\n",
    "            group = sub_df[sub_df[color_key] == n_val].sort_values(x_key)\n",
    "            if group.empty:\n",
    "                continue\n",
    "            y_data = group[y_key].values\n",
    "            ref_val = y_data[0] if len(y_data) > 0 else 0\n",
    "            if abs(ref_val) < 1e-10:\n",
    "                y_rate = np.zeros_like(y_data)\n",
    "            else:\n",
    "                y_rate = ((y_data - ref_val) / ref_val * 100)\n",
    "            all_y_data.extend(y_rate)\n",
    "        y_data_all = np.array(all_y_data)\n",
    "    else:\n",
    "        # 非比率模式：使用原始数据\n",
    "        y_data_all = sub_df[y_key].values\n",
    "    \n",
    "    y_ticks = y_param.get('ticks', [])\n",
    "    # 判断是否使用自定义刻度（ticks存在且非空）\n",
    "    if y_ticks and len(y_ticks) >= 2:\n",
    "        y_tick_min = min(y_ticks)\n",
    "        y_tick_max = max(y_ticks)\n",
    "        y_lim_min = y_tick_min * (1 - buffer_ratio)\n",
    "        y_lim_max = y_tick_max * (1 + buffer_ratio)\n",
    "        ax.set_ylim(y_lim_min, y_lim_max)\n",
    "        ax.yaxis.set_major_locator(plt.FixedLocator(y_ticks))\n",
    "        ax.yaxis.set_major_formatter(plt.FormatStrFormatter('%.2f'))\n",
    "    else:\n",
    "        # 自动计算刻度（根据数据）\n",
    "        if y_data_all.size > 0:\n",
    "            y_min, y_max = y_data_all.min(), y_data_all.max()\n",
    "            y_lim_min = y_min - (y_max - y_min) * buffer_ratio if y_max != y_min else y_min * (1 - buffer_ratio)\n",
    "            y_lim_max = y_max + (y_max - y_min) * buffer_ratio if y_max != y_min else y_max * (1 + buffer_ratio)\n",
    "            ax.set_ylim(y_lim_min, y_lim_max)\n",
    "        else:\n",
    "            ax.set_ylim(0, 1)\n",
    "    \n",
    "    # ---------------------- 颜色映射处理 ----------------------\n",
    "    norm = plt.Normalize(vmin, vmax)\n",
    "    cmap = plt.get_cmap(plot_params['color_map'])\n",
    "    \n",
    "    # 绘制散点和连线\n",
    "    for n_val in unique_colors:\n",
    "        group = sub_df[sub_df[color_key] == n_val].sort_values(x_key)\n",
    "        if group.empty:\n",
    "            continue\n",
    "            \n",
    "        x_data = group[x_key].values\n",
    "        y_data = group[y_key].values\n",
    "        \n",
    "        # 处理变化率计算（仅在比率模式下）\n",
    "        if rate_mode:\n",
    "            ref_val = y_data[0] if len(y_data) > 0 else 0\n",
    "            if abs(ref_val) < 1e-10:\n",
    "                y_data = np.zeros_like(y_data)\n",
    "            else:\n",
    "                y_data = ((y_data - ref_val) / ref_val * 100)\n",
    "        \n",
    "        # 绘制散点和连线\n",
    "        color = cmap(norm(n_val))\n",
    "        ax.scatter(x_data, y_data, c=[color], s=plot_params['pointsize'], \n",
    "                  alpha=plot_params['alpha'], edgecolor='w', linewidth=0.3)\n",
    "        ax.plot(x_data, y_data, c=color, linewidth=0.8, linestyle='--')\n",
    "        \n",
    "        # 添加标签\n",
    "        if len(x_data) > 0:\n",
    "            x_end = x_data[-1]\n",
    "            y_end = y_data[-1] if len(y_data) > 0 else 0\n",
    "\n",
    "            y_lim = ax.get_ylim()\n",
    "            y_total_range = y_lim[1] - y_lim[0]\n",
    "            y_offset = y_total_range * 0.03\n",
    "            target_y = y_end + y_offset\n",
    "\n",
    "            if target_y > y_lim[1]:\n",
    "                target_y = y_end - y_offset\n",
    "                va = 'top'\n",
    "            else:\n",
    "                va = 'bottom'\n",
    "\n",
    "            if target_y < y_lim[0]:\n",
    "                target_y = y_lim[0] + y_total_range * 0.02\n",
    "                va = 'bottom'\n",
    "\n",
    "            # 使用对应模式的标签名称\n",
    "            print('text',f\"{color_label_name}={int(n_val)}\", )\n",
    "            ax.text(\n",
    "                x_end, target_y, \n",
    "                f\"{color_label_name}={int(n_val)}\", \n",
    "                color=color, \n",
    "                fontsize=plot_params['tick_size']*2/3, \n",
    "                ha='right',\n",
    "                va=va,\n",
    "                clip_on=True\n",
    "            )\n",
    "\n",
    "    # 设置坐标轴标签\n",
    "    ax.set_xlabel(x_label, fontname='Times New Roman', fontsize=plot_params['label_size'])\n",
    "    ax.set_ylabel(y_label, font=font_standard, fontsize=plot_params['label_size'])\n",
    "    \n",
    "    # 刻度样式\n",
    "    ax.tick_params(axis='both', which='major', labelsize=plot_params['tick_size'], \n",
    "                  top=False, right=False, length=3, width=0.8)\n",
    "    ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n",
    "    \n",
    "    # 隐藏上/右边框\n",
    "    ax.spines['top'].set_visible(False)\n",
    "    ax.spines['right'].set_visible(False)\n",
    "\n",
    "# ==================== 六、主绘图函数（自动使用PLOT_PARAMS前三个键） ====================\n",
    "def generate_subplots(df, rate_mode=True, exclude_combinations=None):\n",
    "    # 自动获取PLOT_PARAMS的前三个键作为x、y、color参数\n",
    "    plot_keys = list(PLOT_PARAMS.keys())  # 获取PLOT_PARAMS的键（按定义顺序）\n",
    "    if len(plot_keys) < 3:\n",
    "        raise ValueError(\"PLOT_PARAMS至少需要包含3个参数（x、y、color）\")\n",
    "    \n",
    "    x_key = plot_keys[0]    # 第一个键作为x轴\n",
    "    y_key = plot_keys[1]    # 第二个键作为y轴\n",
    "    color_key = plot_keys[2]# 第三个键作为颜色映射\n",
    "    \n",
    "    print(f\"自动使用参数配置：x={x_key}, y={y_key}, color={color_key}\")\n",
    "\n",
    "    # 设置默认排除列表\n",
    "    if exclude_combinations is None:\n",
    "        exclude_combinations = []\n",
    "    else:\n",
    "        exclude_combinations = [tuple(comb) for comb in exclude_combinations]\n",
    "    \n",
    "    # 数据筛选（增加浮点数容差）\n",
    "    filtered_df = df.copy()\n",
    "    for col, info in FILTER_PARAMS.items():\n",
    "        if col in filtered_df.columns:\n",
    "            if pd.api.types.is_float_dtype(filtered_df[col]):\n",
    "                filtered_df = filtered_df[np.isclose(filtered_df[col], info['value'], atol=1e-5)]\n",
    "            else:\n",
    "                filtered_df = filtered_df[filtered_df[col] == info['value']]\n",
    "    print(f\"筛选后有效数据量: {len(filtered_df)}\")\n",
    "\n",
    "    # 动态分组（根据实际参数值生成子图）\n",
    "    group_params = list(SUBPLOT_PARAMS.keys())  # 顺序为['H', 'B', 'T1', 'T2']\n",
    "    sub_dfs = [filtered_df]\n",
    "    for param in group_params:\n",
    "        sub_dfs = [sub[sub[param]==val].reset_index(drop=True) \n",
    "                  for sub in sub_dfs \n",
    "                  for val in sorted(sub[param].unique())  # 强制排序\n",
    "                  if not sub.empty]\n",
    "    \n",
    "    # 过滤需要删除的子图组合\n",
    "    filtered_sub_dfs = []\n",
    "    for sub_df in sub_dfs:\n",
    "        if sub_df.empty:\n",
    "            continue\n",
    "        current_comb = tuple([sub_df[p].iloc[0] for p in group_params])\n",
    "        if current_comb not in exclude_combinations:\n",
    "            filtered_sub_dfs.append(sub_df)\n",
    "        else:\n",
    "            print(f\"已排除子图: H={current_comb[0]}, B={current_comb[1]}, T1={current_comb[2]}, T2={current_comb[3]}\")\n",
    "    \n",
    "    print(f\"过滤后剩余子图数量: {len(filtered_sub_dfs)}\")\n",
    "    \n",
    "\n",
    "    # 获取全局颜色范围（支持自定义ticks或自动计算）\n",
    "    color_param = param_config[color_key]\n",
    "    color_ticks = color_param.get('ticks', [])\n",
    "    if color_ticks and len(color_ticks) >= 2:\n",
    "        vmin, vmax = min(color_ticks), max(color_ticks)\n",
    "    else:\n",
    "        # 自动计算颜色范围\n",
    "        vmin = filtered_df[color_key].min()\n",
    "        vmax = filtered_df[color_key].max()\n",
    "\n",
    "    # 创建画布\n",
    "    fig, axes = plt.subplots(plot_params['subplot_rows'], plot_params['subplot_cols'],\n",
    "                            figsize=(plot_params['figsizex'], plot_params['figsizey']),\n",
    "                            dpi=plot_params['dpi'], constrained_layout=True)\n",
    "    axes = axes.flatten()\n",
    "\n",
    "    # 绘制子图\n",
    "    for idx, (ax, sub_df) in enumerate(zip(axes, filtered_sub_dfs)):\n",
    "        if len(sub_df) < 5: \n",
    "            ax.set_visible(False)\n",
    "            continue\n",
    "        \n",
    "        print(f\"\\n绘制子图 {idx+1}/{len(filtered_sub_dfs)}\")\n",
    "        check_duplicate_x(sub_df, color_key, x_key, y_key, rate_mode)\n",
    "        draw_scatter_subplot(ax, sub_df, x_key, y_key, color_key, rate_mode, vmin, vmax)\n",
    "        \n",
    "        # 显示参数组合\n",
    "        param_values = [str(int(sub_df[p].iloc[0])) for p in group_params]\n",
    "        param_text = 'x'.join(param_values)\n",
    "        ax.text(0.1, 0.88, param_text, transform=ax.transAxes,\n",
    "               fontproperties=font_standard, fontsize=plot_params['textsize']-1,\n",
    "               va='top', bbox=dict(facecolor='white', alpha=0.9, edgecolor='none'))\n",
    "\n",
    "    # 隐藏多余子图\n",
    "    for ax in axes[len(filtered_sub_dfs):]:\n",
    "        ax.set_visible(False)\n",
    "\n",
    "    plt.show()\n",
    "\n",
    "# ==================== 七、执行入口 ====================\n",
    "if __name__ == \"__main__\":\n",
    "    # 加载实际数据\n",
    "    # dfdelpara = dfdelpara[dfdelpara['Pucf12f'] <= 38854353]\n",
    "    df=df_6\n",
    "    print(len(df),'df数据量')\n",
    "    df =df[df['type'] ==2] \n",
    "    display(df)\n",
    "    #     data2  # 替换为你的数据加载逻辑\n",
    "    exclude_list = [\n",
    "#         (300,150,6.5,9),    # 第一个要删除的组buffer_ratio合 (H,B,T1,T2)\n",
    "#         (300,300,10,15) , \n",
    "#         (488,300,11,18)     # 第二个要删除的组合\n",
    "        # 可以继续添加更多组合...\n",
    "    ]\n",
    "    # 直接调用，无需指定x/y/color参数（自动使用PLOT_PARAMS前三个键）\"{x_param['rate_name']} ({x_param['unit']})\" if x_param['unit'] else f\"{x_param['rate_name\n",
    "    generate_subplots(\n",
    "        df,\n",
    "        rate_mode=False,\n",
    "        exclude_combinations=exclude_list\n",
    "    )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b946120f",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "4026f25d",
   "metadata": {},
   "source": [
    "### 灵活绘图绘图方法——多图交互（可多图可单图已完成，勿修改）\n",
    "二维散点（XY固定，颜色变量固定，专门一个分图参数）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7652c6cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from matplotlib import cm\n",
    "from matplotlib.colors import Normalize\n",
    "from mpl_toolkits.axes_grid1 import make_axes_locatable\n",
    "import pandas as pd\n",
    "\n",
    "# 假设 df_T 已经定义，这里只是示例，实际使用时需要替换\n",
    "\n",
    "\n",
    "# ========================\n",
    "# 全局配置段\n",
    "# ========================\n",
    "FIGURE_CONFIG = {\n",
    "    'font': {\n",
    "        'western': 'Times New Roman',\n",
    "        'cjk': FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=14),\n",
    "        'size': 14,\n",
    "        'label_size': 14,\n",
    "        'tick_size': 14\n",
    "    },\n",
    "    'axis': {\n",
    "        'x_label': r'$t_{\\mathrm{f}}/t_{\\mathrm{w}}$',  # 默认X轴标签\n",
    "        'y_label': r'$k_{\\mathrm{fem}}$',  # 默认Y轴标签\n",
    "        'limits': {\n",
    "            'x': (0, 3),\n",
    "            'y': (0, 45)\n",
    "        }\n",
    "    },\n",
    "    'layout': {\n",
    "        'figsize': (15, 3),\n",
    "        'subplots': (1, 5)  # 行数，列数\n",
    "    },\n",
    "    'color': {\n",
    "        'map': 'viridis',\n",
    "        'bar': {\n",
    "            'size': \"5%\",\n",
    "            'pad': \"0%\"\n",
    "        },\n",
    "        'limits': {\n",
    "            'min': None,  # 手动设置颜色条最小值\n",
    "            'max': None   # 手动设置颜色条最大值\n",
    "        },\n",
    "        'use_manual_limits': False,  # 是否使用手动设置的颜色条范围\n",
    "        'use_common_colorbar_limits': False  # 子图颜色条范围是否一致\n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "# ========================\n",
    "# 初始化函数\n",
    "# ========================\n",
    "def init_plot_config():\n",
    "    \"\"\"初始化绘图配置\"\"\"\n",
    "    plt.rc('font', family=FIGURE_CONFIG['font']['western'])\n",
    "    plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "    plt.rcParams['axes.unicode_minus'] = False\n",
    "    plt.rcParams['xtick.direction'] = 'in'\n",
    "    plt.rcParams['ytick.direction'] = 'in'\n",
    "    plt.tick_params(bottom=True, top=True, left=True, right=True)\n",
    "\n",
    "\n",
    "# ========================\n",
    "# 坐标轴配置函数\n",
    "# ========================\n",
    "def configure_axes(ax):\n",
    "    \"\"\"统一配置坐标轴\"\"\"\n",
    "\n",
    "    # 统一设置坐标轴标签\n",
    "    ax.set_xlabel(FIGURE_CONFIG['axis']['x_label'],\n",
    "                  fontproperties=FIGURE_CONFIG['font']['cjk'])\n",
    "    ax.set_ylabel(FIGURE_CONFIG['axis']['y_label'],\n",
    "                  fontproperties=FIGURE_CONFIG['font']['cjk'])\n",
    "\n",
    "    ax.set_xlim(FIGURE_CONFIG['axis']['limits']['x'])\n",
    "    ax.set_ylim(FIGURE_CONFIG['axis']['limits']['y'])\n",
    "\n",
    "    ax.tick_params(axis='both', labelsize=FIGURE_CONFIG['font']['tick_size'])\n",
    "\n",
    "\n",
    "# ========================\n",
    "# 核心绘图函数（优化版）\n",
    "# ========================\n",
    "def plot_scatter_group(ax, data, color_param, x_param, y_param, vmin=None, vmax=None):\n",
    "    \"\"\"优化后的散点图绘制函数\"\"\"\n",
    "    # 颜色映射设置\n",
    "    values = data[color_param]\n",
    "    print('color_param', color_param)\n",
    "    values.to_excel('values.xlsx')\n",
    "    if FIGURE_CONFIG['color']['use_manual_limits'] and FIGURE_CONFIG['color']['limits']['min'] is not None and FIGURE_CONFIG['color']['limits']['max'] is not None:\n",
    "        vmin = FIGURE_CONFIG['color']['limits']['min']\n",
    "        vmax = FIGURE_CONFIG['color']['limits']['max']\n",
    "    elif vmin is not None and vmax is not None:\n",
    "        pass\n",
    "    else:\n",
    "        vmin = values.min()\n",
    "        vmax = values.max()\n",
    "    norm = Normalize(vmin=vmin, vmax=vmax)\n",
    "    cmap = cm.get_cmap(FIGURE_CONFIG['color']['map'])\n",
    "\n",
    "    # 绘制散点\n",
    "    sc = ax.scatter(data[x_param], data[y_param],\n",
    "                    c=values, cmap=cmap, norm=norm,\n",
    "                    s=20, alpha=0.8)\n",
    "\n",
    "    # 添加颜色条\n",
    "    divider = make_axes_locatable(ax)\n",
    "    cax = divider.append_axes(\"right\",\n",
    "                              size=FIGURE_CONFIG['color']['bar']['size'],\n",
    "                              pad=FIGURE_CONFIG['color']['bar']['pad'])\n",
    "    plt.colorbar(sc, cax=cax)\n",
    "\n",
    "\n",
    "# ========================\n",
    "# 主流程函数\n",
    "# ========================\n",
    "def generate_main_plot(data, filter_params):\n",
    "    \"\"\"生成主图\"\"\"\n",
    "    init_plot_config()\n",
    "    plt.figure(figsize=FIGURE_CONFIG['layout']['figsize'])\n",
    "\n",
    "    # 参数解析\n",
    "    div_param = filter_params['div_param']\n",
    "    div_values = filter_params['div_values']\n",
    "    x_param = filter_params['x_param']\n",
    "    y_param = filter_params['y_param']\n",
    "    color_param = filter_params['color_param']\n",
    "\n",
    "    if FIGURE_CONFIG['color']['use_common_colorbar_limits']:\n",
    "        all_values = pd.concat([data[data[div_param] == value][color_param] for value in div_values])\n",
    "        common_vmin = all_values.min()\n",
    "        common_vmax = all_values.max()\n",
    "    else:\n",
    "        common_vmin = None\n",
    "        common_vmax = None\n",
    "\n",
    "    # 创建子图\n",
    "    for i, value in enumerate(div_values, 1):\n",
    "        ax = plt.subplot(*FIGURE_CONFIG['layout']['subplots'], i)\n",
    "\n",
    "        # 数据筛选\n",
    "        filtered_data = data[data[div_param] == value]\n",
    "\n",
    "        # 核心绘图\n",
    "        plot_scatter_group(ax, filtered_data, color_param, x_param, y_param, vmin=common_vmin, vmax=common_vmax)\n",
    "        # 统一配置\n",
    "        configure_axes(ax)\n",
    "        ax.set_title(f\"${div_param} = {value}$\",\n",
    "                     fontsize=FIGURE_CONFIG['font']['size'],\n",
    "                     y=1.02)\n",
    "        ax.text(1.02, 1.05, str(r'$\\alpha_{\\mathrm{wKG}}$'), fontsize=10, transform=ax.transAxes)\n",
    "\n",
    "    plt.tight_layout()\n",
    "    return plt.gcf()\n",
    "\n",
    "\n",
    "# ========================\n",
    "# 执行示例\n",
    "# ========================\n",
    "if __name__ == \"__main__\":\n",
    "    # 配置过滤参数\n",
    "    FILTER_PARAMS = {\n",
    "        'div_param': 'n',\n",
    "        'div_values': [1, 2, 3, 4, 5],\n",
    "        'x_param': 'ratio_alpha_tflange_to_tweb',\n",
    "        'y_param': 'k_taucr_fem2',\n",
    "        'color_param': 'KG_quge_web'\n",
    "    }\n",
    "\n",
    "    # 手动设置颜色条范围\n",
    "    FIGURE_CONFIG['color']['limits']['min'] = 0\n",
    "    FIGURE_CONFIG['color']['limits']['max'] = 10\n",
    "    FIGURE_CONFIG['color']['use_manual_limits'] = False  # 设置为 True 表示使用手动设置的范围\n",
    "    FIGURE_CONFIG['color']['use_common_colorbar_limits'] = False  # 设置为 True 表示子图颜色条范围一致\n",
    "\n",
    "    # 生成并显示图表\n",
    "    fig = generate_main_plot(df_B, FILTER_PARAMS)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3b6c972e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-23T01:09:01.615655Z",
     "start_time": "2023-07-23T01:09:01.611666Z"
    }
   },
   "source": [
    "### 多图合一，不筛选，颜色循环式"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e3b53c43",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "from matplotlib.axes import Axes\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from sklearn.metrics import r2_score\n",
    "from matplotlib import colormaps\n",
    "\n",
    "# -----------------------\n",
    "# 配置参数\n",
    "# -----------------------\n",
    "FIGURE_SETTINGS = {\n",
    "    'figsize': (10,16),\n",
    "    'pointsize': 10,\n",
    "    'fontsize': 12,\n",
    "    'labelsize': 12,\n",
    "    'textsize': 12,\n",
    "    'color_map': 'viridis'\n",
    "}\n",
    "rows_num =8  #每行最大子图数量\n",
    "cols_num =5  #每列最大子图数量\n",
    "    \n",
    "# -----------------------\n",
    "# 数据预处理函数\n",
    "# -----------------------\n",
    "def filter_dataframe(df, filter_params, filter_values):\n",
    "    \"\"\"\n",
    "    根据筛选条件过滤DataFrame\n",
    "    :param df: 原始DataFrame\n",
    "    :param filter_params: 筛选参数列表\n",
    "    :param filter_values: 对应参数值列表\n",
    "    :return: 过滤后的DataFrame\n",
    "    \"\"\"\n",
    "    filtered_df = df.copy()\n",
    "    for param, value in zip(filter_params, filter_values):\n",
    "        filtered_df = filtered_df[filtered_df[param] == value].copy()\n",
    "    return filtered_df\n",
    "\n",
    "# -----------------------\n",
    "# 颜色映射处理\n",
    "# -----------------------\n",
    "def create_color_mapping(data, cmap_type):\n",
    "    \"\"\"\n",
    "    创建颜色映射配置\n",
    "    :param data: 颜色映射数据\n",
    "    :param cmap_type: 颜色映射类型\n",
    "    :return: 颜色映射对象、最小值、最大值\n",
    "    \"\"\"\n",
    "    unique_values = sorted(data.unique())\n",
    "    if len(unique_values) == 1:\n",
    "        min_val = max_val = unique_values[0]\n",
    "    else:\n",
    "        min_val = min(unique_values) - (max(unique_values) - min(unique_values)) / ((len(unique_values)-1)*2)\n",
    "        max_val = max(unique_values) + (max(unique_values) - min(unique_values)) / ((len(unique_values)-1)*2)\n",
    "    \n",
    "    cmap = colormaps[cmap_type]\n",
    "    norm = plt.Normalize(vmin=min_val, vmax=max_val)\n",
    "    return cmap, norm, min_val, max_val\n",
    "\n",
    "# -----------------------\n",
    "# 子图绘制函数\n",
    "# -----------------------\n",
    "def plot_subfigure(ax, data, x_param, y_param, color_param, cmap, norm, min_val, max_val, point_size):\n",
    "    \"\"\"\n",
    "    在子图中绘制散点图\n",
    "    :param ax: 子图Axes对象\n",
    "    :param data: 绘图数据\n",
    "    :param x_param: x轴参数\n",
    "    :param y_param: y轴参数\n",
    "    :param color_param: 颜色参数\n",
    "    :param cmap: 颜色映射\n",
    "    :param norm: 标准化对象\n",
    "    :param min_val: 颜色最小值\n",
    "    :param max_val: 颜色最大值\n",
    "    :param point_size: 点大小\n",
    "    \"\"\"\n",
    "    # 数据排序\n",
    "    sorted_data = data.sort_values(by=x_param, ascending=False).reset_index(drop=True)\n",
    "    \n",
    "    # 提取数据\n",
    "    x_values = sorted_data[x_param].values\n",
    "    y_values = sorted_data[y_param].values\n",
    "    c_values = sorted_data[color_param].values\n",
    "    \n",
    "    # 绘制散点\n",
    "    sc = ax.scatter(\n",
    "        x_values, y_values,\n",
    "        c=c_values, cmap=cmap, norm=norm,\n",
    "        s=point_size, edgecolors='w', linewidths=0.5\n",
    "    )\n",
    "    \n",
    "    # 拟合线示例（可根据需要启用）\n",
    "    # coeff = np.polyfit(x_values, y_values, 2)\n",
    "    # fit_values = np.polyval(coeff, x_values)\n",
    "    # ax.plot(x_values, fit_values, 'r--', linewidth=1)\n",
    "    \n",
    "    return sc\n",
    "\n",
    "# -----------------------\n",
    "# 颜色条设置\n",
    "# -----------------------\n",
    "def configure_colorbar(ax, cmap, norm, colorbar_params, label_size):\n",
    "    \"\"\"\n",
    "    配置颜色条\n",
    "    :param ax: 主图Axes对象\n",
    "    :param cmap: 颜色映射\n",
    "    :param norm: 标准化对象\n",
    "    :param colorbar_params: 颜色条参数列表\n",
    "    :param label_size: 标签字体大小\n",
    "    \"\"\"\n",
    "    divider = make_axes_locatable(ax)\n",
    "    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n",
    "    \n",
    "#     cb = plt.colorbar(\n",
    "#         cm.ScalarMappable(norm=norm, cmap=cmap),\n",
    "#         cax=cax, orientation='vertical'\n",
    "#     )\n",
    "    \n",
    "#     cb.set_ticks(colorbar_params)\n",
    "#     cb.set_ticklabels([f\"{v:.2f}\" for v in colorbar_params])\n",
    "#     cb.ax.tick_params(labelsize=label_size)\n",
    "\n",
    "# -----------------------\n",
    "# 主绘图函数\n",
    "# -----------------------\n",
    "def create_visualization(\n",
    "    df, filter_params, filter_values,\n",
    "    subplot_category, subplot_values,\n",
    "    x_axis, y_axis,\n",
    "    color_params, fig_settings\n",
    "):\n",
    "    \"\"\"\n",
    "    创建多子图可视化\n",
    "    :param df: 原始数据\n",
    "    :param filter_params: 基础筛选参数\n",
    "    :param filter_values: 基础筛选值\n",
    "    :param subplot_category: 子图分类参数\n",
    "    :param subplot_values: 子图分类值列表\n",
    "    :param x_axis: x轴参数\n",
    "    :param y_axis: y轴参数\n",
    "    :param color_params: 颜色映射参数列表\n",
    "    :param fig_settings: 绘图配置参数\n",
    "    \"\"\"\n",
    "    # 基础数据筛选\n",
    "    base_df = filter_dataframe(df, filter_params, filter_values)\n",
    "    \n",
    "    # 初始化画布\n",
    "    plt.figure(figsize=fig_settings['figsize'])\n",
    "    \n",
    "    # 计算子图布局\n",
    "    num_subplots = len(color_params)\n",
    "    rows = rows_num# 最大每行7个子图\n",
    "    cols = cols_num\n",
    "    \n",
    "    # 遍历子图分类值\n",
    "    for subplot_val in subplot_values:\n",
    "        # 筛选当前子图数据\n",
    "        sub_df = base_df[base_df[subplot_category] == subplot_val].copy()\n",
    "        \n",
    "        # 遍历颜色参数\n",
    "        for i, color_param in enumerate(color_params):\n",
    "            ax = plt.subplot(rows, cols, i+1)\n",
    "            \n",
    "            # 创建颜色映射\n",
    "            cmap, norm, min_val, max_val = create_color_mapping(\n",
    "                sub_df[color_param], fig_settings['color_map']\n",
    "            )\n",
    "            \n",
    "            # 绘制散点图\n",
    "            sc = plot_subfigure(\n",
    "                ax, sub_df, x_axis, y_axis, color_param,\n",
    "                cmap, norm, min_val, max_val,\n",
    "                fig_settings['pointsize']\n",
    "            )\n",
    "            \n",
    "            # 设置坐标轴标签\n",
    "            ax.set_xlabel(r'$\\alpha_{\\mathrm{wKG}}$', fontsize=fig_settings['textsize'])\n",
    "            ax.set_ylabel(r'$k_{\\mathrm{fem}}$', fontsize=fig_settings['textsize'])\n",
    "            \n",
    "            # 设置标题\n",
    "#             ax.set_title(rf'${color_param}$', fontsize=fig_settings['fontsize'])\n",
    "            ax.set_title(color_param, fontsize=fig_settings['fontsize'])            \n",
    "            # 配置颜色条（仅第一个子图）\n",
    "            if i == 0:\n",
    "                colorbar_params = np.linspace(min_val, max_val, 6)\n",
    "                configure_colorbar(plt.gcf().axes[0], cmap, norm, colorbar_params, fig_settings['labelsize'])\n",
    "# # ————————————————添加阴影区——————————————————\n",
    "\n",
    "            ax.fill_between(dfks2['1/alpha_ks'].values,dfks2['ks'].values,dfks4['ks'].values,  color='lightgray', alpha=0.01)\n",
    "            ax.fill_between(dfks6['1/alpha_ks'].values,dfks6['ks'].values,dfks8['ks'].values,  color='lightgray', alpha=0.01)\n",
    "            ax.plot(dfks1['1/alpha_ks'].values,dfks1['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "                     label=label1)\n",
    "            ax.plot(dfks5['1/alpha_ks'].values,dfks5['ks'].values,c='r',ls='-', linewidth=linewidth,\n",
    "                     label=label5)\n",
    "            ax.plot(dfks2['1/alpha_ks'].values,dfks2['ks'].values,c='g',ls='--', linewidth=linewidth,\n",
    "                     label=label2)\n",
    "            ax.plot(dfks6['1/alpha_ks'].values,dfks6['ks'].values,c='g',ls='--',linewidth=linewidth,\n",
    "                     label=label6)\n",
    "            ax.plot(dfks3['1/alpha_ks'].values,dfks3['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "                     label=label3)\n",
    "            ax.plot(dfks7['1/alpha_ks'].values,dfks7['ks'].values,c='b',ls='-.', linewidth=linewidth,\n",
    "                     label=label7)\n",
    "            ax.plot(dfks4['1/alpha_ks'].values,dfks4['ks'].values,c='y',ls=':', linewidth=linewidth,\n",
    "                     label=label4)\n",
    "            ax.plot(dfks8['1/alpha_ks'].values,dfks8['ks'].values,c='y',ls=':',linewidth=linewidth,\n",
    "                     label=label8)    \n",
    "            ax.set_xlim(xlim)\n",
    "            ax.set_ylim(ylim)  \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "# -----------------------\n",
    "# -----------------------\n",
    "# 主程序入口\n",
    "# -----------------------\n",
    "if __name__ == \"__main__\":\n",
    "    # 配置参数\n",
    "    FILTER_PARAMS = ['type']\n",
    "    FILTER_VALUES = [1]\n",
    "\n",
    "    SUBPLOT_CATEGORY = 'n'\n",
    "    SUBPLOT_VALUES = [1]\n",
    "\n",
    "    X_AXIS = 'KG_quge_web'\n",
    "    Y_AXIS = 'k_taucr_fem2'\n",
    "\n",
    "    COLOR_PARAMS = ['B', 'H', \n",
    "                    'L', 'n',  'T1', 'T2',  'As2',\n",
    "                    'KG_total_web', 'KG_consedge_flange', 'KG_midstiff_flange',\n",
    "                    'GH_quge_web',  'KH_total_web', 'KH_consedge_flange',\n",
    "                    'KH_midstiff_flange', 'I_single_ix', 'I_single_iy', 'I_web_quge_ix',\n",
    "                    'I_web_quge_iy', 'I_flange_consedge_ix', 'I_flange_consedge_iy',\n",
    "                    'I_flange_midstiff_ix',\n",
    "                    'I_flange_midstiff_iy', 'I_total_webix', 'I_total_webiy', 'J_web',\n",
    "                    'J_consedge_half', 'J_midstiff_half', 'J_consedge', 'J_midstiff',\n",
    "                    'ratio_alpha_tflange_to_tweb', 'ratio_alpha_Bflange_to_Hn', \n",
    "                    'ratio_eta_GJdivbyDL', 'EI_edge', 'Dh', 'EI_mid', 'gamma_edge',\n",
    "                    'gamma_mid', 'beta', 'beta2', 'L_to_tw']\n",
    "\n",
    "    # 设置坐标轴范围\n",
    "    xlim = (0, 1)\n",
    "    ylim = (5, 15)\n",
    "    # 执行绘图\n",
    "    create_visualization(\n",
    "        df=df_all,\n",
    "        filter_params=FILTER_PARAMS,\n",
    "        filter_values=FILTER_VALUES,\n",
    "        subplot_category=SUBPLOT_CATEGORY,\n",
    "        subplot_values=SUBPLOT_VALUES,\n",
    "        x_axis=X_AXIS,\n",
    "        y_axis=Y_AXIS,\n",
    "        color_params=COLOR_PARAMS,\n",
    "        fig_settings=FIGURE_SETTINGS\n",
    "    )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3b5a7008",
   "metadata": {},
   "source": [
    "### 进行绘图（筛选真正的变量图）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "814a111d",
   "metadata": {},
   "source": [
    "#### 多图筛选"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "681f6994",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-24T12:06:26.613581Z",
     "start_time": "2023-07-24T12:06:09.573991Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "from sklearn.metrics import r2_score\n",
    "\n",
    "general_list       =['yfss','Imperfectfactor','meshsz','cf1f', 'cf2f', 'cf3f','n','type']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[355.61,     0.002       , 20     ,  0   , 1     ,0   ,1 ,0]# 面内受剪_分离面内\n",
    "# 固定标准参数general list和其值\n",
    "df_selected_del=dfdelpara.copy()\n",
    "for i in range (0,len(general_list)):\n",
    "    df_selected_del=df_selected_del[df_selected_del[general_list[i]]==general_list_number[i]].copy()\n",
    "\n",
    "\n",
    "df=df_selected_del\n",
    "\n",
    "divparname=str('beta')\n",
    "prelist=list(df[divparname].sort_values().unique())\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# 分图后df\n",
    "div_pic_para=str('I_single_ix')\n",
    "# 图内分类型参数（变色或者变形状）I_single_ix\n",
    "# div_colandlegend_para_list=df.columns\n",
    "# div_colandlegend_para_list=['ratio_alpha_Bflange_to_Hn']\n",
    "div_colandlegend_para_list=['KG_quge_web']\n",
    "# div_colandlegend_para_list=str('KG_total_web')\n",
    "# # x_轴\n",
    "x_aixs_paralist=['ratio_alpha_Bflange_to_Hn']\n",
    "\n",
    "# x_aixs_para=df.columns\n",
    "# y_轴\n",
    "y_aixs_para=str('k_taucr_fem2')\n",
    "# 分图筛选一下\n",
    "num_diff_divpic=len(prelist)#共有多少个颜色类型不同数值的数量\n",
    "\n",
    "# 构造小图排布所需要的的画布布局\n",
    "xint=int(num_diff_divpic**0.5)+1#图纸分布x\n",
    "yint=int(num_diff_divpic**0.5)+1#图纸分布y\n",
    "plt.figure(figsize=(20,20))\n",
    "\n",
    "for ilist in range(0,len(prelist)):\n",
    "    ilistnum=prelist[ilist]\n",
    "    dfcol=df[(df[divparname]==ilistnum)]\n",
    "    print(ilistnum,divparname)\n",
    "    axes_sub_fig=plt.subplot(xint,yint,ilist+1)# 小图排布\n",
    "\n",
    "\n",
    "    print(ilistnum)\n",
    "    print(len(dfcol))\n",
    "    print('len(dfcol)')\n",
    "# ------------------可以选择换x轴内容----------------------------\n",
    "    for i in range(0,len(x_aixs_paralist)):\n",
    "        x_aixs_para=x_aixs_paralist[i]\n",
    "#         num_diff_divpic=len(div_colandlegend_para_list)#共有多少个颜色类型不同数值的数量\n",
    "        print('num_diff_divpic',num_diff_divpic)\n",
    "    # 构造小图排布所需要的的画布布局\n",
    "#         xint=int(num_diff_divpic**0.5)+1#图纸分布x\n",
    "#         yint=int(num_diff_divpic**0.5)+1#图纸分布y\n",
    "#         plt.figure(figsize=(20,20))\n",
    "# ------------------可以选择换颜色轴内容----------------------------\n",
    "    #每一张大图内一点一点画小图\n",
    "        for j in range(0,len(div_colandlegend_para_list)):\n",
    "            div_colandlegend_para=div_colandlegend_para_list[j]\n",
    "#             plt.subplot(xint,yint,ilist+1)# 小图排布\n",
    "            print(div_colandlegend_para,x_aixs_para,y_aixs_para)\n",
    "            fitlist=pic_ktaucr_inpicolor_x_scatter(dfcol,div_colandlegend_para,x_aixs_para,y_aixs_para)# 小图内分颜色绘制\n",
    "#             plt.xlabel(x_aixs_para)float(min(colorlmap_ks_list)\n",
    "#-----------------------拟合代码--------------------------------------------\n",
    "\n",
    "    axes_sub_fig.set_xticks(np.linspace(0,7,8,endpoint=True))# x轴标签\n",
    "    axes_sub_fig.set_yticks(np.linspace(0,30,7,endpoint=True))# y轴标签  \n",
    "#     axes_sub_fig.text(0.3,0.8,str(r'$\\alpha_{\\mathrm{wKG}}$')+'='+str(\"%.3f\"%(np.round(ilistnum,3))),transform=axes_sub_fig.transAxes)\n",
    "    axes_sub_fig.text(0.3,0.8,divparname+'='+str(\"%.3f\"%(np.round(ilistnum,3))),transform=axes_sub_fig.transAxes)\n",
    "    axes_sub_fig.set_xlabel(x_aixs_para)# x轴标签  \n",
    "    axes_sub_fig.set_xlim(0,7)        \n",
    "    axes_sub_fig.set_ylim(0,30)\n",
    "plt.show()\n",
    "# plt.savefig(r'R:\\Jupyterdemo\\\\'+str('x')+x_aixs_para+'.svg')#保存图   "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "568b76a8",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-12-02T07:17:37.965568Z",
     "start_time": "2022-12-02T07:17:37.937642Z"
    }
   },
   "source": [
    "#### 绘图采用最终的图形"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "63f994eb",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-23T01:45:49.416326Z",
     "start_time": "2023-07-23T01:45:49.387406Z"
    }
   },
   "outputs": [],
   "source": [
    "# 筛选\n",
    "para_without_para=str('type')\n",
    "para_without_paranum=0\n",
    "# 分图后df\n",
    "div_pic_para=str('KG_quge_web')\n",
    "# 图内分类型参数（变色或者变形状）\n",
    "# type(df.columns)\n",
    "# div_colandlegend_para_list=df.columns\n",
    "# div_colandlegend_para_list=['KG_quge_web','KH_quge_web','KG_consedge_flange','KH_consedge_flange']\n",
    "# div_colandlegend_para=str('KG_quge_web')\n",
    "# # x_轴\n",
    "x_aixs_para=('ratio_alpha_tflange_to_tweb')\n",
    "# x_aixs_para=df.columns\n",
    "# y_轴\n",
    "y_aixs_para=str('k_taucr_fem2')\n",
    "# 分图筛选一下\n",
    "# dfcol=df[(df['KG_quge_web']==0.170000)]\n",
    "dfcol=df\n",
    "pic_ktaucr_inpicolor_x_scatter(df_selected_del,para_without_para,para_without_paranum,div_colandlegend_para,x_aixs_para,y_aixs_para)# 小图内分颜色绘制\n",
    "plt.xlabel(x_aixs_para)\n",
    "plt.ylabel(y_aixs_para)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fbcc66a4",
   "metadata": {},
   "source": [
    "## 3D图"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c4cc07b",
   "metadata": {},
   "source": [
    "### 螺栓分离因素3D图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dedcd9ed",
   "metadata": {},
   "outputs": [],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "# %% 模块导入\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "from matplotlib.ticker import MultipleLocator\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "from matplotlib.font_manager import FontProperties\n",
    "import pandas as pd\n",
    "\n",
    "# %% 全局参数配置\n",
    "# 图形参数\n",
    "plt.rcParams['font.family'] = 'Times New Roman'\n",
    "plt.rcParams['font.sans-serif'] = ['SimSun']  # 中文支持\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "plt.rcParams['xtick.direction'] = 'in'\n",
    "plt.rcParams['ytick.direction'] = 'in'\n",
    "plt.rcParams['xtick.labelsize'] = 12\n",
    "plt.rcParams['ytick.labelsize'] = 12\n",
    "\n",
    "# 样式参数\n",
    "sort_list = ['L', 'T2', 'B', 'T1', 'H']\n",
    "points_size = 10\n",
    "text_size = 12\n",
    "x_line_num = 4\n",
    "y_line_num = 4\n",
    "fig_size_x = 15  # 单位: 英寸\n",
    "fig_size_y = fig_size_x / y_line_num * x_line_num\n",
    "\n",
    "# 字体设置\n",
    "font_song = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=text_size)\n",
    "\n",
    "# %% 功能函数定义\n",
    "def create_3d_scatter_plot(axes, data_df, color_param, x_param, y_param, \n",
    "                          x2_param, color_map='viridis'):\n",
    "    \"\"\"\n",
    "    绘制3D散点图的核心函数\n",
    "    \n",
    "    参数:\n",
    "    axes: 子图对象\n",
    "    data_df: 输入数据DataFrame\n",
    "    color_param: 颜色分类参数\n",
    "    x_param: X轴参数名\n",
    "    y_param: Y轴参数名\n",
    "    x2_param: 第二X轴参数名\n",
    "    color_map: 颜色映射方案\n",
    "    \"\"\"\n",
    "    # 数据预处理\n",
    "    df = data_df.copy().reset_index(drop=True)\n",
    "    \n",
    "    # 颜色映射设置\n",
    "    cmap = cm.get_cmap(color_map)  # 改回旧的获取颜色映射的方式\n",
    "    color_values = df[color_param].values\n",
    "    norm = plt.Normalize(color_values.min(), color_values.max())\n",
    "    \n",
    "    # 数据转换\n",
    "    x_values = df[x_param].values / 1000 if x_param == 'pbol' else df[x_param].values\n",
    "    x2_values = df[x2_param].values\n",
    "    y_values = df[y_param].values\n",
    "    \n",
    "    # 绘制散点\n",
    "    scatter = axes.scatter(x_values, x2_values, y_values,\n",
    "                          c=color_values, cmap=cmap, norm=norm,\n",
    "                          s=points_size, alpha=1, edgecolors='none')\n",
    "    \n",
    "    return scatter\n",
    "\n",
    "# %% 主程序入口\n",
    "if __name__ == \"__main__\":\n",
    "    # 配置参数\n",
    "    config = {\n",
    "        'color_map': 'viridis',\n",
    "        'div_para_list': ['H'],\n",
    "        'div_half_list': ['B'],\n",
    "        'div_second_list': ['T1'],\n",
    "        'x_axis_params': ['ratio_alpha_tflange_to_tweb'],\n",
    "        'x2_axis_param': 'KG_quge_web',\n",
    "        'y_axis_param': 'k_taucr_fem2',\n",
    "        'z_lim_config': {\n",
    "            (0, 100): (0, 50),\n",
    "            (101, 300): (0, 8),\n",
    "            (301, None): (0, 4)\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # 初始化绘图\n",
    "    fig = plt.figure(figsize=(fig_size_x, fig_size_y))\n",
    "    subplot_counter = 0\n",
    "    scatters = []\n",
    "\n",
    "    # 第一层参数筛选\n",
    "    for main_div in config['div_para_list']:\n",
    "        print(f\"\\nProcessing main division: {main_div}\")\n",
    "        main_df = df[df[main_div].notna()]  # 过滤空值\n",
    "\n",
    "        # 第二层参数筛选\n",
    "        for sub_div in config['div_half_list']:\n",
    "            print(f\"Processing sub division: {sub_div}\")\n",
    "            sub_df = main_df[main_df[sub_div].notna()]\n",
    "\n",
    "            # 第三层参数筛选\n",
    "            for sec_div in config['div_second_list']:\n",
    "                print(f\"Processing secondary division: {sec_div}\")\n",
    "                sec_df = sub_df[sub_df[sec_div].notna()]\n",
    "\n",
    "                # 跳过数据不足的情况\n",
    "                if len(sec_df) < 10:\n",
    "                    print(f\"Skipping: Insufficient data ({len(sec_df)} points)\")\n",
    "                    continue\n",
    "\n",
    "                # 创建子图\n",
    "                subplot_counter += 1\n",
    "                ax = fig.add_subplot(x_line_num, y_line_num, subplot_counter, projection='3d')\n",
    "                print(f\"Creating subplot {subplot_counter} with {len(sec_df)} points\")\n",
    "\n",
    "                # 绘制图形\n",
    "                scatter = create_3d_scatter_plot(\n",
    "                    ax, sec_df,\n",
    "                    color_param=config['x2_axis_param'],\n",
    "                    x_param=config['x_axis_params'][0],\n",
    "                    y_param=config['y_axis_param'],\n",
    "                    x2_param=config['x2_axis_param'],\n",
    "                    color_map=config['color_map']\n",
    "                )\n",
    "                scatters.append(scatter)\n",
    "\n",
    "                # 动态设置Z轴范围\n",
    "                main_value = sec_df[main_div].iloc[0]\n",
    "                for (lower, upper), (z_min, z_max) in config['z_lim_config'].items():\n",
    "                    if (lower <= main_value <= upper) if upper else (main_value >= lower):\n",
    "                        ax.set_zlim(z_min, z_max)\n",
    "                        break\n",
    "\n",
    "                # 轴标签设置\n",
    "                ax.set_xlabel('预拉力 (kN)' if config['x_axis_params'][0] == 'pbol' else config['x_axis_params'][0],\n",
    "                            fontproperties=font_song)\n",
    "                ax.set_ylabel(f'${config[\"x2_axis_param\"]}$', fontsize=text_size)\n",
    "                ax.set_zlabel(r'$\\phi$ 变化率 (%)', fontproperties=font_song,\n",
    "                            rotation=90, labelpad=-3.5)\n",
    "\n",
    "                # 视角调整\n",
    "                ax.view_init(elev=12, azim=290)\n",
    "\n",
    "                # 刻度设置\n",
    "                ax.xaxis.set_major_locator(MultipleLocator(0.05))\n",
    "                ax.yaxis.set_major_locator(MultipleLocator(4))\n",
    "\n",
    "                # 子图标题\n",
    "                title_text = (\n",
    "                    f\"{main_div}={sec_df[main_div].iloc[0]:.0f} \"\n",
    "                    f\"{sub_div}={sec_df[sub_div].iloc[0]:.0f}\"\n",
    "                )\n",
    "                ax.set_title(title_text, fontsize=text_size, pad=10)\n",
    "\n",
    "    # 图形优化\n",
    "    if scatters:\n",
    "        # 获取第一个scatter对象的颜色映射信息\n",
    "        first_scatter = scatters[0]\n",
    "        fig.colorbar(first_scatter, ax=fig.get_axes(),\n",
    "                     label=config['x2_axis_param'], pad=0.05, shrink=0.9)\n",
    "\n",
    "    plt.tight_layout(pad=2.5)\n",
    "    plt.show()\n",
    "    # plt.savefig(\"3d_plot.svg\", format=\"svg\", dpi=600)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9722f900",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "962e4274",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 改进版本 - 保留原有注释和功能\n",
    "# 这一部分是我原来自己写的函数\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from matplotlib.ticker import MultipleLocator, FormatStrFormatter\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib.colors import Normalize\n",
    "import matplotlib.ticker as mtick\n",
    "from mpl_toolkits.mplot3d import proj3d\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# %matplotlib inline\n",
    "# 关闭交互式绘图\n",
    "\n",
    "class PlotConfig:\n",
    "    \"\"\"配置设置类\"\"\"\n",
    "    def __init__(self):\n",
    "        self.sort_list = ['L', 'T2', 'T1','B',  'H','n']  # 最后一个参数是组内排序小参数\n",
    "        self.pointsize = 10\n",
    "        self.textsize = 12\n",
    "        self.xlinenum = 4\n",
    "        self.ylinenum = 4\n",
    "        # 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。\n",
    "        # 换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文\n",
    "        self.figsizex = 15  \n",
    "        self.figsizey = self.figsizex / self.ylinenum * self.xlinenum\n",
    "        self.colormap = 'viridis'\n",
    "        \n",
    "    def setup_matplotlib(self):\n",
    "        \"\"\"设置matplotlib全局参数\"\"\"\n",
    "        # 字体设置宋体\n",
    "        try:\n",
    "            self.font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=self.textsize)\n",
    "        except:\n",
    "            print(\"警告: 未找到中文字体，使用默认字体\")\n",
    "            self.font_setS = FontProperties(size=self.textsize)\n",
    "        \n",
    "        plt.rc('font', family='Times New Roman')  # 全局字体为新罗马\n",
    "        plt.rcParams[\"font.sans-serif\"] = [\"SimSun\"]\n",
    "        plt.rcParams['axes.unicode_minus'] = False\n",
    "        plt.rcParams['xtick.direction'] = 'in'  # x刻度向内侧显示\n",
    "        plt.rcParams['ytick.direction'] = 'in'  # y刻度向内侧显示\n",
    "        plt.rcParams['xtick.labelsize'] = self.textsize\n",
    "        plt.rcParams['ytick.labelsize'] = self.textsize\n",
    "        \n",
    "        return self.font_setS\n",
    "\n",
    "# ——————————散点图——————————\n",
    "def pic_ktaucr_inpicolor_x_3dscatter(df_pre, div_colandlegend_para, x_aixs_para, \n",
    "                                      y_aixs_para, x_y_aixs_para, axes_sub_fig, \n",
    "                                      config, df_global):\n",
    "    \"\"\"\n",
    "    画图函数（不需要的参数，不需要的参数对应的值，分类的参数，x轴，y轴）\n",
    "    分类准备工作，这些都是针对'颜色分类的参数'div_colandlegend_para\n",
    "    \"\"\"\n",
    "    \n",
    "    df_pre1 = df_pre.reset_index(drop=True)  # 去掉行名\n",
    "    df_pre1[div_colandlegend_para].value_counts()  # 可能——数值统计\n",
    "    div_pic = df_pre1[div_colandlegend_para].sort_values()  # 可能——数值排序\n",
    "    div_pic.unique()  # 区格宽高比的唯一数值统计\n",
    "    num_diff_divpic = len(div_pic.value_counts())  # 可能——不同数值的数量\n",
    "    \n",
    "    # ——————构造颜色数值对应关系——————————\n",
    "    coltocmap = df_global[div_colandlegend_para].values  # 采用最外层的df分颜色\n",
    "    coltocmap_unique = list(df_pre[div_colandlegend_para].sort_values().unique())\n",
    "    minco = min(coltocmap)\n",
    "    maxco = max(coltocmap)\n",
    "    \n",
    "    # ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend in range(0, num_diff_divpic):\n",
    "        df_div_colandlegend = df_pre1[(df_pre1[div_colandlegend_para] == div_pic.unique()[num_colandlegend])]\n",
    "        # 上面是可能——数值df建立\n",
    "        \n",
    "        # 如果最小值缺失，则跳过；如果上升下降趋势点数量相同，则跳过\n",
    "        if min(df_div_colandlegend[x_aixs_para]) != min(df_global[x_aixs_para]):\n",
    "            # or len(df_div_colandlegend[(df_div_colandlegend[yin_diff]>100)])==len(df_div_colandlegend[(df_div_colandlegend[yin_diff]<100)]):\n",
    "            continue\n",
    "        else:\n",
    "            df_div_colandlegend = df_div_colandlegend.reset_index(drop=True)  # 去掉行名\n",
    "            # 此处得到的df_div_colandlegend就是已经按照颜色分类过的dataframe\n",
    "            div_colandlegend_finalpre = df_div_colandlegend.sort_values(by=div_colandlegend_para, ascending=False)  # 单拿出来并排序\n",
    "            div_colandlegend_final = div_colandlegend_finalpre.reset_index(drop=True)  # 去掉行名\n",
    "            \n",
    "            # 对本种颜色下进行循环构造画图的listdf，x轴从小到大\n",
    "            x_ks_plotlist = []\n",
    "            x_y_ks_plotlist = []\n",
    "            y_ks_plotlist = []\n",
    "            num_del = 0\n",
    "            \n",
    "            # ——————把每个点循环并赋予颜色（一行一行的绘制，即一个点一个点的绘制），构造出来需要的list——————\n",
    "            for num_ks in range(0, len(div_colandlegend_final)):\n",
    "                x_ks = div_colandlegend_final.at[num_ks, x_aixs_para]\n",
    "                x_y_ks = div_colandlegend_final.at[num_ks, x_y_aixs_para]\n",
    "                y_ks = div_colandlegend_final.at[num_ks, y_aixs_para]\n",
    "                z_ks = div_colandlegend_final.at[num_ks, div_colandlegend_para]\n",
    "                \n",
    "                if x_aixs_para == str('pbol'):\n",
    "                    x_ks_plotlist.append(x_ks/1000)  # 这里进行了单位转换\n",
    "                else:\n",
    "                    x_ks_plotlist.append(x_ks)\n",
    "                    \n",
    "                x_y_ks_plotlist.append(x_y_ks)\n",
    "                y_ks_plotlist.append(y_ks)\n",
    "            \n",
    "            # 防止除零错误\n",
    "            if maxco != minco:\n",
    "                colorlmap_ks = (z_ks - minco) / (maxco - minco)\n",
    "            else:\n",
    "                colorlmap_ks = 0.5\n",
    "                \n",
    "            colorlmap_ks_list = np.full((len(div_colandlegend_final) - num_del, 1), colorlmap_ks)\n",
    "            \n",
    "            # ————————————————小图内每个颜色的绘制——————————————————\n",
    "            axes_sub_fig.scatter(np.array(x_ks_plotlist), np.array(x_y_ks_plotlist), \n",
    "                               np.array(y_ks_plotlist), c=colorlmap_ks_list, \n",
    "                               cmap=config.colormap, vmin=0, vmax=1, s=20, alpha=1)\n",
    "            \n",
    "            norm_plot = cm.colors.Normalize(vmin=0, vmax=1)\n",
    "            cmap_plot = cm.get_cmap(config.colormap)\n",
    "            m_plot = cm.ScalarMappable(norm=norm_plot, cmap=cmap_plot)\n",
    "            axes_sub_fig.plot(np.array(x_ks_plotlist), np.array(x_y_ks_plotlist), \n",
    "                            np.array(y_ks_plotlist), c=m_plot.to_rgba(float(min(colorlmap_ks_list))))\n",
    "\n",
    "# ——————————————def函数定义结束————————————————————————————————\n",
    "\n",
    "def process_hierarchical_data(data, config, param_settings):\n",
    "    \"\"\"\n",
    "    处理层级数据并创建图表\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    data : DataFrame - 输入数据\n",
    "    config : PlotConfig - 配置对象\n",
    "    param_settings : dict - 参数设置字典\n",
    "    \"\"\"\n",
    "    \n",
    "    # ——————————预设信息设置————————\n",
    "    # 从参数设置中提取值\n",
    "    div_colandlegend_para_list = param_settings.get('div_colandlegend_para_list', \n",
    "                                                   [config.sort_list[(len(config.sort_list)-2)]])  # 分图\n",
    "    x_aixs_paralist = param_settings.get('x_aixs_paralist', ['sfricn'])  # x轴\n",
    "    x_y_aixs_paralist = param_settings.get('x_y_aixs_paralist', \n",
    "                                         [config.sort_list[(len(config.sort_list)-1)]])  # 第二x轴\n",
    "    y_aixs_para = param_settings.get('y_aixs_para', 'SFcf2f')  # y轴\n",
    "    \n",
    "    div_para_list = param_settings.get('div_para_list', ['H'])  # 第一层筛选参数\n",
    "    div_para_half_list = param_settings.get('div_para_half_list', ['B'])  # 第一层半筛选参数\n",
    "    div_para_second_list = param_settings.get('div_para_second_list', ['T1'])  # 第二层筛选参数\n",
    "    \n",
    "    div_para_plot_prelist = x_y_aixs_paralist\n",
    "    \n",
    "    numaxsub = 0\n",
    "    df = data  # 可以是 df_selected_del[df_selected_del['B']!=400] 或 data2\n",
    "    \n",
    "    # ————————分割图形的筛选方法（筛选第一层）——————————\n",
    "    for num_div_para in range(0, len(div_para_list)):\n",
    "        df_pre_df_para = df.reset_index(drop=True)  # 去掉行名\n",
    "        div_para = div_para_list[num_div_para]\n",
    "        div_pic_df_para = df_pre_df_para[div_para].sort_values()  # 可能——数值排序\n",
    "        len_diff_divpic_df_para = len(div_pic_df_para.value_counts())  # 可能——不同数值的数量\n",
    "        plt.figure(figsize=(config.figsizex, config.figsizey))\n",
    "        \n",
    "        # ——————对每一种颜色数值关系都作图——————————\n",
    "        for num_colandlegend_df_para in range(0, len_diff_divpic_df_para):\n",
    "            df_second = df_pre_df_para[(df_pre_df_para[div_para] == div_pic_df_para.unique()[num_colandlegend_df_para])]\n",
    "            # 连接两种作用的函数的df\n",
    "            \n",
    "            # ————————第一层筛选结束——————————\n",
    "            # ————————分割-图形的筛选方法（筛选一层半）——————————\n",
    "            for num_div_half_para in range(0, len(div_para_half_list)):\n",
    "                df_pre_df_half_para = df_second.reset_index(drop=True)  # 去掉行名\n",
    "                div_half_para = div_para_half_list[num_div_half_para]\n",
    "                div_pic_df_half_para = df_pre_df_half_para[div_half_para].sort_values()  # 可能——数值排序\n",
    "                len_diff_divpic_df_half_para = len(div_pic_df_half_para.value_counts())  # 可能——不同数值的数量\n",
    "                \n",
    "                # ——————对每一种颜色数值关系都作图——————————\n",
    "                for num_colandlegend_df_half_para in range(0, len_diff_divpic_df_half_para):\n",
    "                    df_prehalf = df_pre_df_half_para[(df_pre_df_half_para[div_half_para] == div_pic_df_half_para.unique()[num_colandlegend_df_half_para])]\n",
    "                    \n",
    "                    # ————————分割图形的筛选方法（筛选第第二层）——————————\n",
    "                    for num_div_second_para in range(0, len(div_para_second_list)):\n",
    "                        if len(df_prehalf) < 10:\n",
    "                            break\n",
    "                        else:\n",
    "                            df_pre_df_second_para = df_prehalf.reset_index(drop=True)  # 去掉行名\n",
    "                            div_second_para = div_para_second_list[num_div_second_para]\n",
    "                            div_pic_df_second_para = df_pre_df_second_para[div_second_para].sort_values()  # 可能——数值排序\n",
    "                            num_diff_divpic_df_second_para = len(div_pic_df_second_para.value_counts())  # 可能——不同数值的数量\n",
    "                            \n",
    "                            # ——————对每一种颜色数值关系都作图——————————\n",
    "                            for num_colandlegend_df_second_para in range(0, num_diff_divpic_df_second_para):\n",
    "                                df_div_para_second_colandlegend = df_pre_df_second_para[(df_pre_df_second_para[div_second_para] == div_pic_df_second_para.unique()[num_colandlegend_df_second_para])]\n",
    "                                df_pre = df_div_para_second_colandlegend  # 连接两种作用的函数的df\n",
    "                                \n",
    "                                print('df_pre', len(df_pre))\n",
    "                                print('第一层参数', div_para, div_pic_df_para.unique()[num_colandlegend_df_para], \n",
    "                                      type(div_pic_df_para.unique()[num_colandlegend_df_para]))\n",
    "                                print('第一层半参数', div_half_para, div_pic_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                                print('第二层参数', div_second_para, div_pic_df_second_para.unique()[num_colandlegend_df_second_para])\n",
    "                                \n",
    "                                # 构造小图排布所需要的的画布布局\n",
    "                                numaxsub = numaxsub + 1\n",
    "                                axes_sub_fig = plt.subplot(config.xlinenum, config.ylinenum, numaxsub, projection='3d')  # 小图排布\n",
    "                                print('axes_sub_fignumaxsub', numaxsub)\n",
    "                                \n",
    "                                # ————————第二层筛选结束——————————\n",
    "                                for i in range(0, len(x_aixs_paralist)):\n",
    "                                    x_aixs_para = x_aixs_paralist[i]\n",
    "                                    x_y_aixs_para = x_y_aixs_paralist[0]\n",
    "                                    print('x_y_aixs_para', x_y_aixs_para)\n",
    "                                    \n",
    "                                    # ——————每一张大图内一点一点画小图，主要作用——————————————————\n",
    "                                    for j in range(0, len(div_colandlegend_para_list)):\n",
    "                                        div_colandlegend_para = div_colandlegend_para_list[j]\n",
    "                                        df_plot = df_pre\n",
    "                                        \n",
    "                                        # ————————分割图形的筛选方法（筛选二层前）——————————\n",
    "                                        for num_div_plot_prepara in range(0, len(div_para_plot_prelist)):\n",
    "                                            df_pre_df_plot_prepara = df_plot.reset_index(drop=True)  # 去掉行名\n",
    "                                            div_plot_prepara = div_para_plot_prelist[num_div_plot_prepara]\n",
    "                                            div_pic_df_plot_prepara = df_pre_df_plot_prepara[div_plot_prepara].sort_values()  # 可能——数值排序\n",
    "                                            len_diff_divpic_df_plot_prepara = len(div_pic_df_plot_prepara.value_counts())  # 可能——不同数值的数量\n",
    "                                            \n",
    "                                            # ——————对每一种颜色数值关系都作图——————————\n",
    "                                            for num_colandlegend_df_plot_prepara in range(0, len_diff_divpic_df_plot_prepara):\n",
    "                                                df_plot = df_pre_df_plot_prepara[(df_pre_df_plot_prepara[div_plot_prepara] == div_pic_df_plot_prepara.unique()[num_colandlegend_df_plot_prepara])]\n",
    "                                                pic_ktaucr_inpicolor_x_3dscatter(df_plot, div_colandlegend_para, \n",
    "                                                                                x_aixs_para, y_aixs_para, \n",
    "                                                                                x_y_aixs_para, axes_sub_fig, \n",
    "                                                                                config, df)\n",
    "                                \n",
    "                                # -----------------------单独的图纸设置--------------------------------------------\n",
    "                                axes_sub_fig.set_title(str(div_para) + str('=') +\n",
    "                                                     str('%.0f' % div_pic_df_para.unique()[num_colandlegend_df_para]) + str(' ') +\n",
    "                                                     str(div_half_para) + str('=') +\n",
    "                                                     str('%.0f' % div_pic_df_half_para.unique()[num_colandlegend_df_half_para]) + str(' '),\n",
    "                                                     fontdict={'size': config.textsize}, x=0.5, y=0.9)\n",
    "                                \n",
    "                                # axes_sub_fig.text('特征值变化率(%)', fontproperties=font_setS, rotation = 90,x=0,y=0,z=0)\n",
    "                                # axes_sub_fig.text(6,100,10,str(div_para)+str('=')\n",
    "                                #     +str('%.0f'%div_pic_df_para.unique()[num_colandlegend_df_para])+str(' ')\n",
    "                                #     +str(div_half_para)+str('=')\n",
    "                                #     +str('%.0f'%div_pic_df_half_para.unique()[num_colandlegend_df_half_para])+str(' '),\n",
    "                                #     fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                                \n",
    "                                # axes_sub_fig.zaxis.set_rotate_label(False)\n",
    "                                # plt.set_zlabel('特征值变化率(%)', fontproperties=font_setS, rotation = 90)\n",
    "                                \n",
    "                                if div_pic_df_para.unique()[num_colandlegend_df_para] <= 100:\n",
    "                                    axes_sub_fig.set_zlim(0, 50)\n",
    "                                elif div_pic_df_para.unique()[num_colandlegend_df_para] > 300:\n",
    "                                    axes_sub_fig.set_zlim(0, 4)\n",
    "                                else:\n",
    "                                    axes_sub_fig.set_zlim(0, 8)\n",
    "                                \n",
    "                                # zmajorLocator = MultipleLocator(0.1) #将y轴主刻度标签设置为1的倍数\n",
    "                                # axes_sub_fig.zaxis.set_major_locator(zmajorLocator)\n",
    "                                # axes_sub_fig.set_xlim(60,300)# 这个语句可以调整3d图坐标轴方向\n",
    "                                # axes_sub_fig.set_xticks([80,125,175,230,280])# x轴标签\n",
    "                                # axes_sub_fig.set_xlabel('预拉力'+'(kN)', fontproperties=font_setS)\n",
    "                                # axes_sub_fig.set_xlim(60,300)# 这个语句可以调整3d图坐标轴方向\n",
    "                                axes_sub_fig.set_xticks([0.3, 0.35, 0.4, 0.45])  # x轴标签\n",
    "                                \n",
    "                                # axes_sub_fig.set_ylim(0,10)\n",
    "                                axes_sub_fig.set_yticks([1, 5, 9])  # x轴标签\n",
    "                                axes_sub_fig.set_ylabel('$' + x_y_aixs_para + '$')\n",
    "                                axes_sub_fig.set_zlabel(str(r'$\\phi$' + '变化率(%)'), \n",
    "                                                       fontproperties=config.font_setS, \n",
    "                                                       rotation=90, labelpad=-3.5)\n",
    "                                # axes_sub_fig.set_xlabel(str(r'$μ$'), fontproperties=font_setS)\n",
    "                                axes_sub_fig.view_init(elev=12, azim=290)\n",
    "                                # axes_sub_fig.view_init(elev=15)\n",
    "                                axes_sub_fig.zaxis.set_rotate_label(False)\n",
    "                                # axes_sub_fig.set_zlabel('特征值变化率(%)', fontproperties=font_setS,rotation = 90, labelpad=-0.5)\n",
    "                                # 更改z轴位置\n",
    "                                axes_sub_fig.zaxis._axinfo['juggled'] = (1, 2, 7)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    return plt\n",
    "\n",
    "# 使用示例\n",
    "def main():\n",
    "    \"\"\"主函数示例\"\"\"\n",
    "    \n",
    "    # 初始化配置\n",
    "    config = PlotConfig()\n",
    "    font_set = config.setup_matplotlib()\n",
    "    \n",
    "    # 参数设置 - 保留原有的注释和设置\n",
    "    param_settings = {\n",
    "        # yin_diff='yin_diff'  # 不同值的数列名称：通用因变量 EigenValue diff SLcf2f z\n",
    "        # zi_ori='sfricn'\n",
    "        # zi_diff='pbol_diff_percent'  # 不同值的数列名称：通用自变量pbol_diff_percent\n",
    "        \n",
    "        # 分图参数\n",
    "        'div_colandlegend_para_list': [config.sort_list[(len(config.sort_list)-2)]],\n",
    "        # x轴参数\n",
    "        'x_aixs_paralist': ['sfricn'],\n",
    "        # 第二x轴参数\n",
    "        'x_y_aixs_paralist': [config.sort_list[(len(config.sort_list)-1)]],\n",
    "        # y轴参数\n",
    "        'y_aixs_para': 'SFcf2f',\n",
    "        # 筛选参数\n",
    "        'div_para_list': ['H'],  # 第一层筛选参数\n",
    "        'div_para_half_list': ['B'],  # 第一层半筛选参数\n",
    "        'div_para_second_list': ['T1'],  # 第二层筛选参数\n",
    "    }\n",
    "    \n",
    "    # 加载数据\n",
    "    # data = pd.read_csv('your_data.csv')  # 加载您的实际数据\n",
    "    # data = df_selected_del[df_selected_del['B']!=400]  # 或使用筛选后的数据\n",
    "    # data = data2  # 或使用data2\n",
    "    \n",
    "    # 示例数据（请替换为您的实际数据）\n",
    "    import pandas as pd\n",
    "    np.random.seed(42)\n",
    "    n_samples = 1000\n",
    "    \n",
    "    data = data2\n",
    "    \n",
    "    # 处理并绘图\n",
    "    plt_obj = process_hierarchical_data(data, config, param_settings)\n",
    "    plt_obj.show()\n",
    "    \n",
    "    # 保存图形\n",
    "    # plt_obj.savefig(r'R:\\PhDall\\matplotilibpic\\colorsdivlittle6' + param_settings['x_aixs_paralist'][0] + '.svg')\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "650cd0b9",
   "metadata": {},
   "source": [
    "### 整体截面集合因素3D"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "12eb9664",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "# import matplotlib.pyplot as plt\n",
    "# from matplotlib import cm\n",
    "# from matplotlib import mpl\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "# 定义绘图颜色映射类型\n",
    "colorltype = 'viridis'\n",
    "\n",
    "# 此函数用于绘制3D散点图\n",
    "def pic_ktaucr_inpicolor_x_3dscatter(axes_sub_fig, df_pre, div_colandlegend_para, x_aixs_para, y_aixs_para, x_y_aixs_para):\n",
    "    # 重置索引，去掉原行名\n",
    "    df_pre1 = df_pre.reset_index(drop=True)\n",
    "    # 对颜色分类参数列进行数值统计\n",
    "    print(f\"颜色分类参数 {div_colandlegend_para} 的数值统计:\")\n",
    "    print(df_pre1[div_colandlegend_para].value_counts())\n",
    "    # 对颜色分类参数列进行数值排序\n",
    "    div_pic = df_pre1[div_colandlegend_para].sort_values()\n",
    "    # 统计颜色分类参数列不同数值的数量\n",
    "    num_diff_divpic = len(div_pic.value_counts())\n",
    "    # 获取用于颜色映射的列数据\n",
    "    coltocmap = df_pre[div_colandlegend_para].values\n",
    "    # 获取颜色映射列的唯一值列表\n",
    "    coltocmap_unique = list(df_pre[div_colandlegend_para].sort_values().unique())\n",
    "    # 计算颜色映射列的最小值\n",
    "    minco = min(coltocmap)\n",
    "    # 计算颜色映射列的最大值\n",
    "    maxco = max(coltocmap)\n",
    "    print(f\"颜色映射列 {div_colandlegend_para} 的最小值: {minco}, 最大值: {maxco}\")\n",
    "\n",
    "    # 对每一种颜色数值关系进行绘图\n",
    "    for num_colandlegend in range(num_diff_divpic):\n",
    "        # 筛选出当前颜色分类参数值对应的子数据框\n",
    "        df_div_colandlegend = df_pre1[df_pre1[div_colandlegend_para] == div_pic.unique()[num_colandlegend]]\n",
    "        # 如果当前子数据框的x轴参数最小值不等于原始数据框的x轴参数最小值，则跳过\n",
    "        if min(df_div_colandlegend[x_aixs_para]) != min(df_pre[x_aixs_para]):\n",
    "            print(f\"跳过颜色分类参数值为 {div_pic.unique()[num_colandlegend]} 的数据，因为x轴参数最小值不匹配\")\n",
    "            continue\n",
    "\n",
    "        # 重置索引，去掉原行名\n",
    "        df_div_colandlegend = df_div_colandlegend.reset_index(drop=True)\n",
    "        # 对当前子数据框按颜色分类参数降序排序\n",
    "        div_colandlegend_finalpre = df_div_colandlegend.sort_values(by=div_colandlegend_para, ascending=False)\n",
    "        # 重置索引，去掉原行名\n",
    "        div_colandlegend_final = div_colandlegend_finalpre.reset_index(drop=True)\n",
    "\n",
    "        # 初始化用于存储绘图数据的列表\n",
    "        x_ks_plotlist = []\n",
    "        x_y_ks_plotlist = []\n",
    "        y_ks_plotlist = []\n",
    "        z_ks_plotlist = []\n",
    "\n",
    "        # 遍历当前子数据框的每一行，提取绘图所需数据\n",
    "        for num_ks in range(len(div_colandlegend_final)):\n",
    "            x_ks = div_colandlegend_final.at[num_ks, x_aixs_para]\n",
    "            x_y_ks = div_colandlegend_final.at[num_ks, x_y_aixs_para]\n",
    "            y_ks = div_colandlegend_final.at[num_ks, y_aixs_para]\n",
    "            z_ks = div_colandlegend_final.at[num_ks, div_colandlegend_para]\n",
    "\n",
    "            # 如果x轴参数为'pbol'，进行单位转换\n",
    "            if x_aixs_para == 'pbol':\n",
    "                x_ks_plotlist.append(x_ks / 1000)\n",
    "            else:\n",
    "                x_ks_plotlist.append(x_ks)\n",
    "\n",
    "            x_y_ks_plotlist.append(x_y_ks)\n",
    "            y_ks_plotlist.append(y_ks)\n",
    "            z_ks_plotlist.append(z_ks)\n",
    "\n",
    "        # 处理分母为零的情况，避免出现除零错误\n",
    "        if maxco == minco:\n",
    "            colorlmap_ks = np.zeros_like(z_ks_plotlist)\n",
    "        else:\n",
    "            colorlmap_ks = (np.array(z_ks_plotlist) - minco) / (maxco - minco)\n",
    "\n",
    "        # 调整颜色映射值的形状\n",
    "        colorlmap_ks_list = colorlmap_ks.reshape(-1, 1)\n",
    "\n",
    "        # 绘制散点图\n",
    "        axes_sub_fig.scatter(x_ks_plotlist, x_y_ks_plotlist, y_ks_plotlist, c=colorlmap_ks_list, cmap=colorltype, vmin=0, vmax=1, s=20, alpha=1)\n",
    "        print(f\"绘制颜色分类参数值为 {div_pic.unique()[num_colandlegend]} 的散点图\")\n",
    "\n",
    "        # 创建归一化对象\n",
    "        norm_plot = mpl.colors.Normalize(vmin=0, vmax=1)\n",
    "        # 获取颜色映射对象\n",
    "        cmap_plot = cm.get_cmap(colorltype)\n",
    "        # 创建标量映射对象\n",
    "        m_plot = cm.ScalarMappable(norm=norm_plot, cmap=cmap_plot)\n",
    "        # 绘制线条图\n",
    "        axes_sub_fig.plot(x_ks_plotlist, x_y_ks_plotlist, y_ks_plotlist, c=m_plot.to_rgba(float(min(colorlmap_ks_list))))\n",
    "\n",
    "\n",
    "# 主绘图函数\n",
    "def main_plotting(df):\n",
    "    # 设置筛选参数\n",
    "    div_colandlegend_para_list = ['n']\n",
    "    x_aixs_paralist = ['T1']\n",
    "    x_y_aixs_paralist = ['T2']\n",
    "    y_aixs_para = 'KG_quge_web'\n",
    "    div_para_list = ['H']\n",
    "    div_para_half_list = ['B']\n",
    "    div_para_second_list = ['L']\n",
    "    sort_list = ['H', 'B', 'T1', 'T2', 'n']\n",
    "    div_para_plot_prelist = [sort_list[(len(sort_list) - 1)]]\n",
    "\n",
    "    numaxsub = 0\n",
    "\n",
    "    # 对第一层筛选参数进行循环\n",
    "    for num_div_para in range(len(div_para_list)):\n",
    "        # 重置索引，去掉原行名\n",
    "        df_pre_df_para = df.reset_index(drop=True)\n",
    "        div_para = div_para_list[num_div_para]\n",
    "        # 对第一层筛选参数列进行数值排序\n",
    "        div_pic_df_para = df_pre_df_para[div_para].sort_values()\n",
    "        # 统计第一层筛选参数列不同数值的数量\n",
    "        len_diff_divpic_df_para = len(div_pic_df_para.value_counts())\n",
    "        print(f\"第一层筛选参数 {div_para} 的不同数值数量: {len_diff_divpic_df_para}\")\n",
    "\n",
    "        # 创建新的图形窗口\n",
    "        plt.figure(figsize=(15, 15))\n",
    "\n",
    "        # 对第一层筛选参数的每一种数值关系进行绘图\n",
    "        for num_colandlegend_df_para in range(len_diff_divpic_df_para):\n",
    "            # 筛选出当前第一层筛选参数值对应的子数据框\n",
    "            df_second = df_pre_df_para[df_pre_df_para[div_para] == div_pic_df_para.unique()[num_colandlegend_df_para]]\n",
    "\n",
    "            # 对第一层半筛选参数进行循环\n",
    "            for num_div_half_para in range(len(div_para_half_list)):\n",
    "                # 重置索引，去掉原行名\n",
    "                df_pre_df_half_para = df_second.reset_index(drop=True)\n",
    "                div_half_para = div_para_half_list[num_div_half_para]\n",
    "                # 对第一层半筛选参数列进行数值排序\n",
    "                div_pic_df_half_para = df_pre_df_half_para[div_half_para].sort_values()\n",
    "                # 统计第一层半筛选参数列不同数值的数量\n",
    "                len_diff_divpic_df_half_para = len(div_pic_df_half_para.value_counts())\n",
    "                print(f\"第一层半筛选参数 {div_half_para} 的不同数值数量: {len_diff_divpic_df_half_para}\")\n",
    "\n",
    "                # 对第一层半筛选参数的每一种数值关系进行绘图\n",
    "                for num_colandlegend_df_half_para in range(len_diff_divpic_df_half_para):\n",
    "                    # 筛选出当前第一层半筛选参数值对应的子数据框\n",
    "                    df_prehalf = df_pre_df_half_para[df_pre_df_half_para[div_half_para] == div_pic_df_half_para.unique()[num_colandlegend_df_half_para]]\n",
    "\n",
    "                    # 对第二层筛选参数进行循环\n",
    "                    for num_div_second_para in range(len(div_para_second_list)):\n",
    "                        if len(df_prehalf) < 10:\n",
    "                            print(f\"跳过第二层筛选，因为数据量少于10条\")\n",
    "                            break\n",
    "\n",
    "                        # 重置索引，去掉原行名\n",
    "                        df_pre_df_second_para = df_prehalf.reset_index(drop=True)\n",
    "                        div_second_para = div_para_second_list[num_div_second_para]\n",
    "                        # 对第二层筛选参数列进行数值排序\n",
    "                        div_pic_df_second_para = df_pre_df_second_para[div_second_para].sort_values()\n",
    "                        # 统计第二层筛选参数列不同数值的数量\n",
    "                        num_diff_divpic_df_second_para = len(div_pic_df_second_para.value_counts())\n",
    "                        print(f\"第二层筛选参数 {div_second_para} 的不同数值数量: {num_diff_divpic_df_second_para}\")\n",
    "\n",
    "                        # 对第二层筛选参数的每一种数值关系进行绘图\n",
    "                        for num_colandlegend_df_second_para in range(num_diff_divpic_df_second_para):\n",
    "                            # 筛选出当前第二层筛选参数值对应的子数据框\n",
    "                            df_div_para_second_colandlegend = df_pre_df_second_para[df_pre_df_second_para[div_second_para] == div_pic_df_second_para.unique()[num_colandlegend_df_second_para]]\n",
    "                            df_pre = df_div_para_second_colandlegend\n",
    "                            print(f\"当前子数据框长度: {len(df_pre)}\")\n",
    "                            print(f\"第一层参数 {div_para}: {div_pic_df_para.unique()[num_colandlegend_df_para]}, 类型: {type(div_pic_df_para.unique()[num_colandlegend_df_para])}\")\n",
    "                            print(f\"第一层半参数 {div_half_para}: {div_pic_df_half_para.unique()[num_colandlegend_df_half_para]}\")\n",
    "                            print(f\"第二层参数 {div_second_para}: {div_pic_df_second_para.unique()[num_colandlegend_df_second_para]}\")\n",
    "\n",
    "                            # 增加子图计数器\n",
    "                            numaxsub = numaxsub + 1\n",
    "                            # 创建子图\n",
    "                            axes_sub_fig = plt.subplot(4, 4, numaxsub, projection='3d')\n",
    "                            print(f\"创建子图，编号: {numaxsub}\")\n",
    "\n",
    "                            # 对x轴参数进行循环\n",
    "                            for i in range(len(x_aixs_paralist)):\n",
    "                                x_aixs_para = x_aixs_paralist[i]\n",
    "                                x_y_aixs_para = x_y_aixs_paralist[0]\n",
    "                                print(f\"当前x_y轴参数: {x_y_aixs_para}\")\n",
    "\n",
    "                                # 对颜色分类参数进行循环\n",
    "                                for j in range(len(div_colandlegend_para_list)):\n",
    "                                    div_colandlegend_para = div_colandlegend_para_list[j]\n",
    "                                    df_plot = df_pre\n",
    "\n",
    "                                    # 对绘图前筛选参数进行循环\n",
    "                                    for num_div_plot_prepara in range(len(div_para_plot_prelist)):\n",
    "                                        # 重置索引，去掉原行名\n",
    "                                        df_pre_df_plot_prepara = df_plot.reset_index(drop=True)\n",
    "                                        div_plot_prepara = div_para_plot_prelist[num_div_plot_prepara]\n",
    "                                        # 对绘图前筛选参数列进行数值排序\n",
    "                                        div_pic_df_plot_prepara = df_pre_df_plot_prepara[div_plot_prepara].sort_values()\n",
    "                                        # 统计绘图前筛选参数列不同数值的数量\n",
    "                                        len_diff_divpic_df_plot_prepara = len(div_pic_df_plot_prepara.value_counts())\n",
    "                                        print(f\"绘图前筛选参数 {div_plot_prepara} 的不同数值数量: {len_diff_divpic_df_plot_prepara}\")\n",
    "\n",
    "                                        # 对绘图前筛选参数的每一种数值关系进行绘图\n",
    "                                        for num_colandlegend_df_plot_prepara in range(len_diff_divpic_df_plot_prepara):\n",
    "                                            # 筛选出当前绘图前筛选参数值对应的子数据框\n",
    "                                            df_plot = df_pre_df_plot_prepara[df_pre_df_plot_prepara[div_plot_prepara] == div_pic_df_plot_prepara.unique()[num_colandlegend_df_plot_prepara]]\n",
    "                                            # 调用绘图函数\n",
    "                                            pic_ktaucr_inpicolor_x_3dscatter(axes_sub_fig, df_plot, div_colandlegend_para, x_aixs_para, y_aixs_para, x_y_aixs_para)\n",
    "\n",
    "                            # 设置子图标题\n",
    "                            axes_sub_fig.set_title(f\"{div_para}={div_pic_df_para.unique()[num_colandlegend_df_para]} {div_half_para}={div_pic_df_half_para.unique()[num_colandlegend_df_half_para]}\",\n",
    "                                                   fontdict={'size': 12}, x=0.5, y=0.9)\n",
    "\n",
    "                            # 根据第一层筛选参数值设置z轴范围\n",
    "                            if div_pic_df_para.unique()[num_colandlegend_df_para] <= 100:\n",
    "                                axes_sub_fig.set_zlim(0, 50)\n",
    "                            elif div_pic_df_para.unique()[num_colandlegend_df_para] > 300:\n",
    "                                axes_sub_fig.set_zlim(0, 4)\n",
    "                            else:\n",
    "                                axes_sub_fig.set_zlim(0, 8)\n",
    "\n",
    "                            # 设置x轴刻度\n",
    "                            axes_sub_fig.set_xticks([0.3, 0.35, 0.4, 0.45])\n",
    "                            # 设置y轴刻度\n",
    "                            axes_sub_fig.set_yticks([1, 5, 9])\n",
    "                            # 设置y轴标签\n",
    "                            axes_sub_fig.set_ylabel(f'${x_y_aixs_para}$')\n",
    "                            # 设置z轴标签\n",
    "                            axes_sub_fig.set_zlabel(r'$\\phi$ 变化率(%)', rotation=90, labelpad=-3.5)\n",
    "                            # 设置视角\n",
    "                            axes_sub_fig.view_init(elev=12, azim=290)\n",
    "                            # 不旋转z轴标签\n",
    "                            axes_sub_fig.zaxis.set_rotate_label(False)\n",
    "                            # 更改z轴位置\n",
    "                            axes_sub_fig.zaxis._axinfo['juggled'] = (1, 2, 7)\n",
    "\n",
    "    # 自动调整子图布局\n",
    "    plt.tight_layout()\n",
    "    # 显示图形\n",
    "    plt.show()\n",
    "    # 保存图形为SVG文件\n",
    "#     plt.savefig(r'R:\\PhDall\\matplotilibpic\\colorsdivlittle6.svg')\n",
    "\n",
    "\n",
    "# 示例调用，假设df_alltype是你的数据框\n",
    "main_plotting(df_alltype)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49481011",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "37a20344",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pylab import mpl\n",
    "from matplotlib.ticker import MultipleLocator,FormatStrFormatter\n",
    "from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.axis import Axis \n",
    "from matplotlib.colors import Normalize\n",
    "import matplotlib.cm as cm\n",
    "import matplotlib.ticker as mtick\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d import proj3d \n",
    "\n",
    "# fig = plt.figure(figsize=[6,6])\n",
    "pointsize=10\n",
    "textsize=12\n",
    "xlinenum=4\n",
    "ylinenum=4\n",
    "figsizex= 3.2*ylinenum# 博士论文的版面A4宽度21cm，学校要求为两边各留3cm即15cm净宽。换算约5.9英寸,等分后约1.9英寸，给一个较大值缩减比例进论文）\n",
    "figsizey= figsizex/ylinenum*xlinenum\n",
    "# fig = plt.figure(figsize=[figsizex,figsizey])\n",
    "\n",
    "font_setS = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=textsize) # 字体设置宋体\n",
    "plt.rc('font',family='Times New Roman')# 全局字体为新罗马  \n",
    "plt.rcParams[\"font.sans-serif\"]=[\"Simsun\"]\n",
    "plt.rcParams['axes.unicode_minus']=False\n",
    "plt.rcParams['xtick.direction'] = 'in'# x刻度向内侧显示\n",
    "plt.rcParams['ytick.direction'] = 'in'# y刻度向内侧显示\n",
    "plt.tick_params(bottom=True,top=True,left=True,right=True)# 显示上部和右侧刻度线\n",
    "\n",
    "\n",
    "# # # ——————————散点图——————————\n",
    "def pic_ktaucr_inpicolor_x_3dscatter(df_pre,div_colandlegend_para,x_aixs_para,y_aixs_para,x_y_aixs_para):\n",
    "# #     下面的函数定义是绘图用的\n",
    "# #画图函数（不需要的参数，不需要的参数对应的值，分类的参数，x轴，y轴）\n",
    "    # 分类准备工作，这些都是针对‘颜色分类的参数’div_colandlegend_para\n",
    "\n",
    "    df_pre1=df_pre.reset_index(drop=True)#去掉行名\n",
    "    df_pre1[div_colandlegend_para].value_counts()#可能——数值统计\n",
    "    div_pic=df_pre1[div_colandlegend_para].sort_values()#可能——数值排序\n",
    "    div_pic.unique()#区格宽高比的唯一数值统计\n",
    "    num_diff_divpic=len(div_pic.value_counts())#可能——不同数值的数量\n",
    "# ——————构造颜色数值对应关系——————————\n",
    "    coltocmap=df_pre[div_colandlegend_para].values#采用外层的df分颜色\n",
    "    coltocmap_unique=list(df_pre[div_colandlegend_para].sort_values().unique())\n",
    "    minco=min(coltocmap)-((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))\n",
    "    maxco=max(coltocmap)+((max(coltocmap)-min(coltocmap))/((len(coltocmap)-1)*2))\n",
    "# ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend in range(0,num_diff_divpic):\n",
    "        df_div_colandlegend=df_pre1[(df_pre1[div_colandlegend_para]==div_pic.unique()[num_colandlegend])]\n",
    "        #上面是可能——数值df建立\n",
    "        df_div_colandlegend=df_div_colandlegend.reset_index(drop=True)#去掉行名    \n",
    "        #此处得到的df_div_colandlegend就是已经按照颜色分类过的dataframe\n",
    "        div_colandlegend_finalpre=df_div_colandlegend.sort_values(by=div_colandlegend_para,ascending=False)#单拿出来并排序 \n",
    "        div_colandlegend_final=div_colandlegend_finalpre.reset_index(drop=True)#去掉行名           \n",
    "        #  对本种颜色下进行循环构造画图的listdf，x轴从小到大\n",
    "        x_ks_plotlist =[]\n",
    "        x_y_ks_plotlist =[]\n",
    "        y_ks_plotlist =[]\n",
    "        num_del=0\n",
    "#——————把每个点循环并赋予颜色（一行一行的绘制，即一个点一个点的绘制），构造出来需要的list——————\n",
    "        for num_ks in range(0,len(div_colandlegend_final)):\n",
    "                x_ks=div_colandlegend_final.at[num_ks, x_aixs_para]\n",
    "                x_y_ks=div_colandlegend_final.at[num_ks, x_y_aixs_para]\n",
    "                y_ks=div_colandlegend_final.at[num_ks, y_aixs_para]\n",
    "                z_ks=div_colandlegend_final.at[num_ks, div_colandlegend_para]\n",
    "                x_ks_plotlist.append(x_ks)\n",
    "                x_y_ks_plotlist.append(x_y_ks) \n",
    "                y_ks_plotlist.append(y_ks)\n",
    "        colorlmap_ks=(z_ks-minco)/maxco\n",
    "        colorlmap_ks_list=np.full((len(div_colandlegend_final)-num_del,1),colorlmap_ks)\n",
    "#————————————————小图内每个颜色的绘制——————————————————\n",
    "#         ax = fig.add_subplot(projection='3d')\n",
    "#         ax.scatter(df3d['pbol'].values , df3d['F'].values, df3d['yin_diff'].values, c='r')#绘图命令n=3\n",
    "#  np.array(list1)\n",
    "        print(np.array(x_ks_plotlist))\n",
    "        print(np.array(x_y_ks_plotlist))\n",
    "        print(np.array(y_ks_plotlist))\n",
    "        axes_sub_fig.scatter(np.array(x_ks_plotlist),np.array(x_y_ks_plotlist),np.array(y_ks_plotlist),c=colorlmap_ks_list, cmap=colorltype, vmin=0, vmax=1,s=20,alpha=1)\n",
    "        print(x_ks_plotlist)\n",
    "        print(x_y_ks_plotlist)\n",
    "\n",
    "\n",
    "        norm_plot = mpl.colors.Normalize(vmin=0, vmax=1)\n",
    "        cmap_plot = cm.get_cmap(colorltype)\n",
    "        m_plot = cm.ScalarMappable(norm=norm_plot, cmap=cmap_plot)\n",
    "        axes_sub_fig.plot(np.array(x_ks_plotlist),np.array(x_y_ks_plotlist),np.array(y_ks_plotlist),c=m_plot.to_rgba(float(min(colorlmap_ks_list))))\n",
    "\n",
    "# ———————————colorbar的位置———————————  \n",
    "    divider = make_axes_locatable(plt.gca()) \n",
    "    cax = divider.append_axes(\"right\", \"5 %\",  pad =\"0%\")  \n",
    "#———————————对颜色参数进行处理，以方便构造colorbar———————————  \n",
    "    if len(coltocmap_unique)!=1:\n",
    "        minco_colorbar=min(coltocmap_unique)-((max(coltocmap_unique)-min(coltocmap_unique))/((len(coltocmap_unique)-1)*2))\n",
    "        maxco_colorbar=max(coltocmap_unique)+((max(coltocmap_unique)-min(coltocmap_unique))/((len(coltocmap_unique)-1)*2))\n",
    "    if len(coltocmap_unique)==1:          \n",
    "        minco_colorbar=min(coltocmap_unique)\n",
    "        maxco_colorbar=max(coltocmap_unique)\n",
    "    colorbarparadiff=(maxco_colorbar-minco_colorbar)/10\n",
    "    #下面是采用平均的数值来构造colorbar\n",
    "#     colorbarpara=[minco_colorbar]+[minco_colorbar+colorbarparadiff*1]+[minco_colorbar+colorbarparadiff*2]+[minco_colorbar+colorbarparadiff*3]+[minco_colorbar+colorbarparadiff*4]+[minco_colorbar+colorbarparadiff*5]+[minco_colorbar+colorbarparadiff*6]+[minco_colorbar+colorbarparadiff*7]+[minco_colorbar+colorbarparadiff*8]+[minco_colorbar+colorbarparadiff*9]+[maxco_colorbar]\n",
    "    #下面是采用实际的可能的数值来构造colorbar\n",
    "    colorbarpara=coltocmap_unique\n",
    "#——————————————colorbar设置————————————————————————————————\n",
    "    cmap = plt.get_cmap(colorltype) #获取颜色类型\n",
    "    #对颜色类型进行最大最小值正则化，这里的vmin和vmax指的是填充colorbar的区域\n",
    "    norm = mpl.colors.Normalize(vmin=min(colorbarpara), vmax= max(colorbarpara))\n",
    "    scalarMap = plt.cm.ScalarMappable(norm=norm, cmap=cmap)#提供一个可以映射颜色的对象\n",
    "# #——————————————colorbar右侧数字的设置————————————————————————————————\n",
    "    cb = plt.colorbar(scalarMap,cax=cax, orientation=\"vertical\") \n",
    "#     if maxco_colorbar<1:\n",
    "    labels =np.round(colorbarpara,2)#指的是cb标签的数字\n",
    "    loc    =np.round(colorbarpara,2)#指的是cb横线的位置\n",
    "#     else:\n",
    "#         labels =np.round(colorbarpara)#指的是cb标签的数字\n",
    "#         loc    =np.round(colorbarpara)#指的是cb横线的位置\n",
    "    cb.set_ticks(loc) \n",
    "    cb.set_ticklabels(labels)  \n",
    "#     for labels in cb.ax.yaxis.get_ticklabels()[::len(coltocmap_unique)+1]:# 隐藏掉最大值和最小值\n",
    "#         labels.set_visible(False)\n",
    "    plt.colorbar\n",
    "# # ——————————————def函数定义结束————————————————————————————————  \n",
    "\n",
    "\n",
    "# # ——————————预设信息设置————————\n",
    "colorltype=str('viridis')\n",
    "\n",
    "\n",
    "# 图内分类型参数（变色或者变形状）\n",
    "div_colandlegend_para_list=['n']\n",
    "# # x_轴\n",
    "x_aixs_paralist=['T1']\n",
    "# x_aixs_para=df.columns\n",
    "# 第二x_轴\n",
    "x_y_aixs_paralist=['T2']\n",
    "div_para_plot_prelist=x_y_aixs_paralist\n",
    "# y_轴\n",
    "y_aixs_para=str('KG_quge_web')\n",
    "# yin_diff，pbol_del\n",
    "# 分图筛选一下\n",
    "# 参数KG_quge_web，KH_quge_web，ratio_alpha_Bflange_to_Hn，ratio_alpha_tflange_to_tweb，pbol_del，EigenValue\n",
    "# ['B', 'H','L', 'T1', 'T2', 'n','ratio_alpha_Bflange_to_Hn','KH_quge_web']\n",
    "div_para_list=['H']#第一层筛选参数\n",
    "div_para_half_list=['B']#第一层半筛选参数\n",
    "# div_para_half_prelist=['L']#第二层前\n",
    "div_para_second_list=['L']#第二层筛选参数\n",
    "# dfori=df[df[para_without_para]==para_without_paranum]\n",
    "# print(len(dfori))\n",
    "\n",
    "numaxsub=0\n",
    "# 筛选拼接数量n，用的是函数中的第一个参数\n",
    "# df=df_selected_del[(df_selected_del['n']!=1)&(df_selected_del['n']!=1)]# 这个df_pre已经筛选完了‘不需要的参数’和它“不需要的参数”\n",
    "df=df_T\n",
    "# #————————分割图形的筛选方法（筛选第一层）——————————\n",
    "for num_div_para in range(0,len(div_para_list)):\n",
    "    df_pre_df_para=df.reset_index(drop=True)#去掉行名\n",
    "    div_para=div_para_list[num_div_para]\n",
    "    div_pic_df_para=df_pre_df_para[div_para].sort_values()#可能——数值排序\n",
    "    len_diff_divpic_df_para=len(div_pic_df_para.value_counts())#可能——不同数值的数量\n",
    "    plt.figure(figsize=(figsizex,figsizey))\n",
    "    # ——————对每一种颜色数值关系都作图——————————\n",
    "    for num_colandlegend_df_para in range(0,len_diff_divpic_df_para):\n",
    "        df_second=df_pre_df_para[(df_pre_df_para[div_para]==div_pic_df_para.unique()[num_colandlegend_df_para])]\n",
    "#         print('颜色变量',div_para,div_pic_df_para.unique()[num_colandlegend_df_para])\n",
    "        #连接两种作用的函数的df\n",
    "# #————————第一层筛选结束——————————    \n",
    "# #————————分割-图形的筛选方法（筛选一层半）——————————\n",
    "        for num_div_half_para in range(0,len(div_para_half_list)):\n",
    "            df_pre_df_half_para=df_second.reset_index(drop=True)#去掉行名\n",
    "            div_half_para=div_para_half_list[num_div_half_para]\n",
    "            div_pic_df_half_para=df_pre_df_half_para[div_half_para].sort_values()#可能——数值排序\n",
    "            len_diff_divpic_df_half_para=len(div_pic_df_half_para.value_counts())#可能——不同数值的数量\n",
    "#             plt.figure(figsize=(figsizex,figsizey))\n",
    "            # ——————对每一种颜色数值关系都作图——————————\n",
    "            for num_colandlegend_df_half_para in range(0,len_diff_divpic_df_half_para):\n",
    "                df_prehalf=df_pre_df_half_para[(df_pre_df_half_para[div_half_para]==div_pic_df_half_para.unique()[num_colandlegend_df_half_para])]\n",
    "#                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                #连接两种作用的函数的df\n",
    "        # #————————第层半筛选结束——————————    \n",
    "#                 # #————————分割图形的筛选方法（筛选二层前）——————————\n",
    "#                 for num_div_half_prepara in range(0,len(div_para_half_prelist)):\n",
    "#                     df_pre_df_half_prepara=df_half.reset_index(drop=True)#去掉行名\n",
    "#                     div_half_prepara=div_para_half_prelist[num_div_half_prepara]\n",
    "#                     div_pic_df_half_prepara=df_pre_df_half_prepara[div_half_prepara].sort_values()#可能——数值排序\n",
    "#                     len_diff_divpic_df_half_prepara=len(div_pic_df_half_prepara.value_counts())#可能——不同数值的数量\n",
    "#         #             plt.figure(figsize=(figsizex,figsizey))\n",
    "#                     # ——————对每一种颜色数值关系都作图——————————\n",
    "#                     for num_colandlegend_df_half_prepara in range(0,len_diff_divpic_df_half_prepara):\n",
    "#                         df_prehalf=df_pre_df_half_prepara[(df_pre_df_half_prepara[div_half_prepara]==div_pic_df_half_prepara.unique()[num_colandlegend_df_half_prepara])]\n",
    "#         #                 print('颜色变量',div_half_para,df_pre_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "#                         #连接两种作用的函数的df\n",
    "#                 # #————————第二层前筛选结束——————————   \n",
    "                #————————分割图形的筛选方法（筛选第第二层）——————————\n",
    "                for num_div_second_para in range(0,len(div_para_second_list)):\n",
    "                    if len(df_prehalf)<10:\n",
    "                        break\n",
    "                    else:\n",
    "                        df_pre_df_second_para=df_prehalf.reset_index(drop=True)#去掉行名\n",
    "                        div_second_para=div_para_second_list[num_div_second_para]\n",
    "                        div_pic_df_second_para=df_pre_df_second_para[div_second_para].sort_values()#可能——数值排序\n",
    "                        num_diff_divpic_df_second_para=len(div_pic_df_second_para.value_counts())#可能——不同数值的数量\n",
    "                        # ——————对每一种颜色数值关系都作图——————————\n",
    "                        for num_colandlegend_df_second_para in range(0,num_diff_divpic_df_second_para):\n",
    "                            df_div_para_second_colandlegend=df_pre_df_second_para[(df_pre_df_second_para[div_second_para]==div_pic_df_second_para.unique()[num_colandlegend_df_second_para])]\n",
    "                            df_pre=df_div_para_second_colandlegend #连接两种作用的函数的df\n",
    "                            print('df_pre',len(df_pre))\n",
    "                            print('第一层参数',div_para,div_pic_df_para.unique()[num_colandlegend_df_para],type(div_pic_df_para.unique()[num_colandlegend_df_para]))\n",
    "                            print('第一层半参数',div_half_para,div_pic_df_half_para.unique()[num_colandlegend_df_half_para])\n",
    "                            print('第二层参数',div_second_para,div_pic_df_second_para.unique()[num_colandlegend_df_second_para])\n",
    "                            #  构造小图排布所需要的的画布布局\n",
    "            #                 xint=int(len_diff_divpic_df_para**0.5)+1#图纸分布x\n",
    "            #                 yint=int(len_diff_divpic_df_para**0.5)+1#图纸分布y\n",
    "#                             numaxsub=numaxsub+1\n",
    "#                             axes_sub_fig=plt.subplot(5,5,numaxsub,projection='3d')# 小图排布\n",
    "            # # #————————第二层筛选结束——————————    \n",
    "                            for i in range(0,len(x_aixs_paralist)):\n",
    "                                x_aixs_para=x_aixs_paralist[i]\n",
    "                                x_y_aixs_para=x_y_aixs_paralist[0]\n",
    "                                print('x_y_aixs_para',x_y_aixs_para)\n",
    "                          \n",
    "\n",
    "                                       #——————每一张大图内一点一点画小图，主要作用——————————————————\n",
    "                                for j in range(0,len(div_colandlegend_para_list)):\n",
    "                                    div_colandlegend_para=div_colandlegend_para_list[j]\n",
    "                                    df_plot=df_pre\n",
    "                                    # #————————分割图形的筛选方法（筛选二层前）——————————\n",
    "                                    for num_div_plot_prepara in range(0,len(div_para_plot_prelist)):\n",
    "                                        df_pre_df_plot_prepara=df_plot.reset_index(drop=True)#去掉行名\n",
    "                                        div_plot_prepara=div_para_plot_prelist[num_div_plot_prepara]\n",
    "                                        div_pic_df_plot_prepara=df_pre_df_plot_prepara[div_plot_prepara].sort_values()#可能——数值排序\n",
    "                                        len_diff_divpic_df_plot_prepara=len(div_pic_df_plot_prepara.value_counts())#可能——不同数值的数量\n",
    "                                        if len_diff_divpic_df_plot_prepara<3:\n",
    "                                            break\n",
    "                                        numaxsub=numaxsub+1\n",
    "                                        axes_sub_fig=plt.subplot(5,5,numaxsub,projection='3d')# 小图排布\n",
    "                                        # ——————对每一种颜色数值关系都作图——————————\n",
    "                                        for num_colandlegend_df_plot_prepara in range(0,len_diff_divpic_df_plot_prepara):\n",
    "                                            df_plot=df_pre_df_plot_prepara[(df_pre_df_plot_prepara[div_plot_prepara]==div_pic_df_plot_prepara.unique()[num_colandlegend_df_plot_prepara])]\n",
    "#                                             if\n",
    "#                                             numaxsub=numaxsub+1\n",
    "#                                             axes_sub_fig=plt.subplot(5,5,numaxsub,projection='3d')# 小图排布\n",
    "                                            pic_ktaucr_inpicolor_x_3dscatter(df_plot,div_colandlegend_para,x_aixs_para,y_aixs_para,x_y_aixs_para) \n",
    "\n",
    "                                    \n",
    "#                                     pic_ktaucr_inpicolor_x_3dscatter(df_pre,div_colandlegend_para,x_aixs_para,y_aixs_para,x_y_aixs_para) \n",
    "                                    textlegend=round(div_pic_df_para.unique()[num_colandlegend_df_para],0)#小数位数,2\n",
    "\n",
    "                                    axes_sub_fig.text(0,30,0.2,str(div_para)+str('=')\n",
    "                                        +str('%.0f'%div_pic_df_para.unique()[num_colandlegend_df_para])+str(' ')\n",
    "                                        +str(div_half_para)+str('=')\n",
    "                                        +str('%.0f'%div_pic_df_second_para.unique()[num_colandlegend_df_second_para])\n",
    "                                        +str(div_half_para)+str('=')\n",
    "                                        +str('%.0f'%div_pic_df_half_para.unique()[num_colandlegend_df_half_para]),\n",
    "                                        fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "#                                     axes_sub_fig.text(1.02,1.02,str('n'),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "\n",
    "                        #                 axes_sub_fig.text(0.4,0.75,str(r'$\\alpha_{\\mathrm{wKH}}$')+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                        #                 axes_sub_fig.text(0.2,0.6,str(r'$\\alpha_{\\mathrm{BtHn}}$')+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "                        #                 axes_sub_fig.text(0.4,0.75,str(div_para)+str('=')+str(textlegend),fontsize=textsize,transform=axes_sub_fig.transAxes)\n",
    "\n",
    "                        #-----------------------单独的图纸设置--------------------------------------------\n",
    "                                axes_sub_fig.set_xlim(0,30)\n",
    "#                                 xmajorLocator = MultipleLocator(500) #将y轴主刻度标签设置为1的倍数\n",
    "                                axes_sub_fig.set_xticks([5,15,25],fontsize=textsize)# x轴标签\n",
    "                                axes_sub_fig.set_ylim(35,0)\n",
    "#                                 ymajorLocator = MultipleLocator(500) #将y轴主刻度标签设置为1的倍数\n",
    "                                axes_sub_fig.set_yticks([5,18,30],fontsize=textsize)# x轴标签\n",
    "\n",
    "#                                 axes_sub_fig.set_zlim(0,3)               \n",
    "#                                 zmajorLocator = MultipleLocator(0.5) #将y轴主刻度标签设置为1的倍数                          \n",
    "\n",
    "\n",
    "\n",
    "                        #                 axes_sub_fig.set_xlabel(str(r'$t_\\mathrm{f}/t_\\mathrm{w}$'),fontsize=textsize)\n",
    "                        #                 axes_sub_fig.set_ylabel(r'$k_{\\mathrm{fem}}$',fontsize=textsize)\n",
    "            #                         axes_sub_fig.set_ylim(0,10)       \n",
    "#                                     axes_sub_fig.yaxis.set_major_formatter(mtick.FormatStrFormatter('%.2f'))        \n",
    "#                                         axes_sub_fig.set_yticks([0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5])# x轴标签\n",
    "#                                         axes_sub_fig.set_yticks([0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5])# xy轴标签\n",
    "#                                         axes_sub_fig.set_yticks([0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5])# z轴标签\n",
    "            #                     axes_sub_fig.yaxis.set_major_formatter(mtick.FormatStrFormatter('%.0f'))\n",
    "            #                     axes_sub_fig.yaxis.set_major_formatter(mtick.FormatStrFormatter('%.0f'))\n",
    "#                                         axes_sub_fig.ticklabel_format(axis=\"y\", style=\"sci\", scilimits=(0,6))#表示对范围之外的值换科学记数法，范围内的数不换；\n",
    "            #                     axes_sub_fig.ticklabel_format(axis=\"x\", style=\"sci\", scilimits=(50,300))\n",
    "            #                     axes_sub_fig.set_xticks([80,125,150,175,230,280],fontsize=textsize)# x轴标签\n",
    "                                axes_sub_fig.get_yaxis().get_offset_text().set(va='bottom', ha='left',fontsize=textsize)\n",
    "                                axes_sub_fig.yaxis.get_offset_text().set_fontsize(textsize)\n",
    "            #                     axes_sub_fig.set_xlabel('螺栓预拉力(kN)', fontproperties=font_setS)\n",
    "                                axes_sub_fig.set_xlabel('$'+x_aixs_paralist[0]+'$'+'(mm)', fontproperties=font_setS)\n",
    "#                                 axes_sub_fig.set_ylabel(str(r'$\\lambda_{\\rm n}$'), fontproperties=font_setS)   # \\rm代表转换为正体，$代表转化为数学模式\n",
    "#                                         axes_sub_fig.set_ylabel('临界力(kN)', fontproperties=font_setS)           \n",
    "                                axes_sub_fig.set_ylabel('$'+x_y_aixs_paralist[0]+'$'+'(mm)', fontproperties=font_setS)         \n",
    "            #                     axes_sub_fig.xticks(fontsize=textsize) \n",
    "            #                     axes_sub_fig.yticks(fontsize=textsize)  \n",
    "            #                     axes_sub_fig.set_ylim(df_pre[y_aixs_para].mean()*0.95/1000, df_pre[y_aixs_para].mean()*1.05/1000) \n",
    "\n",
    "                            axes_sub_fig.view_init(elev=20, azim=110)\n",
    "                            plt.tight_layout()\n",
    "                            plt.show\n",
    "#                             plt.savefig(r'R:\\PhDall\\matplotilibpic\\\\'+str('colorsdivlittle6')+x_aixs_para+'.svg')#保存图   "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "98db3a64",
   "metadata": {},
   "source": [
    "# 轴压传统拟合方法数据分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f3af117f",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "from typing import Dict, Tuple, List\n",
    "import symfit as sf\n",
    "from symfit import variables, Fit, Model, Piecewise, Eq, GreaterThan\n",
    "\n",
    "# ========================================\n",
    "# 配置管理模块\n",
    "# ========================================\n",
    "class ConfigManager:\n",
    "    DEPENDENT_VAR = \"SFcf2f_n\"\n",
    "    INDEPENDENT_VARS = [\"B\", \"H\", \"T1\", \"T2\", \"n\", \"L\", \"Imperfectfactor\", \"yfss\"]\n",
    "    GEO_VARS = [\"H\", \"B\", \"T1\", \"T2\", \"n\"]\n",
    "\n",
    "    FILTERS = {\n",
    "        \"type\": 0,\n",
    "        \"yfss\": 355.61,\n",
    "        \"Imperfectfactor\": 0.002,\n",
    "        \"meshsz\": 20,\n",
    "        \"cf1f\": 0,\n",
    "        \"cf2f\": 1,\n",
    "        \"cf3f\": 0\n",
    "    }\n",
    "\n",
    "    PLOT_CONFIG = {\n",
    "        \"xlim\": (0, 3),\n",
    "        \"ylim\": (0, 1.2)\n",
    "    }\n",
    "\n",
    "# ========================================\n",
    "# 数据处理模块\n",
    "# ========================================\n",
    "class DataProcessor:\n",
    "    @staticmethod\n",
    "    def filter_data(df: pd.DataFrame) -> pd.DataFrame:\n",
    "        \"\"\"应用数据过滤条件\"\"\"\n",
    "        mask = np.ones(len(df), dtype=bool)\n",
    "        for key, value in ConfigManager.FILTERS.items():\n",
    "            mask &= (df[key] == value)\n",
    "        return df[mask].copy()\n",
    "\n",
    "    @staticmethod\n",
    "    def save_checkpoint(df: pd.DataFrame, filename: str) -> None:\n",
    "        \"\"\"保存检查点数据\"\"\"\n",
    "        os.makedirs(os.path.dirname(filename), exist_ok=True)\n",
    "        df.to_csv(filename, index=False)\n",
    "        print(f\"Checkpoint saved: {filename}\")\n",
    "\n",
    "# ========================================\n",
    "# 拟合模型模块\n",
    "# ========================================\n",
    "class SpecFitter:\n",
    "    @staticmethod\n",
    "    def build_china_model() -> Tuple[Model, List]:\n",
    "        \"\"\"构建中国规范模型\"\"\"\n",
    "        x, y = variables('x, y')\n",
    "        params = {\n",
    "            'alphaa': sf.Parameter('alphaa', min=0, max=1),\n",
    "            'alphabs': sf.Parameter('alphabs', min=0, max=1),\n",
    "            'alphabl': sf.Parameter('alphabl', min=0, max=1),\n",
    "            'alphacs': sf.Parameter('alphacs', min=0, max=1),\n",
    "            'alphacl': sf.Parameter('alphacl', min=0, max=1)\n",
    "        }\n",
    "\n",
    "        y1 = 1 - params['alphaa'] * x**2\n",
    "        y2 = (params['alphabs'] + params['alphacs']*x + x**2 -\n",
    "              sf.sqrt((params['alphabs'] + params['alphacs']*x + x**2)**2 - 4*x**2)) / (2*x**2)\n",
    "        y3 = (params['alphabl'] + params['alphacl']*x + x**2 -\n",
    "              sf.sqrt((params['alphabl'] + params['alphacl']*x + x**2)**2 - 4*x**2)) / (2*x**2)\n",
    "\n",
    "        model = Model({y: Piecewise(\n",
    "            (y1, x <= 0.216),\n",
    "            (y2, x <= 1.05),\n",
    "            (y3, x > 1.05)\n",
    "        )})\n",
    "\n",
    "        constraints = [\n",
    "            Eq(y1.diff(x).subs(x, 0.216), y2.diff(x).subs(x, 0.216)),\n",
    "            Eq(y1.subs(x, 0.216), y2.subs(x, 0.216)),\n",
    "            Eq(y2.diff(x).subs(x, 1.05), y3.diff(x).subs(x, 1.05)),\n",
    "            Eq(y2.subs(x, 1.05), y3.subs(x, 1.05)),\n",
    "            GreaterThan(params['alphabl'], params['alphabs']),\n",
    "            GreaterThan(params['alphacl'], params['alphacs'])\n",
    "        ]\n",
    "        return model, list(params.values())\n",
    "\n",
    "    @staticmethod\n",
    "    def build_usa_model() -> Tuple[Model, List]:\n",
    "        \"\"\"构建美国规范模型\"\"\"\n",
    "        x, y = variables('x, y')\n",
    "        params = {\n",
    "            'x0us': sf.Parameter('x0us', value=1.5, min=1.49, max=1.51),\n",
    "            'alphausa': sf.Parameter('alphausa', value=0.658, min=0.6, max=0.7),\n",
    "            'alphausb': sf.Parameter('alphausb', value=0.877, min=0.8, max=0.9)\n",
    "        }\n",
    "\n",
    "        y1 = params['alphausa'] ** (x**2)\n",
    "        y2 = params['alphausb'] / (x**2)\n",
    "\n",
    "        model = Model({y: Piecewise(\n",
    "            (y1, x <= params['x0us']),\n",
    "            (y2, x > params['x0us'])\n",
    "        )})\n",
    "\n",
    "        constraints = [\n",
    "            Eq(y1.diff(x).subs(x, params['x0us']), y2.diff(x).subs(x, params['x0us'])),\n",
    "            Eq(y1.subs(x, params['x0us']), y2.subs(x, params['x0us']))\n",
    "        ]\n",
    "        return model, list(params.values())\n",
    "\n",
    "    @staticmethod\n",
    "    def build_eu_model() -> Tuple[Model, List]:\n",
    "        \"\"\"构建欧洲规范模型\"\"\"\n",
    "        x, y = variables('x, y')\n",
    "        params = {\n",
    "            'x0eu': sf.Parameter('x0eu', value=0.2, min=0.19, max=0.21),\n",
    "            'alphaeu': sf.Parameter('alphaeu', value=0.2, min=0.1, max=0.3)\n",
    "        }\n",
    "\n",
    "        y1 = 1.0\n",
    "        denominator = 0.5 * (1 + params['alphaeu']*(x - 0.2) + x**2) + \\\n",
    "                      sf.sqrt((0.5*(1 + params['alphaeu']*(x - 0.2) + x**2))**2 - x**2)\n",
    "        y2 = 1 / denominator\n",
    "\n",
    "        model = Model({y: Piecewise(\n",
    "            (y1, x <= params['x0eu']),\n",
    "            (y2, x > params['x0eu'])\n",
    "        )})\n",
    "\n",
    "        constraints = [Eq(y1, y2.subs(x, params['x0eu']))]\n",
    "        return model, list(params.values())\n",
    "\n",
    "# ========================================\n",
    "# 拟合执行模块\n",
    "# ========================================\n",
    "class FitExecutor:\n",
    "    @staticmethod\n",
    "    def execute_fit(model: Model, params: List,\n",
    "                    x_data: np.ndarray, y_data: np.ndarray) -> Dict:\n",
    "        \"\"\"执行拟合并返回结果\"\"\"\n",
    "        try:\n",
    "            fit = Fit(model, x=x_data, y=y_data, constraints=model.constraints)\n",
    "            result = fit.execute()\n",
    "            return {\n",
    "                'params': result.params,\n",
    "                'r_squared': result.r_squared,\n",
    "                'success': True\n",
    "            }\n",
    "        except Exception as e:\n",
    "            print(f\"Fitting failed: {str(e)}\")\n",
    "            return {\n",
    "                'params': {},\n",
    "                'r_squared': 0.0,\n",
    "                'success': False\n",
    "            }\n",
    "\n",
    "    @staticmethod\n",
    "    def plot_result(x_data: np.ndarray, y_data: np.ndarray,\n",
    "                    model: Model, params: Dict,\n",
    "                    geo_params: Dict, spec_name: str) -> None:\n",
    "        \"\"\"绘制拟合结果\"\"\"\n",
    "        plt.figure(figsize=(12, 6))\n",
    "        plt.scatter(x_data, y_data, label=\"Experimental Data\", alpha=0.6)\n",
    "\n",
    "        x_range = np.linspace(*ConfigManager.PLOT_CONFIG['xlim'], 300)\n",
    "        y_pred = model(x=x_range, **params).y\n",
    "        plt.plot(x_range, y_pred, 'r-', label=\"Fitted Curve\", linewidth=2)\n",
    "\n",
    "        plt.title(f\"{spec_name} Fit - {geo_params}\")\n",
    "        plt.xlabel(\"Non-dimensional Slenderness λ\")\n",
    "        plt.ylabel(\"Stability Factor φ\")\n",
    "        plt.xlim(ConfigManager.PLOT_CONFIG['xlim'])\n",
    "        plt.ylim(ConfigManager.PLOT_CONFIG['ylim'])\n",
    "        plt.legend()\n",
    "        plt.grid(True, linestyle='--', alpha=0.6)\n",
    "\n",
    "        save_path = os.path.join(\"plots\",\n",
    "                                 f\"{spec_name}_{'_'.join(map(str, geo_params.values()))}.png\")\n",
    "        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n",
    "        plt.savefig(save_path, dpi=300)\n",
    "        plt.close()\n",
    "\n",
    "# ========================================\n",
    "# 主执行流程\n",
    "# ========================================\n",
    "def main(raw_data: pd.DataFrame):\n",
    "    print(\"=== Program Execution Started ===\")\n",
    "\n",
    "    # 数据预处理\n",
    "    filtered_data = DataProcessor.filter_data(raw_data)\n",
    "    DataProcessor.save_checkpoint(filtered_data, \"data/filtered_data.csv\")\n",
    "\n",
    "    # 初始化结果存储\n",
    "    spec_results = {\n",
    "        '中国规范': pd.DataFrame(columns=ConfigManager.GEO_VARS +\n",
    "                               ['alphaa', 'alphabs', 'alphabl', 'alphacs', 'alphacl', 'R2']),\n",
    "        '美国规范': pd.DataFrame(columns=ConfigManager.GEO_VARS +\n",
    "                               ['alphausa', 'alphausb', 'R2']),\n",
    "        '欧洲规范': pd.DataFrame(columns=ConfigManager.GEO_VARS +\n",
    "                               ['alphaeu', 'R2'])\n",
    "    }\n",
    "\n",
    "    # 分组处理\n",
    "    grouped = filtered_data.groupby(ConfigManager.GEO_VARS)\n",
    "    print(f\"Total groups: {len(grouped)}\")\n",
    "\n",
    "    for group_key, group_data in grouped:\n",
    "        geo_params = dict(zip(ConfigManager.GEO_VARS, group_key))\n",
    "        print(f\"\\nProcessing group: {geo_params}\")\n",
    "\n",
    "        # 提取数据\n",
    "        x_data = group_data[\"L\"].values.reshape(-1, 1)\n",
    "        y_data = group_data[ConfigManager.DEPENDENT_VAR].values.reshape(-1, 1)\n",
    "\n",
    "        # 保存组数据\n",
    "        group_file = os.path.join(\"groups\", f\"group_{'_'.join(map(str, group_key))}.csv\")\n",
    "        DataProcessor.save_checkpoint(group_data, group_file)\n",
    "\n",
    "        # 执行各规范拟合\n",
    "        for spec in ['中国规范', '美国规范', '欧洲规范']:\n",
    "            if spec == '中国规范':\n",
    "                model, params = SpecFitter.build_china_model()\n",
    "            elif spec == '美国规范':\n",
    "                model, params = SpecFitter.build_usa_model()\n",
    "            else:\n",
    "                model, params = SpecFitter.build_eu_model()\n",
    "\n",
    "            fit_result = FitExecutor.execute_fit(model, params, x_data, y_data)\n",
    "            if fit_result['success'] and fit_result['r_squared'] > 0.85:\n",
    "                # 保存临时结果\n",
    "                temp_file = os.path.join(\"temp\", f\"{spec.lower()}_{'_'.join(map(str, group_key))}.csv\")\n",
    "                fit_result['params'].to_csv(temp_file, index=False)\n",
    "\n",
    "                # 更新最终结果\n",
    "                result_row = {**geo_params, **fit_result['params'], 'R2': fit_result['r_squared']}\n",
    "                spec_results[spec] = pd.concat([spec_results[spec], pd.DataFrame([result_row])], ignore_index=True)\n",
    "\n",
    "                # 绘制结果\n",
    "                FitExecutor.plot_result(x_data, y_data, model, fit_result['params'], geo_params, spec)\n",
    "\n",
    "    # 保存最终结果\n",
    "    os.makedirs(\"results\", exist_ok=True)\n",
    "    for spec, df in spec_results.items():\n",
    "        df.to_csv(f\"results/{spec}_results.csv\", index=False)\n",
    "        print(f\"\\n{spec} Results:\")\n",
    "        print(df.describe())\n",
    "\n",
    "    print(\"\\n=== Program Execution Completed ===\")\n",
    "\n",
    "# ========================================\n",
    "# 程序入口\n",
    "# ========================================\n",
    "if __name__ == \"__main__\":\n",
    "    # 初始化目录\n",
    "    for dir in [\"plots\", \"groups\", \"temp\", \"results\"]:\n",
    "        os.makedirs(dir, exist_ok=True)\n",
    "\n",
    "    # 加载数据（示例数据）\n",
    "    # 这里需要你替换为实际的数据加载方式\n",
    "    raw_data = df_basepara\n",
    "\n",
    "    # 执行主流程\n",
    "    main(raw_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e8520db",
   "metadata": {},
   "source": [
    "## 轴压"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "95d40cdb",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from symfit import variables, parameters, Fit, Piecewise, Eq, Model, Parameter\n",
    "from typing import Tuple, Dict, List\n",
    "import sympy\n",
    "import os\n",
    "\n",
    "# =====================================================================================\n",
    "# 配置与全局参数定义\n",
    "# =====================================================================================\n",
    "CONFIG = {\n",
    "    \"dependent_var\": \"SFcf2f_n\",  # 依赖变量（稳定系数 φ）\n",
    "    \"independent_vars\": [\"B\", \"H\", \"T1\", \"T2\", \"n\", \"L\", \"Imperfectfactor\", \"yfss\"],  # 独立变量\n",
    "    \"geo_vars\": [\"H\", \"B\", \"T1\", \"T2\", \"n\"],  # 几何参数（用于分组）\n",
    "    \"filters\": {  # 数据过滤条件\n",
    "        \"type\": 0,\n",
    "        \"yfss\": 355.61,\n",
    "        \"Imperfectfactor\": 0.002,\n",
    "        \"meshsz\": 20,\n",
    "        \"cf1f\": 0,\n",
    "        \"cf2f\": 0,\n",
    "        \"cf3f\": 1\n",
    "    },\n",
    "    \"plot\": {  # 绘图范围\n",
    "        \"xlim\": (0, 3),\n",
    "        \"ylim\": (0, 1.2)\n",
    "    }\n",
    "}\n",
    "\n",
    "# =====================================================================================\n",
    "# 数据预处理模块\n",
    "# =====================================================================================\n",
    "def prepare_data(df: pd.DataFrame) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    数据预处理函数\n",
    "    \n",
    "    Args:\n",
    "        df (pd.DataFrame): 原始数据\n",
    "    \n",
    "    Returns:\n",
    "        pd.DataFrame: 过滤后的数据\n",
    "    \n",
    "    Outputs:\n",
    "        - 数据过滤前后的统计信息\n",
    "        - 过滤条件说明\n",
    "        - 前5行数据示例\n",
    "    \"\"\"\n",
    "    # 1. 应用过滤条件\n",
    "    filter_conditions = [df[key] == value for key, value in CONFIG[\"filters\"].items()]\n",
    "    combined_filter = np.logical_and.reduce(filter_conditions)\n",
    "    filtered_df = df[combined_filter].copy()\n",
    "    \n",
    "    # 2. 输出数据信息\n",
    "    print(\"=== 数据预处理结果 ===\")\n",
    "    print(f\"原始数据行数: {len(df)}\")\n",
    "    print(f\"过滤后数据行数: {len(filtered_df)}\")\n",
    "    print(f\"过滤条件: {CONFIG['filters']}\")\n",
    "    print(\"前5行数据示例：\\n\", filtered_df.head(), \"\\n\")\n",
    "    \n",
    "    # 3. 检查点：保存过滤后的数据\n",
    "    filtered_df.to_csv(\"filtered_data_checkpoint.csv\", index=False)\n",
    "    print(\"检查点：过滤后的数据已保存至 filtered_data_checkpoint.csv\")\n",
    "    \n",
    "    return filtered_df\n",
    "\n",
    "# =====================================================================================\n",
    "# 曲线拟合核心类\n",
    "# =====================================================================================\n",
    "class CurveFitter:\n",
    "    \"\"\"\n",
    "    通用曲线拟合器\n",
    "    \n",
    "    Attributes:\n",
    "        model_config (dict): 模型配置\n",
    "        params (dict): 拟合参数\n",
    "        model (Model): 符号数学模型\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, model_config: Dict):\n",
    "        self.model_config = model_config\n",
    "        self.x, self.y = variables('x, y')\n",
    "        self.params = {}\n",
    "        self._init_parameters()\n",
    "        self._build_model()\n",
    "    \n",
    "    def _init_parameters(self):\n",
    "        \"\"\"初始化拟合参数及其约束范围\"\"\"\n",
    "        print(f\"\\n=== {self.model_config['name']} 参数初始化 ===\")\n",
    "        for name, (init_val, min_val, max_val) in self.model_config[\"parameters\"].items():\n",
    "            param = Parameter(name, value=init_val, min=min_val, max=max_val)\n",
    "            self.params[name] = param\n",
    "            print(f\"参数 {name}: 初始值={param.value:.4f}，范围 [{min_val:.4f}, {max_val:.4f}]\")\n",
    "    \n",
    "    def _build_model(self):\n",
    "        \"\"\"构建分段函数模型\"\"\"\n",
    "        piecewise_parts = []\n",
    "        for expr_str, cond_str in self.model_config[\"piecewise\"]:\n",
    "            # 将表达式字符串转换为SymPy表达式\n",
    "            expr = sympy.sympify(expr_str, locals={**self.params, \"x\": self.x, \"sqrt\": sympy.sqrt})\n",
    "            cond = sympy.sympify(cond_str, locals={\"x\": self.x})\n",
    "            piecewise_parts.append((expr, cond))\n",
    "        \n",
    "        self.model = Model({self.y: Piecewise(*piecewise_parts)})\n",
    "        print(f\"模型构建完成：{self.model_config['name']}\")\n",
    "    \n",
    "    def fit(self, x_data: pd.Series, y_data: pd.Series) -> Tuple[Dict, float]:\n",
    "        \"\"\"\n",
    "        执行曲线拟合\n",
    "        \n",
    "        Args:\n",
    "            x_data (pd.Series): 独立变量数据（无量纲长细比 λ）\n",
    "            y_data (pd.Series): 依赖变量数据（稳定系数 φ）\n",
    "        \n",
    "        Returns:\n",
    "            Tuple[Dict, float]: 拟合参数字典和 R² 值\n",
    "        \"\"\"\n",
    "        try:\n",
    "            # 1. 处理约束条件\n",
    "            constraints = []\n",
    "            for constraint_str in self.model_config.get(\"constraints\", []):\n",
    "                constraint = sympy.sympify(constraint_str, locals={**self.params, \"x\": self.x})\n",
    "                constraints.append(constraint)\n",
    "            \n",
    "            # 2. 执行拟合\n",
    "            fit = Fit(\n",
    "                self.model,\n",
    "                x=x_data.values,\n",
    "                y=y_data.values,\n",
    "                constraints=constraints\n",
    "            )\n",
    "            result = fit.execute()\n",
    "            \n",
    "            # 3. 输出结果\n",
    "            print(f\"\\n=== 拟合完成：{self.model_config['name']} ===\")\n",
    "            print(f\"R² 值：{result.r_squared:.4f}\")\n",
    "            print(\"参数结果：\")\n",
    "            for name, param in result.params.items():\n",
    "                std = getattr(param, \"stdev\", None)\n",
    "                print(f\"  {name}: {param.value:.4f}\" + (f\" ± {std:.4f}\" if std else \"\"))\n",
    "            \n",
    "            return result.params, result.r_squared\n",
    "        \n",
    "        except RuntimeError as e:\n",
    "            print(f\"拟合失败：{str(e)}\")\n",
    "            print(\"可能原因：数据不足、约束冲突或参数范围设置不当\")\n",
    "            return {}, 0.0\n",
    "        \n",
    "        except Exception as e:\n",
    "            print(f\"未知错误：{str(e)}\")\n",
    "            return {}, 0.0\n",
    "    \n",
    "    def plot(self, x_data: pd.Series, y_data: pd.Series, \n",
    "             params: Dict, geo_params: Dict):\n",
    "        \"\"\"\n",
    "        可视化拟合结果\n",
    "        \n",
    "        Args:\n",
    "            x_data (pd.Series): 独立变量数据\n",
    "            y_data (pd.Series): 依赖变量数据\n",
    "            params (Dict): 拟合参数字典\n",
    "            geo_params (Dict): 几何参数字典\n",
    "        \"\"\"\n",
    "        # 1. 创建画布\n",
    "        plt.figure(figsize=(12, 6))\n",
    "        plt.scatter(x_data, y_data, label=\"实验数据\", alpha=0.6)\n",
    "        \n",
    "        # 2. 绘制拟合曲线\n",
    "        x_range = np.linspace(*CONFIG[\"plot\"][\"xlim\"], 100)\n",
    "        y_pred = self.model(x=x_range, **params).y\n",
    "        plt.plot(x_range, y_pred, 'r-', label=\"拟合曲线\", linewidth=2)\n",
    "        \n",
    "        # 3. 设置图表属性\n",
    "        plt.title(f\"{self.model_config['name']} - {geo_params}\")\n",
    "        plt.xlabel(\"无量纲长细比 λ\")\n",
    "        plt.ylabel(\"稳定系数 φ\")\n",
    "        plt.xlim(CONFIG[\"plot\"][\"xlim\"])\n",
    "        plt.ylim(CONFIG[\"plot\"][\"ylim\"])\n",
    "        plt.legend()\n",
    "        plt.grid(True, linestyle='--', alpha=0.6)\n",
    "        \n",
    "        # 4. 保存图表\n",
    "        save_dir = \"plots\"\n",
    "        os.makedirs(save_dir, exist_ok=True)\n",
    "        save_path = f\"{save_dir}/{self.model_config['name']}_{'_'.join(map(str, geo_params.values()))}.png\"\n",
    "        plt.savefig(save_path, dpi=300)\n",
    "        print(f\"图表已保存至：{save_path}\")\n",
    "        plt.close()\n",
    "\n",
    "# =====================================================================================\n",
    "# 规范配置\n",
    "# =====================================================================================\n",
    "MODEL_CONFIGS = {\n",
    "    \"中国规范\": {\n",
    "        \"name\": \"中国规范轴压曲线\",\n",
    "        \"parameters\": {  # 参数初始值及约束范围\n",
    "            \"alphaa\": (0.5, 0, 1),\n",
    "            \"alphabs\": (0.5, 0, 1),\n",
    "            \"alphabl\": (0.5, 0, 1),\n",
    "            \"alphacs\": (0.5, 0, 1),\n",
    "            \"alphacl\": (0.5, 0, 1)\n",
    "        },\n",
    "        \"piecewise\": [  # 分段函数定义\n",
    "            (\"1 - alphaa*x**2\", \"x <= 0.216\"),\n",
    "            (\"(alphabs + alphacs*x + x**2 - sqrt((alphabs + alphacs*x + x**2)**2 - 4*x**2))/(2*x**2)\", \"x <= 1.05\"),\n",
    "            (\"(alphabl + alphacl*x + x**2 - sqrt((alphabl + alphacl*x + x**2)**2 - 4*x**2))/(2*x**2)\", \"x > 1.05\")\n",
    "        ],\n",
    "        \"constraints\": [  # 连续性约束\n",
    "            \"Eq(Derivative(1 - alphaa*x**2, x).subs(x, 0.216), Derivative((alphabs + alphacs*x + x**2 - sqrt((alphabs + alphacs*x + x**2)**2 - 4*x**2))/(2*x**2), x).subs(x, 0.216))\",\n",
    "            \"Eq(1 - alphaa*0.216**2, (alphabs + alphacs*0.216 + 0.216**2 - sqrt((alphabs + alphacs*0.216 + 0.216**2)**2 - 4*0.216**2))/(2*0.216**2))\",\n",
    "            \"Eq(Derivative((alphabs + alphacs*x + x**2 - sqrt((alphabs + alphacs*x + x**2)**2 - 4*x**2))/(2*x**2), x).subs(x, 1.05), Derivative((alphabl + alphacl*x + x**2 - sqrt((alphabl + alphacl*x + x**2)**2 - 4*x**2))/(2*x**2), x).subs(x, 1.05))\",\n",
    "            \"Eq((alphabs + alphacs*1.05 + 1.05**2 - sqrt((alphabs + alphacs*1.05 + 1.05**2)**2 - 4*1.05**2))/(2*1.05**2), (alphabl + alphacl*1.05 + 1.05**2 - sqrt((alphabl + alphacl*1.05 + 1.05**2)**2 - 4*1.05**2))/(2*1.05**2))\",\n",
    "            \"alphabl > alphabs\",  # 物理意义约束\n",
    "            \"alphacl > alphacs\"\n",
    "        ]\n",
    "    },\n",
    "    \"美国规范\": {\n",
    "        \"name\": \"美国规范轴压曲线\",\n",
    "        \"parameters\": {\n",
    "            \"alphausa\": (0.5, 0, 1),\n",
    "            \"alphausb\": (0.5, 0, 1)\n",
    "        },\n",
    "        \"piecewise\": [\n",
    "            (\"alphausa*x**2\", \"x <= 1.5\"),\n",
    "            (\"alphausb/x**2\", \"x > 1.5\")\n",
    "        ],\n",
    "        \"constraints\": [\n",
    "            \"Eq(Derivative(alphausa*x**2, x).subs(x, 1.5), Derivative(alphausb/x**2, x).subs(x, 1.5))\",\n",
    "            \"Eq(alphausa*(1.5)**2, alphausb/(1.5)**2)\"\n",
    "        ]\n",
    "    },\n",
    "    \"欧洲规范\": {\n",
    "        \"name\": \"欧洲规范轴压曲线\",\n",
    "        \"parameters\": {\n",
    "            \"alphaeu\": (0.5, 0, 1)\n",
    "        },\n",
    "        \"piecewise\": [\n",
    "            (\"1\", \"x <= 0.2\"),\n",
    "            (\"1/(0.5*(1 + alphaeu*(x-0.2) + x**2) + sqrt(0.25*(1 + alphaeu*(x-0.2) + x**2)**2 - x**2))\", \"x > 0.2\")\n",
    "        ],\n",
    "        \"constraints\": [\n",
    "            \"Eq(1, 1/(0.5*(1 + alphaeu*(0.2-0.2) + 0.2**2) + sqrt(0.25*(1 + alphaeu*(0.2-0.2) + 0.2**2)**2 - 0.2**2)))\"\n",
    "        ]\n",
    "    }\n",
    "}\n",
    "\n",
    "# =====================================================================================\n",
    "# 主流程\n",
    "# =====================================================================================\n",
    "def main(input_df: pd.DataFrame):\n",
    "    \"\"\"主执行流程\"\"\"\n",
    "    print(\"=== 程序启动 ===\")\n",
    "    \n",
    "    # 1. 数据预处理\n",
    "    df = prepare_data(input_df)\n",
    "    \n",
    "    # 2. 初始化结果存储\n",
    "    results = {\n",
    "        \"中国规范\": pd.DataFrame(columns=CONFIG[\"geo_vars\"] + [\"alphaa\", \"alphabs\", \"alphabl\", \"alphacs\", \"alphacl\", \"R2\"]),\n",
    "        \"美国规范\": pd.DataFrame(columns=CONFIG[\"geo_vars\"] + [\"alphausa\", \"alphausb\", \"R2\"]),\n",
    "        \"欧洲规范\": pd.DataFrame(columns=CONFIG[\"geo_vars\"] + [\"alphaeu\", \"R2\"])\n",
    "    }\n",
    "    \n",
    "    # 3. 数据分组处理\n",
    "    grouped = df.groupby(CONFIG[\"geo_vars\"])\n",
    "    print(f\"\\n=== 数据分组情况 ===\")\n",
    "    print(f\"总组数：{len(grouped)}\")\n",
    "    \n",
    "    for group_id, group_data in grouped:\n",
    "        geo_params = dict(zip(CONFIG[\"geo_vars\"], group_id))\n",
    "        \n",
    "        # 3.1 输出当前组信息\n",
    "        print(\"\\n=== 当前处理组 ===\")\n",
    "        print(f\"几何参数：{geo_params}\")\n",
    "        print(f\"组内数据量：{len(group_data)}\")\n",
    "        print(f\"X范围：{group_data['L'].min():.2f} ~ {group_data['L'].max():.2f}\")\n",
    "        print(f\"Y范围：{group_data[CONFIG['dependent_var']].min():.2f} ~ {group_data[CONFIG['dependent_var']].max():.2f}\")\n",
    "        \n",
    "        # 3.2 检查点：保存组数据\n",
    "        group_key = \"_\".join(map(str, geo_params.values()))\n",
    "        group_data.to_csv(f\"group_{group_key}_data.csv\", index=False)\n",
    "        print(f\"检查点：组数据已保存至 group_{group_key}_data.csv\")\n",
    "        \n",
    "        x_data = group_data[\"L\"]\n",
    "        y_data = group_data[CONFIG[\"dependent_var\"]]\n",
    "        \n",
    "        # 4. 拟合所有规范模型\n",
    "        for spec in MODEL_CONFIGS:\n",
    "            fitter = CurveFitter(MODEL_CONFIGS[spec])\n",
    "            \n",
    "            print(f\"\\n=== 开始拟合：{spec} ===\")\n",
    "            print(f\"分段条件：{fitter.model_config['piecewise']}\")\n",
    "            print(f\"约束条件：{fitter.model_config['constraints']}\")\n",
    "            \n",
    "            params, r2 = fitter.fit(x_data, y_data)\n",
    "            if params:\n",
    "                fitter.plot(x_data, y_data, params, geo_params)\n",
    "                \n",
    "                # 保存临时结果\n",
    "                result_row = geo_params.copy()\n",
    "                result_row.update(params)\n",
    "                result_row[\"R2\"] = r2\n",
    "                pd.DataFrame([result_row]).to_csv(\n",
    "                    f\"temp/{spec}_{group_key}_params.csv\", \n",
    "                    index=False\n",
    "                )\n",
    "                print(f\"检查点：{spec} 参数已保存至 temp/{spec}_{group_key}_params.csv\")\n",
    "                \n",
    "                # 更新最终结果\n",
    "                results[spec] = pd.concat([results[spec], pd.DataFrame([result_row])], ignore_index=True)\n",
    "    \n",
    "    # 5. 保存最终结果\n",
    "    os.makedirs(\"results\", exist_ok=True)\n",
    "    for spec, df in results.items():\n",
    "        df.to_csv(f\"results/{spec}_结果.csv\", index=False)\n",
    "        print(f\"\\n=== {spec} 最终结果 ===\")\n",
    "        print(df.describe())\n",
    "        print(f\"结果已保存至：results/{spec}_结果.csv\")\n",
    "    \n",
    "    print(\"\\n=== 程序执行完毕 ===\")\n",
    "\n",
    "# =====================================================================================\n",
    "# 程序入口\n",
    "# =====================================================================================\n",
    "if __name__ == \"__main__\":\n",
    "    # 确保目录存在\n",
    "    for dir_name in [\"plots\", \"temp\", \"results\"]:\n",
    "        os.makedirs(dir_name, exist_ok=True)\n",
    "    \n",
    "    # 加载数据\n",
    "    raw_data = dfdelpara\n",
    "    \n",
    "    # 执行主流程\n",
    "    main(raw_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "49b7586e",
   "metadata": {},
   "source": [
    "## 自变量与因变量"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e05316b8",
   "metadata": {},
   "source": [
    "### 因变量"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f6a370f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:52.921515Z",
     "start_time": "2023-09-18T07:28:52.909548Z"
    }
   },
   "outputs": [],
   "source": [
    "# yml = df[['Pucf1f', 'Pucf2f', 'Pucf3f', 'Pucff']].values # 采用多变量时\n",
    "ymlname='SFcf2f_n'\n",
    "# ymlname='CWcf2f'\n",
    "# ymlname='SFcf2f'\n",
    "yml = df[[ ymlname]].values\n",
    "yml"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7cb94c51",
   "metadata": {},
   "source": [
    "### 自变量"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8bb20973",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:53.290465Z",
     "start_time": "2023-09-18T07:28:53.275488Z"
    }
   },
   "outputs": [],
   "source": [
    "# 多元自变量\n",
    "xmlpolyname=['B', 'H', 'T1', 'T2','n', 'L', 'Imperfectfactor', 'yfss']\n",
    "# xmlpolyname=['B', 'BoltB', 'BoltD', 'cf1f', 'cf2f', 'cf3f','F', 'H', \n",
    "#             'Imperfectfactor', 'L','meshsz', 'n', 'pbol', 'sfricn', 'T1', 'T2','yfsn', 'yfss', 'yusn', 'yuss']\n",
    "xmlpoly= df[xmlpolyname].values \n",
    "print(xmlpoly)\n",
    "\n",
    "# 一元自变量\n",
    "xmluniname=str('SLcf2f_n')\n",
    "xmluni= df[[xmluniname]].values \n",
    "print(xmluni)\n",
    "\n",
    "# 确定最终自变量(是多元还是一元)\n",
    "xmlname=xmluniname\n",
    "xml=xmluni\n",
    "print(xmlname)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "491ef41d",
   "metadata": {},
   "source": [
    "## 数值拟合方法（采用自编拟合包装器）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ceac5455",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:53.640579Z",
     "start_time": "2023-09-18T07:28:53.631930Z"
    }
   },
   "outputs": [],
   "source": [
    "import scipy\n",
    "from scipy import optimize\n",
    "import sympy\n",
    "from scipy.optimize import curve_fit\n",
    "print(scipy.__version__)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b099908a",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:53.855365Z",
     "start_time": "2023-09-18T07:28:53.813146Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import operator\n",
    "import symfit as sf\n",
    "from symfit import variables, parameters, Fit, exp, Model\n",
    "from symfit.core.objectives import LogLikelihood\n",
    "# ————————————————————————\n",
    "# 数值拟合方法（中国规范）分段连续函数的拟合\n",
    "def xyfit(xpic, ypic):\n",
    "    x, y = variables('x, y')\n",
    "#     x0 = sf.Parameter('x0', 0.216, min=0.2159, max=0.2161)\n",
    "#     x1 = sf.Parameter('x1', 1.05, min=1.04, max=1.06)\n",
    "    x0 =0.216\n",
    "    x1 =1.05\n",
    "    alphaa = sf.Parameter('alphaa',  min=0, max=1)\n",
    "    alphabs = sf.Parameter('alphabs', min=0, max=1)#尾号s和l代表该参数小于和大于分界点x1（1.05的对应参数）\n",
    "    alphabl = sf.Parameter('alphabl', min=0, max=1)\n",
    "    alphacs = sf.Parameter('alphacs', min=0, max=1)\n",
    "    alphacl = sf.Parameter('alphacl', min=0, max=1)\n",
    "    y1 = 1-alphaa*(x**2)\n",
    "    y2 = ((alphabs+alphacs*x+x**(2))-((alphabs+alphacs*x+x**(2))**(2)-4*(x**(2)))**(0.5))*0.5/(x**(2))\n",
    "    y3 = ((alphabl+alphacl*x+x**(2))-((alphabl+alphacl*x+x**(2))**(2)-4*(x**(2)))**(0.5))*0.5/(x**(2))\n",
    "    model = Model({y: Piecewise((y1, x <= x0),\n",
    "                                (y2, x <= x1),\n",
    "                                (y3, x >  x1))})   \n",
    "    cons = [Eq(y1.diff(x).subs({x: x0}), y2.diff(x).subs({x: x0})),#x0处斜率连续\n",
    "            Eq(y1.subs({x: x0}), y2.subs({x: x0})),#x0处数值连续\n",
    "            Eq(y2.diff(x).subs({x: x1}), y3.diff(x).subs({x: x1})),#x1处斜率连续\n",
    "            Eq(y2.subs({x: x1}), y3.subs({x: x1})),#x1处数值连续\n",
    "            sympy.GreaterThan(alphabl,alphabs),#alphabs<alphabl\n",
    "            sympy.GreaterThan(alphacl,alphacs)]#alphacs<alphacl\n",
    "# 数据\n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values                  \n",
    "# 拟合\n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=cons)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "#      作图\n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))   \n",
    "    plt.plot(xdata, model(x=xdata, **fit_result.params).y,alpha = .5)\n",
    "    plt.scatter(xdata,ydata)\n",
    "# # 规范图-中国规范轴压\n",
    "#     def plotcode_cn (a_cn,b_cns,b_cnl,c_cns,c_cnl,codecolor):\n",
    "#         codeplotx1 = np.linspace(0, 0.215, 100)\n",
    "#         codeploty1 =1-a_cn*(codeplotx1**2)\n",
    "#         codeplotx2 = np.linspace(0.215,1.05, 100)\n",
    "#         codeploty2 =  ((b_cns+c_cns*codeplotx2+codeplotx2**(2))-((b_cns+c_cns*codeplotx2+codeplotx2**(2))**(2)-\n",
    "#                                                                  4*(codeplotx2**(2)))**(0.5))*0.5/(codeplotx2**(2))\n",
    "#         codeplotx3 = np.linspace(1.05,3, 100)\n",
    "#         codeploty3 =  ((b_cnl+c_cnl*codeplotx3+codeplotx3**(2))-((b_cnl+c_cnl*codeplotx3+codeplotx3**(2))**(2)-\n",
    "#                                                                  4*(codeplotx3**(2)))**(0.5))*0.5/(codeplotx3**(2))\n",
    "#         plt.plot(codeplotx1,codeploty1,codecolor,label='type',alpha = .5)    \n",
    "#         plt.plot(codeplotx2,codeploty2,codecolor,label='type',alpha = .5) \n",
    "#         plt.plot(codeplotx3,codeploty3,codecolor,label='type',alpha = .5)                                                                                                     \n",
    "\n",
    "#     cn_list=[[0.41,0.986,0.986,0.152,0.152,'g'],\n",
    "#              [0.65,0.965,0.965,0.3,0.3,'b'],\n",
    "#              [0.73,0.906,1.216,0.595,0.302,'y'],\n",
    "#              [1.35,0.868,1.372,0.915,0.432,'g']]\n",
    " \n",
    "#     for i in range(4):\n",
    "#         print(i)\n",
    "# #         print(cn_listpar)\n",
    "#         cn_listpar=cn_list[i]\n",
    "#         print(cn_listpar)       \n",
    "#         plotcode_cn(cn_listpar[0],cn_listpar[1],cn_listpar[2],cn_listpar[3],cn_listpar[4],cn_listpar[5])\n",
    "#     plt.show()\n",
    "    x0res = x0\n",
    "    alphaares=fit_result.value(alphaa)\n",
    "    alphabsres=fit_result.value(alphabs)\n",
    "    alphablres=fit_result.value(alphabl)\n",
    "    alphacsres=fit_result.value(alphacs)\n",
    "    alphaclres=fit_result.value(alphacl)\n",
    "    rsquraredcn= fit_result.r_squared\n",
    "    return x0res,alphaares,alphabsres,alphablres,alphacsres,alphaclres,rsquraredcn\n",
    "# ——————————————————————————\n",
    "# 数值拟合方法（美国规范）\n",
    "def xyfit_us(xpic, ypic):\n",
    "    x, y = variables('x, y')\n",
    "    x0us = sf.Parameter('x0us', 1.50, min=1.49, max=1.51)\n",
    "    alphausa = sf.Parameter('alphausa', 0.50, min=0, max=1)\n",
    "    alphausb = sf.Parameter('alphausb', 0.50, min=0, max=1)\n",
    "    y1 = alphausa**(x*x)\n",
    "    y2 = alphausb/(x*x)\n",
    "    model = Model({y: Piecewise((y1, x <= x0us),\n",
    "                                (y2, x > x0us))})\n",
    "    cons = [Eq(y1.diff(x).subs({x: x0us}), y2.diff(x).subs({x: x0us})),\n",
    "            Eq(y1.subs({x: x0us}), y2.subs({x: x0us}))]\n",
    "# 数据\n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values                  \n",
    "# 拟合\n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=cons)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "# 作图\n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))   \n",
    "    plt.plot(xdata, model(x=xdata, **fit_result.params).y)\n",
    "    plt.scatter(xdata,ydata)\n",
    "# 规范图-美国规范轴压\n",
    "    codeplotx1 = np.linspace(0, 1.5, 100)\n",
    "    codeploty1=0.658**(codeplotx1*codeplotx1)\n",
    "    codeplotx2 = np.linspace(1.5,3, 100)\n",
    "    codeploty2= 0.877/(codeplotx2 *codeplotx2 )\n",
    "    plt.plot(codeplotx1,codeploty1,'g',label='type',alpha = .5)    \n",
    "    plt.plot(codeplotx2,codeploty2,'g',label='type',alpha = .5)    \n",
    "# 规范图-美国规范受剪\n",
    "\n",
    "# 输出参数\n",
    "    x0usres = fit_result.value(x0us)\n",
    "    alphausares=fit_result.value(alphausa)\n",
    "    alphausbres=fit_result.value(alphausb)\n",
    "    rsquraredus= fit_result.r_squared\n",
    "    return x0usres,alphausares,alphausbres,rsquraredus\n",
    "# —————————————————————————————\n",
    "# 数值拟合方法（欧洲规范）\n",
    "def xyfit_eu(xpic, ypic):\n",
    "    x, y = variables('x, y')\n",
    "    x0eu = sf.Parameter('x0eu', 0.2, min=0.19, max=0.21)\n",
    "    alphaeu = sf.Parameter('alphaeu', 0.50, min=0, max=1)\n",
    "    y1 = 1\n",
    "    y2 = 1/((0.5*(1+alphaeu*(x-0.2)+x**(2)))+((0.5*(1+alphaeu*(x-0.2)+x**(2)))**(2)-x**(2))**(0.5))\n",
    "    model = Model({y: Piecewise((y1, x <= x0eu),\n",
    "                                (y2, x > x0eu))})\n",
    "    cons = [Eq(1, y2.subs({x: x0eu}))]\n",
    "# 数据\n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values                  \n",
    "# 拟合\n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=cons)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "#      作图\n",
    "    plt.ylim((0, 1.2))\n",
    "    plt.xlim((0, 3))   \n",
    "    plt.plot(xdata, model(x=xdata, **fit_result.params).y)\n",
    "    plt.scatter(xdata,ydata)\n",
    "    x0eures = fit_result.value(x0eu)\n",
    "    alphaeures=fit_result.value(alphaeu)\n",
    "    rsquraredeu= fit_result.r_squared\n",
    "    return x0eures, alphaeures,rsquraredeu"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3eef6e22",
   "metadata": {},
   "source": [
    "## 拟合"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b9b070e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:54.673843Z",
     "start_time": "2023-09-18T07:28:54.131056Z"
    }
   },
   "outputs": [],
   "source": [
    "\n",
    "general_list       =['type','yfss','Imperfectfactor','meshsz','cf1f','cf2f', 'cf3f']# 筛选基础数据用的list_分离面内\n",
    "general_list_number=[   0  ,355.61,     0.002       , 20      , 0   ,   1   ,   0  ]# 面内受剪_分离面内\n",
    "\n",
    "df_basepara=dfdelpara.copy()\n",
    "\n",
    "for i in range (0,len(general_list)):\n",
    "    df_basepara=df_basepara[df_basepara[general_list[i]]==general_list_number[i]].copy()\n",
    "\n",
    "df=df_basepara\n",
    "df['cf2f'].value_counts()\n",
    "df.to_excel('df_basepara.xlsx')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "58dbfb44",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:54.674900Z",
     "start_time": "2023-09-18T07:28:54.674900Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import sympy\n",
    "from sympy import Eq, Piecewise, GreaterThan\n",
    "import symfit as sf\n",
    "from symfit import variables, parameters, Fit, exp, Model\n",
    "from symfit.core.objectives import LogLikelihood\n",
    "\n",
    "\n",
    "# 中国规范分段拟合函数\n",
    "def xyfit(xpic, ypic):\n",
    "    x, y = variables('x, y')\n",
    "    x0 = 0.216  # 固定分界点\n",
    "    x1 = 1.05\n",
    "    \n",
    "    # 定义参数\n",
    "    alphaa = sf.Parameter('alphaa', min=0, max=1)\n",
    "    alphabs = sf.Parameter('alphabs', min=0, max=1)\n",
    "    alphabl = sf.Parameter('alphabl', min=0, max=1)\n",
    "    alphacs = sf.Parameter('alphacs', min=0, max=1)\n",
    "    alphacl = sf.Parameter('alphacl', min=0, max=1)\n",
    "    \n",
    "    # 分段函数表达式\n",
    "    y1 = 1 - alphaa * (x**2)\n",
    "    y2 = ((alphabs + alphacs * x + x**2) - sympy.sqrt((alphabs + alphacs * x + x**2)**2 - 4 * x**2)) / (2 * x**2)\n",
    "    y3 = ((alphabl + alphacl * x + x**2) - sympy.sqrt((alphabl + alphacl * x + x**2)**2 - 4 * x**2)) / (2 * x**2)\n",
    "    \n",
    "    # 分段模型\n",
    "    model_dict = {\n",
    "        y: Piecewise(\n",
    "            (y1, x <= x0),\n",
    "            (y2, x <= x1),\n",
    "            (y3, x > x1)\n",
    "        )\n",
    "    }\n",
    "    model = Model(model_dict)\n",
    "    \n",
    "    # 约束条件：连续性和导数连续性\n",
    "    constraints = [\n",
    "        Eq(y1.subs(x, x0), y2.subs(x, x0)),\n",
    "        Eq(y1.diff(x).subs(x, x0), y2.diff(x).subs(x, x0)),\n",
    "        Eq(y2.subs(x, x1), y3.subs(x, x1)),\n",
    "        Eq(y2.diff(x).subs(x, x1), y3.diff(x).subs(x, x1)),\n",
    "        GreaterThan(alphabl, alphabs),  # alphabl > alphabs\n",
    "        GreaterThan(alphacl, alphacs)   # alphacl > alphacs\n",
    "    ]\n",
    "    \n",
    "    # 数据\n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values\n",
    "    \n",
    "    # 拟合模型\n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=constraints)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "    \n",
    "    # 绘图\n",
    "    plt.ylim(0, 1.2)\n",
    "    plt.xlim(0, 3)\n",
    "    plt.scatter(xdata, ydata, label='Data')\n",
    "    x_smooth = np.linspace(0, 3, 300)\n",
    "    y_pred = model(x=x_smooth, **fit_result.params).y\n",
    "    plt.plot(x_smooth, y_pred, 'r', label='Fit')\n",
    "    plt.legend()\n",
    "    plt.show()\n",
    "    \n",
    "    # 返回拟合参数\n",
    "    params = {\n",
    "        'x0': x0,\n",
    "        'alphaa': fit_result.value(alphaa),\n",
    "        'alphabs': fit_result.value(alphabs),\n",
    "        'alphabl': fit_result.value(alphabl),\n",
    "        'alphacs': fit_result.value(alphacs),\n",
    "        'alphacl': fit_result.value(alphacl),\n",
    "        'r_squared': fit_result.r_squared\n",
    "    }\n",
    "    return params\n",
    "\n",
    "# 美国规范拟合函数\n",
    "def xyfit_us(xpic, ypic):\n",
    "    x, y = variables('x, y')\n",
    "    x0us = sf.Parameter('x0us', value=1.5, min=1.49, max=1.51)\n",
    "    alphausa = sf.Parameter('alphausa', value=0.658, min=0.6, max=0.7)\n",
    "    alphausb = sf.Parameter('alphausb', value=0.877, min=0.8, max=0.9)\n",
    "    \n",
    "    # 分段函数\n",
    "    y1 = alphausa ** (x**2)\n",
    "    y2 = alphausb / (x**2)\n",
    "    \n",
    "    model_dict = {\n",
    "        y: Piecewise(\n",
    "            (y1, x <= x0us),\n",
    "            (y2, x > x0us)\n",
    "        )\n",
    "    }\n",
    "    model = Model(model_dict)\n",
    "    \n",
    "    # 约束条件：连续性和导数连续性\n",
    "    constraints = [\n",
    "        Eq(y1.subs(x, x0us), y2.subs(x, x0us)),\n",
    "        Eq(y1.diff(x).subs(x, x0us), y2.diff(x).subs(x, x0us)),\n",
    "    ]\n",
    "    \n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values\n",
    "    \n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=constraints)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "    \n",
    "    plt.ylim(0, 1.2)\n",
    "    plt.xlim(0, 3)\n",
    "    plt.scatter(xdata, ydata, label='Data')\n",
    "    x_smooth = np.linspace(0, 3, 300)\n",
    "    y_pred = model(x=x_smooth, **fit_result.params).y\n",
    "    plt.plot(x_smooth, y_pred, 'r', label='Fit')\n",
    "    plt.legend()\n",
    "    plt.show()\n",
    "    \n",
    "    params = {\n",
    "        'x0us': fit_result.value(x0us),\n",
    "        'alphausa': fit_result.value(alphausa),\n",
    "        'alphausb': fit_result.value(alphausb),\n",
    "        'r_squared': fit_result.r_squared\n",
    "    }\n",
    "    return params\n",
    "\n",
    "# 欧洲规范拟合函数\n",
    "def xyfit_eu(xpic, ypic):\n",
    "    x, y = variables('x, y')\n",
    "    x0eu = sf.Parameter('x0eu', value=0.2, min=0.19, max=0.21)\n",
    "    alphaeu = sf.Parameter('alphaeu', value=0.2, min=0.1, max=0.3)\n",
    "    \n",
    "    # 分段函数\n",
    "    y1 = 1.0\n",
    "    denominator = 0.5 * (1 + alphaeu * (x - 0.2) + x**2) + sympy.sqrt((0.5 * (1 + alphaeu * (x - 0.2) + x**2))**2 - x**2)\n",
    "    y2 = 1 / denominator\n",
    "    \n",
    "    model_dict = {\n",
    "        y: Piecewise(\n",
    "            (y1, x <= x0eu),\n",
    "            (y2, x > x0eu)\n",
    "        )\n",
    "    }\n",
    "    model = Model(model_dict)\n",
    "    \n",
    "    # 约束条件：连续性\n",
    "    constraints = [Eq(y1, y2.subs(x, x0eu))]\n",
    "    \n",
    "    xdata = xpic.values\n",
    "    ydata = ypic.values\n",
    "    \n",
    "    fit = Fit(model, x=xdata, y=ydata, constraints=constraints)\n",
    "    fit_result = fit.execute()\n",
    "    print(fit_result)\n",
    "    \n",
    "    plt.ylim(0, 1.2)\n",
    "    plt.xlim(0, 3)\n",
    "    plt.scatter(xdata, ydata, label='Data')\n",
    "    x_smooth = np.linspace(0, 3, 300)\n",
    "    y_pred = model(x=x_smooth, **fit_result.params).y\n",
    "    plt.plot(x_smooth, y_pred, 'r', label='Fit')\n",
    "    plt.legend()\n",
    "    plt.show()\n",
    "    \n",
    "    params = {\n",
    "        'x0eu': fit_result.value(x0eu),\n",
    "        'alphaeu': fit_result.value(alphaeu),\n",
    "        'r_squared': fit_result.r_squared\n",
    "    }\n",
    "    return params"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "943bbe04",
   "metadata": {},
   "source": [
    "## 参数拟合的可视化呈现"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd90c64f",
   "metadata": {},
   "source": [
    "### 可视化数据处理"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21c441de",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:54.889027Z",
     "start_time": "2023-09-18T07:28:54.844454Z"
    }
   },
   "outputs": [],
   "source": [
    "print(type(dfresultcn),\n",
    "        dfresultus,\n",
    "        dfresulteu)\n",
    "\n",
    "\n",
    "dfresultcn1=dfresultcn.dropna(axis=0,how='any') # 去除含有nan的行\n",
    "dfresultus1=dfresultus.dropna(axis=0,how='any')# 去除含有nan的行\n",
    "dfresulteu1=dfresulteu.dropna(axis=0,how='any')# 去除含有nan的行\n",
    "\n",
    "dfresultcn2=dfresultcn1[(dfresultcn1['R2_cn']>=0.85)] # 去除回归系数小于0.85的值\n",
    "dfresultus2=dfresultus1[(dfresultus1['R2_us']>=0.85)] # 去除回归系数小于0.85的值\n",
    "dfresulteu2=dfresulteu1[(dfresulteu1['R2_eu']>=0.85)] # 去除回归系数小于0.85的值\n",
    "dfresultcn_final=dfresultcn2\n",
    "dfresultus_final=dfresultus2\n",
    "dfresulteu_final=dfresulteu2\n",
    "print(dfresultcn_final,\n",
    "        dfresultus_final,\n",
    "        dfresulteu_final)\n",
    "print(len(dfresultcn_final)/len(dfresultcn),\n",
    "      len(dfresultus_final)/len(dfresultus),\n",
    "      len(dfresulteu_final)/len(dfresulteu))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f5062c4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:55.055718Z",
     "start_time": "2023-09-18T07:28:55.038033Z"
    }
   },
   "outputs": [],
   "source": [
    "dfresultcn_final.head()\n",
    "dfresultcn_final.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2e2e290d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:55.288628Z",
     "start_time": "2023-09-18T07:28:55.257155Z"
    }
   },
   "outputs": [],
   "source": [
    "len(dfresultcn_final)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c8c6c7c3",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:55.422253Z",
     "start_time": "2023-09-18T07:28:55.390518Z"
    }
   },
   "outputs": [],
   "source": [
    "dfresultcn_final.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "63e5cd5a",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:55.573266Z",
     "start_time": "2023-09-18T07:28:55.543777Z"
    }
   },
   "outputs": [],
   "source": [
    "dfresultcn_final.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16778b98",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:55.739906Z",
     "start_time": "2023-09-18T07:28:55.711918Z"
    }
   },
   "outputs": [],
   "source": [
    "dfresultcn_final.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8d7aa15b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.323889Z",
     "start_time": "2023-07-04T14:49:09.323889Z"
    }
   },
   "outputs": [],
   "source": [
    "dfresultcn_final.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dbd3d34c",
   "metadata": {},
   "source": [
    "### 可视化"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "db5cd58d",
   "metadata": {},
   "source": [
    "#### 矩阵图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f9f63e4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.324858Z",
     "start_time": "2023-07-04T14:49:09.324858Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "print(sns.__version__)\n",
    "sns.pairplot(data=dfresultcn_final)\n",
    "# sns.pairplot(data=dfresultcn_final, compute_pareto_front hue='H')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "54df13a3",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.326851Z",
     "start_time": "2023-07-04T14:49:09.326851Z"
    }
   },
   "outputs": [],
   "source": [
    "mt_cn = sns.PairGrid(dfresultcn_final, diag_sharey=False)\n",
    "mt_cn.map_upper(sns.scatterplot)  #右上角做散点图\n",
    "mt_cn.map_lower(sns.kdeplot)  #左下角做等高线图\n",
    "mt_cn.map_diag(sns.histplot)  #中间做直方图\n",
    "mt_us = sns.PairGrid(dfresultus_final, diag_sharey=False)\n",
    "mt_us.map_upper(sns.scatterplot)  #右上角做散点图\n",
    "mt_us.map_lower(sns.kdeplot)  #左下角做等高线图\n",
    "mt_us.map_diag(sns.histplot)  #中间做直方图\n",
    "mt_eu = sns.PairGrid(dfresulteu_final, diag_sharey=True)population\n",
    "mt_eu.map_upper(sns.scatterplot)  #右上角做散点图\n",
    "mt_eu.map_lower(sns.kdeplot)  #左下角做等高线图\n",
    "mt_eu.map_diag(sns.histplot)  #中间做直方图"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a3add92b",
   "metadata": {},
   "source": [
    "#### 多子图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "081bfaae",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.327848Z",
     "start_time": "2023-07-04T14:49:09.327848Z"
    }
   },
   "outputs": [],
   "source": [
    "print(sns.__version__)\n",
    "sns.displot(data=dfresultcn_final['alphaa_cn'],\n",
    "            x=dfresultcn_final['H'], \n",
    "            hue=dfresultcn_final['B'], \n",
    "            col=dfresultcn_final['n'], kde=True,bins=30,rug=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f608ef43",
   "metadata": {},
   "source": [
    "#### 单子图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "afcf6e8b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.328845Z",
     "start_time": "2023-07-04T14:49:09.328845Z"
    }
   },
   "outputs": [],
   "source": [
    "# sns.jointplot(x=dfresultcn_final['alphaa_cn'],y=dfresultcn_final['alphab_cn'])\n",
    "sns.jointplot(x='R2_cn',y='R2_cn', data=dfresultcn_final)\n",
    "\n",
    "# sns.jointplot(x=dfresultcn_final['alphab_cn'],y=dfresultcn_final['alphac_cn'])\n",
    "# sns.jointplot(x=dfresultcn_final['alphac_cn'],y=dfresultcn_final['alphaa_cn'])\n",
    "# sns.jointplot(x=dfresultcn_final['R2_cn'],y=dfresultcn_final['R2_cn'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "610bad15",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.329843Z",
     "start_time": "2023-07-04T14:49:09.329843Z"
    }
   },
   "outputs": [],
   "source": [
    "sns.pairplot(dfresultcn_final)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7968b755",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.330840Z",
     "start_time": "2023-07-04T14:49:09.330840Z"
    }
   },
   "outputs": [],
   "source": [
    "f=dfresultcn_final.pivot('alphaa_cn','alphac_cn','R2_cn')\n",
    "sns.heatmap(f)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7d0e756",
   "metadata": {},
   "source": [
    "# 传统机器学习数据分析（基于sklearn）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6bc7fc2b",
   "metadata": {},
   "source": [
    "## 包的引入及通用代码"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7f51fb80",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-20T04:52:06.445691Z",
     "start_time": "2023-09-20T04:52:04.981610Z"
    }
   },
   "outputs": [],
   "source": [
    "import sklearn\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.model_selection import train_test_split\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.preprocessing import MinMaxScaler \n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.neighbors import KNeighborsRegressor\n",
    "from sklearn.svm import SVR\n",
    "from sklearn.ensemble import BaggingRegressor\n",
    "from sklearn.linear_model import Ridge\n",
    "from sklearn.linear_model import Lasso\n",
    "from sklearn.ensemble import GradientBoostingRegressor\n",
    "from sklearn.ensemble import AdaBoostRegressor\n",
    "from sklearn.neural_network import MLPRegressor\n",
    "from sklearn.tree import DecisionTreeRegressor\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.tree import ExtraTreeRegressor\n",
    "from sklearn.metrics import r2_score \n",
    "from sklearn.metrics import mean_absolute_error\n",
    "from sklearn.metrics import mean_squared_error\n",
    "from sklearn.preprocessing import PolynomialFeatures\n",
    "print('sklearn版本',sklearn.__version__)\n",
    "scaler = MinMaxScaler()\n",
    "# autosklearn没有windows版本"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e6d102ce",
   "metadata": {},
   "source": [
    "## 数据准备"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "618e94c6",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T19:56:54.721509Z",
     "start_time": "2023-09-18T19:56:54.706550Z"
    }
   },
   "outputs": [],
   "source": [
    "dfdelpara=df\n",
    "dfdelparapp=dfdelpara[['H','B','T1','T2','L','n','type',\n",
    "                       'yfss','Imperfectfactor','pbol', 'sfricn','F','BoltB','BoltD',\n",
    "                       'cf1f', 'cf2f', 'cf3f','EigenValue','Bcf1f','Bcf2f','Bcf3f','Pucf1f','Pucf2f','Pucf3f',\n",
    "                       'SLcf1f','SLcf2f','SLcf3f','SFcf1f','SFcf2f','SFcf3f','CWcf1f','CWcf2f','CWcf3f']]\n",
    "\n",
    "# data0pp=dfdelparapp[(dfdelparapp[str('type')]==0)]\n",
    "# data1pp=dfdelparapp[(dfdelparapp[str('type')]==1)]\n",
    "# data2pp=dfdelparapp[(dfdelparapp[str('type')]==2)]\n",
    "# # data0.drop('F',axis=1, inplace=True)\n",
    "# # data1.drop('F',axis=1, inplace=True)\n",
    "\n",
    "\n",
    "# data0=data0pp.drop(['type','F','BoltB','BoltD','sfricn','pbol'],axis=1,inplace=False)\n",
    "# data1=data1pp.drop(['type','F','BoltB','BoltD','pbol'],axis=1,inplace=False)\n",
    "# data2=data2pp.drop(['type'],axis=1,inplace=False)\n",
    "# 多元自变量\n",
    "# xmlpolyname=['B', 'H', 'T1', 'T2','n', 'L', 'Imperfectfactor', 'yfss']\n",
    "xmlpolyname=['B', 'BoltB', 'BoltD', 'cf1f', 'cf2f', 'cf3f','F', 'H', \n",
    "            'Imperfectfactor', 'L','meshsz', 'n', 'pbol', 'sfricn', 'T1', 'T2','yfsn', 'yfss', 'yusn', 'yuss']\n",
    "xmlpoly= df[xmlpolyname].values \n",
    "print(xmlpoly)\n",
    "\n",
    "# # 一元自变量\n",
    "xmluniname=str('SLcf2f')\n",
    "xmluni= df[[xmluniname]].values \n",
    "# print(xmluni)\n",
    "\n",
    "# 确定最终自变量(是多元还是一元)\n",
    "# xmlname=xmluniname# 多元\n",
    "\n",
    "xml=xmluni# 一元\n",
    "# print(xmlname)\n",
    "#自变量\n",
    "x = xml\n",
    "print(xml)\n",
    "\n",
    "# # 一元自变量\n",
    "# yml = df[['Pucf1f', 'Pucf2f', 'Pucf3f', 'Pucff']].values # 采用多变量时\n",
    "# ymlname='SLcf2f'\n",
    "# ymlname='CWcf2f'\n",
    "ymlname='SFcf2f'\n",
    "yml = df[[ ymlname]].values\n",
    "yml\n",
    "#因变量\n",
    "y = yml\n",
    "print(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "21a55fc9",
   "metadata": {},
   "source": [
    "## 全部机器学习算法回归"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c970560f",
   "metadata": {},
   "source": [
    "1、稳定系数公式的回归时，每一个截面参数作为一类，即改变的是不同的构件高度L,采用除了L之外的所有参数作为自变量,对CW进行回归。\n",
    "2、对于特征值Bcff或极限承载力Puff作为目标值,对所有参数作为自变量,进行多元回归\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72533610",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T19:56:59.629481Z",
     "start_time": "2023-09-18T19:56:57.714940Z"
    }
   },
   "outputs": [],
   "source": [
    "# 选择回归模型\n",
    "clflist=[LinearRegression(),KNeighborsRegressor(),SVR(),Ridge(),Lasso(),\n",
    "         MLPRegressor(),DecisionTreeRegressor(),ExtraTreeRegressor(),RandomForestRegressor(),AdaBoostRegressor(),\n",
    "        GradientBoostingRegressor(),BaggingRegressor()]\n",
    "for clfi in range(len(clflist)):\n",
    "    clf=clflist[clfi]\n",
    "    print(clf)\n",
    "    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.6, random_state=1)\n",
    "    print(x_train.shape)\n",
    "    print(x_test.shape)\n",
    "    print(np.isnan(x_train).any())\n",
    "    pf=PolynomialFeatures(degree=3)\n",
    "    # 归一化\n",
    "    x_train = scaler.fit_transform(x_train)\n",
    "    x_test = scaler.fit_transform(x_test)\n",
    "    x_train = pf.fit_transform(x_train)\n",
    "    x_test = pf.fit_transform(x_test)  \n",
    "    \n",
    "    print('训练集',x_train)\n",
    "    print('测试集',x_test)\n",
    "    # 进行回归拟合\n",
    "    rf = clf.fit (x_train, y_train.ravel())\n",
    "    y_test = rf.predict(x_test)\n",
    "    #Equation coefficient and Intercept\n",
    "    print(\"结果如下：\")\n",
    "    print(\"训练集分数：\",rf.score(x_train,y_train))\n",
    "    print(\"验证集分数：\",rf.score(x_test,y_test))\n",
    "\n",
    "#     print('权重: ', rf.coef_)\n",
    "#     print('偏置: ', rf.intercept_)\n",
    "    #预测值输出\n",
    "    predicted= rf.predict(x_test)\n",
    "#     # 画图\n",
    "#     plt.xlabel(xmlname)\n",
    "#     plt.ylabel(ymlname)\n",
    "#     # 画训练集的散点图\n",
    "#     plt.scatter(x_train,y_train,alpha=0.8,edgecolors='g',color=[1,1,1,0]) # 将face颜色设为全透明, 使用edgecolors控制边缘颜色。\n",
    "#     # 画预测模型的散点图\n",
    "#     plt.scatter(x_train,rf.predict(x_train),color='blue',linewidth=1)\n",
    "#     plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "544c9aed",
   "metadata": {},
   "source": [
    "### 均值归一化"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b07f5099",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.334829Z",
     "start_time": "2023-07-04T14:49:09.334829Z"
    }
   },
   "outputs": [],
   "source": [
    "x_train = scaler.fit_transform(x_train)\n",
    "x_test = scaler.fit_transform(x_test)\n",
    "print(x_train)\n",
    "print(x_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "584e1a89",
   "metadata": {},
   "source": [
    "### 多元线性回归"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "93d75094",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.335827Z",
     "start_time": "2023-07-04T14:49:09.335827Z"
    }
   },
   "outputs": [],
   "source": [
    "x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.8, random_state=22)# 构造数据\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "# def display_lr():\n",
    "# pd_data=df#原始数表\n",
    "# #画出单因素拟合情况\n",
    "# print('pd_data.head(10)=\\n{}'.format(pd_data.head(10)))\n",
    "# # mpl.rcParams['font.sans-serif'] = ['SimHei']  #配置显示中文，否则乱码\n",
    "# plt.rcParams['axes.unicode_minus']=False #用来正常显示负号，如果是plt画图，则将mlp换成plt\n",
    "# sns.pairplot(pd_data, x_vars=list(xmlpolyname), y_vars=yml,kind=\"reg\", size=5, aspect=0.7)\n",
    "plt.show()\n",
    "# 定义线性模型\n",
    "reg = linear_model.LinearRegression() \n",
    "model=reg.fit(x_train,y_train) # 回归\n",
    "print(model)\n",
    "print('模型截距:',reg.intercept_)\n",
    "\n",
    "print ('参数权重:',reg.coef_)\n",
    "print(type(reg.coef_))\n",
    "# 数组转化为列表\n",
    "print(reg.coef_.tolist())\n",
    "\n",
    "# 模型输出\n",
    "print(ymlname)\n",
    "print(reg.coef_)\n",
    "print(list(yml))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7db4a349",
   "metadata": {},
   "source": [
    "#### 模型预测"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd7d2aa9",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.336824Z",
     "start_time": "2023-07-04T14:49:09.336824Z"
    }
   },
   "outputs": [],
   "source": [
    "y_pred=reg.predict(x_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "900fdf59",
   "metadata": {},
   "source": [
    "#### 评价"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cb443177",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.337821Z",
     "start_time": "2023-07-04T14:49:09.337821Z"
    }
   },
   "outputs": [],
   "source": [
    "#模型评价  \n",
    "import matplotlib.pyplot as plt  \n",
    "plt.figure()  \n",
    "plt.plot(range(len(y_pred)),y_pred,'b',label='predict')  \n",
    "plt.plot(range(len(y_pred)),y_test,'r',label='test')  \n",
    "plt.legend(loc='upper right')  \n",
    "plt.xlabel('the number of sales')  \n",
    "plt.ylabel('value of sales')  \n",
    "plt.show()  "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad0b73f7",
   "metadata": {},
   "source": [
    "### 计算均方根误差RMSE来评估模型"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "852cbc56",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.339816Z",
     "start_time": "2023-07-04T14:49:09.339816Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn import metrics  \n",
    "import numpy as np  \n",
    "np.sqrt(metrics.mean_squared_error(y_test, y_pred)) "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b0959d66",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-08-23T06:21:02.220589Z",
     "start_time": "2022-08-23T06:21:01.735415Z"
    }
   },
   "source": [
    "## 随机森林"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7cc3f5f4",
   "metadata": {},
   "source": [
    "### 核心代码"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "df4ae952",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.340813Z",
     "start_time": "2023-07-04T14:49:09.340813Z"
    }
   },
   "outputs": [],
   "source": [
    "#导入数据集\n",
    "df = df            \n",
    "#自变量\n",
    "x = xml\n",
    "#因变量\n",
    "y = yml\n",
    "\n",
    "x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.6, random_state=1)\n",
    "\n",
    "# 评估回归性能\n",
    "# criterion ：\n",
    "# 回归树衡量分枝质量的指标，支持的标准有三种：\n",
    "# 1）输入\"mse\"使用均方误差mean squared error(MSE)，父节点和叶子节点之间的均方误差的差额将被用来作为特征选择的标准，\n",
    "# 这种方法通过使用叶子节点的均值来最小化L2损失\n",
    "# 2）输入“friedman_mse”使用费尔德曼均方误差，这种指标使用弗里德曼针对潜在分枝中的问题改进后的均方误差\n",
    "# 3）输入\"mae\"使用绝对平均误差MAE（mean absolute error），这种指标使用叶节点的中值来最小化L1损失\n",
    "\n",
    "#此处使用mse\n",
    "forest = RandomForestRegressor(n_estimators=1000,\n",
    "                               criterion='squared_error',\n",
    "                               random_state=1,\n",
    "                               n_jobs=-1)\n",
    "forest.fit(x_train, y_train)\n",
    "y_train_pred = forest.predict(x_train)\n",
    "y_test_pred = forest.predict(y_test)\n",
    "\n",
    "print('MSE train: %.3f, test: %.3f' % (\n",
    "        mean_squared_error(y_train, y_train_pred),\n",
    "        mean_squared_error(y_test, y_test_pred)))\n",
    "print('R^2 train: %.3f, test: %.3f' % (\n",
    "        r2_score(y_train, y_train_pred),\n",
    "        r2_score(y_test, y_test_pred)))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "256d7a38",
   "metadata": {},
   "source": [
    "### 变量重要性及其可视化"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dd2faf2d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.340813Z",
     "start_time": "2023-07-04T14:49:09.340813Z"
    }
   },
   "outputs": [],
   "source": [
    "# Get numerical feature importances\n",
    "importances = list(forest.feature_importances_)\n",
    "print(importances)\n",
    "\n",
    "# Saving feature names for later use\n",
    "feature_list = list(df.columns)[0:len(xmlpolyname)]\n",
    "\n",
    "feature_importances = [(feature, round(importance, 3)) for feature, importance in zip(feature_list, importances)]\n",
    "# Sort the feature importances by most important first\n",
    "feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)\n",
    "\n",
    "# Print out the feature and importances \n",
    "print(feature_importances)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef642eb2",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.342808Z",
     "start_time": "2023-07-04T14:49:09.342808Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "# Set the style\n",
    "# plt.style.use('fivethirtyeight')\n",
    "# list of x locations for plotting\n",
    "x_values = list(range(len(importances)))\n",
    "print(x_values)\n",
    "# Make a bar chart\n",
    "plt.bar(x_values, importances, orientation = 'vertical')\n",
    "# Tick labels for x axis\n",
    "plt.xticks(x_values, feature_list,rotation=30)\n",
    "# Axis labels and title\n",
    "plt.ylabel('Importance'); plt.xlabel('Variable'); plt.title('Variable Importances');\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6b83538e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.343805Z",
     "start_time": "2023-07-04T14:49:09.343805Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "pipe = Pipeline([('scaler', StandardScaler()), ('reduce_dim', PCA()),\n",
    "                 ('regressor', forest)])\n",
    "pipe.fit(X_train, y_train)\n",
    "ypipe = pipe.predict(X_test)\n",
    "\n",
    "from six import StringIO\n",
    "from IPython.display import Image\n",
    "from sklearn.tree import export_graphviz\n",
    "import pydotplus\n",
    "import os\n",
    "\n",
    "dot_data = StringIO()\n",
    "export_graphviz(pipe.named_steps['regressor'].estimators_[0],\n",
    "                out_file=dot_data)\n",
    "graph = pydotplus.graph_from_dot_data(dot_data.getvalue())\n",
    "graph.write_png('tree.png')\n",
    "Image(graph.create_png())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "da2682a1",
   "metadata": {},
   "source": [
    "## Adaboost回归"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72a44337",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.344803Z",
     "start_time": "2023-07-04T14:49:09.344803Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn import ensemble\n",
    "model_adaboost_regressor = ensemble.AdaBoostRegressor(n_estimators=50)  # 这里使用50个决策树\n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f20822b3",
   "metadata": {},
   "source": [
    "## GBRT回归"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "71abe9f1",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.345800Z",
     "start_time": "2023-07-04T14:49:09.345800Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn import ensemble\n",
    "model_gradient_boosting_regressor = ensemble.GradientBoostingRegressor(n_estimators=100)  # 这里使用100个决策树\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "983839b0",
   "metadata": {},
   "source": [
    "## Bagging回归"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3d73fb90",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.346797Z",
     "start_time": "2023-07-04T14:49:09.346797Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn import ensemble\n",
    "model_bagging_regressor = ensemble.BaggingRegressor()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "815c56c6",
   "metadata": {},
   "source": [
    "## ExtraTree极端随机树回归"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "da91166b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-07-04T14:49:09.347794Z",
     "start_time": "2023-07-04T14:49:09.347794Z"
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.tree import ExtraTreeRegressor\n",
    "model_extra_tree_regressor = ExtraTreeRegressor()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e29d271c",
   "metadata": {},
   "source": [
    "## 神经网络"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e0c60757",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "ba5e1105",
   "metadata": {},
   "source": [
    "# 自动机器学习"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d9c7c8d0",
   "metadata": {},
   "source": [
    "## 通用机器学习参数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "178ffc0f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-20T04:56:31.836627Z",
     "start_time": "2023-09-20T04:56:31.333605Z"
    }
   },
   "outputs": [],
   "source": [
    "# 划分训练集、测试集划分方式一致\n",
    "# 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
    "#        'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
    "\n",
    "data0pre=data0[(data0['cf2f']==1 )]  # 只保留面内有作用的数据\n",
    "data1pre=data1[(data1['cf2f']==1 )]  # 只保留面内有作用的数据\n",
    "data2pre=data2[(data2['cf2f']==1 )]  # 只保留面内有作用的数据\n",
    "\n",
    "data0ML=data0pre.drop(['Bcf1f','Bcf2f','Bcf3f','Pucf1f','Pucf2f','is_dup'],axis=1,inplace=False)\n",
    "data1ML=data1pre.drop(['Bcf1f','Bcf2f','Bcf3f','Pucf1f','Pucf2f','is_dup'],axis=1,inplace=False)\n",
    "data2ML=data2pre.drop(['Bcf1f','Bcf2f','Bcf3f','Pucf1f','Pucf2f','is_dup'],axis=1,inplace=False)\n",
    "\n",
    "\n",
    "# # 删除重复数据\n",
    "\n",
    "print('是否存在重复数据data0ML',data0ML.duplicated().any())\n",
    "print('是否存在重复数据data1ML',data1ML.duplicated().any())\n",
    "print('是否存在重复数据data2ML',data2ML.duplicated().any())\n",
    "\n",
    "print('是否存在重复数据dfdelparapp',dfdelparapp.duplicated().any())\n",
    "\n",
    "\n",
    "# # 确定最终ML\n",
    "df_autoML = dfdelparapp.copy()\n",
    "\n",
    "# FinalMLpara=str('EigenValue')\n",
    "\n",
    "# # 使用sample函数随机抽取数据：\n",
    "# train_data=df_autoML.sample(frac=0.8,random_state=0, axis=0)  # 随机取多少行，axix=0表示行，#random_state: 设定随机种子\n",
    "\n",
    "# # # 再选取剩下的数据作为测试集：\n",
    "# test_data=df_autoML[~df_autoML.index.isin(train_data.index)]\n",
    "\n",
    "\n",
    "# # # 用于Autokeras\n",
    "# # train_data.to_csv(\"train.csv\", index=False)#训练集,输出不显示 index (索引)值\n",
    "# # test_data.to_csv(\"eval.csv\", index=False)#测试集,输出不显示 index (索引)值\n",
    "# # train_file_path = \"train.csv\"#训练集\n",
    "# # test_file_path = \"eval.csv\"#测试集\n",
    "# # # 用于Autogluon\n",
    "# # train_data = train_data\n",
    "# # test_data = test_data\n",
    "\n",
    "# # print(len(df_autoML))\n",
    "\n",
    "# # print(len(train_data))\n",
    "# # print(len(test_data))\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a31bd082",
   "metadata": {},
   "source": [
    "## 采用AutoKeras（可用，适用于深度学习的）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e4857340",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-20T04:56:37.815582Z",
     "start_time": "2023-09-20T04:56:33.205731Z"
    }
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import tensorflow as tf\n",
    "import keras\n",
    "import autokeras as ak\n",
    "from tensorflow.python.client import device_lib\n",
    "print(device_lib.list_local_devices())\n",
    "print(tf.__version__)\n",
    "print(keras.__version__)\n",
    "print(ak.__version__)\n",
    "# [name: \"/device:CPU:0\"\n",
    "# device_type: \"CPU\"\n",
    "# memory_limit: 268435456\n",
    "# locality {\n",
    "# }\n",
    "# incarnation: 11446219509844950189\n",
    "# xla_global_id: -1\n",
    "# ]\n",
    "# 2.10.1\n",
    "# 2.10.0\n",
    "# 1.1.0\n",
    "tf.test.is_gpu_available()#验证gpu是否可用"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dc18438e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-20T04:56:43.379733Z",
     "start_time": "2023-09-20T04:56:43.371754Z"
    }
   },
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "import os\n",
    "print(\"Num GPUs Available: \", len(tf.config.experimental.list_physical_devices('GPU')))\n",
    "tf.test.is_built_with_gpu_support()\n",
    "os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1029919b",
   "metadata": {},
   "source": [
    "### 运行 StructuredDataRegressor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "86304835",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-20T04:51:23.537365Z",
     "start_time": "2023-09-20T04:51:22.926968Z"
    }
   },
   "outputs": [],
   "source": [
    "#reg设置，初始化结构数据回归\n",
    "reg = ak.StructuredDataRegressor(overwrite=True,loss=\"mean_squared_error\", max_trials=3)  # 尝试max_trials种不同的模型\n",
    "# 将训练数据喂给结构化数据回归工具\n",
    "reg.fit(train_file_path,FinalMLpara, epochs=10,validation_split=0.2)#  \n",
    "# epochs=10,epochs 设置为 10。也可以不指定 epochs 以获取自适应数量的 epochs，使用等于 1000 的 epoch 并使用等于 30 的耐心提前停止。\n",
    "# 使用最后 20% 的训练数据作为验证数据，验证集\n",
    "# 采用mse作为指标和损失"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5c95f242",
   "metadata": {},
   "source": [
    "### 模型预测"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f0fd2362",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.220Z"
    }
   },
   "outputs": [],
   "source": [
    "# 采用最好的模型进行预测\n",
    "predicted_y = reg.predict(test_file_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e7051fc0",
   "metadata": {},
   "source": [
    "### 评估模型"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "18044991",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.230Z"
    }
   },
   "outputs": [],
   "source": [
    "# 采用测试数据评估模型\n",
    "reg.evaluate(test_file_path,FinalMLpara)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5dd34627",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-08-23T11:41:24.083760Z",
     "start_time": "2022-08-23T11:40:26.750939Z"
    },
    "scrolled": true
   },
   "source": [
    "### 将 AutoKeras 找到的最佳模型导出为 Keras 模型。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "569c4c0a",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.241Z"
    }
   },
   "outputs": [],
   "source": [
    "model = reg.export_model()# 导出最佳模型\n",
    "model.summary()# 最佳模型总结\n",
    "from keras.utils import plot_model\n",
    "import pydot\n",
    "import graphviz\n",
    "import pydotplus\n",
    "plot_model(model,to_file='Autokeras_model.png',show_shapes=True,show_layer_names=False)\n",
    "# model.predict(train_file_path)# 利用最佳模型进行训练"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "879aeb90",
   "metadata": {},
   "source": [
    "# Real数据"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "67ba423d",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.251Z"
    }
   },
   "outputs": [],
   "source": [
    "# 验证pytorch是否可以工作\n",
    "import torch\n",
    "print(torch.cuda.device_count())  # Should be > 0\n",
    "print(torch.__version__)\n",
    "import pandas as pd\n",
    "from sklearn.model_selection import train_test_split\n",
    "from autogluon.tabular import TabularDataset, TabularPredictor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e866298b",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "df_all_dic=dfdelpara\n",
    "df_all_dic =df_all_dic[(df_all_dic['meshsz'] == 40) | (df_alltype['meshsz'] == 20)]\n",
    "df_all_dic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c9c9d6e2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 手动处理独热编码\n",
    "\n",
    "# 删除空行\n",
    "df_all_dic1 = df_all_dic.dropna(how='all').copy()\n",
    "\n",
    "# 定义一个函数，根据 type 列的值添加新列\n",
    "# def add_columns(row):\n",
    "#     if row['type'] == 0:\n",
    "#         return pd.Series([1, 0, 0], index=['type0', 'type1', 'type2'])\n",
    "#     elif row['type'] == 1:\n",
    "#         return pd.Series([0, 1, 0], index=['type0', 'type1', 'type2'])\n",
    "#     elif row['type'] == 2:\n",
    "#         return pd.Series([0, 0, 1], index=['type0', 'type1', 'type2'])\n",
    "#     return pd.Series([None, None, None], index=['type0', 'type1', 'type2'])\n",
    "\n",
    "# # 应用函数添加新列\n",
    "# new_columns = df_all_dic1.apply(add_columns, axis=1)\n",
    "# df_all_dic1 = pd.concat([df_all_dic1, new_columns], axis=1)\n",
    "\n",
    "df_all_dic=df_all_dic1.copy()\n",
    "# df_all_dic.to_excel('processed_data.xlsx')\n",
    "# df_all_dic =df_all_dic[(df_all_dic['meshsz'] == 40) | (df_alltype['meshsz'] == 20)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "611b91a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# df_all_dic=df_all_dic[['B', 'cf1f', 'cf2f', 'cf3f', 'H', 'Imperfectfactor', 'L', 'meshsz', 'n',\n",
    "#        'pbol', 'sfricn', 'T1', 'T2', 'yfsn', 'yfss', 'yusn', 'yuss',\n",
    "#        'EigenValue', 'Pucf1f', 'Pucf2f', 'Pucf3f', 'type', 'Bcf1f', 'Bcf2f',\n",
    "#        'Bcf3f', 'Bcff', 'BoltB', 'BoltD','axialratio',  'F']]\n",
    "\n",
    "data0=df_all_dic[(df_all_dic['type'] == 0) ]\n",
    "data1=df_all_dic[(df_all_dic['type'] == 1) ]\n",
    "data2=df_all_dic[(df_all_dic['type'] == 2) ]\n",
    "\n",
    "data0_auto_pre=data0[(data0['meshsz'] == 40) | (data0['meshsz'] == 20)]\n",
    "data1_auto_pre=data1[(data1['meshsz'] == 40) | (data1['meshsz'] == 20)]\n",
    "data2_auto_pre=data2[(data2['meshsz'] == 40) | (data2['meshsz'] == 20)]\n",
    "\n",
    "data0_auto=data0_auto_pre[['B', 'cf1f', 'cf2f', 'axialratio', 'H',  'L',  'n', 'T1', 'T2', 'Imperfectfactor', 'yfss', 'EigenValue' ]].dropna(subset=['EigenValue'])\n",
    "display(data0_auto.reset_index(drop=True) ),data0_auto.to_excel('data0_auto.xlsx') \n",
    "data0_auto_P=data0_auto_pre[['B', 'cf1f', 'cf2f', 'axialratio', 'H',  'L',  'n', 'T1', 'T2',  'Imperfectfactor','yfss', 'EigenValue' ]].dropna(subset=['EigenValue'])\n",
    "display(data0_auto_P.reset_index(drop=True) ),data0_auto_P.to_excel('data0_auto.xlsx') \n",
    "\n",
    "data1_auto=data1_auto_pre[['B', 'cf1f', 'cf2f','axialratio', 'H',  'L',  'n', 'T1', 'T2', 'Imperfectfactor', 'yfss','sfricn', 'EigenValue']].dropna(subset=['EigenValue'])\n",
    "display(data1_auto.reset_index(drop=True) ),data1_auto.to_excel('data1_auto.xlsx') \n",
    "data1_auto_P=data1_auto_pre[['B', 'cf1f', 'cf2f','axialratio', 'H',  'L',  'n', 'T1', 'T2', 'Imperfectfactor', 'yfss','sfricn', 'EigenValue']].dropna(subset=['EigenValue'])\n",
    "display(data1_auto_P.reset_index(drop=True) ),data1_auto_P.to_excel('data1_auto.xlsx') \n",
    "\n",
    "data2_auto=data2_auto_pre[['B', 'cf1f', 'cf2f', 'axialratio', 'H',  'L',  'n', 'T1', 'T2',  'Imperfectfactor','yfss', 'sfricn','EigenValue','F','pbol']].dropna(subset=['EigenValue'])\n",
    "display(data2_auto.reset_index(drop=True) ),data2_auto.to_excel('data2_auto.xlsx') \n",
    "data2_auto_P=data2_auto_pre[['B', 'cf1f', 'cf2f', 'axialratio', 'H',  'L',  'n', 'T1', 'T2', 'Imperfectfactor', 'yfss', 'sfricn','EigenValue','F','pbol']].dropna(subset=['EigenValue'])\n",
    "display(data2_auto_P.reset_index(drop=True) ),data2_auto_P.to_excel('data2_auto.xlsx') "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "384474c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_all_dic = df_all_dic.drop_duplicates()\n",
    "df_all_dic\n",
    "# # 使用 query 方法进行优化：这里的 pucf12f == pucf12f 是一种利用 NaN 不等于自身的特性来检查非空值。\n",
    "# df_all_dic['Pucf12f'] = pd.to_numeric(df_all_dic['Pucf12f'], errors='coerce')\n",
    "# # 如果 pucf12f 列包含非数值类型（如字符串），则需要先转换数据类型。例如：\n",
    "# df_all_dic = df_all_dic.query('Pucf12f != 0 and Pucf12f == Pucf12f')\n",
    "# print(\"删除后 Pucf12f 列中的零值和空值行数:\", df_all_dic[(df_all_dic['Pucf12f'].isna() | (df_all_dic['Pucf12f'] == 0))].shape[0])\n",
    "# print(len(df_all_dic))\n",
    "\n",
    "# # original_df=df_all_dic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "11454ac6",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# # -*- coding: utf-8 -*-\n",
    "\n",
    "# # 导入库后立即配置字体\n",
    "# import matplotlib.pyplot as plt\n",
    "# import seaborn as sns\n",
    "# from scipy.stats.mstats import winsorize\n",
    "# from scipy import stats\n",
    "# import pandas as pd\n",
    "# import numpy as np\n",
    "# from sklearn.model_selection import train_test_split\n",
    "# from autogluon.tabular import TabularDataset\n",
    "# from statsmodels.graphics.gofplots import qqplot\n",
    "# from IPython.display import display\n",
    "# from sklearn.preprocessing import OneHotEncoder, LabelEncoder\n",
    "# import warnings\n",
    "# import missingno as msno  # 缺失值可视化库（需安装：pip install missingno）\n",
    "\n",
    "# # 抑制无关警告\n",
    "# warnings.filterwarnings(\"ignore\", category=UserWarning, module=\"matplotlib\")\n",
    "# warnings.filterwarnings(\"ignore\", message=\"p-value may not be accurate for N > 5000.\")\n",
    "\n",
    "# # 配置中文字体\n",
    "# plt.rcParams.update({\n",
    "#     \"font.family\": \"sans-serif\",\n",
    "#     \"font.sans-serif\": [\"simsun\"],\n",
    "#     \"axes.unicode_minus\": False,\n",
    "#     \"figure.dpi\": 150,\n",
    "# })\n",
    "# sns.set(style=\"whitegrid\", font=\"simsun\", font_scale=0.9)\n",
    "\n",
    "# # --------------------------- 可视化函数（兼容missingno旧版本） ---------------------------\n",
    "# def plot_missing_values(df, title=\"缺失值分布对比\"):\n",
    "#     \"\"\"绘制缺失值热图和矩阵（移除旧版本不支持的参数）\"\"\"\n",
    "#     plt.figure(figsize=(18, 8))\n",
    "\n",
    "#     # 子图1：缺失值热图（使用默认参数）\n",
    "#     plt.subplot(1, 2, 1)\n",
    "#     msno.heatmap(df)  # 旧版本仅支持默认参数\n",
    "#     plt.title(f\"{title} - 热图\", fontsize=10)\n",
    "\n",
    "#     # 子图2：缺失值矩阵（抽样10%避免卡顿）\n",
    "#     plt.subplot(1, 2, 2)\n",
    "#     sample_df = df.sample(frac=0.1, random_state=42) if len(df) > 10000 else df\n",
    "#     msno.matrix(sample_df)  # 使用默认颜色\n",
    "#     plt.title(f\"{title} - 矩阵图（抽样10%）\", fontsize=10)\n",
    "\n",
    "#     plt.tight_layout()\n",
    "#     plt.show()\n",
    "\n",
    "\n",
    "# def plot_data_type_comparison(original_df, processed_df, title=\"数据类型分布对比\"):\n",
    "#     \"\"\"对比处理前后数据类型分布\"\"\"\n",
    "#     original_types = original_df.dtypes.value_counts().reset_index(name=\"列数\")\n",
    "#     processed_types = processed_df.dtypes.value_counts().reset_index(name=\"列数\")\n",
    "\n",
    "#     plt.figure(figsize=(12, 6))\n",
    "#     sns.barplot(x=\"index\", y=\"列数\", data=original_types, label=\"处理前\", color=\"skyblue\", alpha=0.7)\n",
    "#     sns.barplot(x=\"index\", y=\"列数\", data=processed_types, label=\"处理后\", color=\"orange\", alpha=0.7)\n",
    "\n",
    "#     plt.ylabel(\"列数\", fontsize=10)\n",
    "#     plt.xlabel(\"数据类型\", fontsize=10)\n",
    "#     plt.title(title, fontsize=12)\n",
    "#     plt.xticks(rotation=45, ha=\"right\", fontsize=8)\n",
    "#     plt.legend(fontsize=10)\n",
    "#     plt.show()\n",
    "\n",
    "\n",
    "# def plot_numeric_distribution_comparison(original_df, processed_df, numeric_cols):\n",
    "#     \"\"\"对比数值型特征分布（限制展示前8列）\"\"\"\n",
    "#     plot_cols = numeric_cols[:8]\n",
    "#     n_cols = 4\n",
    "#     # 每个列有两个子图（直方图和箱线图），所以行数翻倍\n",
    "#     n_rows = 2 * ((len(plot_cols) + n_cols - 1) // n_cols)\n",
    "#     plt.figure(figsize=(16, 4 * n_rows))\n",
    "\n",
    "#     for i, col in enumerate(plot_cols):\n",
    "#         # 抽样10000行避免内存压力\n",
    "#         original_sample = original_df[col].sample(min(10000, len(original_df)), random_state=42)\n",
    "#         processed_sample = processed_df[col].sample(min(10000, len(processed_df)), random_state=42)\n",
    "\n",
    "#         # 直方图\n",
    "#         plt.subplot(n_rows, n_cols, 2 * i + 1)\n",
    "#         sns.histplot(original_sample, kde=True, bins=30, color=\"skyblue\", alpha=0.6, label=\"处理前\")\n",
    "#         sns.histplot(processed_sample, kde=True, bins=30, color=\"orange\", alpha=0.6, label=\"处理后\")\n",
    "#         plt.title(f\"{col} - 分布对比\", fontsize=10)\n",
    "#         plt.legend(fontsize=8)\n",
    "\n",
    "#         # 箱线图（修正数据格式为长格式）\n",
    "#         plt.subplot(n_rows, n_cols, 2 * i + 2)\n",
    "#         # 合并数据并添加分组标签\n",
    "#         combined_data = pd.DataFrame({\n",
    "#             'value': pd.concat([original_sample, processed_sample], ignore_index=True),\n",
    "#             'group': ['处理前'] * len(original_sample) + ['处理后'] * len(processed_sample)\n",
    "#         })\n",
    "#         sns.boxplot(data=combined_data, x='group', y='value', palette=[\"skyblue\", \"orange\"])\n",
    "#         plt.title(f\"{col} - 异常值对比\", fontsize=10)\n",
    "#         plt.xlabel(\"\")  # 移除x轴标签（原labels参数冗余）\n",
    "\n",
    "#     plt.tight_layout()\n",
    "#     plt.show()\n",
    "\n",
    "\n",
    "# def plot_categorical_distribution_comparison(original_df, processed_df, categorical_cols):\n",
    "#     \"\"\"对比类别型特征分布（限制展示前4列）\"\"\"\n",
    "#     plot_cols = categorical_cols[:4]\n",
    "#     plt.figure(figsize=(16, 6 * len(plot_cols)))\n",
    "\n",
    "#     for i, col in enumerate(plot_cols):\n",
    "#         # 处理前分布\n",
    "#         plt.subplot(len(plot_cols), 2, 2 * i + 1)\n",
    "#         original_counts = original_df[col].value_counts(dropna=True, normalize=True) * 100\n",
    "#         original_counts.plot(kind=\"bar\", color=\"skyblue\", alpha=0.7)\n",
    "#         plt.title(f\"{col} - 处理前类别占比（%）\", fontsize=10)\n",
    "#         plt.xticks(rotation=45, ha=\"right\", fontsize=8)\n",
    "\n",
    "#         # 处理后分布（独热编码列显示新列）\n",
    "#         plt.subplot(len(plot_cols), 2, 2 * i + 2)\n",
    "#         if col in processed_df.columns:\n",
    "#             processed_counts = processed_df[col].value_counts(dropna=True, normalize=True) * 100\n",
    "#             processed_counts.plot(kind=\"bar\", color=\"orange\", alpha=0.7)\n",
    "#         else:\n",
    "#             encoded_cols = [c for c in processed_df.columns if c.startswith(f\"{col}_\")]\n",
    "#             if encoded_cols:\n",
    "#                 encoded_counts = processed_df[encoded_cols].sum().sort_values(ascending=False)\n",
    "#                 encoded_counts.plot(kind=\"bar\", color=\"orange\", alpha=0.7)\n",
    "#                 plt.title(f\"{col} - 独热编码后新列占比（%）\", fontsize=10)\n",
    "#             else:\n",
    "#                 plt.text(0.5, 0.5, \"列已删除\", ha=\"center\", va=\"center\", fontsize=10)\n",
    "\n",
    "#         plt.xticks(rotation=45, ha=\"right\", fontsize=8)\n",
    "\n",
    "#     plt.tight_layout()\n",
    "#     plt.show()\n",
    "\n",
    "# # --------------------------- 数据预处理函数（优化后） ---------------------------\n",
    "# def enhanced_data_processor(\n",
    "#     data, \n",
    "#     x_cols, \n",
    "#     y_cols, \n",
    "#     onehot_cols: list = None,  # 需独热编码的列（仅当use_onehot=True时有效）\n",
    "#     use_onehot: bool = True,  # 是否启用独热编码（默认启用）\n",
    "#     is_classification=False, \n",
    "#     onehot_kwargs=None\n",
    "# ):\n",
    "#     original_df = data.copy()\n",
    "#     if onehot_kwargs is None:\n",
    "#         onehot_kwargs = {}\n",
    "#     # 初始化onehot_cols（若未指定且use_onehot=True，默认空列表避免报错）\n",
    "#     onehot_cols = onehot_cols if onehot_cols is not None else []\n",
    "\n",
    "#     def validate_data_types():\n",
    "#         if not (isinstance(y_cols, list) and len(y_cols) == 1):\n",
    "#             raise ValueError(\"目标列必须是包含单个列名的列表\")\n",
    "#         if y_cols[0] not in data.columns:\n",
    "#             raise ValueError(f\"目标列 {y_cols[0]} 不存在\")\n",
    "#         # 新增：当use_onehot=True但onehot_cols非列表时报错\n",
    "#         if use_onehot and not isinstance(onehot_cols, list):\n",
    "#             raise ValueError(\"当use_onehot=True时，onehot_cols必须是列名列表\")\n",
    "\n",
    "#     def handle_missing_values(df):\n",
    "#         missing_cols = {col: (df[col].isnull().sum() / len(df) * 100) \n",
    "#                         for col in df.columns if df[col].isnull().any()}\n",
    "#         num_cols = df.select_dtypes(include=np.number).columns\n",
    "#         df[num_cols] = df[num_cols].fillna(df[num_cols].median())\n",
    "#         cat_cols = df.select_dtypes(include=['object', 'category']).columns\n",
    "#         for col in cat_cols:\n",
    "#             df[col] = df[col].fillna('Unknown')\n",
    "#         return df, missing_cols\n",
    "\n",
    "#     def handle_outliers(df):\n",
    "#         num_cols = df.select_dtypes(include=np.number).columns\n",
    "#         for col in num_cols:\n",
    "#             df[col] = winsorize(df[col], limits=[0.01, 0.01])\n",
    "#         return df\n",
    "\n",
    "#     def convert_data_types(df):\n",
    "#         int_cols = df.select_dtypes(include=np.integer).columns.difference(y_cols + onehot_cols)\n",
    "#         for col in int_cols:\n",
    "#             if df[col].nunique() < 20:\n",
    "#                 df[col] = df[col].astype('category').cat.codes.astype('int32')\n",
    "#             else:\n",
    "#                 df[col] = df[col].astype('int32')\n",
    "#         return df\n",
    "\n",
    "#     def encode_categorical_features(df, onehot_cols):\n",
    "#         if not use_onehot:  # 不启用时直接跳过编码\n",
    "#             return df\n",
    "#         # 新增：提示用户当前编码的列\n",
    "#         if onehot_cols:\n",
    "#             print(f\"正在对以下列执行独热编码：{onehot_cols}\")\n",
    "#         else:\n",
    "#             print(\"注意：use_onehot=True但onehot_cols为空，未执行任何独热编码\")\n",
    "        \n",
    "#         for col in onehot_cols:\n",
    "#             if col not in df.columns:\n",
    "#                 print(f\"警告：列 {col} 不存在于数据中，跳过编码\")\n",
    "#                 continue\n",
    "#             try:\n",
    "#                 encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore', **onehot_kwargs)\n",
    "#                 encoded = encoder.fit_transform(df[[col]])\n",
    "#                 new_cols = encoder.get_feature_names_out([col])\n",
    "#                 df = pd.concat([df.drop(col, axis=1), pd.DataFrame(encoded, columns=new_cols)], axis=1)\n",
    "#             except ValueError as e:\n",
    "#                 print(f\"警告：列 {col} 独热编码失败，原因：{str(e)}，已跳过\")\n",
    "#         return df\n",
    "\n",
    "#     validate_data_types()\n",
    "#     processed, _ = handle_missing_values(data.copy())\n",
    "#     processed = processed.pipe(handle_outliers).pipe(convert_data_types)\n",
    "#     # 仅当启用独热编码时执行编码步骤\n",
    "#     if use_onehot:\n",
    "#         processed = processed.pipe(encode_categorical_features, onehot_cols)\n",
    "#     valid_mask = (processed[y_cols] != 0).any(axis=1)\n",
    "#     processed_data = processed[valid_mask].reset_index(drop=True)\n",
    "#     return original_df, processed_data\n",
    "\n",
    "\n",
    "# def feature_normality_test(data, feature_cols):\n",
    "#     \"\"\"特征变量正态性检验（带可视化）\"\"\"\n",
    "#     for col in feature_cols:\n",
    "#         if pd.api.types.is_numeric_dtype(data[col]):\n",
    "#             feature_data = data[col].dropna()[~np.isinf(data[col])]\n",
    "#             if len(feature_data) == 0:\n",
    "#                 print(f\"警告：特征 {col} 无有效数据，跳过检验\")\n",
    "#                 continue\n",
    "\n",
    "#             # 统计量计算\n",
    "#             mean, median, std = feature_data.mean(), feature_data.median(), feature_data.std()\n",
    "#             skew, kurt = feature_data.skew(), feature_data.kurt()\n",
    "#             ks_p = stats.kstest(feature_data, 'norm')[1]\n",
    "#             ad_result = stats.anderson(feature_data, 'norm')\n",
    "#             ad_p = next((sl / 100 for i, sl in enumerate(ad_result.significance_level)\n",
    "#                          if ad_result.statistic < ad_result.critical_values[i]), None)\n",
    "#             shapiro_p = stats.shapiro(feature_data)[1]\n",
    "\n",
    "#             # 可视化\n",
    "#             fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n",
    "#             sns.histplot(feature_data, kde=True, bins=30, ax=ax1, color='skyblue')\n",
    "#             ax1.axvline(mean, c='red', ls='--', label=f'均值=μ={mean:.2f}')\n",
    "#             ax1.axvline(median, c='green', ls='--', label=f'中位数=Med={median:.2f}')\n",
    "#             ax1.set_title(f'特征 {col} 分布直方图')\n",
    "\n",
    "#             qqplot(feature_data, line='s', ax=ax2)\n",
    "#             ax2.set_title(f'特征 {col} QQ图（正态性检验）')\n",
    "\n",
    "#             # 统计信息文本框\n",
    "#             ad_p_str = f'{ad_p:.4f}' if ad_p is not None else 'N/A'\n",
    "#             stats_text = (f'样本量: N={len(feature_data)}\\n'\n",
    "#                           f'均值: μ={mean:.2f}, 标准差: σ={std:.2f}\\n'\n",
    "#                           f'偏度: S={skew:.2f}, 峰度: K={kurt:.2f}\\n\\n'\n",
    "#                           f'K-S检验 p值: {ks_p:.4e}\\n'\n",
    "#                           f'A-D检验 p值: {ad_p_str}\\n'\n",
    "#                           f'Shapiro-Wilk检验 p值: {shapiro_p:.4e}')\n",
    "#             ax1.text(0.98, 0.9, stats_text, transform=ax1.transAxes,\n",
    "#                      fontsize=8, bbox=dict(facecolor='white', alpha=0.8), va='top', ha='right')\n",
    "#             plt.tight_layout()\n",
    "#             plt.show()\n",
    "\n",
    "\n",
    "# def comprehensive_normality_test(data, target_col):\n",
    "#     \"\"\"目标变量正态性检验（返回统计量）\"\"\"\n",
    "#     target_data = data[target_col].dropna()[~np.isinf(data[target_col])]\n",
    "#     if len(target_data) == 0:\n",
    "#         print(f\"警告：目标列 {target_col} 无有效数据，无法进行检验\")\n",
    "#         return None\n",
    "\n",
    "#     ks_p = stats.kstest(target_data, 'norm')[1]\n",
    "#     ad_result = stats.anderson(target_data, 'norm')\n",
    "#     ad_p = next((sl / 100 for i, sl in enumerate(ad_result.significance_level)\n",
    "#                  if ad_result.statistic < ad_result.critical_values[i]), None)\n",
    "#     shapiro_p = stats.shapiro(target_data)[1]\n",
    "\n",
    "#     return {\n",
    "#         'K-S p值': ks_p,\n",
    "#         'A-D p值': ad_p,\n",
    "#         'Shapiro-Wilk p值': shapiro_p\n",
    "#     }\n",
    "\n",
    "\n",
    "# def data_transformation(data, target_col):\n",
    "#     \"\"\"目标变量对数变换（处理非正态分布，兼容零值）\"\"\"\n",
    "#     data[target_col] = np.log1p(data[target_col])\n",
    "#     return data\n",
    "\n",
    "# if __name__ == \"__main__\":\n",
    "#     # 加载数据（请替换为实际文件路径）\n",
    "#     try:\n",
    "#         df = df_all_dic  # 替换为你的数据文件\n",
    "#         df.columns = df.columns.str.strip().str.replace(' ', '_')\n",
    "#         print(f\"成功加载原始数据，形状：{df.shape}\")\n",
    "#         display(df.head())\n",
    "#     except FileNotFoundError:\n",
    "#         raise ValueError(\"错误：请确保数据文件存在\")\n",
    "\n",
    "#     target_col = ['Pucf12f']\n",
    "#     initial_feature_cols = [col for col in df.columns if col != target_col[0]]\n",
    "\n",
    "#     # ================= 优化：统一命名并简化控制逻辑 =================\n",
    "#     # 核心控制变量（统一命名为use_onehot，与函数参数一致）\n",
    "#     use_onehot = False  # 用户可设置为False跳过独热编码\n",
    "    \n",
    "#     # 根据use_onehot自动决定是否需要指定onehot_cols\n",
    "#     if use_onehot:\n",
    "#         # 用户需手动指定需要独热编码的列（示例：['type', 'category_col']）\n",
    "#         selected_onehot_cols = ['type']  # 替换为你的目标列\n",
    "#         # 新增：校验列是否存在\n",
    "#         invalid_cols = [col for col in selected_onehot_cols if col not in df.columns]\n",
    "#         if invalid_cols:\n",
    "#             raise ValueError(f\"以下列不存在于数据中，无法编码：{invalid_cols}\")\n",
    "#     else:\n",
    "#         selected_onehot_cols = []  # 不使用时自动设为空列表（无需用户干预）\n",
    "\n",
    "#     # ================= 调用预处理函数 =================\n",
    "#     print(\"\\n开始数据预处理...\")\n",
    "#     original_df, processed_data = enhanced_data_processor(\n",
    "#         df, \n",
    "#         initial_feature_cols, \n",
    "#         y_cols=target_col, \n",
    "#         onehot_cols=selected_onehot_cols, \n",
    "#         use_onehot=use_onehot  # 关键开关参数（命名统一）\n",
    "#     )\n",
    "\n",
    "#     # --------------------------- 可视化对比 ---------------------------\n",
    "\n",
    "#     # 1. 缺失值对比\n",
    "#     print(\"\\n===== 缺失值分布对比 =====\")\n",
    "#     plot_missing_values(original_df, \"处理前缺失值分布\")\n",
    "#     plot_missing_values(processed_data, \"处理后缺失值分布\")\n",
    "\n",
    "#     # 2. 数据类型对比\n",
    "#     print(\"\\n===== 数据类型分布对比 =====\")\n",
    "#     plot_data_type_comparison(original_df, processed_data)\n",
    "\n",
    "#     # 3. 数值型特征对比\n",
    "#     numeric_cols = original_df.select_dtypes(include=np.number).columns.tolist()\n",
    "#     if numeric_cols:\n",
    "#         print(f\"\\n===== 数值型特征分布对比（展示前8列）=====\")\n",
    "#         plot_numeric_distribution_comparison(original_df, processed_data, numeric_cols)\n",
    "\n",
    "#     # 4. 类别型特征对比\n",
    "#     categorical_cols = original_df.select_dtypes(include=['object', 'category']).columns.tolist()\n",
    "#     if categorical_cols:\n",
    "#         print(f\"\\n===== 类别型特征分布对比（展示前4列）=====\")\n",
    "#         plot_categorical_distribution_comparison(original_df, processed_data, categorical_cols)\n",
    "\n",
    "#     # --------------------------- 后续处理 ---------------------------\n",
    "#     feature_cols = [col for col in processed_data.columns if col != target_col[0]]\n",
    "    \n",
    "\n",
    "#     print(f\"\\n处理后数据形状：{processed_data.shape}\")\n",
    "#     print(\"数据类型分布：\\n\", processed_data.dtypes.value_counts())\n",
    "# # 处理后关键信息总结\n",
    "# print(\"\\n=================== 处理后关键变化总结 ===================\")\n",
    "# print(f\"特征数量变化：{len(df.columns)} → {len(processed_data.columns)}\")\n",
    "# # 错误：onehot_cols 未定义，应使用主程序中的 selected_onehot_cols\n",
    "# # print(\"独热编码生成列示例：\", [col for col in processed_data.columns if any(col.startswith(f\"{oc}_\") for oc in onehot_cols)][:5])\n",
    "\n",
    "# # 正确：使用 selected_onehot_cols\n",
    "# print(\"独热编码生成列示例：\", [col for col in processed_data.columns if any(col.startswith(f\"{oc}_\") for oc in selected_onehot_cols)][:5])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b356416b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# # 查看原始类别列的唯一值（以'type'为例）\n",
    "# print(\"原始类别列唯一值：\", original_df['type'].unique())\n",
    "# # 查看处理后独热列的统计信息\n",
    "# print(\"\\n独热编码列统计：\")\n",
    "# processed_data[['type_0', 'type_1', 'type_2']].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "60e9d766",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 假设 df 是你的 DataFrame\n",
    "# processed_data = processed_data.drop('type', axis=1)\n",
    "# processed_data.to_excel('processed_data.xlsx')\n",
    "# processed_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3db84d50",
   "metadata": {},
   "outputs": [],
   "source": [
    "# from sklearn.model_selection import train_test_split\n",
    "# processed_data=df_all_dic\n",
    "# train_set, temp_set = train_test_split(processed_data, test_size=0.3, random_state=42) #这个随机种子和系统层面的不同\n",
    "\n",
    "# val_set, test_set = train_test_split(temp_set, test_size=0.5, random_state=42)\n",
    "\n",
    "# # 比例验证\n",
    "# print(f\"训练集比例: {len(train_set)/len(processed_data):.2%}\")\n",
    "# print(f\"验证集比例: {len(val_set)/len(processed_data):.2%}\")\n",
    "# print(f\"测试集比例: {len(test_set)/len(processed_data):.2%}\")\n",
    "# # 保存数据集\n",
    "# train_set.to_csv('train_data.csv', index=False)\n",
    "# val_set.to_csv('val_data.csv', index=False)\n",
    "# test_set.to_csv('test_data.csv', index=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8a7fc2ba",
   "metadata": {},
   "outputs": [],
   "source": [
    "# \"\"\"\n",
    "# 基于AutoGluon的全栈回归预测框架（支持12种SOTA模型）\n",
    "\n",
    "# 核心模型库：\n",
    "# 1. 树模型：XGBoost (GPU/CPU)、LightGBM (GPU/CPU)、CatBoost (GPU/CPU)、RandomForest、ExtraTrees、GBM\n",
    "# 2. 深度学习：TabNet、NeuralNet (PyTorch)、FastAI Tabular\n",
    "# 3. 传统方法：SVM、AdaBoost、贝叶斯岭回归\n",
    "# 4. 集成方法：Stacking (2层)、Bagging (5折)\n",
    "\n",
    "# 创新点：\n",
    "# - 动态模型选择策略（自动匹配硬件资源）\n",
    "# - 多编码策略支持（独热/标签/频率编码自动适配）\n",
    "# - 全模型类型覆盖（工业级+学术级算法组合）\n",
    "# \"\"\"\n",
    "\n",
    "# # ============================== 基础依赖与全局定义 ==============================\n",
    "# import pandas as pd\n",
    "# import numpy as np\n",
    "# import torch\n",
    "# from autogluon.tabular import TabularPredictor, TabularDataset\n",
    "# from sklearn.compose import ColumnTransformer\n",
    "# from sklearn.pipeline import Pipeline\n",
    "# from sklearn.preprocessing import (\n",
    "#     QuantileTransformer, OneHotEncoder, LabelEncoder, \n",
    "#     RobustScaler, StandardScaler, \n",
    "# )\n",
    "# from sklearn.impute import SimpleImputer self.custom_metrics\n",
    "# import os\n",
    "# from typing import Dict, List, Tuple, Any\n",
    "# from sklearn.model_selection import train_test_split\n",
    "\n",
    "# # 自定义 FrequencyEncoder 以兼容旧版本\n",
    "# from sklearn.base import BaseEstimator, TransformerMixin\n",
    "\n",
    "# class FrequencyEncoder(BaseEstimator, TransformerMixin):\n",
    "#     def __init__(self, normalize=True):\n",
    "#         self.normalize = normalize\n",
    "#         self.freq_map = None\n",
    "\n",
    "#     def fit(self, X, y=None):\n",
    "#         self.freq_map = X.value_counts(normalize=self.normalize).to_dict()\n",
    "#         return self\n",
    "\n",
    "#     def transform(self, X, y=None):\n",
    "#         return X.map(self.freq_map).fillna(0)\n",
    "\n",
    "# # 支持的全部模型类型（工业级+学术级）\n",
    "# SUPPORTED_MODELS = [\n",
    "#     \"XGB\", \"LGBM\", \"CAT\", \"RF\",       # 树模型\n",
    "#     \"XT\", \"GBM\", \"TabNet\", \"NN_TORCH\", # 增强树与深度学习\n",
    "#     \"FASTAI\", \"SVM\", \"AdaBoost\", \"BayesianRidge\",  # 传统与贝叶斯方法\n",
    "#     \"KNN\", \"LR\",                      # 新增：K近邻和线性回归\n",
    "#     \"ENS_WEIGHTED\", \"SIMPLE_ENS_WEIGHTED\",  # 集成策略\n",
    "#     \"IM_RULEFIT\", \"IM_FIGS\",          # 可解释性模型\n",
    "#     \"DUMMY\"                           # 基线模型\n",
    "# ]\n",
    "   \n",
    "# # 硬件感知配置（自动检测GPU能力）\n",
    "# GPU_AVAILABLE = torch.cuda.is_available()\n",
    "# DEFAULT_SEED = 42\n",
    "# NUM_CORES = os.cpu_count()\n",
    "\n",
    "# # ============================== 自适应特征工程模块 ==============================\n",
    "# class AdaptiveFeatureEngineer:\n",
    "#     \"\"\"\n",
    "#     支持多编码策略的特征工程管道（自动选择最佳编码方式）\n",
    "    \n",
    "#     参数:\n",
    "#         target_col (str): 目标变量列名\n",
    "#         cat_encoding (str): 类别特征编码方式（onehot/label/freq）\n",
    "#     \"\"\"\n",
    "#     def __init__(self, target_col: str, cat_encoding: str = \"onehot\"):\n",
    "#         self.target_col = target_col\n",
    "#         self.cat_encoding = cat_encoding.lower()\n",
    "#         self.encoders = {\n",
    "#             \"onehot\": OneHotEncoder(handle_unknown='ignore', sparse_output=False),\n",
    "#             \"label\": LabelEncoder(),\n",
    "#             \"freq\": FrequencyEncoder(normalize=True)\n",
    "#         }\n",
    "        \n",
    "#         # 数值特征处理管道（鲁棒缩放+分位数转换）\n",
    "#         self.numeric_pipeline = Pipeline([\n",
    "#             ('imputer', SimpleImputer(strategy='median')),  # 缺失值填充\n",
    "#             ('scaler', RobustScaler()),                      # 抗异常值缩放\n",
    "#             ('quantile', QuantileTransformer(output_distribution='normal'))\n",
    "#         ])\n",
    "    \n",
    "#     def _select_encoder(self, X: pd.DataFrame) -> ColumnTransformer:\n",
    "#         \"\"\"根据编码策略生成列转换器\"\"\"\n",
    "#         cat_cols = X.select_dtypes(exclude=np.number).columns.tolist()\n",
    "#         num_cols = X.select_dtypes(include=np.number).columns.tolist()\n",
    "        \n",
    "#         transformers = [('num', self.numeric_pipeline, num_cols)]\n",
    "#         if cat_cols:\n",
    "#             encoder = self.encoders[self.cat_encoding]\n",
    "#             transformers.append(('cat', encoder, cat_cols))\n",
    "        \n",
    "#         return ColumnTransformer(transformers=transformers, verbose_feature_names_out=False)\n",
    "    \n",
    "#     def transform(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, np.ndarray]:\n",
    "#         \"\"\"端到端特征工程（含目标变量对数变换）\"\"\"\n",
    "#         X, y = data.drop(self.target_col, axis=1), data[self.target_col]\n",
    "#         preprocessor = self._select_encoder(X)\n",
    "#         X_processed = preprocessor.fit_transform(X)\n",
    "#         feature_names = preprocessor.get_feature_names_out()  # 保留特征名\n",
    "#         y_transformed = np.log1p(y)  # 稳定梯度的目标变换\n",
    "#         return pd.DataFrame(X_processed, columns=feature_names), y_transformed\n",
    "\n",
    "# # ============================== 全模型超参数空间 ==============================\n",
    "# from typing import Dict\n",
    "\n",
    "# def get_hyperparameter_space(gpu_count: int) -> Dict[str, Dict]:\n",
    "#     \"\"\"\n",
    "#     生成 AutoGluon 支持的所有表单回归模型的超参数搜索空间（硬件感知配置）\n",
    "    \n",
    "#     参数:\n",
    "#         gpu_count (int): 使用的 GPU 数量（0=CPU 模式）\n",
    "    \n",
    "#     返回:\n",
    "#         包含所有模型超参数的字典（键为 AutoGluon 标准缩写）\n",
    "#     \"\"\"\n",
    "#     base_config = {\n",
    "#         \"n_jobs\": NUM_CORES,          # 多核并行（根据 CPU 核心数调整）\n",
    "#         \"random_state\": DEFAULT_SEED, # 固定随机种子保证可复现\n",
    "#         \"eval_metric\": \"rmse\"         # 回归任务评估指标（均方根误差）\n",
    "#     }\n",
    "    \n",
    "#     return {\n",
    "#         # ------------------------------ 树模型（GPU 加速） ------------------------------\n",
    "#         \"XGB\": {  # XGBoost\n",
    "#             **base_config,\n",
    "#             \"tree_method\": \"gpu_hist\" if gpu_count else \"hist\",  # GPU 用 gpu_hist，CPU 用 hist\n",
    "#             \"n_estimators\": (500, 3000),                        # 基学习器数量（大范围搜索）\n",
    "#             \"learning_rate\": (0.001, 0.2, 'log'),                # 学习率（对数空间搜索）\n",
    "#             \"max_depth\": (6, 12)                                 # 树深度（避免过拟合）\n",
    "#         },\n",
    "#         \"LGBM\": {  # LightGBM（修正缩写：原 LGB → LGBM）\n",
    "#             **base_config,\n",
    "#             \"device\": \"gpu\" if gpu_count else \"cpu\",             # GPU 加速开关\n",
    "#             \"n_estimators\": (500, 4000),                        # 基学习器数量（比 XGB 更大范围）\n",
    "#             \"num_leaves\": (30, 1000),                            # 叶子节点数（控制复杂度）\n",
    "#             \"min_child_samples\": (20, 200)                       # 子节点最小样本数（防过拟合）\n",
    "#         },\n",
    "#         \"CAT\": {  # CatBoost\n",
    "#             **base_config,\n",
    "#             \"task_type\": \"GPU\" if gpu_count else \"CPU\",          # GPU 加速开关（CAT 特有参数）\n",
    "#             \"iterations\": (1000, 5000),                          # 迭代次数（比 XGB 更激进）\n",
    "#             \"learning_rate\": (0.001, 0.3, 'log'),                # 学习率（范围更广）\n",
    "#             \"depth\": (4, 10)                                     # 树深度（比 XGB 更浅）\n",
    "#         },\n",
    "\n",
    "#         # ------------------------------ 传统树模型（CPU 优化） ------------------------------\n",
    "#         \"RF\": {  # Random Forest\n",
    "#             **base_config,\n",
    "#             \"n_estimators\": (500, 2000),                        # 树数量（CPU 友好范围）\n",
    "#             \"max_depth\": (10, 40),                               # 树深度（限制复杂度）\n",
    "#             \"max_features\": ['sqrt', 'log2', 0.8]                # 特征采样策略（提升多样性）\n",
    "#         },\n",
    "#         \"XT\": {  # Extra Trees（极端随机树）\n",
    "#             **base_config,\n",
    "#             \"n_estimators\": (500, 2000),                        # 树数量（与 RF 一致）\n",
    "#             \"max_depth\": (None, 50),                             # 深度可选无限制（增强拟合能力）\n",
    "#             \"bootstrap\": [True, False]                           # 自助采样（增加模型多样性）\n",
    "#         },\n",
    "#         \"GBM\": {  # Gradient Boosting（Scikit-learn 版）\n",
    "#             **base_config,\n",
    "#             \"n_estimators\": (500, 3000),                        # 迭代次数（轻量级提升）\n",
    "#             \"learning_rate\": (0.001, 0.2, 'log'),                # 学习率（与 XGB 一致）\n",
    "#             \"max_depth\": (3, 8)                                  # 树深度（更浅，避免过拟合）\n",
    "#         },\n",
    "#         \"KNN\": {  # K-Nearest Neighbors（新增，适合局部模式挖掘）\n",
    "#             **base_config,\n",
    "#             \"n_neighbors\": (3, 50),                             # 近邻数量（小范围搜索）\n",
    "#             \"weights\": ['uniform', 'distance'],                 # 权重策略（距离加权或平均）\n",
    "#             \"p\": [1, 2]                                          # 距离度量（曼哈顿或欧氏距离）\n",
    "#         },\n",
    "\n",
    "#         # ------------------------------ 深度学习模型（GPU 优先） ------------------------------\n",
    "#         \"NN_TORCH\": {  # PyTorch 神经网络\n",
    "#             \"num_epochs\": (200, 800),                            # 训练轮次（根据数据量调整）\n",
    "#             \"batch_size\": [512, 1024, 2048],                     # 批次大小（GPU 内存感知）\n",
    "#             \"hidden_layer_sizes\": [(1024, 512), (512, 256), (256, 128)],  # 隐藏层结构（不同复杂度）\n",
    "#             \"device\": \"cuda\" if gpu_count else \"cpu\",             # GPU 加速开关\n",
    "#             \"eval_metric\": \"rmse\"                                 # 回归任务指标\n",
    "#         },\n",
    "#         \"FASTAI\": {  # FastAI 表格模型（修正缩写：原 FastAI → 官方大写）\n",
    "#             \"loss_func\": \"MSELoss\",                              # 回归任务损失函数\n",
    "#             \"epochs\": (100, 500),                                # 训练轮次（比 NN_TORCH 更短）\n",
    "#             \"bs\": [256, 512],                                    # 批次大小（适配 GPU 内存）\n",
    "#             \"lr\": (1e-4, 1e-2, 'log'),                           # 学习率（对数空间搜索）\n",
    "#             \"device\": \"cuda\" if gpu_count else \"cpu\"              # GPU 加速开关\n",
    "#         },\n",
    "#         \"TabNet\": {  # TabNet（表格专用深度学习模型）\n",
    "#             \"n_steps\": (3, 8),                                   # 决策步骤数（控制模型深度）\n",
    "#             \"gamma\": (1.0, 3.0),                                 # 特征掩码的稀疏性控制\n",
    "#             \"n_shared\": (2, 6),                                  # 共享层数量（提升特征复用）\n",
    "#             \"optimizer_lr\": (1e-4, 0.1, 'log'),                  # 优化器学习率（范围更广）\n",
    "#             \"device\": \"cuda\" if gpu_count else \"cpu\"             # GPU 加速开关\n",
    "#         },\n",
    "\n",
    "#         # ------------------------------ 传统与贝叶斯模型 ------------------------------\n",
    "#         \"LR\": {  # 线性回归（新增，基线模型）\n",
    "#             **base_config,\n",
    "#             \"penalty\": ['l1', 'l2', 'elasticnet'],              # 正则化类型（L1/L2/弹性网络）\n",
    "#             \"alpha\": (1e-4, 1e2, 'log'),                        # 正则化强度（对数空间搜索）\n",
    "#             \"l1_ratio\": (0.1, 0.9)                               # 弹性网络 L1 比例（平衡 L1/L2）\n",
    "#         },\n",
    "#         \"SVM\": {  # 支持向量机\n",
    "#             \"kernel\": ['rbf', 'linear', 'poly'],                 # 核函数类型（径向基/线性/多项式）\n",
    "#             \"C\": (1e-3, 1e3, 'log'),                             # 正则化强度（控制间隔宽度）\n",
    "#             \"gamma\": (1e-4, 1e2, 'log'),                         # 核函数宽度（影响局部性）\n",
    "#             \"epsilon\": (0.01, 0.2)                                # 不敏感损失函数宽度\n",
    "#         },\n",
    "#         \"AdaBoost\": {  # 提升树\n",
    "#             \"n_estimators\": (500, 2000),                        # 基学习器数量（提升次数）\n",
    "#             \"learning_rate\": (0.01, 0.5, 'log'),                 # 学习率（控制提升步长）\n",
    "#             \"base_estimator\": [\"DecisionTreeRegressor\"],         # 基学习器（固定为决策树）\n",
    "#             \"max_depth\": (3, 8)                                  # 基树深度（限制复杂度）\n",
    "#         },\n",
    "#         \"BayesianRidge\": {  # 贝叶斯岭回归\n",
    "#             \"n_iter\": (100, 1000),                               # 迭代次数（收敛性控制）\n",
    "#             \"tol\": (1e-3, 1e-1, 'log'),                          # 收敛阈值（对数空间搜索）\n",
    "#             \"alpha_1\": (1e-6, 1e-1, 'log'),                      # 超参数（控制先验分布）\n",
    "#             \"lambda_1\": (1e-6, 1e-1, 'log')                      # 超参数（控制权重稀疏性）\n",
    "#         },\n",
    "\n",
    "#         # ------------------------------ 集成策略（自动生成，无需手动调参） ------------------------------\n",
    "#         \"ENS_WEIGHTED\": {  # 加权集成（AutoGluon 默认集成策略）\n",
    "#             \"stack_ensemble_levels\": 1,                           # 堆叠集成层数（与 stack 策略配合）\n",
    "#             \"refit_full\": True                                    # 用全量数据重新训练（提升泛化）\n",
    "#         },\n",
    "#         \"SIMPLE_ENS_WEIGHTED\": {  # 简化加权集成（计算更快）\n",
    "#             \"weight_algorithm\": \"auto\",                           # 权重计算方式（自动选择）\n",
    "#             \"use_bag_holdout\": True                               # 使用袋装保留集（提升稳定性）\n",
    "#         },\n",
    "\n",
    "#         # ------------------------------ 可解释性模型（可选） ------------------------------\n",
    "#         \"IM_RULEFIT\": {  # 规则拟合模型（生成可解释规则）\n",
    "#             \"n_estimators\": (100, 500),                          # 基树数量（控制规则数量）\n",
    "#             \"max_rules\": (50, 200),                               # 最大规则数（平衡复杂度与可解释性）\n",
    "#             \"random_state\": DEFAULT_SEED\n",
    "#         },\n",
    "#         \"IM_FIGS\": {  # 灵活可解释梯度树（结合提升与可解释性）\n",
    "#             \"max_depth\": (3, 6),                                  # 树深度（限制规则长度）\n",
    "#             \"learning_rate\": (0.01, 0.1, 'log'),                 # 学习率（控制提升步长）\n",
    "#             \"n_estimators\": (200, 800)                           # 基树数量（提升拟合能力）\n",
    "#         },\n",
    "\n",
    "#         # ------------------------------ 基线模型（用于对比） ------------------------------\n",
    "#         \"DUMMY\": {  # 随机基线模型（预测均值）\n",
    "#             \"strategy\": \"mean\"                                    # 回归任务策略（预测目标均值）\n",
    "#         }\n",
    "#     }\n",
    "\n",
    "# # ============================== 全模型集成训练器 ==============================\n",
    "# class UniversalModelEnsemble:\n",
    "#     \"\"\"\n",
    "#     支持12种模型的全自动训练框架（含模型选择与硬件适配）\n",
    "    \n",
    "#     参数:\n",
    "#         target_col (str): 目标变量列名\n",
    "#         gpu_count (int): GPU使用数量（0=禁用）\n",
    "#         included_models (List[str]): 启用的模型列表（默认全部支持）\n",
    "#     \"\"\"\n",
    "#     def __init__(\n",
    "#         self, \n",
    "#         target_col: str, \n",
    "#         gpu_count: int = 0, \n",
    "#         included_models: List[str] = SUPPORTED_MODELS\n",
    "#     ):\n",
    "#         self.target_col = target_col\n",
    "#         self.gpu_count = gpu_count\n",
    "#         self.included_models = included_models\n",
    "        \n",
    "#         # 初始化预测器（支持所有模型类型）\n",
    "#         self.predictor = TabularPredictor(\n",
    "#             label=target_col,\n",
    "#             problem_type=\"regression\",\n",
    "#             eval_metric=\"rmse\",\n",
    "#             path=\"model_zoo/\"\n",
    "#         )\n",
    "    \n",
    "#     def fit(self, train_data: pd.DataFrame, val_data: pd.DataFrame) -> None:\n",
    "#         \"\"\"\n",
    "#         多模型并行训练（自动分配计算资源）\n",
    "        \n",
    "#         参数:\n",
    "#             train_data: 训练数据集（含目标变量）\n",
    "#             val_data: 验证数据集（含目标变量）\n",
    "#         \"\"\"\n",
    "#         # 转换为AutoGluon数据集格式\n",
    "#         train_dataset = TabularDataset(train_data)\n",
    "#         val_dataset = TabularDataset(val_data)\n",
    "        \n",
    "#         # 硬件感知训练配置（新增use_bag_holdout=True）\n",
    "#         fit_config = {\n",
    "#             \"num_gpus\": self.gpu_count,\n",
    "#             \"num_cpus\": NUM_CORES,\n",
    "#             \"presets\": \"best_quality\",  # 启用高级优化\n",
    "#             \"hyperparameters\": get_hyperparameter_space(self.gpu_count),\n",
    "#             \"included_model_types\": self.included_models,\n",
    "#             \"use_bag_holdout\": True  # 关键修改：允许袋装模式使用验证数据\n",
    "#         }\n",
    "        \n",
    "#         self.predictor.fit(\n",
    "#             train_data=train_dataset,\n",
    "#             tuning_data=val_dataset,\n",
    "#             **fit_config\n",
    "#         )\n",
    "    \n",
    "#     def evaluate(self, test_data: pd.DataFrame, y_true: np.ndarray) -> Dict[str, float]:\n",
    "#         \"\"\"多尺度评估（含逆变换和统计指标）\"\"\"\n",
    "#         y_pred_transformed = self.predictor.predict(test_data)  # 模型输出是变换后的值\n",
    "#         y_pred = np.expm1(y_pred_transformed)  # 逆变换回原始尺度\n",
    "        \n",
    "#         from sklearn.metrics import mean_squared_error, r2_score  # 显式导入\n",
    "#         # 原始尺度评估\n",
    "#         metrics = {\n",
    "#             \"RMSE\": np.sqrt(mean_squared_error(y_true, y_pred)),\n",
    "#             \"R2\": r2_score(y_true, y_pred),\n",
    "#             \"MAE\": np.mean(np.abs(y_true - y_pred)),\n",
    "#             # 变换后尺度评估（可选）\n",
    "#             \"RMSE_transformed\": np.sqrt(mean_squared_error(np.log1p(y_true), y_pred_transformed))\n",
    "#         }\n",
    "#         return metrics\n",
    "    \n",
    "#     def save(self, path: str = \"model_zoo/\"):\n",
    "#         self.predictor.save(path)\n",
    "\n",
    "#     @classmethod\n",
    "#     def load(cls, path: str, target_col: str):\n",
    "#         predictor = TabularPredictor.load(path)\n",
    "#         return cls(target_col=target_col, predictor=predictor)\n",
    "\n",
    "# # ============================== 学术实验主类 ==============================\n",
    "# class ComprehensiveRegressionStudy:\n",
    "#     \"\"\"\n",
    "#     支持全模型类型的可复现实验框架（符合ACM TOMM代码规范）\n",
    "    \n",
    "#     参数:\n",
    "#         config (Dict): 实验配置，包含数据路径、模型参数等\n",
    "#     \"\"\"\n",
    "#     def __init__(self, config: Dict):\n",
    "#         self.config = config\n",
    "#         self.feature_engineer = AdaptiveFeatureEngineer(\n",
    "#             target_col=config[\"target_col\"],\n",
    "#             cat_encoding=config.get(\"cat_encoding\", \"onehot\")\n",
    "#         )\n",
    "#         self.model_ensemble = UniversalModelEnsemble(\n",
    "#             target_col=config[\"target_col\"],\n",
    "#             gpu_count=config[\"gpu_count\"],\n",
    "#             included_models=config.get(\"included_models\", SUPPORTED_MODELS)\n",
    "#         )\n",
    "    \n",
    "#     def _load_and_preprocess(self, train_set, val_set, test_set) -> Tuple[pd.DataFrame, ...]:\n",
    "#         \"\"\"数据加载与预处理（支持缺失值处理）\"\"\"\n",
    "#         # 处理目标变量非有限值\n",
    "#         def handle_inf(data):\n",
    "#             valid_mask = np.isfinite(data[self.config[\"target_col\"]])\n",
    "#             return data[valid_mask].reset_index(drop=True)\n",
    "\n",
    "#         train_set = handle_inf(train_set)\n",
    "#         val_set = handle_inf(val_set)\n",
    "#         test_set = handle_inf(test_set)\n",
    "        \n",
    "#         # 特征工程\n",
    "#         X_train, y_train = self.feature_engineer.transform(train_set)\n",
    "#         X_val, y_val = self.feature_engineer.transform(val_set)\n",
    "#         X_test, y_test = self.feature_engineer.transform(test_set)\n",
    "        \n",
    "#         # 合并训练验证集（带目标变量）\n",
    "#         train_with_target = pd.concat([X_train.reset_index(drop=True), pd.DataFrame(y_train, columns=[self.config[\"target_col\"]])], axis=1)\n",
    "#         val_with_target = pd.concat([X_val.reset_index(drop=True), pd.DataFrame(y_val, columns=[self.config[\"target_col\"]])], axis=1)\n",
    "        \n",
    "#         return train_with_target, val_with_target, X_test, y_test\n",
    "\n",
    "#     def run(self, train_set, val_set, test_set) -> Dict[str, Any]:\n",
    "#         \"\"\"完整实验流程（返回结构化结果）\"\"\"\n",
    "#         # 确定性配置\n",
    "#         np.random.seed(self.config[\"seed\"])\n",
    "#         torch.manual_seed(self.config[\"seed\"])\n",
    "        \n",
    "#         # 数据处理\n",
    "#         train, val, X_test, y_test = self._load_and_preprocess(train_set, val_set, test_set)\n",
    "        \n",
    "#         # 模型训练\n",
    "#         self.model_ensemble.fit(train, val)\n",
    "        \n",
    "#         # 结果评估\n",
    "#         metrics = self.model_ensemble.evaluate(X_test, y_test)\n",
    "#         leaderboard = self.model_ensemble.predictor.leaderboard(sort_by=\"rmse\")\n",
    "#         feature_importance = self.model_ensemble.predictor.feature_importance()\n",
    "        \n",
    "#         return {\n",
    "#             \"config\": self.config,\n",
    "#             \"metrics\": metrics,\n",
    "#             \"leaderboard\": leaderboard,\n",
    "#             \"feature_importance\": feature_importance,\n",
    "#             \"best_model\": self.model_ensemble.predictor.get_model_best()\n",
    "#         }\n",
    "\n",
    "# # ============================== 主实验运行 ==============================\n",
    "# if __name__ == \"__main__\":\n",
    "#     # 完整实验配置（包含所有支持的模型）\n",
    "#     EXPERIMENT_CONFIG = {\n",
    "#         \"data_path\": {\n",
    "#             \"train\": \"data/train.csv\",\n",
    "#             \"val\": \"data/val.csv\",\n",
    "#             \"test\": \"data/test.csv\"\n",
    "#         },\n",
    "#         \"target_col\": \"Pucf12f\",\n",
    "#         \"gpu_count\": 1,  # 启用单GPU\n",
    "#         \"seed\": 42,\n",
    "#         \"cat_encoding\": \"onehot\",  # 可选：label/freq\n",
    "#         \"included_models\": SUPPORTED_MODELS  # 使用全部12种模型\n",
    "#     }\n",
    "    \n",
    "#     processed_data=processed_data.copy()\n",
    "#     # 假设 processed_data 是原始数据\n",
    "\n",
    "    \n",
    "#     study = ComprehensiveRegressionStudy(EXPERIMENT_CONFIG)\n",
    "#     results = study.run(train_set, val_set, test_set)\n",
    "    \n",
    "#     # 学术级结果输出\n",
    "#     print(\"\\n\" + \"=\"*80)\n",
    "#     print(f\"[MODEL PERFORMANCE LEADERBOARD] (按RMSE排序)\")\n",
    "#     print(results[\"leaderboard\"].head().to_string(index=False))\n",
    "    \n",
    "#     print(\"\\n\" + \"=\"*80)\n",
    "#     print(f\"[KEY EVALUATION METRICS]\")\n",
    "#     for metric, value in results[\"metrics\"].items():\n",
    "#         print(f\"  {metric}: {value:.4f}\")\n",
    "    \n",
    "#     print(\"\\n\" + \"=\"*80)\n",
    "#     print(f\"[TOP 10 FEATURES]\")\n",
    "#     for i, (feature, imp) in enumerate(results[\"feature_importance\"].head(10).items(), 1):\n",
    "#         print(f\"  {i:2d}. {feature:<30} {imp:.4f}\")\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0c202f5c",
   "metadata": {},
   "source": [
    "## 并行运行方案"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "567b5c5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from matplotlib import pyplot as plt\n",
    "import seaborn as sns\n",
    "import time\n",
    "import os\n",
    "import joblib\n",
    "import warnings\n",
    "from datetime import datetime\n",
    "from IPython.display import display, HTML\n",
    "from typing import Optional, Dict, List, Tuple, Union\n",
    "import json\n",
    "from matplotlib.font_manager import FontProperties\n",
    "import scipy.stats as stats\n",
    "import traceback\n",
    "from joblib import Parallel, delayed  # 新增并行计算支持\n",
    "\n",
    "# Set numpy environment variable first\n",
    "os.environ['NUMPY_EXPERIMENTAL_ARRAY_FUNCTION'] = '0'\n",
    "\n",
    "# PyTorch imports for GPU acceleration\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "from torch.utils.data import DataLoader, TensorDataset\n",
    "from sklearn.base import BaseEstimator, RegressorMixin\n",
    "\n",
    "\n",
    "\n",
    "# Check GPU availability\n",
    "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "print(f\"Using device: {device}\")\n",
    "if torch.cuda.is_available():\n",
    "    print(f\"GPU: {torch.cuda.get_device_name(0)}\")\n",
    "    print(f\"GPU Memory: {torch.cuda.get_device_properties(0).total_memory / 1e9:.2f} GB\")\n",
    "\n",
    "# Font settings\n",
    "try:\n",
    "    font_set = FontProperties(fname=r\"c:\\windows\\fonts\\simsun.ttc\", size=12)\n",
    "    plt.rcParams[\"font.sans-serif\"] = [\"Simsun\"]\n",
    "except:\n",
    "    font_set = None\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "\n",
    "\n",
    "import psutil\n",
    "import os\n",
    "\n",
    "def auto_set_jobs(memory_safety_factor=0.7):\n",
    "    \"\"\"自动设置最佳并行作业数\"\"\"\n",
    "    total_cores = os.cpu_count()\n",
    "    total_mem_gb = psutil.virtual_memory().total / (1024**3)\n",
    "    \n",
    "    # 估算每个任务需要的内存 (GB)\n",
    "    # 根据数据集大小动态调整\n",
    "    dataset_size_gb = data.memory_usage(deep=True).sum() / (1024**3)\n",
    "    per_job_mem = max(0.5, dataset_size_gb * 2)  # 保守估计\n",
    "    \n",
    "    # 基于内存限制计算最大并行度\n",
    "    mem_limited_jobs = int((total_mem_gb * memory_safety_factor) / per_job_mem)\n",
    "    \n",
    "    # 基于CPU核心计算\n",
    "    cpu_limited_jobs = max(1, total_cores - 8)  # 保留8个核心\n",
    "    \n",
    "    # 取最小值\n",
    "    return min(mem_limited_jobs, cpu_limited_jobs)\n",
    "\n",
    "# 自动设置最佳并行度\n",
    "optimal_jobs = auto_set_jobs()\n",
    "\n",
    "# Advanced models and tools\n",
    "from sklearn.model_selection import (train_test_split, GridSearchCV, RandomizedSearchCV, \n",
    "                                   cross_val_score, KFold, StratifiedKFold)\n",
    "from sklearn.preprocessing import (StandardScaler, MinMaxScaler, RobustScaler, \n",
    "                                  PolynomialFeatures, PowerTransformer, QuantileTransformer)\n",
    "from sklearn.pipeline import Pipeline, make_pipeline\n",
    "from sklearn.compose import ColumnTransformer\n",
    "from sklearn.metrics import (r2_score, mean_squared_error, mean_absolute_error, \n",
    "                           mean_absolute_percentage_error, explained_variance_score)\n",
    "from sklearn.inspection import permutation_importance, PartialDependenceDisplay\n",
    "from sklearn.feature_selection import RFECV, SelectFromModel, SelectKBest, f_regression\n",
    "\n",
    "# Regression models\n",
    "from sklearn.linear_model import (LinearRegression, Ridge, Lasso, ElasticNet, \n",
    "                                 HuberRegressor, RANSACRegressor, BayesianRidge, SGDRegressor)\n",
    "from sklearn.svm import SVR\n",
    "from sklearn.kernel_ridge import KernelRidge\n",
    "from sklearn.neighbors import KNeighborsRegressor\n",
    "from sklearn.tree import DecisionTreeRegressor\n",
    "from sklearn.ensemble import (RandomForestRegressor, GradientBoostingRegressor, \n",
    "                             AdaBoostRegressor, ExtraTreesRegressor, BaggingRegressor, \n",
    "                             HistGradientBoostingRegressor, StackingRegressor)\n",
    "from sklearn.gaussian_process import GaussianProcessRegressor\n",
    "from sklearn.gaussian_process.kernels import RBF, DotProduct, Matern\n",
    "from sklearn.cross_decomposition import PLSRegression\n",
    "from sklearn.neural_network import MLPRegressor\n",
    "from sklearn.base import clone\n",
    "\n",
    "# Advanced integration and optimization\n",
    "from sklearn.model_selection import ParameterGrid\n",
    "from xgboost import XGBRegressor\n",
    "from lightgbm import LGBMRegressor\n",
    "\n",
    "# Try to import CatBoost\n",
    "try:\n",
    "    from catboost import CatBoostRegressor\n",
    "    CATBOOST_AVAILABLE = True\n",
    "except ImportError as e:\n",
    "    print(f\"CatBoost import failed: {e}. Continuing without CatBoost.\")\n",
    "    CATBOOST_AVAILABLE = False\n",
    "except Exception as e:\n",
    "    print(f\"Error importing CatBoost: {e}. Continuing without CatBoost.\")\n",
    "    CATBOOST_AVAILABLE = False\n",
    "\n",
    "from sklearn.decomposition import PCA, KernelPCA\n",
    "\n",
    "# Settings\n",
    "warnings.filterwarnings('ignore')\n",
    "plt.rcParams['font.sans-serif'] = ['SimHei']\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "sns.set_style('whitegrid')\n",
    "pd.set_option('display.max_columns', None)\n",
    "pd.set_option('display.width', None)\n",
    "\n",
    "\n",
    "class PyTorchRegressor(BaseEstimator, RegressorMixin):\n",
    "    \"\"\"PyTorch Neural Network Regressor with GPU support and improved serialization\"\"\"\n",
    "    \n",
    "    def __init__(self, hidden_sizes=(100, 50), activation='relu', learning_rate=0.001,\n",
    "                 batch_size=32, epochs=100, dropout=0.2, early_stopping=True,\n",
    "                 patience=10, device=None, results_dir=None):\n",
    "        self.hidden_sizes = hidden_sizes\n",
    "        self.activation = activation\n",
    "        self.learning_rate = learning_rate\n",
    "        self.batch_size = batch_size\n",
    "        self.epochs = epochs\n",
    "        self.dropout = dropout\n",
    "        self.early_stopping = early_stopping\n",
    "        self.patience = patience\n",
    "        self.device_str = device if device else ('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "        self.model = None\n",
    "        self.scaler_X = StandardScaler()\n",
    "        self.scaler_y = StandardScaler()\n",
    "        self.best_loss = float('inf')\n",
    "        self.input_dim = None\n",
    "        self.model_state_dict = None\n",
    "        self.training_history = []  # 保存训练历史用于可视化\n",
    "        self.results_dir = results_dir  # 新增：结果保存目录\n",
    "    \n",
    "    @property\n",
    "    def device(self):\n",
    "        return torch.device(self.device_str)\n",
    "    \n",
    "    def _build_model(self, input_dim):\n",
    "        \"\"\"Build PyTorch model\"\"\"\n",
    "        layers = []\n",
    "        prev_size = input_dim\n",
    "        \n",
    "        for hidden_size in self.hidden_sizes:\n",
    "            layers.append(nn.Linear(prev_size, hidden_size))\n",
    "            layers.append(nn.BatchNorm1d(hidden_size))\n",
    "            \n",
    "            if self.activation == 'relu':\n",
    "                layers.append(nn.ReLU())\n",
    "            elif self.activation == 'tanh':\n",
    "                layers.append(nn.Tanh())\n",
    "            elif self.activation == 'leaky_relu':\n",
    "                layers.append(nn.LeakyReLU())\n",
    "            \n",
    "            layers.append(nn.Dropout(self.dropout))\n",
    "            prev_size = hidden_size\n",
    "        \n",
    "        layers.append(nn.Linear(prev_size, 1))\n",
    "        \n",
    "        return nn.Sequential(*layers)\n",
    "    \n",
    "    def fit(self, X, y):\n",
    "        \"\"\"Fit the model with training history logging and file saving\"\"\"\n",
    "        if hasattr(X, 'values'):\n",
    "            X = X.values\n",
    "        if hasattr(y, 'values'):\n",
    "            y = y.values\n",
    "        \n",
    "        self.input_dim = X.shape[1]\n",
    "        \n",
    "        # Scale data\n",
    "        X_scaled = self.scaler_X.fit_transform(X)\n",
    "        y_scaled = self.scaler_y.fit_transform(y.reshape(-1, 1)).ravel()\n",
    "        \n",
    "        # Convert to PyTorch tensors\n",
    "        X_tensor = torch.FloatTensor(X_scaled).to(self.device)\n",
    "        y_tensor = torch.FloatTensor(y_scaled).to(self.device)\n",
    "        \n",
    "        # Create data loader\n",
    "        dataset = TensorDataset(X_tensor, y_tensor)\n",
    "        loader = DataLoader(dataset, batch_size=self.batch_size, shuffle=True)\n",
    "        \n",
    "        # Build model\n",
    "        self.model = self._build_model(X.shape[1]).to(self.device)\n",
    "        \n",
    "        # Loss and optimizer\n",
    "        criterion = nn.MSELoss()\n",
    "        optimizer = optim.Adam(self.model.parameters(), lr=self.learning_rate)\n",
    "        scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=5, factor=0.5)\n",
    "        \n",
    "        # Training\n",
    "        self.model.train()\n",
    "        patience_counter = 0\n",
    "        best_model_state = None\n",
    "        \n",
    "        for epoch in range(self.epochs):\n",
    "            epoch_loss = 0\n",
    "            for batch_X, batch_y in loader:\n",
    "                optimizer.zero_grad()\n",
    "                outputs = self.model(batch_X).squeeze()\n",
    "                loss = criterion(outputs, batch_y)\n",
    "                loss.backward()\n",
    "                optimizer.step()\n",
    "                epoch_loss += loss.item()\n",
    "            \n",
    "            avg_loss = epoch_loss / len(loader)\n",
    "            scheduler.step(avg_loss)\n",
    "            \n",
    "            # 记录训练历史（新增学习率）\n",
    "            current_lr = optimizer.param_groups[0]['lr']\n",
    "            self.training_history.append({\n",
    "                'epoch': epoch,\n",
    "                'loss': avg_loss,\n",
    "                'learning_rate': current_lr\n",
    "            })\n",
    "            \n",
    "            if self.early_stopping:\n",
    "                if avg_loss < self.best_loss:\n",
    "                    self.best_loss = avg_loss\n",
    "                    patience_counter = 0\n",
    "                    best_model_state = self.model.state_dict().copy()\n",
    "                else:\n",
    "                    patience_counter += 1\n",
    "                    if patience_counter >= self.patience:\n",
    "                        if best_model_state is not None:\n",
    "                            self.model.load_state_dict(best_model_state)\n",
    "                        break\n",
    "        \n",
    "        # Save model state for serialization\n",
    "        self.model_state_dict = self.model.state_dict()\n",
    "        \n",
    "        # 保存训练历史到文件（新增）\n",
    "        if self.results_dir:\n",
    "            os.makedirs(f\"{self.results_dir}/training_metrics\", exist_ok=True)\n",
    "            with open(f\"{self.results_dir}/training_metrics/training_history.json\", 'w', encoding='utf-8') as f:\n",
    "                json.dump(self.training_history, f, ensure_ascii=False, indent=2)\n",
    "        \n",
    "        return self\n",
    "    \n",
    "    def predict(self, X):\n",
    "        \"\"\"Make predictions\"\"\"\n",
    "        if hasattr(X, 'values'):\n",
    "            X = X.values\n",
    "        \n",
    "        # Rebuild model if necessary\n",
    "        if self.model is None and self.model_state_dict is not None:\n",
    "            self.model = self._build_model(self.input_dim).to(self.device)\n",
    "            self.model.load_state_dict(self.model_state_dict)\n",
    "        \n",
    "        X_scaled = self.scaler_X.transform(X)\n",
    "        X_tensor = torch.FloatTensor(X_scaled).to(self.device)\n",
    "        \n",
    "        self.model.eval()\n",
    "        with torch.no_grad():\n",
    "            predictions_scaled = self.model(X_tensor).cpu().numpy()\n",
    "        \n",
    "        predictions = self.scaler_y.inverse_transform(predictions_scaled)\n",
    "        return predictions.ravel()\n",
    "    \n",
    "    def __getstate__(self):\n",
    "        \"\"\"Custom serialization with training history\"\"\"\n",
    "        state = self.__dict__.copy()\n",
    "        # Remove non-serializable objects\n",
    "        if 'model' in state:\n",
    "            del state['model']\n",
    "        return state\n",
    "    \n",
    "    def __setstate__(self, state):\n",
    "        \"\"\"Custom deserialization\"\"\"\n",
    "        self.__dict__.update(state)\n",
    "        self.model = None\n",
    "\n",
    "\n",
    "class SimplifiedHyperparameterTuner:\n",
    "    \"\"\"Simplified hyperparameter tuner with detailed logging and parallel execution\"\"\"\n",
    "    \n",
    "    def __init__(self, X_train, y_train, random_state=42, n_jobs=1, use_gpu=True, results_dir=None):\n",
    "        self.X_train = X_train\n",
    "        self.y_train = y_train\n",
    "        self.random_state = random_state\n",
    "        self.n_jobs = n_jobs  # 现在支持并行\n",
    "        self.use_gpu = use_gpu and torch.cuda.is_available()\n",
    "        self.models = {}\n",
    "        self.results = {}\n",
    "        self.tuning_log = []  # 保存调优日志\n",
    "        self.results_dir = results_dir\n",
    "        if results_dir:\n",
    "            os.makedirs(f\"{results_dir}/tuning_results\", exist_ok=True)\n",
    "    \n",
    "    def get_model_configs(self) -> Dict:\n",
    "        \"\"\"Get model configurations with academic descriptions\"\"\"\n",
    "        configs = {\n",
    "            # Linear models\n",
    "            \"Ridge\": {\n",
    "                \"model_class\": Ridge,\n",
    "                \"param_grid\": {\n",
    "                    'alpha': [0.001, 0.01, 0.1, 1, 10, 100, 1000],\n",
    "                    'solver': ['auto', 'svd', 'cholesky', 'lsqr']\n",
    "                },\n",
    "                \"desc\": \"岭回归（L2正则化）\",\n",
    "                \"academic_desc\": \"Ridge regression (L2 regularization) is a linear model that adds a penalty equivalent to the square of the magnitude of the coefficients.\"\n",
    "            },\n",
    "            \"Lasso\": {\n",
    "                \"model_class\": Lasso,\n",
    "                \"param_grid\": {\n",
    "                    'alpha': [0.0001, 0.001, 0.01, 0.1, 1],\n",
    "                    'max_iter': [5000]\n",
    "                },\n",
    "                \"desc\": \"套索回归（L1正则化）\",\n",
    "                \"academic_desc\": \"Lasso (Least Absolute Shrinkage and Selection Operator) regression (L1 regularization) is a linear model that adds a penalty equivalent to the absolute value of the magnitude of the coefficients.\"\n",
    "            },\n",
    "            \"ElasticNet\": {\n",
    "                \"model_class\": ElasticNet,\n",
    "                \"param_grid\": {\n",
    "                    'alpha': [0.0001, 0.001, 0.01, 0.1, 1],\n",
    "                    'l1_ratio': [0.1, 0.3, 0.5, 0.7, 0.9],\n",
    "                    'max_iter': [5000]\n",
    "                },\n",
    "                \"desc\": \"弹性网络（L1+L2正则化）\",\n",
    "                \"academic_desc\": \"Elastic Net combines the penalties of Ridge (L2) and Lasso (L1) regression, offering a compromise that can select features while maintaining some of the stability of Ridge.\"\n",
    "            },\n",
    "            \n",
    "            # Tree models\n",
    "            \"RandomForest\": {\n",
    "                \"model_class\": RandomForestRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'n_estimators': [100, 200, 500],\n",
    "                    'max_depth': [10, 20, 30, None],\n",
    "                    'min_samples_split': [2, 5, 10],\n",
    "                    'min_samples_leaf': [1, 2, 4],\n",
    "                    'random_state': [self.random_state]\n",
    "                },\n",
    "                \"desc\": \"随机森林\",\n",
    "                \"academic_desc\": \"Random Forest is an ensemble learning method that operates by constructing multiple decision trees at training time and outputting the mean prediction of the individual trees.\"\n",
    "            },\n",
    "            \"GradientBoosting\": {\n",
    "                \"model_class\": GradientBoostingRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'n_estimators': [100, 200, 300],\n",
    "                    'learning_rate': [0.01, 0.05, 0.1],\n",
    "                    'max_depth': [3, 5, 7],\n",
    "                    'subsample': [0.8, 0.9, 1.0],\n",
    "                    'random_state': [self.random_state]\n",
    "                },\n",
    "                \"desc\": \"梯度提升\",\n",
    "                \"academic_desc\": \"Gradient Boosting is an ensemble machine learning technique for regression that builds a model by sequentially adding weak learners, each correcting the previous one.\"\n",
    "            },\n",
    "            \n",
    "            # XGBoost with GPU\n",
    "            \"XGBoost\": {\n",
    "                \"model_class\": XGBRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'n_estimators': [100, 200, 300],\n",
    "                    'learning_rate': [0.01, 0.05, 0.1],\n",
    "                    'max_depth': [3, 5, 7],\n",
    "                    'subsample': [0.8, 0.9, 1.0],\n",
    "                    'colsample_bytree': [0.8, 0.9, 1.0],\n",
    "                    'tree_method': ['gpu_hist' if self.use_gpu else 'auto'],\n",
    "                    'predictor': ['gpu_predictor' if self.use_gpu else 'auto'],\n",
    "                    'random_state': [self.random_state]\n",
    "                },\n",
    "                \"desc\": \"XGBoost（GPU加速）\" if self.use_gpu else \"XGBoost\",\n",
    "                \"academic_desc\": \"XGBoost (eXtreme Gradient Boosting) is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable, with optional GPU acceleration.\"\n",
    "            },\n",
    "            \n",
    "            # LightGBM with GPU\n",
    "            \"LightGBM\": {\n",
    "                \"model_class\": LGBMRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'n_estimators': [100, 200, 300],\n",
    "                    'learning_rate': [0.01, 0.05, 0.1],\n",
    "                    'num_leaves': [31, 50, 100],\n",
    "                    'max_depth': [-1, 10, 20],\n",
    "                    'subsample': [0.8, 0.9, 1.0],\n",
    "                    'device': ['gpu' if self.use_gpu else 'cpu'],\n",
    "                    'random_state': [self.random_state],\n",
    "                    'verbose': [-1]\n",
    "                },\n",
    "                \"desc\": \"LightGBM（GPU加速）\" if self.use_gpu else \"LightGBM\",\n",
    "                \"academic_desc\": \"LightGBM is a gradient boosting framework that uses tree-based learning algorithms, designed for speed and performance with lower memory usage, supporting GPU acceleration.\"\n",
    "            },\n",
    "            \n",
    "            # PyTorch Neural Network\n",
    "            \"PyTorchNN\": {\n",
    "                \"model_class\": PyTorchRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'hidden_sizes': [(100,), (200,), (100, 50)],\n",
    "                    'activation': ['relu', 'tanh'],\n",
    "                    'learning_rate': [0.001, 0.01],\n",
    "                    'batch_size': [32, 64],\n",
    "                    'epochs': [100, 200],\n",
    "                    'dropout': [0.2, 0.3],\n",
    "                    'device': [self.device_str],\n",
    "                    'results_dir': [self.results_dir]  # 传递结果目录\n",
    "                },\n",
    "                \"desc\": \"PyTorch神经网络（GPU）\" if self.use_gpu else \"PyTorch神经网络\",\n",
    "                \"academic_desc\": \"A feedforward neural network implemented with PyTorch, allowing for flexible architecture design and GPU acceleration for faster training.\"\n",
    "            },\n",
    "            \n",
    "            # Traditional MLP\n",
    "            \"MLP\": {\n",
    "                \"model_class\": MLPRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'hidden_layer_sizes': [(100,), (100, 50)],\n",
    "                    'activation': ['relu', 'tanh'],\n",
    "                    'alpha': [0.0001, 0.001, 0.01],\n",
    "                    'learning_rate': ['adaptive'],\n",
    "                    'max_iter': [1000],\n",
    "                    'early_stopping': [True],\n",
    "                    'random_state': [self.random_state]\n",
    "                },\n",
    "                \"desc\": \"多层感知机\",\n",
    "                \"academic_desc\": \"A multi-layer perceptron (MLP) is a class of feedforward artificial neural network that consists of multiple layers of nodes in a directed graph, with each layer fully connected to the next one.\"\n",
    "            },\n",
    "            \n",
    "            # SVR\n",
    "            \"SVR\": {\n",
    "                \"model_class\": SVR,\n",
    "                \"param_grid\": {\n",
    "                    'kernel': ['rbf', 'linear', 'poly', 'sigmoid'],\n",
    "                    'C': [0.1, 1, 10, 100],\n",
    "                    'gamma': ['scale', 'auto', 0.1, 0.01],\n",
    "                    'epsilon': [0.01, 0.1, 0.5, 1.0],\n",
    "                    'degree': [2, 3]\n",
    "                },\n",
    "                \"desc\": \"支持向量回归（SVR）\",\n",
    "                \"academic_desc\": \"Support Vector Regression (SVR) uses a kernel function to map data into a high-dimensional feature space, finding a linear regression hyperplane in this space. It is robust to outliers and suitable for small-sample, high-dimensional data.\"\n",
    "            },\n",
    "            \n",
    "            # KNN\n",
    "            \"KNN\": {\n",
    "                \"model_class\": KNeighborsRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'n_neighbors': [3, 5, 7, 10, 15],\n",
    "                    'weights': ['uniform', 'distance'],\n",
    "                    'metric': ['euclidean', 'manhattan', 'minkowski'],\n",
    "                    'p': [1, 2]\n",
    "                },\n",
    "                \"desc\": \"K近邻回归（KNN）\",\n",
    "                \"academic_desc\": \"K-Nearest Neighbors (KNN) is a non-parametric model that predicts based on the average (or weighted average) of the k nearest training samples. It is simple to implement and effective for datasets with local patterns.\"\n",
    "            }\n",
    "        }\n",
    "        \n",
    "        # Add CatBoost if available\n",
    "        if CATBOOST_AVAILABLE:\n",
    "            configs[\"CatBoost\"] = {\n",
    "                \"model_class\": CatBoostRegressor,\n",
    "                \"param_grid\": {\n",
    "                    'iterations': [500, 1000],\n",
    "                    'learning_rate': [0.01, 0.05, 0.1],\n",
    "                    'depth': [6, 8, 10],\n",
    "                    'task_type': ['GPU' if self.use_gpu else 'CPU'],\n",
    "                    'random_state': [self.random_state],\n",
    "                    'verbose': [0]\n",
    "                },\n",
    "                \"desc\": \"CatBoost（GPU加速）\" if self.use_gpu else \"CatBoost\",\n",
    "                \"academic_desc\": \"CatBoost is a gradient boosting algorithm that uses categorical features effectively and supports GPU acceleration for faster training.\"\n",
    "            }\n",
    "            \n",
    "        return configs\n",
    "    \n",
    "    @property\n",
    "    def device_str(self):\n",
    "        return 'cuda' if self.use_gpu else 'cpu'\n",
    "    \n",
    "    def tune_models(self, cv_folds=5) -> Dict:\n",
    "        \"\"\"Perform hyperparameter tuning with detailed logging and parallel execution\"\"\"\n",
    "        print(\"=\"*80)\n",
    "        print(\"开始简化超参数调优 (并行增强版)\")\n",
    "        print(f\"GPU加速: {'启用' if self.use_gpu else '禁用'}\")\n",
    "        print(f\"并行作业数: {self.n_jobs}\")\n",
    "        print(\"=\"*80)\n",
    "        \n",
    "        configs = self.get_model_configs()\n",
    "        results = {}\n",
    "        \n",
    "        # Create preprocessing pipeline\n",
    "        scaler = StandardScaler()\n",
    "        X_scaled = scaler.fit_transform(self.X_train)\n",
    "        \n",
    "        for name, config in configs.items():\n",
    "            print(f\"\\n调优 {name} ({config['desc']})...\")\n",
    "            start_time = time.time()\n",
    "            model_desc = config['desc']\n",
    "            model_academic_desc = config.get('academic_desc', '')\n",
    "\n",
    "            try:\n",
    "                # Create cross-validation splitter\n",
    "                kf = KFold(n_splits=cv_folds, shuffle=True, random_state=self.random_state)\n",
    "                \n",
    "                # 检查模型是否支持GPU\n",
    "                is_gpu_model = any(key in config['param_grid'] for key in ['device', 'tree_method', 'task_type'])\n",
    "                \n",
    "                # 手动网格搜索\n",
    "                best_score = -float('inf')\n",
    "                best_params = None\n",
    "                best_model = None\n",
    "                param_results = []  # 保存每个参数组合的结果\n",
    "                \n",
    "                param_grid = list(ParameterGrid(config['param_grid']))\n",
    "                total_fits = len(param_grid)\n",
    "                \n",
    "                # ===== 新增并行评估函数 =====\n",
    "                def evaluate_params(params):\n",
    "                    \"\"\"评估单个参数组合的性能\"\"\"\n",
    "                    # 序列化参数（用于日志）\n",
    "                    serialized_params = self._serialize_params(params)\n",
    "                    \n",
    "                    # Cross-validation scores\n",
    "                    cv_scores = []\n",
    "                    fold_results = []  # 保存每个折的结果，包含训练时间\n",
    "                    \n",
    "                    for fold, (train_idx, val_idx) in enumerate(kf.split(X_scaled)):\n",
    "                        X_train_cv = X_scaled[train_idx]\n",
    "                        y_train_cv = self.y_train.iloc[train_idx] if hasattr(self.y_train, 'iloc') else self.y_train[train_idx]\n",
    "                        X_val_cv = X_scaled[val_idx]\n",
    "                        y_val_cv = self.y_train.iloc[val_idx] if hasattr(self.y_train, 'iloc') else self.y_train[val_idx]\n",
    "                        \n",
    "                        # Create and train model\n",
    "                        model = config['model_class'](**params)\n",
    "                        fold_start = time.time()\n",
    "                        model.fit(X_train_cv, y_train_cv)\n",
    "                        fold_time = time.time() - fold_start\n",
    "                        \n",
    "                        # Evaluate\n",
    "                        y_pred = model.predict(X_val_cv)\n",
    "                        score = r2_score(y_val_cv, y_pred)\n",
    "                        cv_scores.append(score)\n",
    "                        \n",
    "                        # 保存该折的详细结果\n",
    "                        fold_results.append({\n",
    "                            'fold': fold,\n",
    "                            'params': serialized_params,\n",
    "                            'r2_score': score,\n",
    "                            'mse': mean_squared_error(y_val_cv, y_pred),\n",
    "                            'mae': mean_absolute_error(y_val_cv, y_pred),\n",
    "                            'training_time': fold_time\n",
    "                        })\n",
    "                    \n",
    "                    # Average CV score\n",
    "                    avg_score = np.mean(cv_scores)\n",
    "                    std_score = np.std(cv_scores)\n",
    "                    \n",
    "                    return {\n",
    "                        'params': params,\n",
    "                        'mean_r2': avg_score,\n",
    "                        'std_r2': std_score,\n",
    "                        'fold_results': fold_results\n",
    "                    }\n",
    "                # ===== 结束新增 =====\n",
    "                \n",
    "                # 根据模型类型选择执行策略\n",
    "                if is_gpu_model or total_fits < 5 or self.n_jobs == 1:\n",
    "                    # GPU模型或小规模参数网格使用串行\n",
    "                    print(f\"  使用串行评估 ({total_fits} 参数组合)\")\n",
    "                    for i, params in enumerate(param_grid):\n",
    "                        if i % 5 == 0:\n",
    "                            print(f\"  进度: {i}/{total_fits} 个参数组合已测试\")\n",
    "                        param_result = evaluate_params(params)\n",
    "                        param_results.append(param_result)\n",
    "                else:\n",
    "                    # 非GPU模型使用并行\n",
    "                    print(f\"  使用并行评估 ({total_fits} 参数组合, {self.n_jobs} 进程)\")\n",
    "                    param_results = Parallel(n_jobs=self.n_jobs, verbose=10)(\n",
    "                        delayed(evaluate_params)(params) for params in param_grid\n",
    "                    )\n",
    "                \n",
    "                # 处理结果并选择最佳参数\n",
    "                for p in param_results:\n",
    "                    if p['mean_r2'] > best_score:\n",
    "                        best_score = p['mean_r2']\n",
    "                        best_params = p['params']\n",
    "                \n",
    "                # 使用最佳参数训练最终模型\n",
    "                best_model = config['model_class'](**best_params)\n",
    "                best_model.fit(X_scaled, self.y_train)\n",
    "                \n",
    "                # 创建包含预处理和模型的pipeline\n",
    "                final_pipeline = Pipeline([\n",
    "                    ('scaler', StandardScaler()),\n",
    "                    ('model', best_model)\n",
    "                ])\n",
    "                \n",
    "                # 在完整训练集上拟合\n",
    "                final_pipeline.fit(self.X_train, self.y_train)\n",
    "                \n",
    "                # 存储结果\n",
    "                results[name] = {\n",
    "                    'model': final_pipeline,\n",
    "                    'params': best_params,\n",
    "                    'best_score': best_score,\n",
    "                    'training_time': time.time() - start_time,\n",
    "                    'param_results': param_results\n",
    "                }\n",
    "                \n",
    "                print(f\"  完成! 最佳R²: {best_score:.4f}, 时间: {results[name]['training_time']:.1f}s\")\n",
    "                print(f\"  最佳参数: {best_params}\")\n",
    "                \n",
    "                # 记录调优日志\n",
    "                self.tuning_log.append({\n",
    "                    'model_name': name,\n",
    "                    'description': model_desc,\n",
    "                    'academic_description': model_academic_desc,\n",
    "                    'best_score': best_score,\n",
    "                    'best_params': best_params,\n",
    "                    'training_time': time.time() - start_time,\n",
    "                    'parameter_search_size': total_fits,\n",
    "                    'parallel_jobs': self.n_jobs if not is_gpu_model and total_fits >= 5 else 1,\n",
    "                    'status': 'success'\n",
    "                })\n",
    "                \n",
    "                # 保存参数调优详细结果\n",
    "                if self.results_dir:\n",
    "                    param_results_df = pd.DataFrame([\n",
    "                        {**p['params'], 'mean_r2': p['mean_r2'], 'std_r2': p['std_r2']} \n",
    "                        for p in param_results\n",
    "                    ])\n",
    "                    param_results_df.to_csv(\n",
    "                        f\"{self.results_dir}/tuning_results/{name}_parameter_results.csv\", \n",
    "                        index=False\n",
    "                    )\n",
    "                    \n",
    "                    # 序列化结果\n",
    "                    serialized_param_results = []\n",
    "                    for p in param_results:\n",
    "                        serialized_p = {\n",
    "                            'params': self._serialize_params(p['params']),\n",
    "                            'mean_r2': p['mean_r2'],\n",
    "                            'std_r2': p['std_r2'],\n",
    "                            'fold_results': p['fold_results']\n",
    "                        }\n",
    "                        serialized_param_results.append(serialized_p)\n",
    "                    \n",
    "                    with open(\n",
    "                        f\"{self.results_dir}/tuning_results/{name}_fold_results.json\", \n",
    "                        'w', \n",
    "                        encoding='utf-8'\n",
    "                    ) as f:\n",
    "                        json.dump(serialized_param_results, f, ensure_ascii=False, \n",
    "                                  indent=2, default=str)\n",
    "                    \n",
    "                    # 保存训练时间 - 修复了这里的语法错误\n",
    "                    training_times = [\n",
    "                        {'params': p['params'], 'mean_training_time': np.mean([f['training_time'] for f in p['fold_results']])}\n",
    "                        for p in param_results\n",
    "                    ]\n",
    "                    pd.DataFrame(training_times).to_csv(\n",
    "                        f\"{self.results_dir}/tuning_results/{name}_training_times.csv\",\n",
    "                        index=False\n",
    "                    )\n",
    "            except Exception as e:\n",
    "                print(f\"  错误: {str(e)}\")\n",
    "                traceback.print_exc()\n",
    "                self.tuning_log.append({\n",
    "                    'model_name': name,\n",
    "                    'description': model_desc,\n",
    "                    'error': str(e),\n",
    "                    'traceback': traceback.format_exc(),\n",
    "                    'training_time': time.time() - start_time,\n",
    "                    'parameter_search_size': total_fits,\n",
    "                    'parallel_jobs': self.n_jobs,\n",
    "                    'status': 'error'\n",
    "                })\n",
    "                continue\n",
    "        \n",
    "        self.results = results\n",
    "        return results\n",
    "    \n",
    "    def _serialize_params(self, params):\n",
    "        \"\"\"增强版参数序列化：处理所有不可序列化对象\"\"\"\n",
    "        serialized = {}\n",
    "        for key, value in params.items():\n",
    "            # 处理高斯过程核函数（RBF, DotProduct, Matern等）\n",
    "            if isinstance(value, (RBF, DotProduct, Matern)):\n",
    "                serialized[key] = f\"{type(value).__name__}(params={value.__dict__})\"\n",
    "            # 处理sklearn模型对象（如SVR）\n",
    "            elif hasattr(value, '__class__') and hasattr(value, '__dict__'):\n",
    "                serialized[key] = f\"{type(value).__name__}(params={value.__dict__})\"\n",
    "            # 处理numpy数组\n",
    "            elif isinstance(value, np.ndarray):\n",
    "                serialized[key] = value.tolist()\n",
    "            # 处理其他不可序列化对象（转为字符串）\n",
    "            elif not isinstance(value, (str, int, float, bool, type(None))):\n",
    "                serialized[key] = str(value)\n",
    "            else:\n",
    "                serialized[key] = value\n",
    "        return serialized\n",
    "    \n",
    "    def evaluate_models(self, X_test, y_test) -> pd.DataFrame:\n",
    "        \"\"\"Evaluate tuned models on test set with extended metrics\"\"\"\n",
    "        if not self.results:\n",
    "            raise ValueError(\"请先运行tune_models方法\")\n",
    "        \n",
    "        evaluation = []\n",
    "        \n",
    "        for name, model_info in self.results.items():\n",
    "            model = model_info['model']\n",
    "            y_pred = model.predict(X_test)\n",
    "            \n",
    "            # 计算扩展评估指标\n",
    "            metrics = {\n",
    "                '模型': name,\n",
    "                'R²': r2_score(y_test, y_pred),\n",
    "                '调整后R²': 1 - (1 - r2_score(y_test, y_pred)) * (len(y_test) - 1) / (len(y_test) - X_test.shape[1] - 1),\n",
    "                'RMSE': np.sqrt(mean_squared_error(y_test, y_pred)),\n",
    "                'MAE': mean_absolute_error(y_test, y_pred),\n",
    "                'MAPE': mean_absolute_percentage_error(y_test, y_pred),\n",
    "                '解释方差': explained_variance_score(y_test, y_pred),\n",
    "                '训练时间 (s)': model_info['training_time'],\n",
    "                '交叉验证得分 (R²)': model_info['best_score'],\n",
    "                '参数组合数量': len(model_info['param_results'])\n",
    "            }\n",
    "            \n",
    "            evaluation.append(metrics)\n",
    "        \n",
    "        # Create results DataFrame\n",
    "        results_df = pd.DataFrame(evaluation)\n",
    "        results_df = results_df.sort_values('R²', ascending=False).reset_index(drop=True)\n",
    "        \n",
    "        return results_df\n",
    "    \n",
    "    def save_tuning_log(self):\n",
    "        # 创建日志目录（如果不存在）\n",
    "        os.makedirs(self.results_dir, exist_ok=True)\n",
    "    \n",
    "        # 保存简化版调优日志（表格形式）\n",
    "        with open(f\"{self.results_dir}/tuning_log_summary.md\", 'w', encoding='utf-8') as f:\n",
    "            f.write(\"# 模型调优结果汇总\\n\\n\")\n",
    "            f.write(\"| 模型名称 | 描述 | 最佳参数 | 最佳R² | 训练时间(s) | 并行作业数 |\\n\")\n",
    "            f.write(\"|----------|------|----------|--------|-------------|------------|\\n\")\n",
    "            \n",
    "            for entry in self.tuning_log:\n",
    "                if entry['status'] == 'success':\n",
    "                    model_name = entry['model_name']\n",
    "                    description = entry.get('description', 'N/A')\n",
    "                    best_params = \", \".join([f\"{k}={v}\" for k, v in entry.get('best_params', {}).items()])[:50] + \"...\"\n",
    "                    best_score = entry.get('best_score', 'N/A')\n",
    "                    training_time = entry.get('training_time', 'N/A')\n",
    "                    parallel_jobs = entry.get('parallel_jobs', 1)\n",
    "                    \n",
    "                    # 格式化分数（如果是数值）\n",
    "                    if isinstance(best_score, (int, float)):\n",
    "                        best_score = f\"{best_score:.4f}\"\n",
    "                    if isinstance(training_time, (int, float)):\n",
    "                        training_time = f\"{training_time:.2f}\"\n",
    "                    \n",
    "                    f.write(f\"| {model_name} | {description[:30]}... | {best_params} | {best_score} | {training_time} | {parallel_jobs} |\\n\")\n",
    "        \n",
    "        # 保存详细参数搜索记录（JSON格式）\n",
    "        with open(f\"{self.results_dir}/tuning_log_details.json\", 'w', encoding='utf-8') as f:\n",
    "            json.dump(self.tuning_log, f, ensure_ascii=False, indent=2, default=str)\n",
    "\n",
    "\n",
    "class GPUAcceleratedDataLoader:\n",
    "    \"\"\"GPU-accelerated advanced data loader with academic reporting and parallel execution\"\"\"\n",
    "    \n",
    "    def __init__(self, data: pd.DataFrame, target: str, test_size: float = 0.2, \n",
    "                 random_state: int = 42, feature_engineering: bool = True, use_gpu: bool = True,\n",
    "                 results_dir: str = None, n_jobs: int = -1):\n",
    "        self.data = data.copy()\n",
    "        self.target = target\n",
    "        self.test_size = test_size\n",
    "        self.random_state = random_state\n",
    "        self.feature_engineering = feature_engineering\n",
    "        self.use_gpu = use_gpu and torch.cuda.is_available()\n",
    "        self.feature_names = []\n",
    "        self.numeric_features = []\n",
    "        self.categorical_features = []\n",
    "        self.results_dir = results_dir\n",
    "        self.added_features = []  # 保存添加的特征\n",
    "        self.feature_engineering_formulas = []  # 新增：保存特征工程公式\n",
    "        self.n_jobs = n_jobs  # 新增：并行作业数\n",
    "        if results_dir:\n",
    "            os.makedirs(f\"{results_dir}/data_exploration\", exist_ok=True)\n",
    "    \n",
    "    def _process_dict_keys(self, data):\n",
    "        \"\"\"递归处理字典，确保所有键为字符串\"\"\"\n",
    "        if isinstance(data, dict):\n",
    "            return {str(k): self._process_dict_keys(v) for k, v in data.items()}\n",
    "        elif isinstance(data, list):\n",
    "            return [self._process_dict_keys(item) for item in data]\n",
    "        else:\n",
    "            return data\n",
    "    \n",
    "    def explore_data(self) -> None:\n",
    "        \"\"\"高级数据探索，确保字典键为字符串\"\"\"\n",
    "        print(\"=\"*80)\n",
    "        print(\"高级数据探索 (学术增强版)\")\n",
    "        print(\"=\"*80)\n",
    "        \n",
    "        # 保存数据探索结果的字典\n",
    "        exploration_results = {\n",
    "            'basic_info': {},\n",
    "            'missing_values': {},\n",
    "            'target_statistics': {},\n",
    "            'correlation': {}\n",
    "        }\n",
    "        \n",
    "        # Basic statistics\n",
    "        print(f\"\\n数据集形状: {self.data.shape[0]} 行 × {self.data.shape[1]} 列\")\n",
    "        exploration_results['basic_info']['shape'] = (self.data.shape[0], self.data.shape[1])\n",
    "        \n",
    "        # Target variable statistics\n",
    "        print(f\"\\n目标变量 '{self.target}' 统计:\")\n",
    "        target_stats = self.data[self.target].describe()\n",
    "        print(target_stats.to_string())\n",
    "        exploration_results['target_statistics'] = target_stats.to_dict()\n",
    "        \n",
    "        # Missing value analysis\n",
    "        missing = self.data.isnull().sum()\n",
    "        missing_percent = (missing / len(self.data)) * 100\n",
    "        missing_df = pd.DataFrame({\n",
    "            '缺失计数': missing,\n",
    "            '缺失百分比 (%)': missing_percent\n",
    "        }).sort_values('缺失百分比 (%)', ascending=False)\n",
    "        \n",
    "        print(\"\\n缺失值分析:\")\n",
    "        print(missing_df[missing_df['缺失计数'] > 0].to_string())\n",
    "        \n",
    "        # 处理缺失值数据，确保键为字符串\n",
    "        exploration_results['missing_values'] = {\n",
    "            str(col): {'count': missing[col], 'percent': missing_percent[col]} \n",
    "            for col in missing[missing > 0].index\n",
    "        }\n",
    "        \n",
    "        # Target variable distribution\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.histplot(self.data[self.target], kde=True)\n",
    "        plt.title(f'目标变量分布: {self.target}')\n",
    "        plt.tight_layout()\n",
    "        if self.results_dir:\n",
    "            plt.savefig(f\"{self.results_dir}/data_exploration/target_distribution.png\", dpi=300, bbox_inches='tight')\n",
    "        plt.close()\n",
    "        \n",
    "        # 保存目标变量分布数据\n",
    "        exploration_results['target_distribution'] = self.data[self.target].value_counts(bins=20).to_dict()\n",
    "        \n",
    "        # Correlation analysis\n",
    "        numeric_cols = self.data.select_dtypes(include=np.number).columns\n",
    "        if len(numeric_cols) > 1:\n",
    "            if self.use_gpu:\n",
    "                # GPU-accelerated correlation\n",
    "                numeric_data = self.data[numeric_cols].values\n",
    "                numeric_tensor = torch.FloatTensor(numeric_data).to(device)\n",
    "                corr_tensor = torch.corrcoef(numeric_tensor.T)\n",
    "                corr = corr_tensor.cpu().numpy()\n",
    "                corr_df = pd.DataFrame(corr, index=numeric_cols, columns=numeric_cols)\n",
    "            else:\n",
    "                corr_df = self.data[numeric_cols].corr()\n",
    "            \n",
    "            plt.figure(figsize=(12, 10))\n",
    "            sns.heatmap(corr_df, annot=True, fmt=\".2f\", cmap='coolwarm', center=0)\n",
    "            plt.title('特征相关性热图')\n",
    "            plt.tight_layout()\n",
    "            if self.results_dir:\n",
    "                plt.savefig(f\"{self.results_dir}/data_exploration/correlation_heatmap.png\", dpi=300, bbox_inches='tight')\n",
    "            plt.close()\n",
    "            \n",
    "            # 处理相关性矩阵键\n",
    "            exploration_results['correlation']['matrix'] = self._process_dict_keys(corr_df.to_dict())\n",
    "            \n",
    "            # Target variable correlation\n",
    "            target_corr = corr_df[self.target].sort_values(ascending=False)\n",
    "            print(f\"\\n与目标变量的特征相关性:\")\n",
    "            print(target_corr[target_corr.index != self.target].to_string())\n",
    "            exploration_results['correlation']['target_correlation'] = self._process_dict_keys(\n",
    "                target_corr[target_corr.index != self.target].to_dict()\n",
    "            )\n",
    "        \n",
    "        # 保存处理后的数据探索结果\n",
    "        if self.results_dir:\n",
    "            processed_results = self._process_dict_keys(exploration_results)\n",
    "            with open(f\"{self.results_dir}/data_exploration/exploration_results.json\", 'w', encoding='utf-8') as f:\n",
    "                json.dump(processed_results, f, ensure_ascii=False, indent=2)\n",
    "            \n",
    "            # 保存数据基本信息到CSV\n",
    "            missing_df[missing_df['缺失计数'] > 0].to_csv(\n",
    "                f\"{self.results_dir}/data_exploration/missing_values.csv\", \n",
    "                index=True, \n",
    "                encoding='utf-8'\n",
    "            )\n",
    "    \n",
    "    def preprocess_data(self) -> Tuple:\n",
    "        \"\"\"Advanced data preprocessing and feature engineering with versioning\"\"\"\n",
    "        if self.target not in self.data.columns:\n",
    "            raise ValueError(f\"目标列 '{self.target}' 未在数据中找到\")\n",
    "        \n",
    "        # 保存原始数据\n",
    "        original_data = self.data.copy()\n",
    "        \n",
    "        # Handle missing values\n",
    "        self._handle_missing_values()\n",
    "        \n",
    "        # 保存缺失值处理后的数据\n",
    "        data_after_missing = self.data.copy()\n",
    "        \n",
    "        # Feature engineering\n",
    "        if self.feature_engineering:\n",
    "            self._gpu_accelerated_feature_engineering()\n",
    "            \n",
    "            # 保存特征工程公式（新增）\n",
    "            if self.results_dir:\n",
    "                with open(f\"{self.results_dir}/data_exploration/feature_engineering_formulas.txt\", 'w', encoding='utf-8') as f:\n",
    "                    f.write(\"特征工程公式记录:\\n\" + \"\\n\".join(self.feature_engineering_formulas))\n",
    "        \n",
    "        # 保存特征工程后的数据\n",
    "        data_after_fe = self.data.copy()\n",
    "        \n",
    "        # Feature classification\n",
    "        X = self.data.drop(columns=[self.target])\n",
    "        y = self.data[self.target]\n",
    "        \n",
    "        self.numeric_features = X.select_dtypes(include=np.number).columns.tolist()\n",
    "        self.categorical_features = X.select_dtypes(exclude=np.number).columns.tolist()\n",
    "        self.feature_names = self.numeric_features + self.categorical_features\n",
    "        \n",
    "        # Train-test split\n",
    "        X_train, X_test, y_train, y_test = train_test_split(\n",
    "            X, y, test_size=self.test_size, random_state=self.random_state\n",
    "        )\n",
    "        \n",
    "        print(f\"\\n预处理后的数据:\")\n",
    "        print(f\"  训练集: {X_train.shape[0]} 样本, {X_train.shape[1]} 特征\")\n",
    "        print(f\"  测试集: {X_test.shape[0]} 样本\")\n",
    "        \n",
    "        # 确保数据版本目录存在\n",
    "        data_versions_dir = os.path.join(self.results_dir, 'data_versions')\n",
    "        os.makedirs(data_versions_dir, exist_ok=True)\n",
    "        \n",
    "        # 保存中间数据版本\n",
    "        original_data.to_csv(f\"{data_versions_dir}/original_data.csv\", index=False, encoding='utf-8')\n",
    "        data_after_missing.to_csv(f\"{data_versions_dir}/data_after_missing.csv\", index=False, encoding='utf-8')\n",
    "        data_after_fe.to_csv(f\"{data_versions_dir}/data_after_fe.csv\", index=False, encoding='utf-8')\n",
    "        \n",
    "        if self.results_dir:\n",
    "            # 保存特征分类\n",
    "            with open(f\"{data_versions_dir}/feature_classification.json\", 'w', encoding='utf-8') as f:\n",
    "                json.dump({\n",
    "                    'numeric_features': self.numeric_features,\n",
    "                    'categorical_features': self.categorical_features\n",
    "                }, f, ensure_ascii=False, indent=2)\n",
    "        \n",
    "        return X_train, X_test, y_train, y_test\n",
    "    \n",
    "    def _handle_missing_values(self) -> None:\n",
    "        \"\"\"Advanced missing value handling strategy with logging\"\"\"\n",
    "        # Numeric features: use median\n",
    "        num_cols = self.data.select_dtypes(include=np.number).columns\n",
    "        missing_num = {}\n",
    "        for col in num_cols:\n",
    "            if self.data[col].isnull().sum() > 0:\n",
    "                median_val = self.data[col].median()\n",
    "                self.data[col].fillna(median_val, inplace=True)\n",
    "                missing_num[col] = {\n",
    "                    'original_missing': self.data[col].isnull().sum(),\n",
    "                    'filled_value': median_val\n",
    "                }\n",
    "        \n",
    "        # Categorical features: use mode\n",
    "        cat_cols = self.data.select_dtypes(exclude=np.number).columns\n",
    "        missing_cat = {}\n",
    "        for col in cat_cols:\n",
    "            if self.data[col].isnull().sum() > 0:\n",
    "                mode_val = self.data[col].mode()[0]\n",
    "                self.data[col].fillna(mode_val, inplace=True)\n",
    "                missing_cat[col] = {\n",
    "                    'original_missing': self.data[col].isnull().sum(),\n",
    "                    'filled_value': mode_val\n",
    "                }\n",
    "        \n",
    "        # 保存缺失值处理日志\n",
    "        if self.results_dir and (missing_num or missing_cat):\n",
    "            with open(f\"{self.results_dir}/data_exploration/missing_value_handling.json\", 'w', encoding='utf-8') as f:\n",
    "                json.dump({\n",
    "                    'numeric_features': missing_num,\n",
    "                    'categorical_features': missing_cat\n",
    "                }, f, ensure_ascii=False, indent=2)\n",
    "    \n",
    "    def _feature_engineering_log(self):\n",
    "        \"\"\"修正特征工程日志，确保字典键为字符串\"\"\"\n",
    "        feature_engineering_log = {\n",
    "            'added_features': [],\n",
    "            'final_feature_count': self.data.shape[1],\n",
    "            'engineering_formulas': self.feature_engineering_formulas,\n",
    "            'parallel_jobs': self.n_jobs\n",
    "        }\n",
    "        \n",
    "        # 处理添加的特征，确保键为字符串\n",
    "        for feature in self.added_features:\n",
    "            if 'original_feature' in feature:\n",
    "                feature['original_feature'] = str(feature['original_feature'])\n",
    "                feature['new_feature'] = str(feature['new_feature'])\n",
    "            elif 'original_features' in feature:\n",
    "                feature['original_features'] = [str(f) for f in feature['original_features']]\n",
    "                feature['new_feature'] = str(feature['new_feature'])\n",
    "            feature_engineering_log['added_features'].append(feature)\n",
    "        \n",
    "        return feature_engineering_log\n",
    "    \n",
    "    def _gpu_accelerated_feature_engineering(self) -> None:\n",
    "        \"\"\"GPU加速特征工程，确保特征名称为字符串并记录公式\"\"\"\n",
    "        print(\"\\n执行特征工程...\")\n",
    "        \n",
    "        self.added_features = []\n",
    "        self.feature_engineering_formulas = []  # 初始化公式列表\n",
    "        \n",
    "        numeric_cols = self.data.select_dtypes(include=np.number).columns.drop(self.target)\n",
    "        \n",
    "        if len(numeric_cols) > 0:\n",
    "            if self.use_gpu:\n",
    "                print(\"  - 使用GPU加速\")\n",
    "                # Convert numeric data to GPU tensor\n",
    "                numeric_data = self.data[numeric_cols].values\n",
    "                data_tensor = torch.FloatTensor(numeric_data).to(device)\n",
    "                \n",
    "                # 1. Polynomial features on GPU\n",
    "                print(\"  - 创建多项式特征\")\n",
    "                squared = data_tensor ** 2\n",
    "                sqrt_abs = torch.sqrt(torch.abs(data_tensor))\n",
    "                log1p_abs = torch.log1p(torch.abs(data_tensor))\n",
    "                \n",
    "                # Convert back to numpy\n",
    "                squared_np = squared.cpu().numpy()\n",
    "                sqrt_np = sqrt_abs.cpu().numpy()\n",
    "                log_np = log1p_abs.cpu().numpy()\n",
    "                \n",
    "                for i, col in enumerate(numeric_cols):\n",
    "                    col_str = str(col)\n",
    "                    new_col_sq = f'{col_str}_sq'\n",
    "                    new_col_sqrt = f'{col_str}_sqrt'\n",
    "                    new_col_log = f'{col_str}_log'\n",
    "                    \n",
    "                    self.data[new_col_sq] = squared_np[:, i]\n",
    "                    self.data[new_col_sqrt] = sqrt_np[:, i]\n",
    "                    self.data[new_col_log] = log_np[:, i]\n",
    "                    \n",
    "                    self.added_features.append({\n",
    "                        'original_feature': col_str,\n",
    "                        'new_feature': new_col_sq,\n",
    "                        'transformation': 'squared'\n",
    "                    })\n",
    "                    self.added_features.append({\n",
    "                        'original_feature': col_str,\n",
    "                        'new_feature': new_col_sqrt,\n",
    "                        'transformation': 'square root'\n",
    "                    })\n",
    "                    self.added_features.append({\n",
    "                        'original_feature': col_str,\n",
    "                        'new_feature': new_col_log,\n",
    "                        'transformation': 'log1p'\n",
    "                    })\n",
    "                    \n",
    "                    # 记录特征工程公式（新增）\n",
    "                    self.feature_engineering_formulas.append(f\"new_feature = {col_str}²\")\n",
    "                    self.feature_engineering_formulas.append(f\"new_feature = √|{col_str}|\")\n",
    "                    self.feature_engineering_formulas.append(f\"new_feature = log(1+|{col_str}|)\")\n",
    "                \n",
    "                # 2. Interaction features on GPU\n",
    "                print(\"  - 创建交互特征\")\n",
    "                n_features = len(numeric_cols)\n",
    "                max_interactions = min(n_features, 5)\n",
    "                for i in range(max_interactions):\n",
    "                    for j in range(i+1, max_interactions):\n",
    "                        col1 = numeric_cols[i]\n",
    "                        col2 = numeric_cols[j]\n",
    "                        \n",
    "                        interaction = data_tensor[:, i] * data_tensor[:, j]\n",
    "                        division = data_tensor[:, i] / (data_tensor[:, j] + 1e-8)\n",
    "                        \n",
    "                        new_col_mul = f'{col1}_x_{col2}'\n",
    "                        new_col_div = f'{col1}_div_{col2}'\n",
    "                        \n",
    "                        self.data[new_col_mul] = interaction.cpu().numpy()\n",
    "                        self.data[new_col_div] = division.cpu().numpy()\n",
    "                        \n",
    "                        self.added_features.append({\n",
    "                            'original_features': [col1, col2],\n",
    "                            'new_feature': new_col_mul,\n",
    "                            'transformation': 'multiplication'\n",
    "                        })\n",
    "                        self.added_features.append({\n",
    "                            'original_features': [col1, col2],\n",
    "                            'new_feature': new_col_div,\n",
    "                            'transformation': 'division'\n",
    "                        })\n",
    "                        \n",
    "                        # 记录交互特征公式（新增）\n",
    "                        self.feature_engineering_formulas.append(f\"new_feature = {col1} × {col2}\")\n",
    "                        self.feature_engineering_formulas.append(f\"new_feature = {col1} / ({col2} + 1e-8)\")\n",
    "            else:\n",
    "                # CPU feature engineering with parallel execution\n",
    "                print(f\"  - 使用CPU并行加速 (作业数: {self.n_jobs})\")\n",
    "                \n",
    "                # ===== 新增并行特征变换 =====\n",
    "                def process_feature(col):\n",
    "                    \"\"\"处理单个特征的基本变换\"\"\"\n",
    "                    col_str = str(col)\n",
    "                    transformations = {}\n",
    "                    \n",
    "                    # 基本变换\n",
    "                    transformations[f'{col_str}_sq'] = self.data[col] ** 2\n",
    "                    transformations[f'{col_str}_sqrt'] = np.sqrt(np.abs(self.data[col]))\n",
    "                    transformations[f'{col_str}_log'] = np.log1p(np.abs(self.data[col]))\n",
    "                    \n",
    "                    # 记录特征工程\n",
    "                    fe_info = [\n",
    "                        {'original_feature': col_str, 'new_feature': f'{col_str}_sq', 'transformation': 'squared'},\n",
    "                        {'original_feature': col_str, 'new_feature': f'{col_str}_sqrt', 'transformation': 'square root'},\n",
    "                        {'original_feature': col_str, 'new_feature': f'{col_str}_log', 'transformation': 'log1p'}\n",
    "                    ]\n",
    "                    \n",
    "                    # 记录公式\n",
    "                    formulas = [\n",
    "                        f\"new_feature = {col_str}²\",\n",
    "                        f\"new_feature = √|{col_str}|\",\n",
    "                        f\"new_feature = log(1+|{col_str}|)\"\n",
    "                    ]\n",
    "                    \n",
    "                    return transformations, fe_info, formulas\n",
    "                \n",
    "                # 并行处理特征变换\n",
    "                results = Parallel(n_jobs=self.n_jobs, verbose=10)(\n",
    "                    delayed(process_feature)(col) for col in numeric_cols\n",
    "                )\n",
    "                \n",
    "                # 合并结果\n",
    "                for result in results:\n",
    "                    transformations, fe_info, formulas = result\n",
    "                    for new_col, values in transformations.items():\n",
    "                        self.data[new_col] = values\n",
    "                    self.added_features.extend(fe_info)\n",
    "                    self.feature_engineering_formulas.extend(formulas)\n",
    "                # ===== 结束新增 =====\n",
    "                \n",
    "                # 交互特征（限制数量）\n",
    "                max_interactions = min(len(numeric_cols), 5)\n",
    "                interaction_count = 0\n",
    "                interaction_pairs = []\n",
    "                \n",
    "                # 创建交互对\n",
    "                for i in range(max_interactions):\n",
    "                    for j in range(i+1, max_interactions):\n",
    "                        interaction_pairs.append((i, j))\n",
    "                \n",
    "                # ===== 新增并行交互特征计算 =====\n",
    "                def create_interactions(i, j):\n",
    "                    \"\"\"创建两个特征之间的交互特征\"\"\"\n",
    "                    col1 = numeric_cols[i]\n",
    "                    col2 = numeric_cols[j]\n",
    "                    \n",
    "                    interactions = {}\n",
    "                    interactions[f'{col1}_x_{col2}'] = self.data[col1] * self.data[col2]\n",
    "                    interactions[f'{col1}_div_{col2}'] = self.data[col1] / (self.data[col2] + 1e-8)\n",
    "                    \n",
    "                    # 记录特征工程\n",
    "                    fe_info = [\n",
    "                        {'original_features': [col1, col2], 'new_feature': f'{col1}_x_{col2}', 'transformation': 'multiplication'},\n",
    "                        {'original_features': [col1, col2], 'new_feature': f'{col1}_div_{col2}', 'transformation': 'division'}\n",
    "                    ]\n",
    "                    \n",
    "                    # 记录公式\n",
    "                    formulas = [\n",
    "                        f\"new_feature = {col1} × {col2}\",\n",
    "                        f\"new_feature = {col1} / ({col2} + 1e-8)\"\n",
    "                    ]\n",
    "                    \n",
    "                    return interactions, fe_info, formulas\n",
    "                \n",
    "                # 并行处理交互特征\n",
    "                interaction_results = Parallel(n_jobs=self.n_jobs, verbose=10)(\n",
    "                    delayed(create_interactions)(i, j) for i, j in interaction_pairs\n",
    "                )\n",
    "                \n",
    "                # 合并结果\n",
    "                for result in interaction_results:\n",
    "                    interactions, fe_info, formulas = result\n",
    "                    for new_col, values in interactions.items():\n",
    "                        self.data[new_col] = values\n",
    "                    self.added_features.extend(fe_info)\n",
    "                    self.feature_engineering_formulas.extend(formulas)\n",
    "                # ===== 结束新增 =====\n",
    "        \n",
    "        print(f\"特征工程后特征数: {self.data.shape[1]}\")\n",
    "        \n",
    "        # 保存处理后的特征工程日志\n",
    "        if self.results_dir:\n",
    "            processed_log = self._feature_engineering_log()\n",
    "            with open(f\"{self.results_dir}/data_exploration/feature_engineering_log.json\", 'w', encoding='utf-8') as f:\n",
    "                json.dump(processed_log, f, ensure_ascii=False, indent=2)\n",
    "\n",
    "\n",
    "class AdvancedEnsemble:\n",
    "    \"\"\"Advanced model ensemble techniques with academic reporting\"\"\"\n",
    "    \n",
    "    def __init__(self, base_models, meta_model=None, random_state=42, n_jobs=1, results_dir=None):\n",
    "        self.base_models = base_models\n",
    "        self.meta_model = meta_model if meta_model else Ridge()\n",
    "        self.random_state = random_state\n",
    "        self.n_jobs = n_jobs\n",
    "        self.ensemble = None\n",
    "        self.results_dir = results_dir\n",
    "        if results_dir:\n",
    "            os.makedirs(f\"{results_dir}/ensemble\", exist_ok=True)\n",
    "    \n",
    "    def create_stacking_ensemble(self, X, y, cv=5):\n",
    "        \"\"\"Create stacking ensemble model with detailed logging\"\"\"\n",
    "        print(\"\\n创建堆叠集成模型...\")\n",
    "        \n",
    "        # Define base models\n",
    "        estimators = [(name, model['model']) for name, model in self.base_models.items()]\n",
    "        \n",
    "        # Create stacking model\n",
    "        self.ensemble = StackingRegressor(\n",
    "            estimators=estimators,\n",
    "            final_estimator=self.meta_model,\n",
    "            cv=cv,\n",
    "            n_jobs=self.n_jobs,\n",
    "            passthrough=True\n",
    "        )\n",
    "        \n",
    "        # Train ensemble model\n",
    "        self.ensemble.fit(X, y)\n",
    "        \n",
    "        # 保存集成模型结构\n",
    "        if self.results_dir:\n",
    "            with open(f\"{self.results_dir}/ensemble/stacking_structure.txt\", 'w', encoding='utf-8') as f:\n",
    "                f.write(\"堆叠集成模型结构:\\n\\n\")\n",
    "                f.write(\"基础模型:\\n\")\n",
    "                for name, _ in estimators:\n",
    "                    f.write(f\"  - {name}\\n\")\n",
    "                f.write(f\"\\n元模型: {type(self.meta_model).__name__}\")\n",
    "        \n",
    "        return self.ensemble\n",
    "    \n",
    "    def create_voting_ensemble(self, X, y):\n",
    "        \"\"\"Create voting ensemble model (average predictions) with performance comparison\"\"\"\n",
    "        print(\"\\n创建投票集成模型...\")\n",
    "        \n",
    "        # Train all base models\n",
    "        for name, model_info in self.base_models.items():\n",
    "            model_info['model'].fit(X, y)\n",
    "        \n",
    "        # Create average prediction function\n",
    "        def average_predict(X):\n",
    "            predictions = np.zeros(X.shape[0])\n",
    "            for model_info in self.base_models.values():\n",
    "                predictions += model_info['model'].predict(X)\n",
    "            return predictions / len(self.base_models)\n",
    "        \n",
    "        # 评估集成模型性能\n",
    "        if self.results_dir and hasattr(y, 'iloc'):\n",
    "            X_train, X_test, y_train, y_test = train_test_split(\n",
    "                X, y, test_size=0.2, random_state=self.random_state\n",
    "            )\n",
    "            \n",
    "            # 评估基础模型\n",
    "            base_performance = []\n",
    "            for name, model_info in self.base_models.items():\n",
    "                y_pred = model_info['model'].predict(X_test)\n",
    "                r2 = r2_score(y_test, y_pred)\n",
    "                base_performance.append({\n",
    "                    'model': name,\n",
    "                    'r2': r2\n",
    "                })\n",
    "            \n",
    "            # 评估集成模型\n",
    "            y_ensemble_pred = average_predict(X_test)\n",
    "            ensemble_r2 = r2_score(y_test, y_ensemble_pred)\n",
    "            \n",
    "            # 保存性能比较\n",
    "            performance_df = pd.DataFrame(base_performance)\n",
    "            performance_df = performance_df.append({\n",
    "                'model': '投票集成',\n",
    "                'r2': ensemble_r2\n",
    "            }, ignore_index=True)\n",
    "            \n",
    "            performance_df.to_csv(f\"{self.results_dir}/ensemble/voting_ensemble_performance.csv\", index=False, encoding='utf-8')\n",
    "            \n",
    "            # 可视化性能比较\n",
    "            plt.figure(figsize=(10, 6))\n",
    "            sns.barplot(x='r2', y='model', data=performance_df.sort_values('r2', ascending=False))\n",
    "            plt.title('基础模型与投票集成模型性能比较')\n",
    "            plt.tight_layout()\n",
    "            plt.savefig(f\"{self.results_dir}/ensemble/voting_ensemble_performance.png\", dpi=300, bbox_inches='tight')\n",
    "            plt.close()\n",
    "        \n",
    "        return average_predict\n",
    "\n",
    "\n",
    "class ModelEvaluator:\n",
    "    \"\"\"Advanced model evaluation and interpretation tools for academic purposes with parallel execution\"\"\"\n",
    "    \n",
    "    def __init__(self, model, X_train, y_train, X_test, y_test, feature_names, results_dir=None, n_jobs=1):\n",
    "        self.model = model\n",
    "        self.X_train = X_train\n",
    "        self.y_train = y_train\n",
    "        self.X_test = X_test\n",
    "        self.y_test = y_test\n",
    "        self.feature_names = feature_names\n",
    "        self.results_dir = results_dir\n",
    "        self.n_jobs = n_jobs  # 新增：并行作业数\n",
    "        if results_dir:\n",
    "            os.makedirs(f\"{results_dir}/model_evaluation\", exist_ok=True)\n",
    "    \n",
    "    def evaluate_performance(self):\n",
    "        \"\"\"Comprehensive model performance evaluation with extended metrics\"\"\"\n",
    "        # Training set predictions\n",
    "        y_train_pred = self.model.predict(self.X_train)\n",
    "        \n",
    "        # Test set predictions\n",
    "        y_test_pred = self.model.predict(self.X_test)\n",
    "        \n",
    "        # Calculate metrics\n",
    "        metrics = {\n",
    "            '训练集R²': r2_score(self.y_train, y_train_pred),\n",
    "            '测试集R²': r2_score(self.y_test, y_test_pred),\n",
    "            '训练集RMSE': np.sqrt(mean_squared_error(self.y_train, y_train_pred)),\n",
    "            '测试集RMSE': np.sqrt(mean_squared_error(self.y_test, y_test_pred)),\n",
    "            '训练集MAE': mean_absolute_error(self.y_train, y_train_pred),\n",
    "            '测试集MAE': mean_absolute_error(self.y_test, y_test_pred),\n",
    "            '测试集MAPE': mean_absolute_percentage_error(self.y_test, y_test_pred),\n",
    "            '解释方差': explained_variance_score(self.y_test, y_test_pred),\n",
    "            '训练集与测试集R²差值': r2_score(self.y_train, y_train_pred) - r2_score(self.y_test, y_test_pred)\n",
    "        }\n",
    "        \n",
    "        # 保存评估指标\n",
    "        if self.results_dir:\n",
    "            metrics_df = pd.DataFrame([metrics])\n",
    "            metrics_df.to_csv(f\"{self.results_dir}/model_evaluation/performance_metrics.csv\", index=False, encoding='utf-8')\n",
    "            \n",
    "            # 保存为LaTeX表格格式\n",
    "            with open(f\"{self.results_dir}/model_evaluation/performance_metrics.tex\", 'w', encoding='utf-8') as f:\n",
    "                f.write(\"\\\\begin{tabular}{|l|l|l|}\\n\")\n",
    "                f.write(\"\\\\hline\\n\")\n",
    "                f.write(\"指标 & 训练集 & 测试集 \\\\\\\\\\n\")\n",
    "                f.write(\"\\\\hline\\n\")\n",
    "                for key in metrics:\n",
    "                    if \"训练集\" in key or \"测试集\" in key:\n",
    "                        metric_name = key.replace(\"训练集\", \"\").replace(\"测试集\", \"\").replace(\"R²\", \"R$^2$\")\n",
    "                        train_val = metrics[key] if \"训练集\" in key else \"\"\n",
    "                        test_val = metrics[key] if \"测试集\" in key else \"\"\n",
    "                        if \"训练集\" in key and \"测试集\" in key.replace(key, \"\"):\n",
    "                            f.write(f\"{metric_name} & {train_val:.4f} & {test_val:.4f} \\\\\\\\\\n\")\n",
    "                f.write(\"\\\\hline\\n\")\n",
    "                f.write(\"\\\\end{tabular}\\n\")\n",
    "        \n",
    "        return metrics\n",
    "    \n",
    "    def plot_residuals(self):\n",
    "        \"\"\"Plot residual analysis graphs with high DPI for academic papers\"\"\"\n",
    "        y_pred = self.model.predict(self.X_test)\n",
    "        residuals = self.y_test - y_pred\n",
    "        \n",
    "        fig, axes = plt.subplots(1, 2, figsize=(15, 6))\n",
    "        \n",
    "        # Residual distribution\n",
    "        sns.histplot(residuals, kde=True, ax=axes[0])\n",
    "        axes[0].axvline(x=0, color='r', linestyle='--')\n",
    "        axes[0].set_title('残差分布')\n",
    "        axes[0].set_xlabel('残差')\n",
    "        axes[0].set_ylabel('频率')\n",
    "        \n",
    "        # Residuals vs Predicted values\n",
    "        sns.scatterplot(x=y_pred, y=residuals, alpha=0.5, ax=axes[1])\n",
    "        axes[1].axhline(y=0, color='r', linestyle='--')\n",
    "        axes[1].set_title('残差 vs 预测值')\n",
    "        axes[1].set_xlabel('预测值')\n",
    "        axes[1].set_ylabel('残差')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        if self.results_dir:\n",
    "            plt.savefig(f\"{self.results_dir}/model_evaluation/residual_analysis.png\", dpi=600, bbox_inches='tight')\n",
    "        plt.close()\n",
    "    \n",
    "    def plot_predictions(self):\n",
    "        \"\"\"Plot predicted vs actual values comparison with academic styling\"\"\"\n",
    "        y_pred = self.model.predict(self.X_test)\n",
    "        \n",
    "        plt.figure(figsize=(10, 8))\n",
    "        plt.scatter(self.y_test, y_pred, alpha=0.5, color='blue', edgecolor='none', s=30)\n",
    "        plt.plot([self.y_test.min(), self.y_test.max()], \n",
    "                 [self.y_test.min(), self.y_test.max()], \n",
    "                 'r--', lw=2)\n",
    "        plt.xlabel('实际值')\n",
    "        plt.ylabel('预测值')\n",
    "        plt.title('实际值 vs 预测值')\n",
    "        plt.grid(True, linestyle='--', alpha=0.7)\n",
    "        \n",
    "        # Add R² annotation\n",
    "        r2 = r2_score(self.y_test, y_pred)\n",
    "        plt.text(0.05, 0.95, f'R$^2$ = {r2:.4f}', transform=plt.gca().transAxes,\n",
    "                 bbox=dict(facecolor='white', alpha=0.8, edgecolor='gray'))\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        if self.results_dir:\n",
    "            plt.savefig(f\"{self.results_dir}/model_evaluation/actual_vs_predicted.png\", dpi=600, bbox_inches='tight')\n",
    "        plt.close()\n",
    "    \n",
    "    def feature_importance(self, method='built-in', n_repeats=10):\n",
    "        \"\"\"Feature importance analysis with academic visualization and statistical testing\"\"\"\n",
    "        # Try built-in importance first\n",
    "        if hasattr(self.model, 'feature_importances_'):\n",
    "            importances = self.model.feature_importances_\n",
    "        elif hasattr(self.model, 'coef_'):\n",
    "            importances = np.abs(self.model.coef_)\n",
    "        elif hasattr(self.model, 'named_steps') and hasattr(self.model.named_steps['model'], 'feature_importances_'):\n",
    "            # For pipeline models\n",
    "            importances = self.model.named_steps['model'].feature_importances_\n",
    "        elif hasattr(self.model, 'named_steps') and hasattr(self.model.named_steps['model'], 'coef_'):\n",
    "            importances = np.abs(self.model.named_steps['model'].coef_)\n",
    "        else:\n",
    "            # Use permutation importance as fallback\n",
    "            print(\"使用并行排列重要性 (这可能需要一些时间)...\")\n",
    "            # ===== 新增并行排列重要性计算 =====\n",
    "            # 计算基线得分\n",
    "            y_pred = self.model.predict(self.X_test)\n",
    "            baseline_score = r2_score(self.y_test, y_pred)\n",
    "            \n",
    "            # 定义计算单个特征重要性的函数\n",
    "            def calculate_importance(i):\n",
    "                # 为每个进程设置不同的随机种子\n",
    "                np.random.seed(42 + i)\n",
    "                \n",
    "                # 复制数据并打乱当前特征\n",
    "                X_permuted = self.X_test.copy()\n",
    "                if hasattr(X_permuted, 'values'):\n",
    "                    X_permuted = X_permuted.values\n",
    "                else:\n",
    "                    X_permuted = X_permuted.to_numpy()\n",
    "                \n",
    "                # 打乱第i个特征\n",
    "                perm_indices = np.random.permutation(len(X_permuted))\n",
    "                X_permuted[:, i] = X_permuted[perm_indices, i]\n",
    "                \n",
    "                # 预测并计算得分\n",
    "                y_pred_perm = self.model.predict(X_permuted)\n",
    "                score = r2_score(self.y_test, y_pred_perm)\n",
    "                return baseline_score - score\n",
    "            \n",
    "            # 并行计算特征重要性\n",
    "            importance_results = Parallel(n_jobs=self.n_jobs, verbose=10)(\n",
    "                delayed(calculate_importance)(i) for i in range(self.X_test.shape[1])\n",
    "            )\n",
    "            \n",
    "            importances = np.array(importance_results)\n",
    "            # ===== 结束新增 =====\n",
    "        \n",
    "        # Create importance DataFrame\n",
    "        importance_df = pd.DataFrame({\n",
    "            '特征': self.feature_names[:len(importances)],\n",
    "            '重要性': importances\n",
    "        })\n",
    "        \n",
    "        # 添加重要性标准差（如果有）\n",
    "        if 'importances_std' in locals():\n",
    "            importance_df['重要性标准差'] = importances_std\n",
    "            # 计算t统计量和p值（假设正态分布）\n",
    "            importance_df['t统计量'] = importance_df['重要性'] / (importance_df['重要性标准差'] + 1e-8)\n",
    "            importance_df['p值'] = 2 * (1 - stats.norm.cdf(np.abs(importance_df['t统计量'])))\n",
    "        \n",
    "        importance_df = importance_df.sort_values('重要性', ascending=False)\n",
    "        \n",
    "        # 保存特征重要性数据（含统计检验）\n",
    "        if self.results_dir:\n",
    "            importance_df.to_csv(f\"{self.results_dir}/model_evaluation/feature_importance.csv\", index=False, encoding='utf-8')\n",
    "            \n",
    "            # 保存为LaTeX表格（含统计检验）\n",
    "            with open(f\"{self.results_dir}/model_evaluation/feature_importance.tex\", 'w', encoding='utf-8') as f:\n",
    "                f.write(\"\\\\begin{tabular}{|l|l|l|l|l|}\\n\")\n",
    "                f.write(\"\\\\hline\\n\")\n",
    "                f.write(\"特征 & 重要性 & 标准差 & t统计量 & p值 \\\\\\\\\\n\")\n",
    "                f.write(\"\\\\hline\\n\")\n",
    "                for i, row in importance_df.head(10).iterrows():\n",
    "                    f.write(f\"{row['特征']} & {row['重要性']:.4f} & {row.get('重要性标准差', 0):.4f} & {row.get('t统计量', 0):.2f} & {row.get('p值', 0):.4e} \\\\\\\\\\n\")\n",
    "                f.write(\"\\\\hline\\n\")\n",
    "                f.write(\"\\\\end{tabular}\\n\")\n",
    "        \n",
    "        # Plot importance\n",
    "        plt.figure(figsize=(12, 8))\n",
    "        sns.barplot(x='重要性', y='特征', data=importance_df.head(20), color='skyblue')\n",
    "        plt.title('特征重要性 (前20)')\n",
    "        plt.tight_layout()\n",
    "        if self.results_dir:\n",
    "            plt.savefig(f\"{self.results_dir}/model_evaluation/feature_importance.png\", dpi=600, bbox_inches='tight')\n",
    "        plt.close()\n",
    "        \n",
    "        return importance_df\n",
    "    \n",
    "    def plot_partial_dependence(self, features=None, n_features=3):\n",
    "        \"\"\"Plot partial dependence plots for academic interpretation with parallel execution\"\"\"\n",
    "        if features is None:\n",
    "            # 使用最重要的特征\n",
    "            try:\n",
    "                importance_df = self.feature_importance()\n",
    "                features = importance_df.head(n_features)['特征'].tolist()\n",
    "            except:\n",
    "                print(\"无法获取特征重要性，跳过部分依赖图\")\n",
    "                return\n",
    "        \n",
    "        try:\n",
    "            # 确保模型支持部分依赖图\n",
    "            if hasattr(self.model, 'named_steps') and hasattr(self.model.named_steps['model'], 'feature_importances_'):\n",
    "                model = self.model.named_steps['model']\n",
    "            else:\n",
    "                model = self.model\n",
    "            \n",
    "            # ===== 新增并行部分依赖计算 =====\n",
    "            pdp_results = []\n",
    "            \n",
    "            # 并行计算部分依赖\n",
    "            with Parallel(n_jobs=self.n_jobs) as parallel:\n",
    "                for feature in features:\n",
    "                    # 创建网格值\n",
    "                    values = np.linspace(\n",
    "                        np.percentile(self.X_test[feature], 5),\n",
    "                        np.percentile(self.X_test[feature], 95),\n",
    "                        100\n",
    "                    )\n",
    "                    \n",
    "                    # 计算部分依赖\n",
    "                    def calc_pdp(i):\n",
    "                        X_temp = self.X_test.copy()\n",
    "                        X_temp[feature] = values[i]\n",
    "                        preds = model.predict(X_temp)\n",
    "                        return np.mean(preds)\n",
    "                    \n",
    "                    pdp = parallel(delayed(calc_pdp)(i) for i in range(len(values)))\n",
    "                    pdp_results.append((feature, values, pdp))\n",
    "            # ===== 结束新增 =====\n",
    "            \n",
    "            # 绘制结果\n",
    "            plt.figure(figsize=(15, 10))\n",
    "            for i, (feature, values, pdp) in enumerate(pdp_results):\n",
    "                plt.subplot(1, len(features), i+1)\n",
    "                plt.plot(values, pdp)\n",
    "                plt.title(f'Partial Dependence: {feature}')\n",
    "                plt.xlabel(feature)\n",
    "                plt.ylabel('Partial Dependence')\n",
    "            \n",
    "            plt.tight_layout()\n",
    "            if self.results_dir:\n",
    "                plt.savefig(f\"{self.results_dir}/model_evaluation/partial_dependence.png\", dpi=600, bbox_inches='tight')\n",
    "            plt.close()\n",
    "            \n",
    "            print(f\"已生成前{n_features}个特征的部分依赖图\")\n",
    "        except Exception as e:\n",
    "            print(f\"生成部分依赖图时出错: {e}\")\n",
    "\n",
    "\n",
    "class AcademicReportGenerator:\n",
    "    \"\"\"Generate academic-style reports from analysis results\"\"\"\n",
    "    \n",
    "    def __init__(self, results_dir):\n",
    "        self.results_dir = results_dir\n",
    "    \n",
    "    def generate_overview_report(self):\n",
    "        \"\"\"生成分析概述报告，适合作为论文的实验部分\"\"\"\n",
    "        if not os.path.exists(self.results_dir):\n",
    "            print(f\"结果目录 {self.results_dir} 不存在，无法生成报告\")\n",
    "            return\n",
    "        \n",
    "        report = \"# 实验分析报告\\n\\n\"\n",
    "        report += \"## 1. 数据探索\\n\\n\"\n",
    "        report += \"### 1.1 数据基本信息\\n\\n\"\n",
    "        \n",
    "        # 加载数据探索结果\n",
    "        try:\n",
    "            with open(f\"{self.results_dir}/data_exploration/exploration_results.json\", 'r', encoding='utf-8') as f:\n",
    "                exploration = json.load(f)\n",
    "            \n",
    "            report += f\"数据集包含 {exploration['basic_info']['shape'][0]} 个样本和 {exploration['basic_info']['shape'][1]} 个特征。\\n\\n\"\n",
    "            report += \"### 1.2 目标变量分析\\n\\n\"\n",
    "            report += f\"目标变量 '{self._get_target_column()}' 的统计描述如下:\\n\\n\"\n",
    "            report += \"| 统计量 | 值 |\\n\"\n",
    "            report += \"|------|------|\\n\"\n",
    "            for key, value in exploration['target_statistics'].items():\n",
    "                report += f\"| {key} | {value:.4f} |\\n\"\n",
    "            \n",
    "            report += \"\\n### 1.3 缺失值分析\\n\\n\"\n",
    "            if exploration['missing_values']:\n",
    "                report += \"数据中存在以下缺失值:\\n\\n\"\n",
    "                report += \"| 特征 | 缺失计数 | 缺失百分比 (%) |\\n\"\n",
    "                report += \"|------|----------|----------------|-\\n\"\n",
    "                for col, info in exploration['missing_values'].items():\n",
    "                    report += f\"| {col} | {info['count']} | {info['percent']:.2f} |\\n\"\n",
    "            else:\n",
    "                report += \"数据中没有缺失值。\\n\\n\"\n",
    "            \n",
    "            report += \"### 1.4 特征相关性分析\\n\\n\"\n",
    "            report += \"特征与目标变量的相关性分析显示，以下特征与目标变量相关性较高:\\n\\n\"\n",
    "            if 'target_correlation' in exploration['correlation']:\n",
    "                corr = exploration['correlation']['target_correlation']\n",
    "                sorted_corr = sorted(corr.items(), key=lambda x: abs(x[1]), reverse=True)\n",
    "                report += \"| 特征 | 相关系数 |\\n\"\n",
    "                report += \"|------|----------|-\\n\"\n",
    "                for feature, value in sorted_corr[:10]:\n",
    "                    report += f\"| {feature} | {value:.4f} |\\n\"\n",
    "            \n",
    "            report += \"\\n## 2. 特征工程\\n\\n\"\n",
    "            try:\n",
    "                with open(f\"{self.results_dir}/data_exploration/feature_engineering_log.json\", 'r', encoding='utf-8') as f:\n",
    "                    fe_log = json.load(f)\n",
    "                \n",
    "                report += f\"特征工程后，特征数量从 {fe_log.get('original_feature_count', 0)} 增加到 {fe_log['final_feature_count']}。\\n\\n\"\n",
    "                report += \"主要的特征工程操作包括:\\n\\n\"\n",
    "                for feature in fe_log['added_features'][:10]:\n",
    "                    if 'original_feature' in feature:\n",
    "                        report += f\"- 从特征 `{feature['original_feature']}` 创建 `{feature['new_feature']}` ({feature['transformation']})\\n\"\n",
    "                    elif 'original_features' in feature:\n",
    "                        report += f\"- 从特征 `{feature['original_features'][0]}` 和 `{feature['original_features'][1]}` 创建 `{feature['new_feature']}` ({feature['transformation']})\\n\"\n",
    "                \n",
    "                if len(fe_log['added_features']) > 10:\n",
    "                    report += f\"... 以及 {len(fe_log['added_features']) - 10} 个其他特征工程操作\\n\\n\"\n",
    "                \n",
    "                # 新增：特征工程公式\n",
    "                if 'engineering_formulas' in fe_log and fe_log['engineering_formulas']:\n",
    "                    report += \"特征工程的主要公式包括:\\n\\n\"\n",
    "                    for formula in fe_log['engineering_formulas'][:5]:\n",
    "                        report += f\"- {formula}\\n\"\n",
    "                    if len(fe_log['engineering_formulas']) > 5:\n",
    "                        report += f\"... 以及 {len(fe_log['engineering_formulas']) - 5} 个其他公式\\n\\n\"\n",
    "                \n",
    "                # 新增：并行执行信息\n",
    "                if 'parallel_jobs' in fe_log:\n",
    "                    report += f\"特征工程使用 {fe_log['parallel_jobs']} 个并行作业加速计算。\\n\\n\"\n",
    "            \n",
    "            except:\n",
    "                report += \"特征工程日志不存在或无法加载。\\n\\n\"\n",
    "            \n",
    "            report += \"## 3. 模型训练与调优\\n\\n\"\n",
    "            try:\n",
    "                with open(f\"{self.results_dir}/tuning_log_details.json\", 'r', encoding='utf-8') as f:\n",
    "                    tuning_log = json.load(f)\n",
    "                \n",
    "                report += \"我们对以下模型进行了超参数调优:\\n\\n\"\n",
    "                report += \"| 模型 | 最佳交叉验证得分 (R²) | 训练时间 (s) | 参数搜索数量 | 并行作业数 |\\n\"\n",
    "                report += \"|------|----------------------|--------------|--------------|------------|-\\n\"\n",
    "                for entry in tuning_log:\n",
    "                    if entry['status'] == 'success':\n",
    "                        params = \", \".join([f\"{k}={v}\" for k, v in entry.get('best_params', {}).items()])\n",
    "                        report += f\"| {entry['model_name']} | {entry['best_score']:.4f} | {entry['training_time']:.2f} | {entry['parameter_search_size']} | {entry.get('parallel_jobs', 1)} |\\n\"\n",
    "                \n",
    "                report += \"\\n### 3.1 模型性能比较\\n\\n\"\n",
    "                try:\n",
    "                    performance = pd.read_csv(f\"{self.results_dir}/model_performance.csv\")\n",
    "                    report += \"最终模型在测试集上的性能如下:\\n\\n\"\n",
    "                    report += \"| 指标 | 值 |\\n\"\n",
    "                    report += \"|------|----|-\\n\"\n",
    "                    for col in performance.columns:\n",
    "                        if col != '模型':  # 跳过模型名列\n",
    "                            report += f\"| {col} | {performance.iloc[0][col]:.4f} |\\n\"\n",
    "                except:\n",
    "                    report += \"模型性能数据不存在或无法加载。\\n\\n\"\n",
    "                \n",
    "                # 新增：GPU加速效果分析\n",
    "                try:\n",
    "                    gpu_models = ['XGBoost', 'LightGBM', 'PyTorchNN']\n",
    "                    gpu_entries = [e for e in tuning_log if e['model_name'] in gpu_models and e['status'] == 'success']\n",
    "                    cpu_entries = [e for e in tuning_log if e['model_name'] not in gpu_models and e['status'] == 'success']\n",
    "      \n",
    "                    if gpu_entries and cpu_entries:\n",
    "                        gpu_time = np.mean([e['training_time'] for e in gpu_entries])\n",
    "                        cpu_time = np.mean([e['training_time'] for e in cpu_entries])\n",
    "                        speedup = cpu_time / gpu_time if gpu_time > 0 else 0\n",
    "                        report += \"### 3.2 GPU加速效果分析\\n\\n\"\n",
    "                        report += f\"GPU加速模型（{', '.join(gpu_models)}）的平均训练时间为 {gpu_time:.2f} 秒，\\n\"\n",
    "                        report += f\"非GPU模型的平均训练时间为 {cpu_time:.2f} 秒，GPU加速带来了 {speedup:.2f} 倍的训练效率提升。\\n\\n\"\n",
    "                except:\n",
    "                    report += \"GPU加速效果分析数据不存在或无法加载。\\n\\n\"\n",
    "                \n",
    "                # 新增：学习率分析\n",
    "                report += \"## 4. 学习率与训练过程分析\\n\\n\"\n",
    "                try:\n",
    "                    # 检查是否有PyTorch模型的训练历史\n",
    "                    training_history_path = f\"{self.results_dir}/training_metrics/training_history.json\"\n",
    "                    if os.path.exists(training_history_path):\n",
    "                        with open(training_history_path, 'r', encoding='utf-8') as f:\n",
    "                            training_history = json.load(f)\n",
    "                        \n",
    "                        if training_history:\n",
    "                            report += \"### 4.1 学习率变化曲线\\n\\n\"\n",
    "                            report += \"学习率随训练轮次的变化如图所示 (见 `training_metrics/learning_rate_curve.png`):\\n\\n\"\n",
    "                            report += \"![学习率变化曲线](training_metrics/learning_rate_curve.png)\\n\\n\"\n",
    "                            \n",
    "                            # 提取关键学习率指标\n",
    "                            initial_lr = training_history[0]['learning_rate']\n",
    "                            final_lr = training_history[-1]['learning_rate']\n",
    "                            report += f\"学习率从初始值 {initial_lr:.6f} 衰减至最终值 {final_lr:.6f}，衰减率为 {(1 - final_lr/initial_lr)*100:.2f}%。\\n\\n\"\n",
    "                            \n",
    "                            report += \"### 4.2 损失函数收敛过程\\n\\n\"\n",
    "                            report += \"损失函数随训练轮次的变化如图所示 (见 `training_metrics/loss_evolution.png`):\\n\\n\"\n",
    "                            report += \"![损失函数变化](training_metrics/loss_evolution.png)\\n\\n\"\n",
    "                            report += \"训练损失呈现单调下降趋势，最终趋于稳定，表明模型成功收敛。\\n\\n\"\n",
    "                    else:\n",
    "                        report += \"未找到学习率训练历史数据，跳过学习率分析。\\n\\n\"\n",
    "                except Exception as e:\n",
    "                    report += f\"学习率分析出错: {str(e)}\\n\\n\"\n",
    "                \n",
    "                report += \"## 5. 模型评估与解释\\n\\n\"\n",
    "                report += \"### 5.1 预测结果分析\\n\\n\"\n",
    "                report += \"实际值与预测值的比较如图所示 (见 `model_evaluation/actual_vs_predicted.png`):\\n\\n\"\n",
    "                report += \"![实际值 vs 预测值](model_evaluation/actual_vs_predicted.png)\\n\\n\"\n",
    "                \n",
    "                # 获取R²值\n",
    "                try:\n",
    "                    r2_value = performance.iloc[0]['R²']\n",
    "                except:\n",
    "                    r2_value = 0\n",
    "                    \n",
    "                report += f\"模型的决定系数 (R²) 为 {r2_value:.4f}，表明模型解释了目标变量 {r2_value*100:.2f}% 的方差。\\n\\n\"\n",
    "                \n",
    "                report += \"残差分析如图所示 (见 `model_evaluation/residual_analysis.png`):\\n\\n\"\n",
    "                report += \"![残差分析](model_evaluation/residual_analysis.png)\\n\\n\"\n",
    "                report += \"残差分布近似正态，且与预测值无明显相关性，表明模型假设成立。\\n\\n\"\n",
    "                \n",
    "                report += \"### 5.2 特征重要性分析\\n\\n\"\n",
    "                report += \"模型的特征重要性分析显示，以下特征对预测最为重要 (见 `model_evaluation/feature_importance.png`):\\n\\n\"\n",
    "                report += \"![特征重要性](model_evaluation/feature_importance.png)\\n\\n\"\n",
    "                try:\n",
    "                    importance = pd.read_csv(f\"{self.results_dir}/model_evaluation/feature_importance.csv\")\n",
    "                    report += \"特征重要性的详细数据如下:\\n\\n\"\n",
    "                    report += \"| 特征 | 重要性 | 标准差 | t统计量 | p值 |\\n\"\n",
    "                    report += \"|------|--------|--------|----------|------|\\n\"\n",
    "                    for _, row in importance.head(10).iterrows():\n",
    "                        report += f\"| {row['特征']} | {row['重要性']:.4f} | {row.get('重要性标准差', 0):.4f} | {row.get('t统计量', 0):.2f} | {row.get('p值', 0):.4e} |\\n\"\n",
    "                    report += \"\\n基于t统计量和p值，特征重要性具有统计显著性（p < 0.05）。\\n\\n\"\n",
    "                except:\n",
    "                    report += \"特征重要性数据不存在或无法加载。\\n\\n\"\n",
    "                \n",
    "                report += \"### 5.3 特征部分依赖分析\\n\\n\"\n",
    "                report += \"前3个重要特征的部分依赖图如图所示 (见 `model_evaluation/partial_dependence.png`):\\n\\n\"\n",
    "                report += \"![部分依赖图](model_evaluation/partial_dependence.png)\\n\\n\"\n",
    "                report += \"部分依赖图展示了特征与目标变量的非线性关系，有助于理解特征对预测的影响机制。\\n\\n\"\n",
    "                \n",
    "                # 新增：集成模型分析\n",
    "                try:\n",
    "                    if os.path.exists(f\"{self.results_dir}/ensemble/stacking_structure.txt\"):\n",
    "                        report += \"## 6. 集成模型分析\\n\\n\"\n",
    "                        report += \"### 6.1 堆叠集成模型\\n\\n\"\n",
    "                        with open(f\"{self.results_dir}/ensemble/stacking_structure.txt\", 'r', encoding='utf-8') as f:\n",
    "                            report += f.read() + \"\\n\\n\"\n",
    "                        \n",
    "                        report += \"集成模型的性能通常优于单个基础模型，通过组合多个模型的优势提升预测精度。\\n\\n\"\n",
    "                except:\n",
    "                    report += \"未找到集成模型相关数据，跳过集成模型分析。\\n\\n\"\n",
    "                \n",
    "                report += \"## 7. 结论\\n\\n\"\n",
    "                report += \"本研究通过GPU加速的回归分析框架，完成了从数据探索到模型优化的完整流程。主要发现包括：\\n\\n\"\n",
    "                report += \"- 数据探索阶段识别了关键特征与目标变量的相关性\\n\"\n",
    "                report += \"- 特征工程显著增加了特征数量，提升了模型表达能力\\n\"\n",
    "                report += \"- GPU加速技术大幅缩短了训练时间，提升了研究效率\\n\"\n",
    "                report += \"- 最佳模型在测试集上取得了良好的预测性能\\n\"\n",
    "                report += \"- 特征重要性分析揭示了影响目标变量的关键因素\\n\\n\"\n",
    "                report += \"未来工作可以探索更复杂的特征交互、优化学习率策略，或尝试更先进的集成学习方法。\"\n",
    "            \n",
    "            except:\n",
    "                report += \"模型调优日志不存在或无法加载。\\n\\n\"\n",
    "            \n",
    "            # 保存报告\n",
    "            with open(f\"{self.results_dir}/academic_report.md\", 'w', encoding='utf-8') as f:\n",
    "                f.write(report)\n",
    "            \n",
    "            print(f\"学术报告已生成: {self.results_dir}/academic_report.md\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"生成报告时出错: {e}\")\n",
    "    \n",
    "    def _get_target_column(self):\n",
    "        \"\"\"从数据版本中获取目标列名称\"\"\"\n",
    "        try:\n",
    "            with open(f\"{self.results_dir}/data_versions/feature_classification.json\", 'r', encoding='utf-8') as f:\n",
    "                feature_class = json.load(f)\n",
    "            original_data = pd.read_csv(f\"{self.results_dir}/data_versions/original_data.csv\")\n",
    "            feature_cols = feature_class['numeric_features'] + feature_class['categorical_features']\n",
    "            target_col = [col for col in original_data.columns if col not in feature_cols][0]\n",
    "            return target_col\n",
    "        except:\n",
    "            return \"target_column\"\n",
    "\n",
    "\n",
    "class GPUAcceleratedRegressionAnalysis:\n",
    "    \"\"\"GPU-accelerated advanced regression analysis with academic support and parallel execution\"\"\"\n",
    "    \n",
    "    \n",
    "    def __init__(self, data, target, custom_dir=None, random_state=42, n_jobs=-1, use_gpu=True):\n",
    "        \"\"\"\n",
    "        初始化高级回归分析（并行增强版）\n",
    "        \n",
    "        参数:\n",
    "            data: 输入DataFrame\n",
    "            target: 目标变量列名\n",
    "            custom_dir: 自定义结果保存目录\n",
    "            random_state: 随机种子\n",
    "            n_jobs: 并行作业数 (-1 表示使用所有核心)\n",
    "            use_gpu: 是否使用GPU加速\n",
    "        \"\"\"\n",
    "        self.data = data\n",
    "        self.target = target\n",
    "        self.random_state = random_state\n",
    "        self.n_jobs = n_jobs\n",
    "        self.use_gpu = use_gpu and torch.cuda.is_available()\n",
    "        \n",
    "        # 设置自定义结果目录\n",
    "        if custom_dir:\n",
    "            self.results_dir = custom_dir\n",
    "        else:\n",
    "            self.results_dir = f\"regression_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n",
    "        \n",
    "        # 确保目录存在\n",
    "        os.makedirs(self.results_dir, exist_ok=True)\n",
    "        \n",
    "        # 初始化组件（传递自定义目录）\n",
    "        self.data_loader = GPUAcceleratedDataLoader(\n",
    "            data, target, \n",
    "            random_state=random_state, \n",
    "            use_gpu=self.use_gpu,\n",
    "            results_dir=self.results_dir,\n",
    "            n_jobs=self.n_jobs  # 传递并行作业数\n",
    "        )\n",
    "        \n",
    "        # 其他初始化代码\n",
    "        self.X_train, self.X_test, self.y_train, self.y_test = None, None, None, None\n",
    "        self.tuner = None\n",
    "        self.tuning_results = None\n",
    "        self.final_model = None\n",
    "    \n",
    "    def run_analysis(self, cv_folds=5, create_ensemble=True):\n",
    "        \"\"\"运行完整的分析工作流，保留详细的中间过程\"\"\"\n",
    "        print(\"=\"*80)\n",
    "        print(\"开始GPU加速回归分析 (并行增强版)\")\n",
    "        print(f\"GPU支持: {'启用' if self.use_gpu else '禁用'}\")\n",
    "        print(f\"并行作业数: {self.n_jobs}\")\n",
    "        print(f\"结果将保存至: {self.results_dir}\")\n",
    "        print(\"=\"*80)\n",
    "        \n",
    "        # 数据探索\n",
    "        self.data_loader.explore_data()\n",
    "        \n",
    "        # 数据预处理\n",
    "        self.X_train, self.X_test, self.y_train, self.y_test = self.data_loader.preprocess_data()\n",
    "        \n",
    "        # 超参数调优\n",
    "        self.tuner = SimplifiedHyperparameterTuner(\n",
    "            self.X_train, self.y_train, \n",
    "            random_state=self.random_state, \n",
    "            n_jobs=self.n_jobs,\n",
    "            use_gpu=self.use_gpu,\n",
    "            results_dir=self.results_dir\n",
    "        )\n",
    "        \n",
    "        self.tuning_results = self.tuner.tune_models(cv_folds=cv_folds)\n",
    "        \n",
    "        # 保存调优日志\n",
    "        self.tuner.save_tuning_log()\n",
    "        \n",
    "        # 评估调优模型\n",
    "        evaluation_df = self.tuner.evaluate_models(self.X_test, self.y_test)\n",
    "        print(\"\\n模型性能比较:\")\n",
    "        display(evaluation_df)\n",
    "        \n",
    "        # 保存结果\n",
    "        evaluation_df.to_csv(f\"{self.results_dir}/model_performance.csv\", index=False, encoding='utf-8')\n",
    "        \n",
    "        # 选择最佳模型\n",
    "        best_model_name = evaluation_df.iloc[0]['模型']\n",
    "        self.final_model = self.tuning_results[best_model_name]['model']\n",
    "        print(f\"\\n最佳模型: {best_model_name}\")\n",
    "        \n",
    "        # 评估最佳模型\n",
    "        evaluator = ModelEvaluator(\n",
    "            self.final_model,\n",
    "            self.X_train, self.y_train,\n",
    "            self.X_test, self.y_test,\n",
    "            self.data_loader.feature_names,\n",
    "            results_dir=self.results_dir,\n",
    "            n_jobs=self.n_jobs  # 传递并行作业数\n",
    "        )\n",
    "        \n",
    "        # 性能评估\n",
    "        final_metrics = evaluator.evaluate_performance()\n",
    "        print(\"\\n最终模型性能:\")\n",
    "        for metric, value in final_metrics.items():\n",
    "            print(f\"  {metric}: {value:.4f}\")\n",
    "        \n",
    "        # 特征重要性\n",
    "        try:\n",
    "            importance_df = evaluator.feature_importance()\n",
    "        except Exception as e:\n",
    "            print(f\"无法计算特征重要性: {e}\")\n",
    "        \n",
    "        # 保存测试数据和特征名称\n",
    "        joblib.dump({\n",
    "            'X_test': self.X_test,\n",
    "            'y_test': self.y_test,\n",
    "            'feature_names': self.data_loader.feature_names\n",
    "        }, f\"{self.results_dir}/test_data.pkl\")\n",
    "        \n",
    "        # 保存预测结果\n",
    "        y_pred = self.final_model.predict(self.X_test)\n",
    "        pred_df = pd.DataFrame({\n",
    "            '实际值': self.y_test,\n",
    "            '预测值': y_pred\n",
    "        })\n",
    "        pred_df.to_csv(f\"{self.results_dir}/predictions.csv\", index=False, encoding='utf-8')\n",
    "        \n",
    "        # 保存可视化结果\n",
    "        evaluator.plot_predictions()\n",
    "        evaluator.plot_residuals()\n",
    "        \n",
    "        # 新增：绘制学习率曲线（如果有PyTorch模型）\n",
    "        if best_model_name == \"PyTorchNN\":\n",
    "            try:\n",
    "                training_history_path = f\"{self.results_dir}/training_metrics/training_history.json\"\n",
    "                if os.path.exists(training_history_path):\n",
    "                    with open(training_history_path, 'r', encoding='utf-8') as f:\n",
    "                        training_history = json.load(f)\n",
    "                    \n",
    "                    if training_history:\n",
    "                        epochs = [h['epoch'] for h in training_history]\n",
    "                        losses = [h['loss'] for h in training_history]\n",
    "                        lrs = [h['learning_rate'] for h in training_history]\n",
    "                        \n",
    "                        # 绘制学习率曲线\n",
    "                        plt.figure(figsize=(12, 6))\n",
    "                        plt.semilogy(epochs, lrs, 'b-', linewidth=2, alpha=0.8)\n",
    "                        plt.xlabel('训练轮次 (Epoch)')\n",
    "                        plt.ylabel('学习率 (对数刻度)')\n",
    "                        plt.title('学习率变化曲线')\n",
    "                        plt.grid(True, alpha=0.3)\n",
    "                        plt.tight_layout()\n",
    "                        plt.savefig(f\"{self.results_dir}/training_metrics/learning_rate_curve.png\", dpi=300, bbox_inches='tight')\n",
    "                        plt.close()\n",
    "                        \n",
    "                        # 绘制损失曲线\n",
    "                        plt.figure(figsize=(12, 6))\n",
    "                        plt.plot(epochs, losses, 'b-', linewidth=2, alpha=0.8)\n",
    "                        plt.xlabel('训练轮次 (Epoch)')\n",
    "                        plt.ylabel('损失函数值')\n",
    "                        plt.title('损失函数变化曲线')\n",
    "                        plt.grid(True, alpha=0.3)\n",
    "                        plt.tight_layout()\n",
    "                        plt.savefig(f\"{self.results_dir}/training_metrics/loss_evolution.png\", dpi=300, bbox_inches='tight')\n",
    "                        plt.close()\n",
    "            except Exception as e:\n",
    "                print(f\"绘制学习率曲线时出错: {e}\")\n",
    "        \n",
    "        # 生成学术报告\n",
    "        report_generator = AcademicReportGenerator(self.results_dir)\n",
    "        report_generator.generate_overview_report()\n",
    "        \n",
    "        print(\"\\n分析完成！所有结果已保存至:\", self.results_dir)\n",
    "        print(\"学术报告: \", os.path.join(self.results_dir, \"academic_report.md\"))\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7100b320",
   "metadata": {},
   "source": [
    "## 成果处理"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "89ebb4f3",
   "metadata": {},
   "outputs": [],
   "source": [
    "## import os\n",
    "import json\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from typing import Dict, List, Any, Tuple, Optional, Union\n",
    "from dataclasses import dataclass\n",
    "from collections import defaultdict\n",
    "import re\n",
    "from scipy import stats\n",
    "import pickle\n",
    "\n",
    "# 设置中文字体支持\n",
    "plt.rcParams[\"font.family\"] = [\"SimHei\", \"WenQuanYi Micro Hei\", \"Heiti TC\"]\n",
    "plt.rcParams[\"axes.unicode_minus\"] = False  # 解决负号显示问题\n",
    "\n",
    "@dataclass\n",
    "class DataConfig:\n",
    "    \"\"\"数据配置类，支持自定义文件夹路径\"\"\"\n",
    "    results_dir: str = \"results_dir\"          # 根结果目录\n",
    "    exploration_dir: str = \"data_exploration\"  # 数据探索子目录\n",
    "    versions_dir: str = \"data_versions\"        # 数据版本子目录\n",
    "    tuning_dir: str = \"tuning_results\"         # 模型调优子目录\n",
    "    evaluation_dir: str = \"model_evaluation\"   # 模型评估子目录\n",
    "    training_dir: str = \"training_metrics\"     # 训练过程子目录\n",
    "    ensemble_dir: str = \"ensemble\"             # 集成模型子目录\n",
    "\n",
    "\n",
    "class DataExtractor:\n",
    "    \"\"\"数据提取器，用于从各种格式的文件中提取数据\"\"\"\n",
    "    \n",
    "    @staticmethod\n",
    "    def extract_from_json(file_path: str) -> Dict[str, Any]:\n",
    "        \"\"\"从JSON文件中提取数据\"\"\"\n",
    "        try:\n",
    "            with open(file_path, 'r', encoding='utf-8') as f:\n",
    "                return json.load(f)\n",
    "        except Exception as e:\n",
    "            print(f\"读取JSON文件 {file_path} 失败: {e}\")\n",
    "            return {}\n",
    "    \n",
    "    @staticmethod\n",
    "    def extract_from_csv(file_path: str) -> pd.DataFrame:\n",
    "        \"\"\"从CSV文件中提取数据\"\"\"\n",
    "        try:\n",
    "            return pd.read_csv(file_path)\n",
    "        except Exception as e:\n",
    "            print(f\"读取CSV文件 {file_path} 失败: {e}\")\n",
    "            return pd.DataFrame()\n",
    "    \n",
    "    @staticmethod\n",
    "    def extract_from_pkl(file_path: str) -> Any:\n",
    "        \"\"\"从pickle文件中提取数据\"\"\"\n",
    "        try:\n",
    "            with open(file_path, 'rb') as f:\n",
    "                return pickle.load(f)\n",
    "        except Exception as e:\n",
    "            print(f\"读取pickle文件 {file_path} 失败: {e}\")\n",
    "            return None\n",
    "    \n",
    "    @staticmethod\n",
    "    def extract_from_text(file_path: str) -> str:\n",
    "        \"\"\"从文本文件中提取数据\"\"\"\n",
    "        try:\n",
    "            with open(file_path, 'r', encoding='utf-8') as f:\n",
    "                return f.read()\n",
    "        except Exception as e:\n",
    "            print(f\"读取文本文件 {file_path} 失败: {e}\")\n",
    "            return \"\"\n",
    "\n",
    "\n",
    "class DataReader:\n",
    "    \"\"\"数据读取器，负责读取和整合所有数据，支持自定义文件夹路径\"\"\"\n",
    "    \n",
    "    def __init__(self, config: DataConfig = DataConfig()):\n",
    "        self.config = config\n",
    "        self.extractor = DataExtractor()\n",
    "        self._validate_directories()\n",
    "    \n",
    "    def _validate_directories(self) -> None:\n",
    "        \"\"\"验证数据目录是否存在\"\"\"\n",
    "        required_dirs = [\n",
    "            os.path.join(self.config.results_dir, self.config.exploration_dir),\n",
    "            os.path.join(self.config.results_dir, self.config.versions_dir),\n",
    "            os.path.join(self.config.results_dir, self.config.tuning_dir),\n",
    "            os.path.join(self.config.results_dir, self.config.evaluation_dir),\n",
    "            os.path.join(self.config.results_dir, self.config.training_dir),\n",
    "            os.path.join(self.config.results_dir, self.config.ensemble_dir),\n",
    "        ]\n",
    "        \n",
    "        for directory in required_dirs:\n",
    "            if not os.path.exists(directory):\n",
    "                print(f\"警告: 目录不存在或为空: {directory}\")\n",
    "    \n",
    "    # ======================\n",
    "    # 数据探索与预处理结果读取\n",
    "    # ======================\n",
    "    \n",
    "    def read_data_exploration(self) -> Dict[str, Union[pd.DataFrame, Dict[str, Any]]]:\n",
    "        \"\"\"读取数据探索结果\"\"\"\n",
    "        base_dir = os.path.join(\n",
    "            self.config.results_dir, \n",
    "            self.config.exploration_dir\n",
    "        )\n",
    "        \n",
    "        # 读取核心数据\n",
    "        exploration_data = self.extractor.extract_from_json(\n",
    "            os.path.join(base_dir, \"exploration_results.json\")\n",
    "        )\n",
    "        \n",
    "        missing_values = self.extractor.extract_from_csv(\n",
    "            os.path.join(base_dir, \"missing_values.csv\")\n",
    "        )\n",
    "        \n",
    "        # 处理特征工程日志\n",
    "        fe_log = self.extractor.extract_from_json(\n",
    "            os.path.join(base_dir, \"feature_engineering_log.json\")\n",
    "        )\n",
    "        \n",
    "        # 处理特征工程公式\n",
    "        fe_formulas = self.extractor.extract_from_text(\n",
    "            os.path.join(base_dir, \"feature_engineering_formulas.txt\")\n",
    "        )\n",
    "        \n",
    "        # 构建返回结果\n",
    "        return {\n",
    "            'dataset_info': pd.DataFrame([{\n",
    "                'rows': exploration_data.get('rows', 0),\n",
    "                'columns': exploration_data.get('columns', 0),\n",
    "                'numeric_features': len(exploration_data.get('numeric_features', [])),\n",
    "                'categorical_features': len(exploration_data.get('categorical_features', [])),\n",
    "                'total_missing_values': exploration_data.get('total_missing_values', 0)\n",
    "            }]),\n",
    "            'target_stats': pd.DataFrame([exploration_data.get('target_stats', {})]),\n",
    "            'correlation_matrix': pd.DataFrame(exploration_data.get('correlation_matrix', [])),\n",
    "            'missing_values': missing_values,\n",
    "            'feature_engineering': {\n",
    "                'log': pd.DataFrame(fe_log.get('features_added', [])),\n",
    "                'formulas': fe_formulas\n",
    "            },\n",
    "            'raw_data': exploration_data\n",
    "        }\n",
    "    \n",
    "    \n",
    "    # ======================\n",
    "    # 模型调优结果读取\n",
    "    # ======================\n",
    "    \n",
    "    def read_all_tuning_results(self) -> Dict[str, Dict[str, pd.DataFrame]]:\n",
    "        \"\"\"读取所有模型的调优结果\"\"\"\n",
    "        base_dir = os.path.join(self.config.results_dir, self.config.tuning_dir)\n",
    "        model_results = defaultdict(dict)\n",
    "        \n",
    "        # 查找所有模型的调优结果文件\n",
    "        for filename in os.listdir(base_dir):\n",
    "            if '_parameter_results.csv' in filename:\n",
    "                model_name = filename.split('_parameter_results.csv')[0]\n",
    "                \n",
    "                # 读取参数结果\n",
    "                param_df = self.extractor.extract_from_csv(\n",
    "                    os.path.join(base_dir, filename)\n",
    "                )\n",
    "                \n",
    "                # 读取折叠结果\n",
    "                fold_file = os.path.join(base_dir, f\"{model_name}_fold_results.json\")\n",
    "                if os.path.exists(fold_file):\n",
    "                    fold_data = self.extractor.extract_from_json(fold_file)\n",
    "                    \n",
    "                    # 转换为DataFrame\n",
    "                    fold_records = []\n",
    "                    for param_set, folds in fold_data.items():\n",
    "                        for fold_num, metrics in folds.items():\n",
    "                            record = {\n",
    "                                'param_set': int(param_set),\n",
    "                                'fold': int(fold_num),\n",
    "                                'r2': metrics['r2'],\n",
    "                                'mse': metrics['mse'],\n",
    "                                'mae': metrics['mae'],\n",
    "                                'train_time': metrics['train_time']\n",
    "                            }\n",
    "                            fold_records.append(record)\n",
    "                    \n",
    "                    fold_df = pd.DataFrame(fold_records)\n",
    "                else:\n",
    "                    fold_df = pd.DataFrame()\n",
    "                \n",
    "                # 读取训练时间\n",
    "                time_file = os.path.join(base_dir, f\"{model_name}_training_times.csv\")\n",
    "                time_df = self.extractor.extract_from_csv(time_file) if os.path.exists(time_file) else pd.DataFrame()\n",
    "                \n",
    "                model_results[model_name] = {\n",
    "                    'parameter_results': param_df,\n",
    "                    'fold_results': fold_df,\n",
    "                    'training_times': time_df\n",
    "                }\n",
    "        \n",
    "        return model_results\n",
    "    \n",
    "    # ======================\n",
    "    # 模型评估结果读取\n",
    "    # ======================\n",
    "    \n",
    "    def read_model_evaluation(self) -> Dict[str, pd.DataFrame]:\n",
    "        \"\"\"读取模型评估结果\"\"\"\n",
    "        base_dir = os.path.join(self.config.results_dir, self.config.evaluation_dir)\n",
    "        \n",
    "        return {\n",
    "            'performance_metrics': self.extractor.extract_from_csv(\n",
    "                os.path.join(base_dir, \"performance_metrics.csv\")\n",
    "            ),\n",
    "            'feature_importance': self.extractor.extract_from_csv(\n",
    "                os.path.join(base_dir, \"feature_importance.csv\")\n",
    "            )\n",
    "        }\n",
    "    \n",
    "    # ======================\n",
    "    # 训练过程记录读取\n",
    "    # ======================\n",
    "    \n",
    "    def read_training_metrics(self) -> pd.DataFrame:\n",
    "        \"\"\"读取训练过程指标\"\"\"\n",
    "        base_dir = os.path.join(self.config.results_dir, self.config.training_dir)\n",
    "        \n",
    "        history = self.extractor.extract_from_json(\n",
    "            os.path.join(base_dir, \"training_history.json\")\n",
    "        )\n",
    "        \n",
    "        return pd.DataFrame(history)\n",
    "    \n",
    "    # ======================\n",
    "    # 集成模型结果读取\n",
    "    # ======================\n",
    "    \n",
    "    def read_ensemble_results(self) -> Dict[str, Union[pd.DataFrame, str]]:\n",
    "        \"\"\"读取集成模型结果\"\"\"\n",
    "        base_dir = os.path.join(self.config.results_dir, self.config.ensemble_dir)\n",
    "        \n",
    "        # 读取集成结构\n",
    "        structure = self.extractor.extract_from_text(\n",
    "            os.path.join(base_dir, \"stacking_structure.txt\")\n",
    "        )\n",
    "        \n",
    "        # 读取性能数据\n",
    "        performance = self.extractor.extract_from_csv(\n",
    "            os.path.join(base_dir, \"voting_ensemble_performance.csv\")\n",
    "        )\n",
    "        \n",
    "        return {\n",
    "            'structure': structure,\n",
    "            'performance': performance\n",
    "        }\n",
    "    \n",
    "    # ======================\n",
    "    # 最终结果读取\n",
    "    # ======================\n",
    "    \n",
    "    def read_final_results(self) -> Dict[str, Union[pd.DataFrame, Any]]:\n",
    "        \"\"\"读取最终结果\"\"\"\n",
    "        base_dir = self.config.results_dir\n",
    "        \n",
    "        return {\n",
    "            'model_performance': self.extractor.extract_from_csv(\n",
    "                os.path.join(base_dir, \"model_performance.csv\")\n",
    "            ),\n",
    "            'predictions': self.extractor.extract_from_csv(\n",
    "                os.path.join(base_dir, \"predictions.csv\")\n",
    "            ),\n",
    "            'test_data': self.extractor.extract_from_pkl(\n",
    "                os.path.join(base_dir, \"test_data.pkl\")\n",
    "            ),\n",
    "            'academic_report': self.extractor.extract_from_text(\n",
    "                os.path.join(base_dir, \"academic_report.md\")\n",
    "            )\n",
    "        }\n",
    "\n",
    "\n",
    "class DataVisualizer:\n",
    "    \"\"\"数据可视化器，用于生成各类图表\"\"\"\n",
    "    \n",
    "    def __init__(self, reader: DataReader):\n",
    "        self.reader = reader\n",
    "    \n",
    "    def plot_target_distribution(self) -> plt.Figure:\n",
    "        \"\"\"绘制目标变量分布\"\"\"\n",
    "        exploration = self.reader.read_data_exploration()\n",
    "        target_stats = exploration['target_stats']\n",
    "        \n",
    "        fig, ax = plt.subplots(figsize=(10, 6))\n",
    "        \n",
    "        # 尝试从原始数据获取分布\n",
    "        try:\n",
    "            raw_data = exploration['raw_data']\n",
    "            if 'target_distribution' in raw_data and 'values' in raw_data['target_distribution']:\n",
    "                sns.histplot(raw_data['target_distribution']['values'], kde=True, ax=ax)\n",
    "                ax.set_title('目标变量分布')\n",
    "                ax.set_xlabel('值')\n",
    "                ax.set_ylabel('密度')\n",
    "        except:\n",
    "            # 回退方案：使用统计数据生成近似分布\n",
    "            mean = target_stats['mean'].values[0]\n",
    "            std = target_stats['std'].values[0]\n",
    "            min_val = target_stats['min'].values[0]\n",
    "            max_val = target_stats['max'].values[0]\n",
    "            \n",
    "            x = np.linspace(min_val, max_val, 100)\n",
    "            y = stats.norm.pdf(x, mean, std)\n",
    "            ax.plot(x, y, 'b-', linewidth=2)\n",
    "            ax.set_title('目标变量分布 (近似)')\n",
    "            ax.set_xlabel('值')\n",
    "            ax.set_ylabel('概率密度')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "    \n",
    "    def plot_correlation_heatmap(self, top_n: int = 10) -> plt.Figure:\n",
    "        \"\"\"绘制特征与目标变量的相关性热图\"\"\"\n",
    "        exploration = self.reader.read_data_exploration()\n",
    "        corr_matrix = exploration['correlation_matrix']\n",
    "        \n",
    "        # 获取与目标变量相关性最强的前N个特征\n",
    "        target_col = corr_matrix.columns[-1]  # 假设最后一列是目标变量\n",
    "        top_features = corr_matrix.abs().sort_values(target_col, ascending=False).index[:top_n]\n",
    "        top_corr = corr_matrix.loc[top_features, top_features]\n",
    "        \n",
    "        fig, ax = plt.subplots(figsize=(10, 8))\n",
    "        sns.heatmap(top_corr, annot=True, cmap='coolwarm', fmt='.2f', ax=ax)\n",
    "        ax.set_title(f'与目标变量相关性最强的前{top_n}个特征')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "    \n",
    "    def plot_missing_values(self) -> plt.Figure:\n",
    "        \"\"\"绘制缺失值分布\"\"\"\n",
    "        exploration = self.reader.read_data_exploration()\n",
    "        missing = exploration['missing_values']\n",
    "        \n",
    "        if missing.empty:\n",
    "            fig, ax = plt.subplots(figsize=(6, 4))\n",
    "            ax.text(0.5, 0.5, '没有缺失值数据', ha='center', va='center', fontsize=12)\n",
    "            ax.axis('off')\n",
    "            return fig\n",
    "        \n",
    "        # 筛选出有缺失值的特征\n",
    "        missing = missing[missing['missing_count'] > 0]\n",
    "        \n",
    "        if missing.empty:\n",
    "            fig, ax = plt.subplots(figsize=(6, 4))\n",
    "            ax.text(0.5, 0.5, '所有特征都没有缺失值', ha='center', va='center', fontsize=12)\n",
    "            ax.axis('off')\n",
    "            return fig\n",
    "        \n",
    "        fig, ax = plt.subplots(figsize=(10, 6))\n",
    "        sns.barplot(x='feature', y='missing_percentage', data=missing, ax=ax)\n",
    "        ax.set_title('特征缺失值百分比')\n",
    "        ax.set_xlabel('特征')\n",
    "        ax.set_ylabel('缺失百分比 (%)')\n",
    "        plt.xticks(rotation=45, ha='right')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "    \n",
    "    def plot_model_performance(self) -> plt.Figure:\n",
    "        \"\"\"绘制模型性能比较\"\"\"\n",
    "        evaluation = self.reader.read_model_evaluation()\n",
    "        metrics = evaluation['performance_metrics']\n",
    "        \n",
    "        if metrics.empty:\n",
    "            fig, ax = plt.subplots(figsize=(6, 4))\n",
    "            ax.text(0.5, 0.5, '没有模型性能数据', ha='center', va='center', fontsize=12)\n",
    "            ax.axis('off')\n",
    "            return fig\n",
    "        \n",
    "        fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n",
    "        \n",
    "        # R² 分数\n",
    "        sns.barplot(x='model', y='r2', data=metrics, ax=axes[0])\n",
    "        axes[0].set_title('模型 R² 分数')\n",
    "        axes[0].set_xlabel('模型')\n",
    "        axes[0].set_ylabel('R²')\n",
    "        axes[0].tick_params(axis='x', rotation=45)\n",
    "        \n",
    "        # RMSE\n",
    "        sns.barplot(x='model', y='rmse', data=metrics, ax=axes[1])\n",
    "        axes[1].set_title('模型 RMSE')\n",
    "        axes[1].set_xlabel('模型')\n",
    "        axes[1].set_ylabel('RMSE')\n",
    "        axes[1].tick_params(axis='x', rotation=45)\n",
    "        \n",
    "        # MAE\n",
    "        sns.barplot(x='model', y='mae', data=metrics, ax=axes[2])\n",
    "        axes[2].set_title('模型 MAE')\n",
    "        axes[2].set_xlabel('模型')\n",
    "        axes[2].set_ylabel('MAE')\n",
    "        axes[2].tick_params(axis='x', rotation=45)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "    \n",
    "    def plot_feature_importance(self, top_n: int = 10) -> plt.Figure:\n",
    "        \"\"\"绘制特征重要性\"\"\"\n",
    "        evaluation = self.reader.read_model_evaluation()\n",
    "        importance = evaluation['feature_importance']\n",
    "        \n",
    "        if importance.empty:\n",
    "            fig, ax = plt.subplots(figsize=(6, 4))\n",
    "            ax.text(0.5, 0.5, '没有特征重要性数据', ha='center', va='center', fontsize=12)\n",
    "            ax.axis('off')\n",
    "            return fig\n",
    "        \n",
    "        # 按重要性排序并取前N个\n",
    "        importance = importance.sort_values('importance', ascending=False).head(top_n)\n",
    "        \n",
    "        fig, ax = plt.subplots(figsize=(10, 6))\n",
    "        sns.barplot(x='importance', y='feature', data=importance, ax=ax)\n",
    "        ax.set_title(f'特征重要性 (前{top_n}个)')\n",
    "        ax.set_xlabel('重要性')\n",
    "        ax.set_ylabel('特征')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "    \n",
    "    def plot_training_history(self) -> plt.Figure:\n",
    "        \"\"\"绘制训练历史\"\"\"\n",
    "        history = self.reader.read_training_metrics()\n",
    "        \n",
    "        if history.empty:\n",
    "            fig, ax = plt.subplots(figsize=(6, 4))\n",
    "            ax.text(0.5, 0.5, '没有训练历史数据', ha='center', va='center', fontsize=12)\n",
    "            ax.axis('off')\n",
    "            return fig\n",
    "        \n",
    "        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n",
    "        \n",
    "        # 绘制损失函数\n",
    "        if 'train_loss' in history.columns:\n",
    "            ax1.plot(history['epoch'], history['train_loss'], label='训练损失')\n",
    "            if 'val_loss' in history.columns:\n",
    "                ax1.plot(history['epoch'], history['val_loss'], label='验证损失')\n",
    "            ax1.set_title('损失函数变化')\n",
    "            ax1.set_xlabel('轮次')\n",
    "            ax1.set_ylabel('损失')\n",
    "            ax1.legend()\n",
    "        else:\n",
    "            ax1.axis('off')\n",
    "            ax1.text(0.5, 0.5, '没有损失函数数据', ha='center', va='center', fontsize=12)\n",
    "        \n",
    "        # 绘制学习率\n",
    "        if 'learning_rate' in history.columns:\n",
    "            ax2.plot(history['epoch'], history['learning_rate'])\n",
    "            ax2.set_title('学习率变化')\n",
    "            ax2.set_xlabel('轮次')\n",
    "            ax2.set_ylabel('学习率')\n",
    "            ax2.set_yscale('log')  # 对数刻度\n",
    "        else:\n",
    "            ax2.axis('off')\n",
    "            ax2.text(0.5, 0.5, '没有学习率数据', ha='center', va='center', fontsize=12)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "    \n",
    "    def plot_actual_vs_predicted(self) -> plt.Figure:\n",
    "        \"\"\"绘制实际值与预测值对比\"\"\"\n",
    "        final_results = self.reader.read_final_results()\n",
    "        predictions = final_results['predictions']\n",
    "        \n",
    "        if predictions.empty or 'actual' not in predictions.columns or 'predicted' not in predictions.columns:\n",
    "            fig, ax = plt.subplots(figsize=(6, 4))\n",
    "            ax.text(0.5, 0.5, '没有预测数据或格式不正确', ha='center', va='center', fontsize=12)\n",
    "            ax.axis('off')\n",
    "            return fig\n",
    "        \n",
    "        fig, ax = plt.subplots(figsize=(10, 6))\n",
    "        \n",
    "        # 绘制散点图\n",
    "        sns.scatterplot(x='actual', y='predicted', data=predictions, ax=ax)\n",
    "        \n",
    "        # 添加理想线 (y=x)\n",
    "        min_val = min(predictions['actual'].min(), predictions['predicted'].min())\n",
    "        max_val = max(predictions['actual'].max(), predictions['predicted'].max())\n",
    "        ax.plot([min_val, max_val], [min_val, max_val], 'r--', label='理想线')\n",
    "        \n",
    "        ax.set_title('实际值 vs 预测值')\n",
    "        ax.set_xlabel('实际值')\n",
    "        ax.set_ylabel('预测值')\n",
    "        ax.legend()\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        return fig\n",
    "\n",
    "\n",
    "class DataAnalyzer:\n",
    "    \"\"\"数据分析器，用于执行各种数据分析任务\"\"\"\n",
    "    \n",
    "    def __init__(self, reader: DataReader, visualizer: DataVisualizer):\n",
    "        self.reader = reader\n",
    "        self.visualizer = visualizer\n",
    "    \n",
    "    def generate_full_report(self, output_dir: str = \"analysis_report\") -> None:\n",
    "        \"\"\"生成完整的分析报告\"\"\"\n",
    "        os.makedirs(output_dir, exist_ok=True)\n",
    "        \n",
    "        # 1. 数据探索\n",
    "        print(\"正在生成数据探索图表...\")\n",
    "        fig1 = self.visualizer.plot_target_distribution()\n",
    "        fig1.savefig(os.path.join(output_dir, \"target_distribution.png\"))\n",
    "        \n",
    "        fig2 = self.visualizer.plot_correlation_heatmap()\n",
    "        fig2.savefig(os.path.join(output_dir, \"correlation_heatmap.png\"))\n",
    "        \n",
    "        fig3 = self.visualizer.plot_missing_values()\n",
    "        fig3.savefig(os.path.join(output_dir, \"missing_values.png\"))\n",
    "        \n",
    "        # 2. 模型评估\n",
    "        print(\"正在生成模型评估图表...\")\n",
    "        fig4 = self.visualizer.plot_model_performance()\n",
    "        fig4.savefig(os.path.join(output_dir, \"model_performance.png\"))\n",
    "        \n",
    "        fig5 = self.visualizer.plot_feature_importance()\n",
    "        fig5.savefig(os.path.join(output_dir, \"feature_importance.png\"))\n",
    "        \n",
    "        # 3. 训练过程\n",
    "        print(\"正在生成训练过程图表...\")\n",
    "        fig6 = self.visualizer.plot_training_history()\n",
    "        fig6.savefig(os.path.join(output_dir, \"training_history.png\"))\n",
    "        \n",
    "        # 4. 预测结果\n",
    "        print(\"正在生成预测结果图表...\")\n",
    "        fig7 = self.visualizer.plot_actual_vs_predicted()\n",
    "        fig7.savefig(os.path.join(output_dir, \"actual_vs_predicted.png\"))\n",
    "        \n",
    "        # 5. 生成汇总报告\n",
    "        print(\"正在生成汇总报告...\")\n",
    "        self._generate_markdown_report(output_dir)\n",
    "        \n",
    "        print(f\"完整分析报告已生成至: {output_dir}\")\n",
    "    \n",
    "    def _generate_markdown_report(self, output_dir: str) -> None:\n",
    "        \"\"\"生成Markdown格式的分析报告\"\"\"\n",
    "        # 获取数据\n",
    "        exploration = self.reader.read_data_exploration()\n",
    "        evaluation = self.reader.read_model_evaluation()\n",
    "        final_results = self.reader.read_final_results()\n",
    "        \n",
    "        # 创建报告内容\n",
    "        report = \"# 数据分析报告\\n\\n\"\n",
    "        \n",
    "        # 数据概览\n",
    "        report += \"## 数据概览\\n\\n\"\n",
    "        report += f\"数据集行数: {exploration['dataset_info']['rows'][0]}\\n\\n\"\n",
    "        report += f\"数据集列数: {exploration['dataset_info']['columns'][0]}\\n\\n\"\n",
    "        report += f\"数值特征数量: {exploration['dataset_info']['numeric_features'][0]}\\n\\n\"\n",
    "        report += f\"分类特征数量: {exploration['dataset_info']['categorical_features'][0]}\\n\\n\"\n",
    "        \n",
    "        # 目标变量分布\n",
    "        report += \"## 目标变量分布\\n\\n\"\n",
    "        report += \"![Target Distribution](target_distribution.png)\\n\\n\"\n",
    "        \n",
    "        # 相关性分析\n",
    "        report += \"## 相关性分析\\n\\n\"\n",
    "        report += \"![Correlation Heatmap](correlation_heatmap.png)\\n\\n\"\n",
    "        \n",
    "        # 缺失值分析\n",
    "        report += \"## 缺失值分析\\n\\n\"\n",
    "        report += \"![Missing Values](missing_values.png)\\n\\n\"\n",
    "        \n",
    "        # 模型性能\n",
    "        report += \"## 模型性能比较\\n\\n\"\n",
    "        report += \"![Model Performance](model_performance.png)\\n\\n\"\n",
    "        \n",
    "        # 模型性能表格\n",
    "        if not evaluation['performance_metrics'].empty:\n",
    "            report += \"### 详细性能指标\\n\\n\"\n",
    "            report += evaluation['performance_metrics'].to_markdown(na_rep='nan') + \"\\n\\n\"\n",
    "        \n",
    "        # 特征重要性\n",
    "        report += \"## 特征重要性\\n\\n\"\n",
    "        report += \"![Feature Importance](feature_importance.png)\\n\\n\"\n",
    "        \n",
    "        # 训练过程\n",
    "        report += \"## 训练过程\\n\\n\"\n",
    "        report += \"![Training History](training_history.png)\\n\\n\"\n",
    "        \n",
    "        # 预测结果\n",
    "        report += \"## 预测结果\\n\\n\"\n",
    "        report += \"![Actual vs Predicted](actual_vs_predicted.png)\\n\\n\"\n",
    "        \n",
    "        # 保存报告\n",
    "        with open(os.path.join(output_dir, \"analysis_report.md\"), 'w', encoding='utf-8') as f:\n",
    "            f.write(report)\n",
    "\n",
    "# 使用示例（重点展示文件夹路径配置）\n",
    "if __name__ == \"__main__\":\n",
    "    # 方法1：使用默认文件夹路径（results_dir/）\n",
    "    default_reader = DataReader()\n",
    "    default_visualizer = DataVisualizer(default_reader)\n",
    "    default_analyzer = DataAnalyzer(default_reader, default_visualizer)\n",
    "    default_analyzer.generate_full_report(output_dir=\"default_analysis\")\n",
    "    \n",
    "    # 方法2：自定义文件夹路径（例如 /path/to/your/results/）\n",
    "    custom_results_dir = \"/path/to/your/results/\"  # 替换为实际路径\n",
    "    custom_config = DataConfig(\n",
    "        results_dir=custom_results_dir,\n",
    "        exploration_dir=\"data_exploration\",  # 可根据实际情况调整子目录名\n",
    "        versions_dir=\"data_versions\",\n",
    "        tuning_dir=\"tuning_results\",\n",
    "        evaluation_dir=\"model_evaluation\",\n",
    "        training_dir=\"training_metrics\",\n",
    "        ensemble_dir=\"ensemble\"\n",
    "    )\n",
    "    \n",
    "    custom_reader = DataReader(config=custom_config)\n",
    "    custom_visualizer = DataVisualizer(custom_reader)\n",
    "    custom_analyzer = DataAnalyzer(custom_reader, custom_visualizer)\n",
    "    custom_analyzer.generate_full_report(output_dir=\"custom_analysis\")\n",
    "    \n",
    "    # 方法3：交互式指定文件夹路径\n",
    "    user_results_dir = input(\"请输入结果文件夹路径: \")\n",
    "    if not user_results_dir:\n",
    "        user_results_dir = \"results_dir\"  # 默认值\n",
    "    \n",
    "    user_config = DataConfig(results_dir=user_results_dir)\n",
    "    user_reader = DataReader(config=user_config)\n",
    "    \n",
    "    # 示例：读取模型性能数据\n",
    "    evaluation = user_reader.read_model_evaluation()\n",
    "    if not evaluation['performance_metrics'].empty:\n",
    "        best_model = evaluation['performance_metrics'].sort_values('r2', ascending=False).iloc[0]['model']\n",
    "        print(f\"最佳模型: {best_model}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8446fb2",
   "metadata": {},
   "source": [
    "## 读取最佳参数并训练最佳模型\n",
    "是所有已经训练模型的自身最佳参数"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8718f16c",
   "metadata": {},
   "source": [
    "### 定义"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cfde2abe",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import joblib\n",
    "import os\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import json\n",
    "import traceback\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.base import BaseEstimator, RegressorMixin\n",
    "from torch.utils.data import TensorDataset, DataLoader\n",
    "import torch.optim as optim\n",
    "# Move this to the top of the file\n",
    "try:\n",
    "    from catboost import CatBoostRegressor\n",
    "    CATBOOST_AVAILABLE = True\n",
    "except ImportError:\n",
    "    CATBOOST_AVAILABLE = False\n",
    "# 定义 PyTorchRegressor 类（从原始代码复制）\n",
    "class PyTorchRegressor(BaseEstimator, RegressorMixin):\n",
    "    \"\"\"PyTorch Neural Network Regressor with GPU support and improved serialization\"\"\"\n",
    "    \n",
    "    def __init__(self, hidden_sizes=(100, 50), activation='relu', learning_rate=0.001,\n",
    "                 batch_size=32, epochs=100, dropout=0.2, early_stopping=True,\n",
    "                 patience=10, device=None):\n",
    "        self.hidden_sizes = hidden_sizes\n",
    "        self.activation = activation\n",
    "        self.learning_rate = learning_rate\n",
    "        self.batch_size = batch_size\n",
    "        self.epochs = epochs\n",
    "        self.dropout = dropout\n",
    "        self.early_stopping = early_stopping\n",
    "        self.patience = patience\n",
    "        self.device_str = device if device else ('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "        self.model = None\n",
    "        self.scaler_X = StandardScaler()\n",
    "        self.scaler_y = StandardScaler()\n",
    "        self.best_loss = float('inf')\n",
    "        self.input_dim = None\n",
    "        self.model_state_dict = None\n",
    "        self.training_history = []\n",
    "    \n",
    "    @property\n",
    "    def device(self):\n",
    "        return torch.device(self.device_str)\n",
    "    \n",
    "    def _build_model(self, input_dim):\n",
    "        \"\"\"Build PyTorch model\"\"\"\n",
    "        layers = []\n",
    "        prev_size = input_dim\n",
    "        \n",
    "        for hidden_size in self.hidden_sizes:\n",
    "            layers.append(nn.Linear(prev_size, hidden_size))\n",
    "            layers.append(nn.BatchNorm1d(hidden_size))\n",
    "            \n",
    "            if self.activation == 'relu':\n",
    "                layers.append(nn.ReLU())\n",
    "            elif self.activation == 'tanh':\n",
    "                layers.append(nn.Tanh())\n",
    "            elif self.activation == 'leaky_relu':\n",
    "                layers.append(nn.LeakyReLU())\n",
    "            \n",
    "            layers.append(nn.Dropout(self.dropout))\n",
    "            prev_size = hidden_size\n",
    "        \n",
    "        layers.append(nn.Linear(prev_size, 1))\n",
    "        \n",
    "        return nn.Sequential(*layers)\n",
    "    \n",
    "    def fit(self, X, y):\n",
    "        \"\"\"Fit the model with training history logging and file saving\"\"\"\n",
    "        if hasattr(X, 'values'):\n",
    "            X = X.values\n",
    "        if hasattr(y, 'values'):\n",
    "            y = y.values\n",
    "        \n",
    "        self.input_dim = X.shape[1]\n",
    "        \n",
    "        # Scale data\n",
    "        X_scaled = self.scaler_X.fit_transform(X)\n",
    "        y_scaled = self.scaler_y.fit_transform(y.reshape(-1, 1)).ravel()\n",
    "        \n",
    "        # Convert to PyTorch tensors\n",
    "        X_tensor = torch.FloatTensor(X_scaled).to(self.device)\n",
    "        y_tensor = torch.FloatTensor(y_scaled).to(self.device)\n",
    "        \n",
    "        # Create data loader\n",
    "        dataset = TensorDataset(X_tensor, y_tensor)\n",
    "        loader = DataLoader(dataset, batch_size=self.batch_size, shuffle=True)\n",
    "        \n",
    "        # Build model\n",
    "        self.model = self._build_model(X.shape[1]).to(self.device)\n",
    "        \n",
    "        # Loss and optimizer\n",
    "        criterion = nn.MSELoss()\n",
    "        optimizer = optim.Adam(self.model.parameters(), lr=self.learning_rate)\n",
    "        scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=5, factor=0.5)\n",
    "        \n",
    "        # Training\n",
    "        self.model.train()\n",
    "        patience_counter = 0\n",
    "        best_model_state = None\n",
    "        \n",
    "        for epoch in range(self.epochs):\n",
    "            epoch_loss = 0\n",
    "            for batch_X, batch_y in loader:\n",
    "                optimizer.zero_grad()\n",
    "                outputs = self.model(batch_X).squeeze()\n",
    "                loss = criterion(outputs, batch_y)\n",
    "                loss.backward()\n",
    "                optimizer.step()\n",
    "                epoch_loss += loss.item()\n",
    "            \n",
    "            avg_loss = epoch_loss / len(loader)\n",
    "            scheduler.step(avg_loss)\n",
    "            \n",
    "            # Record training history\n",
    "            current_lr = optimizer.param_groups[0]['lr']\n",
    "            self.training_history.append({\n",
    "                'epoch': epoch,\n",
    "                'loss': avg_loss,\n",
    "                'learning_rate': current_lr\n",
    "            })\n",
    "            \n",
    "            if self.early_stopping:\n",
    "                if avg_loss < self.best_loss:\n",
    "                    self.best_loss = avg_loss\n",
    "                    patience_counter = 0\n",
    "                    best_model_state = self.model.state_dict().copy()\n",
    "                else:\n",
    "                    patience_counter += 1\n",
    "                    if patience_counter >= self.patience:\n",
    "                        if best_model_state is not None:\n",
    "                            self.model.load_state_dict(best_model_state)\n",
    "                        break\n",
    "        \n",
    "        # Save model state for serialization\n",
    "        self.model_state_dict = self.model.state_dict()\n",
    "        return self\n",
    "    \n",
    "    def predict(self, X):\n",
    "        \"\"\"Make predictions\"\"\"\n",
    "        if hasattr(X, 'values'):\n",
    "            X = X.values\n",
    "        \n",
    "        # Rebuild model if necessary\n",
    "        if self.model is None and self.model_state_dict is not None:\n",
    "            self.model = self._build_model(self.input_dim).to(self.device)\n",
    "            self.model.load_state_dict(self.model_state_dict)\n",
    "        \n",
    "        X_scaled = self.scaler_X.transform(X)\n",
    "        X_tensor = torch.FloatTensor(X_scaled).to(self.device)\n",
    "        \n",
    "        self.model.eval()\n",
    "        with torch.no_grad():\n",
    "            predictions_scaled = self.model(X_tensor).cpu().numpy()\n",
    "        \n",
    "        predictions = self.scaler_y.inverse_transform(predictions_scaled)\n",
    "        return predictions.ravel()\n",
    "    \n",
    "    def __getstate__(self):\n",
    "        \"\"\"Custom serialization with training history\"\"\"\n",
    "        state = self.__dict__.copy()\n",
    "        # Remove non-serializable objects\n",
    "        if 'model' in state:\n",
    "            del state['model']\n",
    "        return state\n",
    "    \n",
    "    def __setstate__(self, state):\n",
    "        \"\"\"Custom deserialization\"\"\"\n",
    "        self.__dict__.update(state)\n",
    "        self.model = None\n",
    "\n",
    "def initialize_model(model_name, params):\n",
    "    \"\"\"根据模型名称和参数初始化相应的模型\"\"\"\n",
    "    # 特殊处理：修复参数类型问题\n",
    "    if 'hidden_sizes' in params and isinstance(params['hidden_sizes'], list):\n",
    "        params['hidden_sizes'] = tuple(params['hidden_sizes'])\n",
    "    \n",
    "    # 特殊处理：移除PyTorchNN不需要的参数\n",
    "    if model_name == \"PyTorchNN\":\n",
    "        params.pop('results_dir', None)\n",
    "        # 确保使用当前设备\n",
    "        params['device'] = 'cuda' if torch.cuda.is_available() else 'cpu'\n",
    "    \n",
    "    if model_name == \"Ridge\":\n",
    "        from sklearn.linear_model import Ridge\n",
    "        return Ridge(**params)\n",
    "    elif model_name == \"Lasso\":\n",
    "        from sklearn.linear_model import Lasso\n",
    "        return Lasso(**params)\n",
    "    elif model_name == \"ElasticNet\":\n",
    "        from sklearn.linear_model import ElasticNet\n",
    "        return ElasticNet(**params)\n",
    "    elif model_name == \"RandomForest\":\n",
    "        from sklearn.ensemble import RandomForestRegressor\n",
    "        return RandomForestRegressor(**params)\n",
    "    elif model_name == \"GradientBoosting\":\n",
    "        from sklearn.ensemble import GradientBoostingRegressor\n",
    "        return GradientBoostingRegressor(**params)\n",
    "    elif model_name == \"XGBoost\":\n",
    "        from xgboost import XGBRegressor\n",
    "        return XGBRegressor(**params)\n",
    "    elif model_name == \"LightGBM\":\n",
    "        from lightgbm import LGBMRegressor\n",
    "        return LGBMRegressor(**params)\n",
    "    elif model_name == \"PyTorchNN\":\n",
    "        return PyTorchRegressor(**params)\n",
    "    elif model_name == \"MLP\":\n",
    "        from sklearn.neural_network import MLPRegressor\n",
    "        return MLPRegressor(**params)\n",
    "    elif model_name == \"SVR\":\n",
    "        from sklearn.svm import SVR\n",
    "        return SVR(**params)\n",
    "    elif model_name == \"KNN\":\n",
    "        from sklearn.neighbors import KNeighborsRegressor\n",
    "        return KNeighborsRegressor(**params)\n",
    "    elif model_name == \"CatBoost\" and CATBOOST_AVAILABLE:\n",
    "        from catboost import CatBoostRegressor\n",
    "        return CatBoostRegressor(**params)\n",
    "    else:\n",
    "        raise ValueError(f\"Unsupported model: {model_name}\")\n",
    "\n",
    "def retrain_all_models(results_dir, target_column):\n",
    "    \"\"\"\n",
    "    从结果目录中读取所有模型的最佳参数并重新训练保存所有模型\n",
    "    \n",
    "    参数:\n",
    "        results_dir: 结果目录路径\n",
    "        target_column: 目标变量列名\n",
    "    \"\"\"\n",
    "    # 1. 加载训练数据\n",
    "    train_data_path = os.path.join(results_dir, \"data_versions\", \"data_after_fe.csv\")\n",
    "\n",
    "    if not os.path.exists(train_data_path):\n",
    "        print(f\"训练数据文件不存在: {train_data_path}\")\n",
    "        return\n",
    "    \n",
    "    train_data = pd.read_csv(train_data_path)\n",
    "    X_train = train_data.drop(columns=[target_column])\n",
    "    y_train = train_data[target_column]\n",
    "    \n",
    "    # 2. 加载调优日志\n",
    "    tuning_log_path = f\"{results_dir}/tuning_log_details.json\"\n",
    "    if not os.path.exists(tuning_log_path):\n",
    "        print(f\"调优日志文件不存在: {tuning_log_path}\")\n",
    "        return\n",
    "    \n",
    "    with open(tuning_log_path, 'r', encoding='utf-8') as f:\n",
    "        tuning_log = json.load(f)\n",
    "    \n",
    "    # 3. 创建模型保存目录\n",
    "    models_dir = f\"{results_dir}/retrained_models\"\n",
    "    os.makedirs(models_dir, exist_ok=True)\n",
    "    \n",
    "    # 4. 遍历所有模型并重新训练\n",
    "    results = []\n",
    "    \n",
    "    for model_entry in tuning_log:\n",
    "        if model_entry.get('status') != 'success':\n",
    "            continue\n",
    "            \n",
    "        model_name = model_entry['model_name']\n",
    "        best_params = model_entry.get('best_params', {})\n",
    "        \n",
    "        print(f\"\\n{'='*50}\")\n",
    "        print(f\"处理模型: {model_name}\")\n",
    "        print(f\"最佳参数: {best_params}\")\n",
    "        \n",
    "        try:\n",
    "            # 初始化模型\n",
    "            model = initialize_model(model_name, best_params.copy())\n",
    "            \n",
    "            # 创建pipeline\n",
    "            pipeline = Pipeline([\n",
    "                ('scaler', StandardScaler()),\n",
    "                ('model', model)\n",
    "            ])\n",
    "            \n",
    "            # 训练模型\n",
    "            print(f\"开始训练 {model_name}...\")\n",
    "            pipeline.fit(X_train, y_train)\n",
    "            print(f\"{model_name} 训练完成!\")\n",
    "            \n",
    "            # 保存模型\n",
    "            model_save_path = f\"{models_dir}/{model_name}_model.pkl\"\n",
    "            joblib.dump(pipeline, model_save_path)\n",
    "            print(f\"模型已保存至: {model_save_path}\")\n",
    "            \n",
    "            # 记录结果\n",
    "            results.append({\n",
    "                'model': model_name,\n",
    "                'status': 'success',\n",
    "                'save_path': model_save_path,\n",
    "                'parameters': best_params\n",
    "            })\n",
    "            \n",
    "        except Exception as e:\n",
    "            error_msg = f\"训练 {model_name} 时出错: {str(e)}\"\n",
    "            print(error_msg)\n",
    "            traceback.print_exc()\n",
    "            \n",
    "            results.append({\n",
    "                'model': model_name,\n",
    "                'status': 'error',\n",
    "                'error': error_msg,\n",
    "                'parameters': best_params\n",
    "            })\n",
    "    \n",
    "    # 5. 保存训练结果\n",
    "    results_df = pd.DataFrame(results)\n",
    "    results_path = f\"{results_dir}/retraining_results.csv\"\n",
    "    results_df.to_csv(results_path, index=False, encoding='utf-8')\n",
    "    print(f\"\\n所有模型重新训练结果已保存至: {results_path}\")\n",
    "    \n",
    "    return results_df\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dffc2a16",
   "metadata": {},
   "source": [
    "### 运行"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "14d2b650",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "if __name__ == \"__main__\":\n",
    "    # 检查依赖可用性\n",
    "    try:\n",
    "        from catboost import CatBoostRegressor\n",
    "        CATBOOST_AVAILABLE = True\n",
    "    except ImportError:\n",
    "        CATBOOST_AVAILABLE = False\n",
    "    \n",
    "    # 确保PyTorch模块可用\n",
    "    from torch.utils.data import TensorDataset, DataLoader\n",
    "    import torch.optim as optim\n",
    "\n",
    "    # 定义多个任务：每个任务包含结果目录和目标列名\n",
    "    tasks = [\n",
    "#         {\n",
    "#             \"results_dir\": r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\DFT完成\",\n",
    "#             \"target_column\": \"EigenValue\"\n",
    "#         },\n",
    "#         {\n",
    "#             \"results_dir\": r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\DFS完成\",\n",
    "#             \"target_column\": \"EigenValue\"\n",
    "#         },\n",
    "#         {\n",
    "#             \"results_dir\": r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\DFB完成\",\n",
    "#             \"target_column\": \"EigenValue\"\n",
    "#         }\n",
    "#         ,\n",
    "#         {\n",
    "#             \"results_dir\": r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data0_auto_P完成\",\n",
    "#             \"target_column\": \"Pucf12f\"\n",
    "#         }\n",
    "#             ,\n",
    "#         {\n",
    "#             \"results_dir\": r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data1_auto_P完成\",\n",
    "#             \"target_column\": \"Pucf12f\"\n",
    "#         }\n",
    "#         ,\n",
    "        {\n",
    "            \"results_dir\": r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data2_auto_P完成\",\n",
    "            \"target_column\": \"Pucf12f\"\n",
    "        }\n",
    "#         ,\n",
    "    ]\n",
    "\n",
    "    # 顺序执行所有任务\n",
    "    for i, task in enumerate(tasks, 1):\n",
    "        print(f\"\\n{'='*60}\")\n",
    "        print(f\"开始执行第 {i} 个任务:\")\n",
    "        print(f\"结果目录: {task['results_dir']}\")\n",
    "        print(f\"目标列名: {task['target_column']}\")\n",
    "        print(f\"{'='*60}\\n\")\n",
    "        \n",
    "        # 执行当前任务\n",
    "        retrain_results = retrain_all_models(\n",
    "            results_dir=task[\"results_dir\"],\n",
    "            target_column=task[\"target_column\"]\n",
    "        )\n",
    "        \n",
    "        print(f\"\\n第 {i} 个任务执行完成!\")\n",
    "        print(retrain_results)\n",
    "\n",
    "    print(\"\\n所有任务已全部执行完毕!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0057c6aa",
   "metadata": {},
   "source": [
    "## 综合三张图"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "515d6d9f",
   "metadata": {},
   "source": [
    "### 定义"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ccfa1022",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import joblib\n",
    "import os\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import json\n",
    "import traceback\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.base import BaseEstimator, RegressorMixin\n",
    "from torch.utils.data import TensorDataset, DataLoader\n",
    "import torch.optim as optim\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from scipy import stats\n",
    "import matplotlib.gridspec as gridspec\n",
    "from sklearn.inspection import permutation_importance, PartialDependenceDisplay\n",
    "from matplotlib.colors import LinearSegmentedColormap\n",
    "import matplotlib.font_manager as fm\n",
    "import time\n",
    "import warnings\n",
    "from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error\n",
    "from sklearn.model_selection import cross_val_score\n",
    "from sklearn.feature_selection import VarianceThreshold\n",
    "import gc\n",
    "import psutil\n",
    "import tracemalloc\n",
    "from functools import wraps\n",
    "\n",
    "# 忽略特定警告\n",
    "warnings.filterwarnings(\"ignore\", category=UserWarning, module=\"sklearn\")\n",
    "warnings.filterwarnings(\"ignore\", category=FutureWarning)\n",
    "warnings.filterwarnings(\"ignore\", category=RuntimeWarning)\n",
    "warnings.filterwarnings(\"ignore\", message=\"Linear regression equation is singular\", module=\"shap\")\n",
    "\n",
    "# 尝试导入CatBoost和SHAP\n",
    "try:\n",
    "    from catboost import CatBoostRegressor\n",
    "    CATBOOST_AVAILABLE = True\n",
    "except ImportError:\n",
    "    CATBOOST_AVAILABLE = False\n",
    "\n",
    "try:\n",
    "    import shap\n",
    "    SHAP_AVAILABLE = True\n",
    "except ImportError:\n",
    "    SHAP_AVAILABLE = False\n",
    "\n",
    "# ======================== 模型定义 ========================\n",
    "class PyTorchRegressor(BaseEstimator, RegressorMixin):\n",
    "    \"\"\"PyTorch Neural Network Regressor with GPU support\"\"\"\n",
    "    \n",
    "    def __init__(self, hidden_sizes=(100, 50), activation='relu', learning_rate=0.001,\n",
    "                 batch_size=32, epochs=100, dropout=0.2, early_stopping=True,\n",
    "                 patience=10, device=None):\n",
    "        self.hidden_sizes = hidden_sizes\n",
    "        self.activation = activation\n",
    "        self.learning_rate = learning_rate\n",
    "        self.batch_size = batch_size\n",
    "        self.epochs = epochs\n",
    "        self.dropout = dropout\n",
    "        self.early_stopping = early_stopping\n",
    "        self.patience = patience\n",
    "        self.device_str = device if device else ('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "        self.model = None\n",
    "        self.scaler_X = StandardScaler()\n",
    "        self.scaler_y = StandardScaler()\n",
    "        self.best_loss = float('inf')\n",
    "        self.input_dim = None\n",
    "        self.model_state_dict = None\n",
    "        self.training_history = []\n",
    "    \n",
    "    @property\n",
    "    def device(self):\n",
    "        return torch.device(self.device_str)\n",
    "    \n",
    "    def _build_model(self, input_dim):\n",
    "        layers = []\n",
    "        prev_size = input_dim\n",
    "        \n",
    "        for hidden_size in self.hidden_sizes:\n",
    "            layers.append(nn.Linear(prev_size, hidden_size))\n",
    "            layers.append(nn.BatchNorm1d(hidden_size))\n",
    "            \n",
    "            if self.activation == 'relu':\n",
    "                layers.append(nn.ReLU())\n",
    "            elif self.activation == 'tanh':\n",
    "                layers.append(nn.Tanh())\n",
    "            elif self.activation == 'leaky_relu':\n",
    "                layers.append(nn.LeakyReLU())\n",
    "            \n",
    "            layers.append(nn.Dropout(self.dropout))\n",
    "            prev_size = hidden_size\n",
    "        \n",
    "        layers.append(nn.Linear(prev_size, 1))\n",
    "        return nn.Sequential(*layers)\n",
    "    \n",
    "    def fit(self, X, y):\n",
    "        # 记录特征名称\n",
    "        if hasattr(X, 'columns'):\n",
    "            self.feature_names_in_ = X.columns.tolist()\n",
    "        else:\n",
    "            self.feature_names_in_ = [f'feature_{i}' for i in range(X.shape[1])]\n",
    "\n",
    "        if hasattr(X, 'values'):\n",
    "            X = X.values\n",
    "        if hasattr(y, 'values'):\n",
    "            y = y.values\n",
    "        \n",
    "        self.input_dim = X.shape[1]\n",
    "        \n",
    "        X_scaled = self.scaler_X.fit_transform(X)\n",
    "        y_scaled = self.scaler_y.fit_transform(y.reshape(-1, 1)).ravel()\n",
    "        \n",
    "        X_tensor = torch.FloatTensor(X_scaled).to(self.device)\n",
    "        y_tensor = torch.FloatTensor(y_scaled).to(self.device)\n",
    "        \n",
    "        dataset = TensorDataset(X_tensor, y_tensor)\n",
    "        loader = DataLoader(dataset, batch_size=self.batch_size, shuffle=True)\n",
    "        \n",
    "        self.model = self._build_model(X.shape[1]).to(self.device)\n",
    "        \n",
    "        criterion = nn.MSELoss()\n",
    "        optimizer = optim.Adam(self.model.parameters(), lr=self.learning_rate)\n",
    "        scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=5, factor=0.5)\n",
    "        \n",
    "        self.model.train()\n",
    "        patience_counter = 0\n",
    "        best_model_state = None\n",
    "        \n",
    "        for epoch in range(self.epochs):\n",
    "            epoch_loss = 0\n",
    "            for batch_X, batch_y in loader:\n",
    "                optimizer.zero_grad()\n",
    "                outputs = self.model(batch_X).squeeze()\n",
    "                loss = criterion(outputs, batch_y)\n",
    "                loss.backward()\n",
    "                optimizer.step()\n",
    "                epoch_loss += loss.item()\n",
    "            \n",
    "            avg_loss = epoch_loss / len(loader)\n",
    "            scheduler.step(avg_loss)\n",
    "            \n",
    "            current_lr = optimizer.param_groups[0]['lr']\n",
    "            self.training_history.append({\n",
    "                'epoch': epoch,\n",
    "                'loss': avg_loss,\n",
    "                'learning_rate': current_lr\n",
    "            })\n",
    "            \n",
    "            if self.early_stopping:\n",
    "                if avg_loss < self.best_loss:\n",
    "                    self.best_loss = avg_loss\n",
    "                    patience_counter = 0\n",
    "                    best_model_state = self.model.state_dict().copy()\n",
    "                else:\n",
    "                    patience_counter += 1\n",
    "                    if patience_counter >= self.patience:\n",
    "                        if best_model_state is not None:\n",
    "                            self.model.load_state_dict(best_model_state)\n",
    "                        break\n",
    "        \n",
    "        self.model_state_dict = self.model.state_dict()\n",
    "        return self\n",
    "    \n",
    "    def predict(self, X):\n",
    "        if hasattr(X, 'values'):\n",
    "            X = X.values\n",
    "        \n",
    "        if self.model is None and self.model_state_dict is not None:\n",
    "            self.model = self._build_model(self.input_dim).to(self.device)\n",
    "            self.model.load_state_dict(self.model_state_dict)\n",
    "        \n",
    "        X_scaled = self.scaler_X.transform(X)\n",
    "        X_tensor = torch.FloatTensor(X_scaled).to(self.device)\n",
    "        \n",
    "        self.model.eval()\n",
    "        with torch.no_grad():\n",
    "            predictions_scaled = self.model(X_tensor).cpu().numpy()\n",
    "        \n",
    "        predictions = self.scaler_y.inverse_transform(predictions_scaled)\n",
    "        return predictions.ravel()\n",
    "    \n",
    "    def __getstate__(self):\n",
    "        state = self.__dict__.copy()\n",
    "        if 'model' in state:\n",
    "            del state['model']\n",
    "        return state\n",
    "    \n",
    "    def __setstate__(self, state):\n",
    "        self.__dict__.update(state)\n",
    "        self.model = None\n",
    "\n",
    "# ======================== 模型工具函数 ========================\n",
    "def initialize_model(model_name, params):\n",
    "    \"\"\"初始化模型\"\"\"\n",
    "    if 'hidden_sizes' in params and isinstance(params['hidden_sizes'], list):\n",
    "        params['hidden_sizes'] = tuple(params['hidden_sizes'])\n",
    "    \n",
    "    if model_name == \"PyTorchNN\":\n",
    "        params.pop('results_dir', None)\n",
    "        params['device'] = 'cuda' if torch.cuda.is_available() else 'cpu'\n",
    "    \n",
    "    if model_name == \"Ridge\":\n",
    "        from sklearn.linear_model import Ridge\n",
    "        return Ridge(**params)\n",
    "    elif model_name == \"Lasso\":\n",
    "        from sklearn.linear_model import Lasso\n",
    "        return Lasso(** params)\n",
    "    elif model_name == \"ElasticNet\":\n",
    "        from sklearn.linear_model import ElasticNet\n",
    "        return ElasticNet(**params)\n",
    "    elif model_name == \"RandomForest\":\n",
    "        from sklearn.ensemble import RandomForestRegressor\n",
    "        return RandomForestRegressor(** params)\n",
    "    elif model_name == \"GradientBoosting\":\n",
    "        from sklearn.ensemble import GradientBoostingRegressor\n",
    "        return GradientBoostingRegressor(**params)\n",
    "    elif model_name == \"XGBoost\":\n",
    "        from xgboost import XGBRegressor\n",
    "        import xgboost as xgb\n",
    "        \n",
    "        # GPU支持\n",
    "        if xgb.cuda.is_available():\n",
    "            device = \"cuda\"\n",
    "        else:\n",
    "            device = \"cpu\"\n",
    "        \n",
    "        params['tree_method'] = 'hist'\n",
    "        params['device'] = device\n",
    "        params.pop('gpu_id', None)\n",
    "        params.pop('use_label_encoder', None)\n",
    "        \n",
    "        return XGBRegressor(** params)\n",
    "    elif model_name == \"LightGBM\":\n",
    "        from lightgbm import LGBMRegressor\n",
    "        return LGBMRegressor(**params)\n",
    "    elif model_name == \"PyTorchNN\":\n",
    "        return PyTorchRegressor(** params)\n",
    "    elif model_name == \"MLP\":\n",
    "        from sklearn.neural_network import MLPRegressor\n",
    "        return MLPRegressor(**params)\n",
    "    elif model_name == \"SVR\":\n",
    "        from sklearn.svm import SVR\n",
    "        return SVR(** params)\n",
    "    elif model_name == \"KNN\":\n",
    "        from sklearn.neighbors import KNeighborsRegressor\n",
    "        return KNeighborsRegressor(**params)\n",
    "    elif model_name == \"CatBoost\" and CATBOOST_AVAILABLE:\n",
    "        from catboost import CatBoostRegressor\n",
    "        return CatBoostRegressor(** params)\n",
    "    else:\n",
    "        raise ValueError(f\"Unsupported model: {model_name}\")\n",
    "\n",
    "def retrain_all_models(results_dir, target_column, model_names=None):\n",
    "    train_data_path = f\"{results_dir}/data_after_fe.csv\"\n",
    "    if not os.path.exists(train_data_path):\n",
    "        print(f\"训练数据文件不存在: {train_data_path}\")\n",
    "        return\n",
    "    \n",
    "    train_data = pd.read_csv(train_data_path)\n",
    "    X_train = train_data.drop(columns=[target_column])\n",
    "    y_train = train_data[target_column]\n",
    "    \n",
    "    tuning_log_path = f\"{results_dir}/tuning_log_details.json\"\n",
    "    if not os.path.exists(tuning_log_path):\n",
    "        print(f\"调优日志文件不存在: {tuning_log_path}\")\n",
    "        return\n",
    "    \n",
    "    with open(tuning_log_path, 'r', encoding='utf-8') as f:\n",
    "        tuning_log = json.load(f)\n",
    "    \n",
    "    models_dir = f\"{results_dir}/retrained_models\"\n",
    "    os.makedirs(models_dir, exist_ok=True)\n",
    "    \n",
    "    results = []\n",
    "    \n",
    "    for model_entry in tuning_log:\n",
    "        if model_entry.get('status') != 'success':\n",
    "            continue\n",
    "            \n",
    "        model_name = model_entry['model_name']\n",
    "        \n",
    "        if model_names is not None and model_name not in model_names:\n",
    "            continue\n",
    "        \n",
    "        best_params = model_entry.get('best_params', {})\n",
    "        \n",
    "        print(f\"\\n{'='*50}\")\n",
    "        print(f\"处理模型: {model_name}\")\n",
    "        print(f\"最佳参数: {best_params}\")\n",
    "        \n",
    "        try:\n",
    "            model = initialize_model(model_name, best_params.copy())\n",
    "            \n",
    "            pipeline = Pipeline([\n",
    "                ('scaler', StandardScaler()),\n",
    "                ('model', model)\n",
    "            ])\n",
    "            \n",
    "            print(f\"开始训练 {model_name}...\")\n",
    "            pipeline.fit(X_train, y_train)\n",
    "            print(f\"{model_name} 训练完成!\")\n",
    "            \n",
    "            model_save_path = f\"{models_dir}/{model_name}_model.pkl\"\n",
    "            joblib.dump(pipeline, model_save_path)\n",
    "            print(f\"模型已保存至: {model_save_path}\")\n",
    "            \n",
    "            results.append({\n",
    "                'model': model_name,\n",
    "                'status': 'success',\n",
    "                'save_path': model_save_path,\n",
    "                'parameters': best_params\n",
    "            })\n",
    "            \n",
    "        except Exception as e:\n",
    "            error_msg = f\"训练 {model_name} 时出错: {str(e)}\"\n",
    "            print(error_msg)\n",
    "            traceback.print_exc()\n",
    "            \n",
    "            results.append({\n",
    "                'model': model_name,\n",
    "                'status': 'error',\n",
    "                'error': error_msg,\n",
    "                'parameters': best_params\n",
    "            })\n",
    "    \n",
    "    results_df = pd.DataFrame(results)\n",
    "    results_path = f\"{results_dir}/retraining_results.csv\"\n",
    "    results_df.to_csv(results_path, index=False, encoding='utf-8')\n",
    "    print(f\"\\n所有模型重新训练结果已保存至: {results_path}\")\n",
    "    \n",
    "    return results_df\n",
    "\n",
    "# ======================== 可视化工具 ========================\n",
    "def set_chinese_font():\n",
    "    \"\"\"设置中文字体\"\"\"\n",
    "    font_path = None\n",
    "    system = os.name\n",
    "    \n",
    "    if system == 'nt':\n",
    "        font_path = r\"C:\\Windows\\Fonts\\simsun.ttc\"\n",
    "    elif system == 'posix':\n",
    "        font_path = \"/System/Library/Fonts/PingFang.ttc\"\n",
    "        if not os.path.exists(font_path):\n",
    "            font_path = \"/usr/share/fonts/truetype/droid/DroidSansFallbackFull.ttc\"\n",
    "    \n",
    "    if font_path and os.path.exists(font_path):\n",
    "        font_prop = fm.FontProperties(fname=font_path)\n",
    "        plt.rcParams['font.family'] = font_prop.get_name()\n",
    "        plt.rcParams['axes.unicode_minus'] = False\n",
    "    else:\n",
    "        print(\"未找到中文字体文件，将使用默认字体\")\n",
    "\n",
    "set_chinese_font()\n",
    "\n",
    "def render_fig_to_array(fig):\n",
    "    \"\"\"将图表转换为图像数组\"\"\"\n",
    "    fig.canvas.draw()\n",
    "    return np.array(fig.canvas.renderer.buffer_rgba())\n",
    "\n",
    "# ======================== 数据处理函数 ========================\n",
    "def load_test_data(config):\n",
    "    \"\"\"加载测试数据\"\"\"\n",
    "    data_path = config['DATA_PATH']\n",
    "    if not os.path.exists(data_path):\n",
    "        raise FileNotFoundError(f\"测试数据文件未找到: {data_path}\")\n",
    "    \n",
    "    test_data = joblib.load(data_path)\n",
    "    \n",
    "    required_keys = ['X_test', 'y_test', 'feature_names']\n",
    "    for key in required_keys:\n",
    "        if key not in test_data:\n",
    "            raise KeyError(f\"测试数据中缺少必需的键: {key}\")\n",
    "    \n",
    "    X_test = test_data['X_test']\n",
    "    if not isinstance(X_test, pd.DataFrame):\n",
    "        X_test = pd.DataFrame(X_test, columns=test_data['feature_names'])\n",
    "    \n",
    "    y_test = test_data['y_test']\n",
    "    \n",
    "    if isinstance(y_test, pd.Series):\n",
    "        X_test.index = range(len(X_test))\n",
    "        y_test.index = range(len(y_test))\n",
    "    else:\n",
    "        y_test = pd.Series(y_test, index=range(len(y_test)))\n",
    "    \n",
    "    if len(X_test) > config['MAX_SAMPLES']:\n",
    "        sample_indices = np.random.choice(\n",
    "            len(X_test), \n",
    "            min(config['MAX_SAMPLES'], len(X_test)), \n",
    "            replace=False\n",
    "        )\n",
    "        X_test = X_test.iloc[sample_indices]\n",
    "        y_test = y_test.iloc[sample_indices]\n",
    "        print(f\"使用{len(X_test)}个样本代替完整测试集({len(test_data['y_test'])}个样本)\")\n",
    "    \n",
    "    return X_test, y_test, test_data['feature_names']\n",
    "\n",
    "def load_retrained_models(config):\n",
    "    \"\"\"加载重新训练的模型\"\"\"\n",
    "    models_dir = config['MODELS_DIR']\n",
    "    model_names = config.get('model_names')\n",
    "    \n",
    "    if not os.path.exists(models_dir):\n",
    "        raise FileNotFoundError(f\"模型目录不存在: {models_dir}\")\n",
    "    \n",
    "    models = {}\n",
    "    model_files = [f for f in os.listdir(models_dir) if f.endswith(\".pkl\")]\n",
    "    \n",
    "    if model_names is not None:\n",
    "        target_files = [f\"{name}_model.pkl\" for name in model_names]\n",
    "        model_files = [f for f in model_files if f in target_files]\n",
    "    else:\n",
    "        available_models = [f.replace(\"_model.pkl\", \"\") for f in model_files]\n",
    "        print(f\"可用模型: {available_models}\")\n",
    "    \n",
    "    model_files.sort()\n",
    "    \n",
    "    for model_file in model_files:\n",
    "        model_name = model_file.replace(\"_model.pkl\", \"\")\n",
    "        model_path = os.path.join(models_dir, model_file)\n",
    "        try:\n",
    "            models[model_name] = joblib.load(model_path)\n",
    "            print(f\"成功加载模型: {model_name}\")\n",
    "        except Exception as e:\n",
    "            print(f\"加载模型 {model_file} 失败: {str(e)}\")\n",
    "    \n",
    "    if not models:\n",
    "        raise ValueError(f\"在目录 {models_dir} 中未找到有效的模型文件\")\n",
    "    \n",
    "    return models\n",
    "\n",
    "def get_model_features(model):\n",
    "    \"\"\"获取模型特征名称\"\"\"\n",
    "    try:\n",
    "        if hasattr(model, 'feature_names_in_'):\n",
    "            return model.feature_names_in_\n",
    "        \n",
    "        if isinstance(model, Pipeline):\n",
    "            last_step = model.steps[-1][1]\n",
    "            if hasattr(last_step, 'feature_names_in_'):\n",
    "                return last_step.feature_names_in_\n",
    "            if hasattr(last_step, 'get_booster'):\n",
    "                return last_step.get_booster().feature_names\n",
    "        \n",
    "        if hasattr(model, 'feature_importances_') and hasattr(model, 'feature_name_'):\n",
    "            return model.feature_name_\n",
    "        \n",
    "        if hasattr(model, 'coef_') and hasattr(model, 'feature_names_in_'):\n",
    "            return model.feature_names_in_\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"获取模型特征名称失败: {str(e)}\")\n",
    "    \n",
    "    return None\n",
    "\n",
    "def align_features(X_test, model_features):\n",
    "    \"\"\"特征对齐\"\"\"\n",
    "    if model_features is None:\n",
    "        return X_test\n",
    "    \n",
    "    missing_features = set(model_features) - set(X_test.columns)\n",
    "    if missing_features:\n",
    "        print(f\"警告: 测试数据缺少 {len(missing_features)} 个特征: {list(missing_features)[:5]}...\")\n",
    "        \n",
    "        for feature in missing_features:\n",
    "            X_test[feature] = 0\n",
    "    \n",
    "    try:\n",
    "        return X_test[model_features]\n",
    "    except KeyError as e:\n",
    "        print(f\"特征对齐失败: {str(e)}\")\n",
    "        return X_test\n",
    "\n",
    "# ======================== 评估函数 ========================\n",
    "def calculate_model_metrics(models, X_test, y_test, config):\n",
    "    \"\"\"计算模型评估指标\"\"\"\n",
    "    metrics = []\n",
    "    for name, model in models.items():\n",
    "        try:\n",
    "            model_features = get_model_features(model)\n",
    "            \n",
    "            X_test_aligned = align_features(X_test.copy(), model_features)\n",
    "            \n",
    "            if len(X_test_aligned) > config['MAX_SAMPLES']:\n",
    "                sample_indices = np.random.choice(\n",
    "                    len(X_test_aligned), \n",
    "                    config['MAX_SAMPLES'], \n",
    "                    replace=False\n",
    "                )\n",
    "                X_sample = X_test_aligned.iloc[sample_indices]\n",
    "                y_sample = y_test.iloc[sample_indices]\n",
    "            else:\n",
    "                X_sample = X_test_aligned\n",
    "                y_sample = y_test\n",
    "                \n",
    "            if isinstance(X_sample, pd.DataFrame):\n",
    "                X_sample = X_sample.values\n",
    "                \n",
    "            y_pred = model.predict(X_sample)\n",
    "            \n",
    "            abs_y_sample = np.abs(y_sample)\n",
    "            with np.errstate(divide='ignore', invalid='ignore'):\n",
    "                mape = np.mean(np.abs((y_sample - y_pred) / abs_y_sample)) * 100\n",
    "                mape = np.where(np.isinf(mape) | np.isnan(mape), 0, mape)\n",
    "            \n",
    "            metrics.append({\n",
    "                \"Model\": name,\n",
    "                \"R²\": r2_score(y_sample, y_pred),\n",
    "                \"RMSE\": np.sqrt(mean_squared_error(y_sample, y_pred)),\n",
    "                \"MAE\": mean_absolute_error(y_sample, y_pred),\n",
    "                \"MAPE\": mape\n",
    "            })\n",
    "        except Exception as e:\n",
    "            print(f\"计算 {name} 模型指标时出错: {str(e)}\")\n",
    "    \n",
    "    if not metrics:\n",
    "        raise ValueError(\"没有成功计算任何模型的指标，请检查模型和数据\")\n",
    "    \n",
    "    return pd.DataFrame(metrics).sort_values(\"R²\", ascending=False)\n",
    "\n",
    "# ======================== 可视化分析函数 ========================\n",
    "def plot_comprehensive_model_analysis(metrics_df, model, model_name, X_test, y_test, feature_names, results_dir, config):\n",
    "    \"\"\"绘制综合分析图\"\"\"\n",
    "    try:\n",
    "        start_time = time.time()\n",
    "        print(f\"开始生成 {model_name} 的综合分析图...\")\n",
    "        \n",
    "        # 创建模型专属文件夹和子图文件夹\n",
    "        model_dir = os.path.join(results_dir, f\"{model_name}_analysis\")\n",
    "        os.makedirs(model_dir, exist_ok=True)\n",
    "        subfig_dir = os.path.join(model_dir, \"subfigures\")\n",
    "        os.makedirs(subfig_dir, exist_ok=True)\n",
    "        \n",
    "        model_features = get_model_features(model)\n",
    "        X_test_aligned = align_features(X_test.copy(), model_features)\n",
    "        \n",
    "        # 采样确保样本量充足\n",
    "        sample_size = min(config['MAX_SAMPLES'], len(X_test_aligned))\n",
    "        if len(X_test_aligned) > sample_size:\n",
    "            sample_indices = np.random.choice(len(X_test_aligned), sample_size, replace=False)\n",
    "            X_sample = X_test_aligned.iloc[sample_indices]\n",
    "            y_sample = y_test.iloc[sample_indices]\n",
    "        else:\n",
    "            X_sample = X_test_aligned\n",
    "            y_sample = y_test\n",
    "        \n",
    "        # 计算预测值和残差\n",
    "        y_pred = model.predict(X_sample)\n",
    "        residuals = y_sample - y_pred\n",
    "        \n",
    "        # 网格布局\n",
    "        fig = plt.figure(figsize=(18, 22))\n",
    "        gs = gridspec.GridSpec(4, 3, height_ratios=[1, 1.2, 1, 1.2])\n",
    "        \n",
    "        # (a) 特征重要性Top 10\n",
    "        ax1 = plt.subplot(gs[0, 0])\n",
    "        importance_df = None\n",
    "        try:\n",
    "            top_n = min(10, len(feature_names))\n",
    "            result = permutation_importance(\n",
    "                model, X_sample, y_sample, \n",
    "                n_repeats=5, \n",
    "                random_state=config['RANDOM_STATE'], \n",
    "                n_jobs=-1\n",
    "            )\n",
    "            \n",
    "            sorted_idx = result.importances_mean.argsort()[::-1]\n",
    "            top_features = [feature_names[i] for i in sorted_idx[:top_n]]\n",
    "            top_importances = result.importances_mean[sorted_idx[:top_n]]\n",
    "            \n",
    "            importance_df = pd.DataFrame({\n",
    "                \"Feature\": top_features,\n",
    "                \"Importance\": top_importances\n",
    "            })\n",
    "            \n",
    "            sns.barplot(x=\"Importance\", y=\"Feature\", data=importance_df, \n",
    "                       ax=ax1, palette=\"rocket\")\n",
    "            ax1.set_title(\"(a) 特征重要性Top 10\", fontsize=14, fontweight='bold')\n",
    "            ax1.set_xlabel(\"重要性分数\")\n",
    "            ax1.set_ylabel(\"\")\n",
    "            for i, v in enumerate(importance_df['Importance']):\n",
    "                ax1.text(v + 0.01, i, f'{v:.4f}', ha='left', va='center', fontsize=10)\n",
    "            \n",
    "            # 单独保存特征重要性图\n",
    "            fig1, ax1_sub = plt.subplots(figsize=(10, 6))\n",
    "            sns.barplot(x=\"Importance\", y=\"Feature\", data=importance_df, \n",
    "                       ax=ax1_sub, palette=\"rocket\")\n",
    "            ax1_sub.set_title(f\"{model_name} 特征重要性Top 10\", fontsize=14, fontweight='bold')\n",
    "            ax1_sub.set_xlabel(\"重要性分数\")\n",
    "            ax1_sub.set_ylabel(\"\")\n",
    "            for i, v in enumerate(importance_df['Importance']):\n",
    "                ax1_sub.text(v + 0.01, i, f'{v:.4f}', ha='left', va='center', fontsize=10)\n",
    "            fig1.tight_layout()\n",
    "            fig1.savefig(os.path.join(subfig_dir, f\"{model_name}_feature_importance.png\"), dpi=config['DPI'])\n",
    "            plt.close(fig1)\n",
    "        except Exception as e:\n",
    "            print(f\"获取特征重要性失败: {str(e)}\")\n",
    "            ax1.text(0.5, 0.5, \"特征重要性不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax1.set_title(\"(a) 特征重要性\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # (b) 残差分布\n",
    "        ax2 = plt.subplot(gs[0, 1])\n",
    "        try:\n",
    "            sns.histplot(residuals, kde=True, ax=ax2, stat='density', color='skyblue')\n",
    "            ax2.axvline(0, color='r', linestyle='--', alpha=0.7)\n",
    "            ax2.set_title(\"(b) 残差分布\", fontsize=14, fontweight='bold')\n",
    "            ax2.set_xlabel(\"残差\")\n",
    "            if len(residuals) > 2:\n",
    "                skewness = stats.skew(residuals)\n",
    "                kurtosis = stats.kurtosis(residuals)\n",
    "                ax2.text(0.95, 0.95, f'偏度: {skewness:.3f}\\n峰度: {kurtosis:.3f}', \n",
    "                         transform=ax2.transAxes, ha='right', va='top', fontsize=10,\n",
    "                         bbox=dict(facecolor='white', alpha=0.8))\n",
    "            \n",
    "            # 单独保存残差分布图\n",
    "            fig2, ax2_sub = plt.subplots(figsize=(10, 6))\n",
    "            sns.histplot(residuals, kde=True, ax=ax2_sub, stat='density', color='skyblue')\n",
    "            ax2_sub.axvline(0, color='r', linestyle='--', alpha=0.7)\n",
    "            ax2_sub.set_title(f\"{model_name} 残差分布\", fontsize=14, fontweight='bold')\n",
    "            ax2_sub.set_xlabel(\"残差\")\n",
    "            if len(residuals) > 2:\n",
    "                ax2_sub.text(0.95, 0.95, f'偏度: {skewness:.3f}\\n峰度: {kurtosis:.3f}', \n",
    "                             transform=ax2_sub.transAxes, ha='right', va='top', fontsize=10,\n",
    "                             bbox=dict(facecolor='white', alpha=0.8))\n",
    "            fig2.tight_layout()\n",
    "            fig2.savefig(os.path.join(subfig_dir, f\"{model_name}_residual_distribution.png\"), dpi=config['DPI'])\n",
    "            plt.close(fig2)\n",
    "        except Exception as e:\n",
    "            print(f\"生成残差分布图失败: {str(e)}\")\n",
    "            ax2.text(0.5, 0.5, \"残差分布不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax2.set_title(\"(b) 残差分布\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # (c) 实际值 vs 预测值\n",
    "        ax3 = plt.subplot(gs[1, :])\n",
    "        try:\n",
    "            cmap = LinearSegmentedColormap.from_list(\"custom\", [\"#2c7bb6\", \"#abd9e9\", \"#ffffbf\", \"#fdae61\", \"#d7191c\"])\n",
    "            hb = ax3.hexbin(y_sample, y_pred, gridsize=50, cmap=cmap, bins='log', mincnt=1)\n",
    "            cb = fig.colorbar(hb, ax=ax3)\n",
    "            cb.set_label('数据点对数密度')\n",
    "            min_val = min(y_sample.min(), y_pred.min())\n",
    "            max_val = max(y_sample.max(), y_pred.max())\n",
    "            ax3.plot([min_val, max_val], [min_val, max_val], 'k--', linewidth=2, label='完美预测')\n",
    "            if len(y_sample) > 1:\n",
    "                slope, intercept, r_value, p_value, std_err = stats.linregress(y_sample, y_pred)\n",
    "                line_x = np.linspace(min_val, max_val, 100)\n",
    "                line_y = intercept + slope * line_x\n",
    "                ax3.plot(line_x, line_y, 'r-', linewidth=2, label='回归拟合')\n",
    "            ax3.set_xlabel(\"实际值\", fontsize=12)\n",
    "            ax3.set_ylabel(\"预测值\", fontsize=12)\n",
    "            ax3.set_title(f\"(c) 实际值 vs 预测值: {model_name} (R²={r2_score(y_sample, y_pred):.4f})\", \n",
    "                         fontsize=14, fontweight='bold')\n",
    "            ax3.legend(loc='upper right')\n",
    "            if len(y_sample) > 1:\n",
    "                ax3.text(0.05, 0.95, f'回归方程: y = {slope:.4f}x + {intercept:.4f}\\nR² = {r_value**2:.4f}', \n",
    "                         transform=ax3.transAxes, ha='left', va='top', fontsize=10,\n",
    "                         bbox=dict(facecolor='white', alpha=0.8))\n",
    "            \n",
    "            # 单独保存实际值 vs 预测值图\n",
    "            fig3, ax3_sub = plt.subplots(figsize=(10, 8))\n",
    "            hb_sub = ax3_sub.hexbin(y_sample, y_pred, gridsize=50, cmap=cmap, bins='log', mincnt=1)\n",
    "            cb_sub = fig3.colorbar(hb_sub, ax=ax3_sub)\n",
    "            cb_sub.set_label('数据点对数密度')\n",
    "            ax3_sub.plot([min_val, max_val], [min_val, max_val], 'k--', linewidth=2, label='完美预测')\n",
    "            if len(y_sample) > 1:\n",
    "                ax3_sub.plot(line_x, line_y, 'r-', linewidth=2, label='回归拟合')\n",
    "            ax3_sub.set_xlabel(\"实际值\", fontsize=12)\n",
    "            ax3_sub.set_ylabel(\"预测值\", fontsize=12)\n",
    "            ax3_sub.set_title(f\"{model_name} 实际值 vs 预测值 (R²={r2_score(y_sample, y_pred):.4f})\", \n",
    "                             fontsize=14, fontweight='bold')\n",
    "            ax3_sub.legend(loc='upper right')\n",
    "            if len(y_sample) > 1:\n",
    "                ax3_sub.text(0.05, 0.95, f'回归方程: y = {slope:.4f}x + {intercept:.4f}\\nR² = {r_value**2:.4f}', \n",
    "                             transform=ax3_sub.transAxes, ha='left', va='top', fontsize=10,\n",
    "                             bbox=dict(facecolor='white', alpha=0.8))\n",
    "            fig3.tight_layout()\n",
    "            fig3.savefig(os.path.join(subfig_dir, f\"{model_name}_actual_vs_predicted.png\"), dpi=config['DPI'])\n",
    "            plt.close(fig3)\n",
    "        except Exception as e:\n",
    "            print(f\"生成实际值vs预测值图失败: {str(e)}\")\n",
    "            ax3.text(0.5, 0.5, \"实际值vs预测值图不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax3.set_title(\"(c) 实际值 vs 预测值\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # (d) 部分依赖图\n",
    "        ax4 = plt.subplot(gs[2, 0])\n",
    "        try:\n",
    "            if importance_df is not None and not importance_df.empty and len(feature_names) > 0:\n",
    "                top_feature = importance_df.iloc[0]['Feature']\n",
    "                fig_pdp, ax_pdp = plt.subplots(figsize=(8, 6))\n",
    "                try:\n",
    "                    PartialDependenceDisplay.from_estimator(\n",
    "                        model, X_sample, [top_feature], \n",
    "                        ax=ax_pdp, \n",
    "                        line_kw={\"color\": \"darkred\", \"linewidth\": 3},\n",
    "                        kind='average',\n",
    "                        grid_resolution=20\n",
    "                    )\n",
    "                    # 单独保存部分依赖图\n",
    "                    fig_pdp.savefig(os.path.join(subfig_dir, f\"{model_name}_pdp_{top_feature}.png\"), dpi=config['DPI'])\n",
    "                except Exception as e:\n",
    "                    print(f\"部分依赖图计算失败: {str(e)}\")\n",
    "                    ax_pdp.text(0.5, 0.5, \"部分依赖图不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "                \n",
    "                ax4.imshow(render_fig_to_array(fig_pdp))\n",
    "                plt.close(fig_pdp)\n",
    "                ax4.set_title(f\"(d) 部分依赖图: {top_feature}\", fontsize=14, fontweight='bold')\n",
    "                ax4.axis('off')\n",
    "            else:\n",
    "                ax4.text(0.5, 0.5, \"部分依赖图不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "                ax4.set_title(\"(d) 部分依赖图\", fontsize=14, fontweight='bold')\n",
    "        except Exception as e:\n",
    "            print(f\"生成部分依赖图失败: {str(e)}\")\n",
    "            ax4.text(0.5, 0.5, \"部分依赖图不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax4.set_title(\"(d) 部分依赖图\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # (e) 特征交互热力图\n",
    "        ax5 = plt.subplot(gs[2, 1])\n",
    "        try:\n",
    "            if importance_df is not None and not importance_df.empty and len(feature_names) > 1:\n",
    "                feat1 = importance_df.iloc[0]['Feature']\n",
    "                feat2 = importance_df.iloc[1]['Feature']\n",
    "                \n",
    "                sample_size = min(200, len(X_sample))\n",
    "                sample_indices = np.random.choice(len(X_sample), sample_size, replace=False)\n",
    "                X_small = X_sample.iloc[sample_indices]\n",
    "                \n",
    "                heatmap_data = pd.DataFrame({\n",
    "                    feat1: X_small[feat1],\n",
    "                    feat2: X_small[feat2],\n",
    "                    'Prediction': model.predict(X_small)\n",
    "                })\n",
    "                \n",
    "                heatmap_data['feat1_bin'] = pd.cut(heatmap_data[feat1], bins=10)\n",
    "                heatmap_data['feat2_bin'] = pd.cut(heatmap_data[feat2], bins=10)\n",
    "                pivot_table = heatmap_data.groupby(['feat1_bin', 'feat2_bin'])['Prediction'].mean().unstack()\n",
    "                \n",
    "                sns.heatmap(pivot_table, cmap='viridis', ax=ax5, cbar_kws={'label': '预测值'})\n",
    "                ax5.set_title(f\"(e) 特征交互热力图: {feat1} vs {feat2}\", fontsize=14, fontweight='bold')\n",
    "                ax5.set_xlabel(feat1)\n",
    "                ax5.set_ylabel(feat2)\n",
    "                \n",
    "                # 单独保存特征交互热力图\n",
    "                fig5, ax5_sub = plt.subplots(figsize=(10, 8))\n",
    "                sns.heatmap(pivot_table, cmap='viridis', ax=ax5_sub, cbar_kws={'label': '预测值'})\n",
    "                ax5_sub.set_title(f\"{model_name} 特征交互热力图: {feat1} vs {feat2}\", fontsize=14, fontweight='bold')\n",
    "                ax5_sub.set_xlabel(feat1)\n",
    "                ax5_sub.set_ylabel(feat2)\n",
    "                fig5.tight_layout()\n",
    "                fig5.savefig(os.path.join(subfig_dir, f\"{model_name}_feature_interaction.png\"), dpi=config['DPI'])\n",
    "                plt.close(fig5)\n",
    "            else:\n",
    "                ax5.text(0.5, 0.5, \"特征交互图不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "                ax5.set_title(\"(e) 特征交互图\", fontsize=14, fontweight='bold')\n",
    "        except Exception as e:\n",
    "            print(f\"生成特征交互图失败: {str(e)}\")\n",
    "            ax5.text(0.5, 0.5, \"特征交互图不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax5.set_title(\"(e) 特征交互图\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # (f) 相对误差分布\n",
    "        ax6 = plt.subplot(gs[2, 2])\n",
    "        try:\n",
    "            error = np.abs(y_pred - y_sample)\n",
    "            abs_y_sample = np.abs(y_sample)\n",
    "            with np.errstate(divide='ignore', invalid='ignore'):\n",
    "                relative_error = error / abs_y_sample\n",
    "                relative_error = np.where(np.isinf(relative_error) | np.isnan(relative_error), 0, relative_error)\n",
    "            \n",
    "            sns.kdeplot(relative_error, ax=ax6, color='purple', fill=True)\n",
    "            ax6.axvline(np.median(relative_error), color='r', linestyle='--', alpha=0.7)\n",
    "            ax6.set_title(\"(f) 相对误差分布\", fontsize=14, fontweight='bold')\n",
    "            ax6.set_xlabel(\"相对误差\")\n",
    "            \n",
    "            median_error = np.median(relative_error)\n",
    "            iqr = np.percentile(relative_error, 75) - np.percentile(relative_error, 25)\n",
    "            ax6.text(0.95, 0.95, f'中位数: {median_error:.3f}\\nIQR: {iqr:.3f}', \n",
    "                     transform=ax6.transAxes, ha='right', va='top', fontsize=10,\n",
    "                     bbox=dict(facecolor='white', alpha=0.8))\n",
    "            \n",
    "            # 单独保存相对误差分布图\n",
    "            fig6, ax6_sub = plt.subplots(figsize=(10, 6))\n",
    "            sns.kdeplot(relative_error, ax=ax6_sub, color='purple', fill=True)\n",
    "            ax6_sub.axvline(np.median(relative_error), color='r', linestyle='--', alpha=0.7)\n",
    "            ax6_sub.set_title(f\"{model_name} 相对误差分布\", fontsize=14, fontweight='bold')\n",
    "            ax6_sub.set_xlabel(\"相对误差\")\n",
    "            ax6_sub.text(0.95, 0.95, f'中位数: {median_error:.3f}\\nIQR: {iqr:.3f}', \n",
    "                         transform=ax6_sub.transAxes, ha='right', va='top', fontsize=10,\n",
    "                         bbox=dict(facecolor='white', alpha=0.8))\n",
    "            fig6.tight_layout()\n",
    "            fig6.savefig(os.path.join(subfig_dir, f\"{model_name}_relative_error.png\"), dpi=config['DPI'])\n",
    "            plt.close(fig6)\n",
    "        except Exception as e:\n",
    "            print(f\"生成相对误差分布失败: {str(e)}\")\n",
    "            ax6.text(0.5, 0.5, \"相对误差分布不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax6.set_title(\"(f) 相对误差分布\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # (g) 预测区间分析\n",
    "        ax7 = plt.subplot(gs[3, :])\n",
    "        try:\n",
    "            sample_size = min(300, len(X_sample))\n",
    "            sample_indices = np.random.choice(len(X_sample), sample_size, replace=False)\n",
    "            X_plot = X_sample.iloc[sample_indices]\n",
    "            y_plot = y_sample.iloc[sample_indices]\n",
    "            y_pred_plot = y_pred[sample_indices]\n",
    "\n",
    "            sort_idx = np.argsort(y_pred_plot)\n",
    "            y_pred_sorted = y_pred_plot[sort_idx]\n",
    "            y_actual_sorted = y_plot.iloc[sort_idx].values\n",
    "\n",
    "            error = y_actual_sorted - y_pred_sorted\n",
    "            std_error = np.std(error)\n",
    "            n = len(error)\n",
    "            z_score = 1.96\n",
    "            prediction_interval = z_score * std_error\n",
    "\n",
    "            r2 = r2_score(y_actual_sorted, y_pred_sorted)\n",
    "            rmse = np.sqrt(mean_squared_error(y_actual_sorted, y_pred_sorted))\n",
    "\n",
    "            ax7.fill_between(\n",
    "                y_pred_sorted,\n",
    "                y_pred_sorted - prediction_interval,\n",
    "                y_pred_sorted + prediction_interval,\n",
    "                color='lightblue',\n",
    "                alpha=0.5,\n",
    "                label='95%预测区间'\n",
    "            )\n",
    "\n",
    "            ax7.plot(y_pred_sorted, y_pred_sorted, 'r-', linewidth=2, label='完美预测')\n",
    "            ax7.scatter(y_pred_sorted, y_actual_sorted, \n",
    "                        c=np.abs(error), \n",
    "                        cmap='viridis', \n",
    "                        alpha=0.9, \n",
    "                        s=50, \n",
    "                        edgecolor='k')\n",
    "\n",
    "            ax7.set_xlabel(\"预测值\", fontsize=12)\n",
    "            ax7.set_ylabel(\"实际值\", fontsize=12)\n",
    "            ax7.set_title(f\"(g) 预测区间分析: {model_name}\", fontsize=14, fontweight='bold')\n",
    "\n",
    "            ax7.legend(bbox_to_anchor=(0.01, 0.75), loc='center left')\n",
    "            ax7.text(0.01, 0.85, \n",
    "                     f'R² = {r2:.4f}\\nRMSE = {rmse:.4f}\\n预测区间宽度 = {2*prediction_interval:.4f}', \n",
    "                     transform=ax7.transAxes, \n",
    "                     fontsize=10,\n",
    "                     bbox=dict(facecolor='white', alpha=0.8))\n",
    "\n",
    "            # 单独保存预测区间分析图\n",
    "            fig7, ax7_sub = plt.subplots(figsize=(12, 8))\n",
    "            ax7_sub.fill_between(\n",
    "                y_pred_sorted,\n",
    "                y_pred_sorted - prediction_interval,\n",
    "                y_pred_sorted + prediction_interval,\n",
    "                color='lightblue',\n",
    "                alpha=0.5,\n",
    "                label='95%预测区间'\n",
    "            )\n",
    "            ax7_sub.plot(y_pred_sorted, y_pred_sorted, 'r-', linewidth=2, label='完美预测')\n",
    "            ax7_sub.scatter(y_pred_sorted, y_actual_sorted, \n",
    "                            c=np.abs(error), \n",
    "                            cmap='viridis', \n",
    "                            alpha=0.9, \n",
    "                            s=50, \n",
    "                            edgecolor='k')\n",
    "            ax7_sub.set_xlabel(\"预测值\", fontsize=12)\n",
    "            ax7_sub.set_ylabel(\"实际值\", fontsize=12)\n",
    "            ax7_sub.set_title(f\"{model_name} 预测区间分析\", fontsize=14, fontweight='bold')\n",
    "            ax7_sub.legend(bbox_to_anchor(0.01, 0.75), loc='center left')\n",
    "            ax7_sub.text(0.01, 0.85, \n",
    "                         f'R² = {r2:.4f}\\nRMSE = {rmse:.4f}\\n预测区间宽度 = {2*prediction_interval:.4f}', \n",
    "                         transform=ax7_sub.transAxes, \n",
    "                         fontsize=10,\n",
    "                         bbox=dict(facecolor='white', alpha=0.8))\n",
    "            fig7.tight_layout()\n",
    "            fig7.savefig(os.path.join(subfig_dir, f\"{model_name}_prediction_interval.png\"), dpi=config['DPI'])\n",
    "            plt.close(fig7)\n",
    "\n",
    "        except Exception as e:\n",
    "            print(f\"生成预测区间失败: {str(e)}\")\n",
    "            ax7.text(0.5, 0.5, \"预测区间分析不可用\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax7.set_title(\"(g) 预测区间分析\", fontsize=14, fontweight='bold')        \n",
    "\n",
    "        plt.tight_layout()\n",
    "        plt.subplots_adjust(top=0.94)\n",
    "        plt.suptitle(f\"{model_name}模型的综合分析图\", fontsize=16, fontweight='bold', y=0.98)\n",
    "        \n",
    "        # 保存综合分析图\n",
    "        fig_path = os.path.join(model_dir, f\"{model_name}_comprehensive_analysis.png\")\n",
    "        plt.savefig(fig_path, dpi=config['DPI'], bbox_inches='tight')\n",
    "        plt.close(fig)\n",
    "        \n",
    "        end_time = time.time()\n",
    "        print(f\"{model_name}的综合分析图生成完成，耗时{end_time - start_time:.2f}秒\")\n",
    "        \n",
    "        return {\n",
    "            \"comprehensive\": fig_path,\n",
    "            \"subfigures\": subfig_dir\n",
    "        }\n",
    "    except Exception as e:\n",
    "        print(f\"生成综合分析图时出错: {str(e)}\")\n",
    "        traceback.print_exc()\n",
    "        return None\n",
    "\n",
    "def plot_model_performance_decomposition(model, model_name, X_test, y_test, config, results_dir):\n",
    "    \"\"\"绘制模型性能分解图\"\"\"\n",
    "    try:\n",
    "        start_time = time.time()\n",
    "        print(f\"开始生成 {model_name} 的模型性能分解图...\")\n",
    "        \n",
    "        # 获取模型特征并对齐\n",
    "        model_features = get_model_features(model)\n",
    "        X_test_aligned = align_features(X_test.copy(), model_features)\n",
    "        \n",
    "        # 采样处理\n",
    "        if len(X_test_aligned) > config['MAX_SAMPLES']:\n",
    "            sample_indices = np.random.choice(\n",
    "                len(X_test_aligned), \n",
    "                config['MAX_SAMPLES'], \n",
    "                replace=False\n",
    "            )\n",
    "            X_sample = X_test_aligned.iloc[sample_indices]\n",
    "            y_sample = y_test.iloc[sample_indices]\n",
    "        else:\n",
    "            X_sample = X_test_aligned\n",
    "            y_sample = y_test\n",
    " \n",
    "        # 获取预测值\n",
    "        y_pred = model.predict(X_sample)\n",
    "        \n",
    "        # 转换为 NumPy 数组\n",
    "        y_sample_np = y_sample.values\n",
    "        y_pred_np = y_pred\n",
    "        \n",
    "        # 创建图表\n",
    "        fig = plt.figure(figsize=(12, 8))\n",
    "        \n",
    "        # 按目标值分位数分组\n",
    "        if len(y_sample_np) > 10:\n",
    "            # 使用 NumPy 进行分位数计算\n",
    "            quantiles = np.linspace(0, 1, 6)  # 5个分箱需要6个分位点\n",
    "            bin_edges = np.quantile(y_sample_np, quantiles)\n",
    "            bin_centers = (bin_edges[1:] + bin_edges[:-1]) / 2\n",
    "            \n",
    "            group_r2 = []\n",
    "            group_rmse = []\n",
    "            \n",
    "            for i in range(len(bin_edges) - 1):\n",
    "                mask = (y_sample_np >= bin_edges[i]) & (y_sample_np < bin_edges[i+1])\n",
    "                group_y_true = y_sample_np[mask]\n",
    "                group_y_pred = y_pred_np[mask]\n",
    "                \n",
    "                if len(group_y_true) > 1:\n",
    "                    group_r2.append(r2_score(group_y_true, group_y_pred))\n",
    "                    group_rmse.append(np.sqrt(mean_squared_error(group_y_true, group_y_pred)))\n",
    "                else:\n",
    "                    group_r2.append(np.nan)\n",
    "                    group_rmse.append(np.nan)\n",
    "                \n",
    "                # 手动释放内存\n",
    "                del group_y_true, group_y_pred\n",
    "                gc.collect()\n",
    "            \n",
    "            # 绘制双轴图\n",
    "            ax = fig.add_subplot(111)\n",
    "            ax2 = ax.twinx()\n",
    "            \n",
    "            l1 = ax.plot(bin_centers, group_r2, 'o-', color='blue', label='R²', linewidth=2)\n",
    "            l2 = ax2.plot(bin_centers, group_rmse, 's-', color='red', label='RMSE', linewidth=2)\n",
    "            \n",
    "            ax.set_xlabel(\"目标值分位数中点\")\n",
    "            ax.set_ylabel(\"R²\", color='blue')\n",
    "            ax2.set_ylabel(\"RMSE\", color='red')\n",
    "            \n",
    "            ax.tick_params(axis='y', labelcolor='blue')\n",
    "            ax2.tick_params(axis='y', labelcolor='red')\n",
    "            \n",
    "            ax.set_title(f\"{model_name} 模型性能分解图\", fontsize=14, fontweight='bold')\n",
    "            \n",
    "            # 合并图例\n",
    "            lines = l1 + l2\n",
    "            labels = [l.get_label() for l in lines]\n",
    "            ax.legend(lines, labels, loc='upper center')\n",
    "            \n",
    "            # 添加网格线\n",
    "            ax.grid(True, linestyle='--', alpha=0.6)\n",
    "        else:\n",
    "            ax = fig.add_subplot(111)\n",
    "            ax.text(0.5, 0.5, \"样本量不足，无法分解性能\", ha=\"center\", va=\"center\", fontsize=12)\n",
    "            ax.set_title(f\"{model_name} 模型性能分解图\", fontsize=14, fontweight='bold')\n",
    "        \n",
    "        # 保存图表\n",
    "        fig_path = os.path.join(results_dir, f\"{model_name}_performance_decomposition.png\")\n",
    "        plt.savefig(fig_path, dpi=config['DPI'], bbox_inches='tight')\n",
    "        plt.close(fig)\n",
    "        \n",
    "        elapsed = time.time() - start_time\n",
    "        print(f\"成功生成 {model_name} 的模型性能分解图，耗时: {elapsed:.1f}秒\")\n",
    "        return fig_path\n",
    "    except Exception as e:\n",
    "        print(f\"生成 {model_name} 的模型性能分解图失败: {str(e)}\")\n",
    "        traceback.print_exc()\n",
    "        return None\n",
    "\n",
    "def plot_shap_analysis(model, model_name, X_test, feature_names, config, results_dir):\n",
    "    \"\"\"绘制SHAP分析图\"\"\"\n",
    "    if not SHAP_AVAILABLE:\n",
    "        print(\"SHAP库未安装，跳过SHAP分析\")\n",
    "        return None\n",
    "        \n",
    "    try:\n",
    "        start_time = time.time()\n",
    "        print(f\"开始生成 {model_name} 的SHAP分析图...\")\n",
    "        \n",
    "        # 创建SHAP子图目录\n",
    "        shap_dir = os.path.join(results_dir, \"shap_analysis\")\n",
    "        os.makedirs(shap_dir, exist_ok=True)\n",
    "        \n",
    "        # 1. 特征过滤：减少特征数量\n",
    "        model_features = get_model_features(model)\n",
    "        X_test_aligned = align_features(X_test.copy(), model_features)\n",
    "        \n",
    "        # 使用方差过滤移除低信息特征\n",
    "        selector = VarianceThreshold(threshold=0.01)\n",
    "        X_filtered = selector.fit_transform(X_test_aligned)\n",
    "        kept_indices = selector.get_support()\n",
    "        filtered_features = [feature_names[i] for i, kept in enumerate(kept_indices) if kept]\n",
    "        \n",
    "        # 2. 确保样本量 > 特征量\n",
    "        max_shap_samples = config['MAX_SHAP_SAMPLES']\n",
    "        n_features = len(filtered_features)\n",
    "        \n",
    "        # 确保样本量至少比特征量多20%\n",
    "        required_samples = max(n_features + 10, int(n_features * 1.2))\n",
    "        sample_size = max(required_samples, min(max_shap_samples, len(X_filtered)))\n",
    "        \n",
    "        # 采样\n",
    "        if len(X_filtered) > sample_size:\n",
    "            sample_indices = np.random.choice(len(X_filtered), sample_size, replace=False)\n",
    "            X_sample = X_filtered[sample_indices]\n",
    "        else:\n",
    "            X_sample = X_filtered\n",
    "            # 如果样本仍不足，进一步减少特征\n",
    "            if len(X_sample) <= n_features:\n",
    "                reduce_by = n_features - len(X_sample) + 5\n",
    "                if reduce_by > 0:\n",
    "                    print(f\"样本量({len(X_sample)})不足，进一步减少{reduce_by}个特征...\")\n",
    "                    X_sample = X_sample[:, :max(1, n_features - reduce_by)]\n",
    "                    filtered_features = filtered_features[:max(1, n_features - reduce_by)]\n",
    "                    n_features = len(filtered_features)\n",
    "        \n",
    "        # 转换为DataFrame便于处理\n",
    "        X_sample_df = pd.DataFrame(X_sample, columns=filtered_features)\n",
    "        \n",
    "        # 3. 提取内部模型\n",
    "        inner_model = model\n",
    "        if hasattr(model, 'named_steps') and isinstance(model, Pipeline):\n",
    "            inner_model = model.named_steps[list(model.named_steps.keys())[-1]]\n",
    "        \n",
    "        # 4. 选择合适的解释器\n",
    "        try:\n",
    "            # 树模型优先用TreeExplainer\n",
    "            if \"CatBoost\" in model_name or \"XGBoost\" in model_name or \"LightGBM\" in model_name or \"RandomForest\" in model_name or \"GradientBoosting\" in model_name:\n",
    "                explainer = shap.TreeExplainer(inner_model)\n",
    "                shap_values = explainer.shap_values(X_sample_df)\n",
    "            else:\n",
    "                # KernelExplainer：使用L1正则化限制特征\n",
    "                background_samples = min(10, len(X_sample_df))\n",
    "                background = X_sample_df.sample(background_samples, random_state=config['RANDOM_STATE'])\n",
    "                \n",
    "                # 计算SHAP值时限制特征数量\n",
    "                max_features = min(n_features, len(X_sample_df) - 5)\n",
    "                explainer = shap.KernelExplainer(inner_model.predict, background)\n",
    "                shap_values = explainer.shap_values(\n",
    "                    X_sample_df, \n",
    "                    nsamples=100,\n",
    "                    l1_reg=f\"num_features({max_features})\"\n",
    "                )\n",
    "        except Exception as e:\n",
    "            print(f\"SHAP解释器初始化失败，使用备用方案: {str(e)}\")\n",
    "            # 备用方案：强制减少特征\n",
    "            max_features = min(20, len(X_sample_df) - 5)\n",
    "            explainer = shap.KernelExplainer(\n",
    "                inner_model.predict, \n",
    "                X_sample_df.sample(min(5, len(X_sample_df)), random_state=config['RANDOM_STATE'])\n",
    "            )\n",
    "            shap_values = explainer.shap_values(\n",
    "                X_sample_df, \n",
    "                nsamples=50,\n",
    "                l1_reg=f\"num_features({max_features})\"\n",
    "            )\n",
    "        \n",
    "        # 5. 生成并保存SHAP图\n",
    "        # 条形图\n",
    "        plt.figure(figsize=(12, 8))\n",
    "        shap.summary_plot(shap_values, X_sample_df, feature_names=filtered_features, plot_type=\"bar\", show=False)\n",
    "        plt.title(f\"{model_name} 特征贡献SHAP分析\", fontsize=16, fontweight='bold')\n",
    "        plt.tight_layout()\n",
    "        bar_path = os.path.join(shap_dir, f\"{model_name}_shap_bar.png\")\n",
    "        plt.savefig(bar_path, dpi=config['DPI'], bbox_inches='tight')\n",
    "        plt.close()\n",
    "        \n",
    "        # 蜂群图\n",
    "        plt.figure(figsize=(12, 8))\n",
    "        shap.summary_plot(shap_values, X_sample_df, feature_names=filtered_features, show=False)\n",
    "        plt.title(f\"{model_name} SHAP值分布\", fontsize=16, fontweight='bold')\n",
    "        plt.tight_layout()\n",
    "        beeswarm_path = os.path.join(shap_dir, f\"{model_name}_shap_beeswarm.png\")\n",
    "        plt.savefig(beeswarm_path, dpi=config['DPI'], bbox_inches='tight')\n",
    "        plt.close()\n",
    "        \n",
    "        # 依赖图（前2个重要特征）\n",
    "        dependence_paths = []\n",
    "        try:\n",
    "            if isinstance(shap_values, list):\n",
    "                shap_vals = shap_values[0]\n",
    "            else:\n",
    "                shap_vals = shap_values\n",
    "                \n",
    "            # 按SHAP值绝对值的均值排序\n",
    "            feature_importance = np.abs(shap_vals).mean(axis=0)\n",
    "            top_indices = np.argsort(feature_importance)[::-1][:2]  # 取前2个\n",
    "            \n",
    "            for idx in top_indices:\n",
    "                if idx < len(filtered_features):\n",
    "                    feature_name = filtered_features[idx]\n",
    "                    plt.figure(figsize=(10, 6))\n",
    "                    shap.dependence_plot(idx, shap_vals, X_sample_df, feature_names=filtered_features, show=False)\n",
    "                    plt.title(f\"{model_name} SHAP依赖图: {feature_name}\", fontsize=16, fontweight='bold')\n",
    "                    plt.tight_layout()\n",
    "                    dep_path = os.path.join(shap_dir, f\"{model_name}_shap_dependence_{feature_name}.png\")\n",
    "                    plt.savefig(dep_path, dpi=config['DPI'], bbox_inches='tight')\n",
    "                    plt.close()\n",
    "                    dependence_paths.append(dep_path)\n",
    "        except Exception as e:\n",
    "            print(f\"生成SHAP依赖图失败: {str(e)}\")\n",
    "        \n",
    "        elapsed = time.time() - start_time\n",
    "        print(f\"成功生成 {model_name} 的SHAP分析图，耗时: {elapsed:.1f}秒\")\n",
    "        return {\n",
    "            'bar_plot': bar_path,\n",
    "            'beeswarm_plot': beeswarm_path,\n",
    "            'dependence_plots': dependence_paths,\n",
    "            'shap_dir': shap_dir\n",
    "        }\n",
    "    except Exception as e:\n",
    "        print(f\"生成 {model_name} 的SHAP分析图失败: {str(e)}\")\n",
    "        traceback.print_exc()\n",
    "        return None\n",
    "\n",
    "def generate_model_comparison_report(models, metrics_df, X_test, y_test, feature_names, config):\n",
    "    \"\"\"生成模型比较报告\"\"\"\n",
    "    try:\n",
    "        print(\"开始生成模型比较报告...\")\n",
    "        start_time = time.time()\n",
    "        \n",
    "        results_dir = config['RESULTS_DIR']\n",
    "        report_dir = os.path.join(results_dir, \"model_comparison_report\")\n",
    "        os.makedirs(report_dir, exist_ok=True)\n",
    "        \n",
    "        # 创建子图总目录\n",
    "        all_subplots_dir = os.path.join(report_dir, \"all_subplots\")\n",
    "        os.makedirs(all_subplots_dir, exist_ok=True)\n",
    "        \n",
    "        metrics_path = os.path.join(report_dir, \"model_metrics.csv\")\n",
    "        metrics_df.to_csv(metrics_path, index=False)\n",
    "        print(f\"模型性能指标已保存至: {metrics_path}\")\n",
    "        \n",
    "        analysis_paths = {}\n",
    "        for model_name, model in models.items():\n",
    "            # 为每个模型创建子图目录并复制子图\n",
    "            model_subplot_dir = os.path.join(all_subplots_dir, model_name)\n",
    "            os.makedirs(model_subplot_dir, exist_ok=True)\n",
    "            \n",
    "            fig_path = plot_comprehensive_model_analysis(\n",
    "                metrics_df, model, model_name, X_test, y_test, feature_names, report_dir, config\n",
    "            )\n",
    "            if fig_path:\n",
    "                analysis_paths[model_name] = fig_path\n",
    "                \n",
    "                # 复制子图到统一目录\n",
    "                original_subplot_dir = os.path.join(report_dir, f\"{model_name}_analysis/subfigures\")\n",
    "                if os.path.exists(original_subplot_dir):\n",
    "                    import shutil\n",
    "                    for file in os.listdir(original_subplot_dir):\n",
    "                        src = os.path.join(original_subplot_dir, file)\n",
    "                        dst = os.path.join(model_subplot_dir, file)\n",
    "                        if os.path.isfile(src):\n",
    "                            shutil.copy2(src, dst)\n",
    "        \n",
    "        report_path = os.path.join(report_dir, \"model_comparison_report.md\")\n",
    "        with open(report_path, \"w\", encoding=\"utf-8\") as f:\n",
    "            f.write(\"# 模型比较分析报告\\n\\n\")\n",
    "            f.write(f\"生成时间: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n",
    "            \n",
    "            f.write(\"## 模型性能指标比较\\n\\n\")\n",
    "            f.write(metrics_df.to_markdown(index=False) + \"\\n\\n\")\n",
    "            \n",
    "            f.write(\"## 各模型详细分析\\n\\n\")\n",
    "            for model_name in models.keys():\n",
    "                f.write(f\"### {model_name}模型分析\\n\\n\")\n",
    "                if model_name in analysis_paths:\n",
    "                    f.write(f\"#### 综合分析图\\n\")\n",
    "                    f.write(f\"![{model_name}综合分析]({model_name}/{os.path.basename(analysis_paths[model_name]['comprehensive'])})\\n\\n\")\n",
    "                    f.write(f\"#### 单个分析图\\n\")\n",
    "                    f.write(f\"所有子图已保存至: {os.path.join('all_subplots', model_name)}\\n\\n\")\n",
    "                else:\n",
    "                    f.write(f\"{model_name}的综合分析图生成失败\\n\\n\")\n",
    "        \n",
    "        print(f\"模型比较报告已生成: {report_path}\")\n",
    "        end_time = time.time()\n",
    "        print(f\"报告生成完成，耗时{end_time - start_time:.2f}秒\")\n",
    "        \n",
    "        return report_dir\n",
    "    except Exception as e:\n",
    "        print(f\"生成报告时出错: {str(e)}\")\n",
    "        traceback.print_exc()\n",
    "        return None\n",
    "\n",
    "# ======================== 内存管理装饰器 ========================\n",
    "def memory_limit_decorator(func):\n",
    "    \"\"\"内存限制装饰器：监控内存使用，超过阈值则终止任务\"\"\"\n",
    "    @wraps(func)\n",
    "    def wrapper(*args, **kwargs):\n",
    "        # 获取系统总内存（GB）\n",
    "        total_memory = psutil.virtual_memory().total / (1024**3)\n",
    "        # 设置内存阈值（使用70%总内存）\n",
    "        memory_threshold = total_memory * 0.7\n",
    "        \n",
    "        # 开始内存追踪\n",
    "        tracemalloc.start()\n",
    "        snapshot1 = tracemalloc.take_snapshot()\n",
    "        \n",
    "        try:\n",
    "            result = func(*args, **kwargs)\n",
    "            return result\n",
    "        finally:\n",
    "            # 检查内存使用情况\n",
    "            snapshot2 = tracemalloc.take_snapshot()\n",
    "            top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n",
    "            \n",
    "            # 计算当前内存使用\n",
    "            current, peak = tracemalloc.get_traced_memory()\n",
    "            current_gb = current / (1024**3)\n",
    "            peak_gb = peak / (1024**3)\n",
    "            \n",
    "            print(f\"\\n内存使用统计:\")\n",
    "            print(f\"  当前: {current_gb:.2f} GB\")\n",
    "            print(f\"  峰值: {peak_gb:.2f} GB\")\n",
    "            print(f\"  系统总内存: {total_memory:.2f} GB\")\n",
    "            print(f\"  内存阈值: {memory_threshold:.2f} GB\")\n",
    "            \n",
    "            # 检查是否超过阈值\n",
    "            if current_gb > memory_threshold:\n",
    "                print(f\"警告: 内存使用({current_gb:.2f} GB)超过阈值({memory_threshold:.2f} GB)\")\n",
    "                print(\"建议: 降低样本量或增加系统内存\")\n",
    "            \n",
    "            # 停止内存追踪\n",
    "            tracemalloc.stop()\n",
    "    \n",
    "    return wrapper\n",
    "\n",
    "# ======================== 核心处理函数 ========================\n",
    "@memory_limit_decorator\n",
    "def process_single_config(config):\n",
    "    \"\"\"处理单个配置\"\"\"\n",
    "    try:\n",
    "        print(f\"\\n{'='*80}\")\n",
    "        print(f\"开始处理配置: {config.get('name', '未命名配置')}\")\n",
    "        print(f\"数据路径: {config['DATA_PATH']}\")\n",
    "        print(f\"结果路径: {config['RESULTS_DIR']}\")\n",
    "        print(f\"{'='*80}\\n\")\n",
    "        \n",
    "        # 确保结果目录存在\n",
    "        os.makedirs(config['RESULTS_DIR'], exist_ok=True)\n",
    "        analysis_dir = os.path.join(config['RESULTS_DIR'], \"special_analysis\")\n",
    "        os.makedirs(analysis_dir, exist_ok=True)\n",
    "        \n",
    "        # 1. 加载测试数据\n",
    "        print(f\"加载测试数据: {config['DATA_PATH']}\")\n",
    "        X_test, y_test, feature_names = load_test_data(config)\n",
    "        print(f\"测试数据加载完成，样本数: {len(X_test)}, 特征数: {len(feature_names)}\")\n",
    "        \n",
    "        # 2. 加载重新训练的模型\n",
    "        print(f\"加载重新训练的模型: {config['MODELS_DIR']}\")\n",
    "        models = load_retrained_models(config)\n",
    "        print(f\"成功加载 {len(models)} 个模型\")\n",
    "        \n",
    "        # 3. 计算模型性能指标\n",
    "        print(\"计算模型性能指标...\")\n",
    "        metrics_df = calculate_model_metrics(models, X_test, y_test, config)\n",
    "        metrics_path = os.path.join(analysis_dir, \"model_metrics.csv\")\n",
    "        metrics_df.to_csv(metrics_path, index=False)\n",
    "\n",
    "        print(\"\\n模型性能指标:\")\n",
    "        print(metrics_df)\n",
    "\n",
    "        # 4. 为每个模型生成特定分析图\n",
    "        print(\"\\n生成特定分析图...\")\n",
    "        decomposition_paths = {}\n",
    "        shap_paths = {}\n",
    "        comprehensive_paths = {}\n",
    "        \n",
    "        for model_name, model in models.items():\n",
    "            # 创建模型专属文件夹\n",
    "            model_dir = os.path.join(analysis_dir, model_name)\n",
    "            os.makedirs(model_dir, exist_ok=True)\n",
    "            \n",
    "            # 生成综合分析图\n",
    "            comp_path = plot_comprehensive_model_analysis(\n",
    "                metrics_df, model, model_name, X_test, y_test, feature_names, model_dir, config\n",
    "            )\n",
    "            if comp_path:\n",
    "                comprehensive_paths[model_name] = comp_path\n",
    "            \n",
    "            # 生成模型性能分解图\n",
    "            decomp_path = plot_model_performance_decomposition(\n",
    "                model, model_name, X_test, y_test, config, model_dir\n",
    "            )\n",
    "            if decomp_path:\n",
    "                decomposition_paths[model_name] = decomp_path\n",
    "            \n",
    "            # 生成SHAP分析图\n",
    "            shap_path = plot_shap_analysis(\n",
    "                model, model_name, X_test, feature_names, config, model_dir\n",
    "            )\n",
    "            if shap_path:\n",
    "                shap_paths[model_name] = shap_path\n",
    "\n",
    "        # 5. 生成分析报告\n",
    "        report_path = os.path.join(analysis_dir, \"special_analysis_report.md\")\n",
    "        with open(report_path, \"w\", encoding=\"utf-8\") as f:\n",
    "            f.write(\"# 模型特殊分析报告\\n\\n\")\n",
    "            f.write(f\"生成时间: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n",
    "            \n",
    "            f.write(\"## 模型性能指标\\n\\n\")\n",
    "            f.write(metrics_df.to_markdown(index=False) + \"\\n\\n\")\n",
    "            \n",
    "            f.write(\"## 综合分析图\\n\\n\")\n",
    "            for model_name in models.keys():\n",
    "                f.write(f\"### {model_name}模型\\n\\n\")\n",
    "                if model_name in comprehensive_paths and comprehensive_paths[model_name]:\n",
    "                    comp = comprehensive_paths[model_name]\n",
    "                    f.write(f\"#### 综合分析图\\n\")\n",
    "                    f.write(f\"![{model_name}综合分析]({model_name}/{os.path.basename(comp['comprehensive'])})\\n\\n\")\n",
    "                else:\n",
    "                    f.write(f\"{model_name}的综合分析图生成失败\\n\\n\")\n",
    "            \n",
    "            f.write(\"## 模型性能分解分析\\n\\n\")\n",
    "            for model_name in models.keys():\n",
    "                f.write(f\"### {model_name}模型\\n\\n\")\n",
    "                if model_name in decomposition_paths:\n",
    "                    rel_path = os.path.join(model_name, os.path.basename(decomposition_paths[model_name]))\n",
    "                    f.write(f\"![{model_name}性能分解图]({rel_path})\\n\\n\")\n",
    "                else:\n",
    "                    f.write(f\"{model_name}的性能分解图生成失败\\n\\n\")\n",
    "            \n",
    "            f.write(\"## SHAP特征重要性分析\\n\\n\")\n",
    "            for model_name in models.keys():\n",
    "                f.write(f\"### {model_name}模型\\n\\n\")\n",
    "                if model_name in shap_paths and shap_paths[model_name]:\n",
    "                    shap_files = shap_paths[model_name]\n",
    "                    if 'bar_plot' in shap_files and shap_files['bar_plot']:\n",
    "                        rel_path = os.path.join(model_name, \"shap_analysis\", os.path.basename(shap_files['bar_plot']))\n",
    "                        f.write(f\"#### 特征贡献条形图\\n\")\n",
    "                        f.write(f\"![{model_name}SHAP条形图]({rel_path})\\n\\n\")\n",
    "                    if 'beeswarm_plot' in shap_files and shap_files['beeswarm_plot']:\n",
    "                        rel_path = os.path.join(model_name, \"shap_analysis\", os.path.basename(shap_files['beeswarm_plot']))\n",
    "                        f.write(f\"#### 特征贡献蜂群图\\n\")\n",
    "                        f.write(f\"![{model_name}SHAP蜂群图]({rel_path})\\n\\n\")\n",
    "                else:\n",
    "                    f.write(f\"{model_name}的SHAP分析图生成失败\\n\\n\")\n",
    "        \n",
    "        print(f\"\\n===== 配置处理完成 =====\")\n",
    "        print(f\"特殊分析结果已保存至: {analysis_dir}\")\n",
    "\n",
    "        # 6. 生成模型比较报告\n",
    "        print(\"生成模型比较报告...\")\n",
    "        report_dir = generate_model_comparison_report(\n",
    "            models, metrics_df, X_test, y_test, feature_names, config\n",
    "        )\n",
    "        \n",
    "        print(f\"\\n===== 配置处理完成 =====\")\n",
    "        print(f\"模型评估报告已保存至: {report_dir}\")\n",
    "        return True\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"处理配置时出错: {str(e)}\")\n",
    "        traceback.print_exc()\n",
    "        return False\n",
    "\n",
    "def batch_process(configs):\n",
    "    \"\"\"批量处理多个配置\"\"\"\n",
    "    total = len(configs)\n",
    "    success = 0\n",
    "    failed_configs = []\n",
    "    \n",
    "    print(f\"开始批量处理，共{total}个配置任务\")\n",
    "    \n",
    "    for i, config in enumerate(configs, 1):\n",
    "        print(f\"\\n----- 处理第{i}/{total}个配置: {config['name']} -----\")\n",
    "        \n",
    "        # 配置信息摘要\n",
    "        print(f\"配置参数:\")\n",
    "        print(f\"  MAX_SAMPLES: {config['MAX_SAMPLES']}\")\n",
    "        print(f\"  MAX_FEATURES: {config['MAX_FEATURES']}\")\n",
    "        print(f\"  MAX_SHAP_SAMPLES: {config['MAX_SHAP_SAMPLES']}\")\n",
    "        print(f\"  DPI: {config['DPI']}\")\n",
    "        \n",
    "        # 重试机制\n",
    "        max_retries = 3\n",
    "        for attempt in range(max_retries):\n",
    "            try:\n",
    "                # 执行前进行内存检查\n",
    "                available_memory = psutil.virtual_memory().available / (1024**3)\n",
    "                print(f\"执行前可用内存: {available_memory:.2f} GB\")\n",
    "                \n",
    "                # 执行任务\n",
    "                result = process_single_config(config)\n",
    "                \n",
    "                if result:\n",
    "                    success += 1\n",
    "                    print(f\"✅ 任务成功\")\n",
    "                    break\n",
    "                else:\n",
    "                    print(f\"❌ 任务失败（返回False）\")\n",
    "                    failed_configs.append(config)\n",
    "                    break\n",
    "            \n",
    "            except Exception as e:\n",
    "                print(f\"⚠️ 尝试 {attempt+1}/{max_retries} 失败: {str(e)}\")\n",
    "                if attempt < max_retries - 1:\n",
    "                    print(f\"等待 {30*(attempt+1)} 秒后重试...\")\n",
    "                    time.sleep(30*(attempt+1))  # 指数退避策略\n",
    "                else:\n",
    "                    print(f\"❌ 任务失败（达到最大重试次数）\")\n",
    "                    failed_configs.append(config)\n",
    "        \n",
    "        # 强制垃圾回收\n",
    "        gc.collect()\n",
    "        # 任务间延迟，让系统恢复\n",
    "        time.sleep(10)\n",
    "        \n",
    "        # 打印当前内存状态\n",
    "        after_memory = psutil.virtual_memory().available / (1024**3)\n",
    "        print(f\"执行后可用内存: {after_memory:.2f} GB\")\n",
    "    \n",
    "    # 汇总结果\n",
    "    print(f\"\\n批量处理完成，成功{success}/{total}个配置\")\n",
    "    if failed_configs:\n",
    "        print(\"\\n失败的配置:\")\n",
    "        for config in failed_configs:\n",
    "            print(f\"  - {config['name']}\")\n",
    "    \n",
    "    return success, total\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9ed41465",
   "metadata": {},
   "source": [
    "### 运行"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3da4ea5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# ======================== 主函数 ========================\n",
    "def main():\n",
    "    # 定义批量配置\n",
    "    batch_configs = [\n",
    "#         {\n",
    "#             'name': '数据集1-核心模型评估',\n",
    "#             'DATA_PATH': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFT完成\\test_data.pkl\",\n",
    "#             'MODELS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFT完成\\retrained_models\",\n",
    "#             'RESULTS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFT完成\\results_dataset\",\n",
    "#             'MAX_SAMPLES': 2000,\n",
    "#             'MAX_FEATURES': 80,\n",
    "#             'MAX_SHAP_SAMPLES': 120,  # 略大于特征数\n",
    "#             'SAMPLE_FRACTION': 1,\n",
    "#             'DPI': 300,  # 降低图像质量\n",
    "#             'RANDOM_STATE': 42,\n",
    "#             'TARGET_COLUMN': \"EigenValue\",\n",
    "#             'model_names': ['GradientBoosting']\n",
    "#         }\n",
    "#         ,\n",
    "#         {\n",
    "#             'name': '数据集2-深度学习模型评估',\n",
    "#             'DATA_PATH': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFS完成\\test_data.pkl\",\n",
    "#             'MODELS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFS完成\\retrained_models\",\n",
    "#             'RESULTS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFS完成\\results_dataset\",\n",
    "#             'MAX_SAMPLES': 2000,\n",
    "#             'MAX_FEATURES': 80,\n",
    "#             'MAX_SHAP_SAMPLES': 120,  # 略大于特征数\n",
    "#             'SAMPLE_FRACTION': 1,\n",
    "#             'DPI': 300,  # 降低图像质量\n",
    "#             'RANDOM_STATE': 42,\n",
    "#             'TARGET_COLUMN': \"EigenValue\",\n",
    "#             'model_names': ['GradientBoosting']\n",
    "#         },\n",
    "#         {\n",
    "#             'name': '数据集3-模型评估',\n",
    "#             'DATA_PATH': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFB完成\\test_data.pkl\",\n",
    "#             'MODELS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFB完成\\retrained_models\",\n",
    "#             'RESULTS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\DFB完成\\results_dataset\",\n",
    "#             'MAX_SAMPLES': 2000,\n",
    "#             'MAX_FEATURES': 80,\n",
    "#             'MAX_SHAP_SAMPLES': 120,  # 略大于特征数\n",
    "#             'SAMPLE_FRACTION': 1,\n",
    "#             'DPI': 300,  # 降低图像质量\n",
    "#             'RANDOM_STATE': 42,\n",
    "#             'TARGET_COLUMN': \"EigenValue\",\n",
    "#             'model_names': ['GradientBoosting']\n",
    "# #         },\n",
    "#         {\n",
    "#             'name': '数据集4-模型评估',\n",
    "#             'DATA_PATH': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data0_auto_P完成\\test_data.pkl\",\n",
    "#             'MODELS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data0_auto_P完成\\retrained_models\",\n",
    "#             'RESULTS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data0_auto_P完成\\results_dataset\",\n",
    "#             'MAX_SAMPLES': 2000,\n",
    "#             'MAX_FEATURES': 80,\n",
    "#             'MAX_SHAP_SAMPLES': 120,  # 略大于特征数\n",
    "#             'SAMPLE_FRACTION': 1,\n",
    "#             'DPI': 300,  # 降低图像质量\n",
    "#             'RANDOM_STATE': 42,\n",
    "#             'TARGET_COLUMN': \"Pucf12f\",\n",
    "#             'model_names': ['LightGBM']\n",
    "#         },\n",
    "#         {\n",
    "#             'name': '数据集5-模型评估',\n",
    "#             'DATA_PATH': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data1_auto_P完成\\test_data.pkl\",\n",
    "#             'MODELS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data1_auto_P完成\\retrained_models\",\n",
    "#             'RESULTS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data1_auto_P完成\\results_dataset\",\n",
    "#             'MAX_SAMPLES': 2000,\n",
    "#             'MAX_FEATURES': 80,\n",
    "#             'MAX_SHAP_SAMPLES': 120,  # 略大于特征数\n",
    "#             'SAMPLE_FRACTION': 1,\n",
    "#             'DPI': 300,  # 降低图像质量\n",
    "#             'RANDOM_STATE': 42,\n",
    "#             'TARGET_COLUMN': \"Pucf12f\",\n",
    "#             'model_names': ['XGBoost']\n",
    "#         },\n",
    "        {\n",
    "            'name': '数据集5-模型评估',\n",
    "            'DATA_PATH': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data2_auto_P完成\\test_data.pkl\",\n",
    "            'MODELS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data2_auto_P完成\\retrained_models\",\n",
    "            'RESULTS_DIR': r\"R:\\Jupyterdemo\\phdcode\\MODELtype\\data2_auto_P完成\\results_dataset\",\n",
    "            'MAX_SAMPLES': 2000,\n",
    "            'MAX_FEATURES': 80,\n",
    "            'MAX_SHAP_SAMPLES': 120,  # 略大于特征数\n",
    "            'SAMPLE_FRACTION': 1,\n",
    "            'DPI': 300,  # 降低图像质量\n",
    "            'RANDOM_STATE': 42,\n",
    "            'TARGET_COLUMN': \"Pucf12f\",\n",
    "            'model_names': ['GradientBoosting']\n",
    "        }\n",
    "    ]\n",
    "    \n",
    "    # 执行批量处理\n",
    "    batch_process(batch_configs)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # 启动内存监控\n",
    "    tracemalloc.start()\n",
    "    \n",
    "    # 执行主函数\n",
    "    main()\n",
    "    \n",
    "    # 停止内存监控\n",
    "    tracemalloc.stop()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9764d2d2",
   "metadata": {},
   "source": [
    "## 结果处理合并（绘图）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "08de614e",
   "metadata": {},
   "source": [
    "### 定义"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c110948c",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import json\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import joblib\n",
    "from matplotlib.font_manager import FontProperties, findfont, FontManager\n",
    "from matplotlib.gridspec import GridSpec\n",
    "from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.decomposition import PCA\n",
    "from IPython.display import display, Markdown\n",
    "import statsmodels.api as sm\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# 设置字体为支持中文的字体（跨平台兼容）\n",
    "def get_chinese_font():\n",
    "    \"\"\"获取支持中文的字体，跨平台兼容\"\"\"\n",
    "    # 尝试常见的中文字体\n",
    "    font_candidates = [\n",
    "        \"SimSun\",           # Windows 宋体\n",
    "        \"SimSun\",  # Linux\n",
    "        \"SimSun\",         # MacOS\n",
    "        \"SimSun\"  # 通用开源字体\n",
    "    ]\n",
    "    \n",
    "    # 查找系统中可用的字体\n",
    "    fm = FontManager()\n",
    "    available_fonts = [f.name for f in fm.ttflist]\n",
    "    \n",
    "    for font in font_candidates:\n",
    "        if font in available_fonts:\n",
    "            return font\n",
    "    \n",
    "    # 如果没有找到中文字体，使用默认字体并警告\n",
    "    print(\"警告: 未找到合适的中文字体，可能导致中文显示异常\")\n",
    "    return \"Arial Unicode MS\"  # 最后的备选\n",
    "\n",
    "# 设置中文字体\n",
    "chinese_font = get_chinese_font()\n",
    "plt.rcParams[\"font.family\"] = [\"simsun\", chinese_font]\n",
    "plt.rcParams[\"axes.unicode_minus\"] = False  # 正确显示负号\n",
    "plt.rcParams['figure.dpi'] = 300  # 高分辨率，适合论文\n",
    "plt.rcParams['axes.titlesize'] = 14  # 标题字体大小\n",
    "plt.rcParams['axes.labelsize'] = 12  # 坐标轴标签字体大小\n",
    "plt.rcParams['xtick.labelsize'] = 10  # x轴刻度字体大小\n",
    "plt.rcParams['ytick.labelsize'] = 10  # y轴刻度字体大小\n",
    "plt.rcParams['legend.fontsize'] = 10  # 图例字体大小\n",
    "\n",
    "class MLVisualizationSystem:\n",
    "    \"\"\"机器学习模型可视化分析系统 - 学术论文专用版\"\"\"\n",
    "    def __init__(self, base_dir=None):\n",
    "        \"\"\"\n",
    "        初始化可视化系统\n",
    "\n",
    "        Parameters:\n",
    "        -----------\n",
    "        base_dir : str, optional\n",
    "            基础目录路径，如果未提供则使用默认路径\n",
    "        \"\"\"\n",
    "        # 设置默认基础目录\n",
    "        self.base_dir = base_dir or r\"R:\\Jupyterdemo\\phdcode\\DFT完成\"\n",
    "\n",
    "        # 确保目录路径正确\n",
    "        self.base_dir = os.path.normpath(self.base_dir)\n",
    "\n",
    "        self.data = {}\n",
    "        self.metadata = {\n",
    "            'data_loaded': False,\n",
    "            'sensitivity_analyzed': False,  # 修复敏感性分析元数据\n",
    "            'directories': {\n",
    "                'data_exploration': os.path.join(self.base_dir, 'data_exploration'),\n",
    "                'data_versions': os.path.join(self.base_dir, 'data_versions'),\n",
    "                'model_evaluation': os.path.join(self.base_dir, 'model_evaluation'),\n",
    "                'training_metrics': os.path.join(self.base_dir, 'training_metrics'),\n",
    "                'tuning_results': os.path.join(self.base_dir, 'tuning_results')\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # 设置字体属性\n",
    "        self.font_set = FontProperties(family=chinese_font, size=12)\n",
    "   \n",
    "    def load_all_data(self):\n",
    "        \"\"\"加载所有数据\"\"\"\n",
    "        print(\"正在加载所有数据...\")\n",
    "        \n",
    "        # 加载基础文件\n",
    "        self._load_basic_files()\n",
    "        \n",
    "        # 加载各目录的数据\n",
    "        for dir_name, dir_path in self.metadata['directories'].items():\n",
    "            if os.path.exists(dir_path):\n",
    "                print(f\"\\n加载 {dir_name} 目录数据...\")\n",
    "                self._load_directory_data(dir_name, dir_path)\n",
    "        \n",
    "        self.metadata['data_loaded'] = True\n",
    "        print(\"\\n数据加载完成！\")\n",
    "        \n",
    "    def _load_basic_files(self):\n",
    "        \"\"\"加载基础文件\"\"\"\n",
    "        basic_files = {\n",
    "            'predictions.csv': 'predictions',\n",
    "            'model_performance.csv': 'model_performance',\n",
    "            'test_data.pkl': 'test_data',\n",
    "            'tuning_log_details.json': 'tuning_details',\n",
    "            'tuning_log_summary.md': 'tuning_summary',\n",
    "            'academic_report.md': 'academic_report'\n",
    "        }\n",
    "        \n",
    "        for filename, key in basic_files.items():\n",
    "            file_path = os.path.join(self.base_dir, filename)\n",
    "            if os.path.exists(file_path):\n",
    "                try:\n",
    "                    if filename.endswith('.csv'):\n",
    "                        self.data[key] = pd.read_csv(file_path)\n",
    "                    elif filename.endswith('.json'):\n",
    "                        with open(file_path, 'r', encoding='utf-8') as f:\n",
    "                            self.data[key] = json.load(f)\n",
    "                    elif filename.endswith('.pkl'):\n",
    "                        self.data[key] = joblib.load(file_path)\n",
    "                    elif filename.endswith('.md'):\n",
    "                        with open(file_path, 'r', encoding='utf-8') as f:\n",
    "                            self.data[key] = f.read()\n",
    "                    print(f\"✓ 加载 {filename}\")\n",
    "                except Exception as e:\n",
    "                    print(f\"✗ 加载 {filename} 失败: {e}\")\n",
    "                    \n",
    "        # 处理预测数据\n",
    "        if 'predictions' in self.data and 'test_data' in self.data:\n",
    "            self._process_predictions()\n",
    "            \n",
    "    def _process_predictions(self):\n",
    "        \"\"\"处理预测数据，提取实际值和各模型预测值\"\"\"\n",
    "        pred_df = self.data['predictions']\n",
    "        test_data = self.data['test_data']\n",
    "        \n",
    "        if 'y_test' in test_data:\n",
    "            self.data['y_test'] = test_data['y_test']\n",
    "            \n",
    "        # 假设预测数据包含实际值和预测值列\n",
    "        if '实际值' in pred_df.columns:\n",
    "            self.data['y_test'] = pred_df['实际值'].values\n",
    "        elif '真实值' in pred_df.columns:  # 增加兼容性\n",
    "            self.data['y_test'] = pred_df['真实值'].values\n",
    "            \n",
    "        # 提取各模型的预测值\n",
    "        self.data['predictions'] = {}\n",
    "        if '模型' in pred_df.columns:\n",
    "            # 按模型分组\n",
    "            for model in pred_df['模型'].unique():\n",
    "                model_pred = pred_df[pred_df['模型'] == model]\n",
    "                if '预测值' in model_pred.columns:\n",
    "                    self.data['predictions'][model] = model_pred['预测值'].values\n",
    "        else:\n",
    "            # 直接提取预测值列\n",
    "            for col in pred_df.columns:\n",
    "                if col not in ['实际值', '真实值', 'index', 'Unnamed: 0'] and ('预测' in col or 'pred' in col.lower()):\n",
    "                    self.data['predictions'][col] = pred_df[col].values\n",
    "                    \n",
    "    def _load_directory_data(self, dir_name, dir_path):\n",
    "        \"\"\"加载目录中的数据\"\"\"\n",
    "        self.data[dir_name] = {}\n",
    "        \n",
    "        for filename in os.listdir(dir_path):\n",
    "            if filename.endswith('.png'):\n",
    "                continue\n",
    "                \n",
    "            file_path = os.path.join(dir_path, filename)\n",
    "            try:\n",
    "                if filename.endswith('.csv'):\n",
    "                    self.data[dir_name][filename] = pd.read_csv(file_path)\n",
    "                elif filename.endswith('.json'):\n",
    "                    with open(file_path, 'r', encoding='utf-8') as f:\n",
    "                        self.data[dir_name][filename] = json.load(f)\n",
    "                print(f\"  ✓ {filename}\")\n",
    "            except Exception as e:\n",
    "                print(f\"  ✗ {filename}: {e}\")\n",
    "                \n",
    "    # ==================== 数据探索可视化 ====================\n",
    "    \n",
    "    def plot_data_exploration(self):\n",
    "        \"\"\"数据探索可视化\"\"\"\n",
    "        if 'data_exploration' not in self.data:\n",
    "            print(\"未找到数据探索数据\")\n",
    "            return\n",
    "            \n",
    "        data = self.data['data_exploration']\n",
    "        \n",
    "        # 1. 数据探索结果\n",
    "        if 'exploration_results.json' in data:\n",
    "            self._plot_exploration_results(data['exploration_results.json'])\n",
    "            \n",
    "        # 2. 特征工程日志\n",
    "        if 'feature_engineering_log.json' in data:\n",
    "            self._plot_feature_engineering(data['feature_engineering_log.json'])\n",
    "            \n",
    "        # 3. 缺失值分析\n",
    "        if 'missing_values.csv' in data:\n",
    "            self._plot_missing_values(data['missing_values.csv'])\n",
    "            \n",
    "        # 4. 特征重要性\n",
    "        if 'feature_importance.csv' in data:\n",
    "            self._plot_feature_importance(data['feature_importance.csv'])\n",
    "            \n",
    "    def _plot_exploration_results(self, data):\n",
    "        \"\"\"绘制数据探索结果\"\"\"\n",
    "        # 目标变量分布\n",
    "        if 'target_statistics' in data:\n",
    "            plt.figure(figsize=(10, 6))\n",
    "            target_stats = pd.Series(data['target_statistics'])\n",
    "            sns.histplot(target_stats, kde=True)\n",
    "            plt.title('目标变量分布', fontproperties=self.font_set)\n",
    "            plt.xlabel('值', fontproperties=self.font_set)\n",
    "            plt.ylabel('频率', fontproperties=self.font_set)\n",
    "            plt.grid(alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "        # 特征相关性热图\n",
    "        if 'correlation' in data and 'matrix' in data['correlation']:\n",
    "            corr_matrix = pd.DataFrame(data['correlation']['matrix'])\n",
    "            plt.figure(figsize=(12, 10))\n",
    "            sns.heatmap(corr_matrix, annot=True, fmt=\".2f\", cmap='coolwarm', center=0,\n",
    "                       annot_kws={\"fontproperties\": self.font_set})\n",
    "            plt.title('特征相关性热图', fontproperties=self.font_set)\n",
    "            plt.xlabel('特征', fontproperties=self.font_set)\n",
    "            plt.ylabel('特征', fontproperties=self.font_set)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    def _plot_feature_engineering(self, data):\n",
    "        \"\"\"绘制特征工程结果\"\"\"\n",
    "        if 'added_features' in data:\n",
    "            added_features = data['added_features']\n",
    "            feature_names = [f['new_feature'] for f in added_features]\n",
    "            transformations = [f['transformation'] for f in added_features]\n",
    "            \n",
    "            plt.figure(figsize=(12, 8))\n",
    "            sns.countplot(y=transformations)\n",
    "            plt.title('特征工程操作类型分布', fontproperties=self.font_set)\n",
    "            plt.xlabel('数量', fontproperties=self.font_set)\n",
    "            plt.ylabel('变换类型', fontproperties=self.font_set)\n",
    "            plt.grid(axis='x', alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    def _plot_missing_values(self, df):\n",
    "        \"\"\"绘制缺失值分析\"\"\"\n",
    "        if df.empty or 'feature' not in df.columns or 'missing_count' not in df.columns:\n",
    "            print(\"缺失值数据格式不正确\")\n",
    "            return\n",
    "            \n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.barplot(x='missing_count', y='feature', data=df.head(20))\n",
    "        plt.title('缺失值分析 (前20个特征)', fontproperties=self.font_set)\n",
    "        plt.xlabel('缺失计数', fontproperties=self.font_set)\n",
    "        plt.ylabel('特征', fontproperties=self.font_set)\n",
    "        plt.grid(axis='x', alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def _plot_feature_importance(self, df):\n",
    "        \"\"\"绘制特征重要性\"\"\"\n",
    "        if df.empty:\n",
    "            print(\"特征重要性数据为空\")\n",
    "            return\n",
    "            \n",
    "        # 尝试不同的列名\n",
    "        importance_col = None\n",
    "        feature_col = None\n",
    "        \n",
    "        for col in ['重要性', 'importance', 'Importance']:\n",
    "            if col in df.columns:\n",
    "                importance_col = col\n",
    "                break\n",
    "                \n",
    "        for col in ['特征', 'feature', 'Feature']:\n",
    "            if col in df.columns:\n",
    "                feature_col = col\n",
    "                break\n",
    "                \n",
    "        if importance_col and feature_col:\n",
    "            plt.figure(figsize=(12, 8))\n",
    "            df_sorted = df.nlargest(20, importance_col)\n",
    "            sns.barplot(x=importance_col, y=feature_col, data=df_sorted, palette='viridis')\n",
    "            plt.title('特征重要性 (前20个)', fontproperties=self.font_set)\n",
    "            plt.xlabel('重要性', fontproperties=self.font_set)\n",
    "            plt.ylabel('特征', fontproperties=self.font_set)\n",
    "            plt.grid(axis='x', alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    # ==================== 数据版本可视化 ====================\n",
    "    \n",
    "    def plot_data_versions(self):\n",
    "        \"\"\"数据版本可视化\"\"\"\n",
    "        if 'data_versions' not in self.data:\n",
    "            print(\"未找到数据版本数据\")\n",
    "            return\n",
    "            \n",
    "        data = self.data['data_versions']\n",
    "        \n",
    "        # 特征分类信息\n",
    "        if 'feature_classification.json' in data:\n",
    "            self._plot_feature_classification(data['feature_classification.json'])\n",
    "            \n",
    "        # 数据分布对比\n",
    "        for filename in ['original_data.csv', 'data_after_missing.csv', 'data_after_fe.csv']:\n",
    "            if filename in data:\n",
    "                title_map = {\n",
    "                    'original_data.csv': '原始数据分布',\n",
    "                    'data_after_missing.csv': '处理缺失值后的数据分布',\n",
    "                    'data_after_fe.csv': '特征工程后的数据分布'\n",
    "                }\n",
    "                self._plot_data_distribution(data[filename], title_map.get(filename, filename))\n",
    "                \n",
    "    def _plot_feature_classification(self, data):\n",
    "        \"\"\"绘制特征分类信息\"\"\"\n",
    "        numeric_features = data.get('numeric_features', [])\n",
    "        categorical_features = data.get('categorical_features', [])\n",
    "        \n",
    "        plt.figure(figsize=(10, 6))\n",
    "        categories = ['数值型'] * len(numeric_features) + ['类别型'] * len(categorical_features)\n",
    "        features = numeric_features + categorical_features\n",
    "        \n",
    "        df = pd.DataFrame({'特征': features, '类型': categories})\n",
    "        sns.countplot(data=df, x='类型')\n",
    "        plt.title('特征类型分布', fontproperties=self.font_set)\n",
    "        plt.xlabel('特征类型', fontproperties=self.font_set)\n",
    "        plt.ylabel('数量', fontproperties=self.font_set)\n",
    "        plt.grid(axis='y', alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def _plot_data_distribution(self, df, title=\"数据分布\"):\n",
    "        \"\"\"绘制数据分布图\"\"\"\n",
    "        if df.empty:\n",
    "            return\n",
    "            \n",
    "        # 假设最后一列是目标变量\n",
    "        target_column = df.columns[-1]\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.histplot(df[target_column], kde=True)\n",
    "        plt.title(title, fontproperties=self.font_set)\n",
    "        plt.xlabel('值', fontproperties=self.font_set)\n",
    "        plt.ylabel('频率', fontproperties=self.font_set)\n",
    "        plt.grid(alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    # ==================== 模型评估可视化 ====================\n",
    "    \n",
    "    def plot_model_evaluation(self):\n",
    "        \"\"\"模型评估可视化\"\"\"\n",
    "        # 1. 预测对比\n",
    "        if 'y_test' in self.data and 'predictions' in self.data:\n",
    "            self.plot_prediction_comparison()\n",
    "            self.plot_scatter()\n",
    "            self.plot_scatter_density()\n",
    "            \n",
    "        # 2. 性能指标\n",
    "        if 'model_performance' in self.data:\n",
    "            self.plot_error_metrics()\n",
    "            self.plot_model_performance_synthesis()\n",
    "            self._plot_performance_metrics()\n",
    "            \n",
    "        # 3. 残差分析\n",
    "        if 'predictions' in self.data and len(self.data['predictions']) > 0:\n",
    "            self._plot_residual_analysis()\n",
    "            \n",
    "    def _plot_performance_metrics(self):\n",
    "        \"\"\"绘制模型性能指标对比\"\"\"\n",
    "        perf_df = self.data['model_performance']\n",
    "        \n",
    "        plt.figure(figsize=(14, 5))\n",
    "        metrics = ['R²', 'RMSE', 'MAE', 'MAPE']\n",
    "        \n",
    "        for i, metric in enumerate(metrics):\n",
    "            train_col = f'训练集{metric}'\n",
    "            test_col = f'测试集{metric}'\n",
    "            \n",
    "            # 尝试不同的列名格式\n",
    "            if train_col not in perf_df.columns:\n",
    "                train_col = f'train_{metric.lower()}'\n",
    "            if test_col not in perf_df.columns:\n",
    "                test_col = f'test_{metric.lower()}'\n",
    "                \n",
    "            if train_col in perf_df.columns and test_col in perf_df.columns:\n",
    "                plt.subplot(1, 4, i+1)\n",
    "                \n",
    "                # 获取所有模型的数据\n",
    "                if len(perf_df) > 1:\n",
    "                    # 多模型比较\n",
    "                    models = perf_df['模型'].tolist() if '模型' in perf_df.columns else perf_df.index.tolist()\n",
    "                    train_vals = perf_df[train_col].values\n",
    "                    test_vals = perf_df[test_col].values\n",
    "                    \n",
    "                    x = np.arange(len(models))\n",
    "                    width = 0.35\n",
    "                    \n",
    "                    plt.bar(x - width/2, train_vals, width, label='训练集')\n",
    "                    plt.bar(x + width/2, test_vals, width, label='测试集')\n",
    "                    plt.xticks(x, models, rotation=45, ha='right')\n",
    "                else:\n",
    "                    # 单模型\n",
    "                    train_val = perf_df.iloc[0][train_col]\n",
    "                    test_val = perf_df.iloc[0][test_col]\n",
    "                    plt.bar(['训练集', '测试集'], [train_val, test_val])\n",
    "                    \n",
    "                plt.title(f'{metric} 对比', fontproperties=self.font_set)\n",
    "                plt.ylabel(metric, fontproperties=self.font_set)\n",
    "                if i == 0:\n",
    "                    plt.legend(prop=self.font_set)\n",
    "                plt.grid(axis='y', alpha=0.3)\n",
    "                \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "\n",
    "    def plot_prediction_comparison(self, random_samples=True, sample_size=100, random_seed=42):\n",
    "        \"\"\"\n",
    "        绘制实际值与各模型预测值的对比图\n",
    "        \"\"\"\n",
    "        if not self.metadata['data_loaded'] or 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少预测结果数据\"))\n",
    "            return\n",
    "\n",
    "        y_test = self.data['y_test']\n",
    "        predictions = self.data['predictions']\n",
    "        model_names = list(predictions.keys())\n",
    "\n",
    "        plt.figure(figsize=(14, 8))\n",
    "\n",
    "        # 控制样本选择方式\n",
    "        n_total_samples = len(y_test)\n",
    "        if n_total_samples <= sample_size:\n",
    "            indices = np.arange(n_total_samples)\n",
    "            sample_msg = f\"显示全部 {n_total_samples} 个样本\"\n",
    "        else:\n",
    "            if random_samples:\n",
    "                np.random.seed(random_seed)  # 设置随机种子，确保结果可重现\n",
    "                indices = np.random.choice(n_total_samples, sample_size, replace=False)\n",
    "                indices.sort()  # 按索引排序，使图表x轴有序\n",
    "                sample_msg = f\"随机抽取 {sample_size} 个样本\"\n",
    "            else:\n",
    "                indices = np.arange(sample_size)\n",
    "                sample_msg = f\"显示前 {sample_size} 个样本\"\n",
    "\n",
    "        # 绘制真实值和预测值\n",
    "        plt.plot(indices, y_test[indices], '--*', label='真实值', linewidth=2, markersize=6)\n",
    "\n",
    "        colors = plt.cm.tab10.colors\n",
    "        for i, (name, pred) in enumerate(predictions.items()):\n",
    "            plt.plot(indices, pred[indices], label=name, color=colors[i % len(colors)], \n",
    "                    linewidth=1.5, alpha=0.8)\n",
    "\n",
    "        plt.xlabel('样本点', fontproperties=self.font_set)\n",
    "        plt.ylabel('值', fontproperties=self.font_set)\n",
    "        plt.title(f'不同算法预测结果与实际值对比 ({sample_msg})', fontproperties=self.font_set)\n",
    "\n",
    "        # 优化图例位置和布局\n",
    "        plt.legend(bbox_to_anchor=(0.95, 0.95), loc='upper left', \n",
    "                  prop=self.font_set, frameon=True, framealpha=0.9)\n",
    "\n",
    "        plt.grid(True, linestyle='--', alpha=0.7)\n",
    "        plt.tight_layout()\n",
    "        plt.subplots_adjust(right=0.75)  # 为图例腾出空间\n",
    "        plt.show()\n",
    "\n",
    "    def plot_random_prediction_samples(self, sample_size=5, random_seed=None):\n",
    "        \"\"\"\n",
    "        随机抽取样本并可视化模型预测结果\n",
    "        \"\"\"\n",
    "        if not self.metadata['data_loaded'] or 'X_test' not in self.data or 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少必要数据\"))\n",
    "            return\n",
    "\n",
    "        if 'X_test' not in self.data:  # 增加兼容性检查\n",
    "            if 'test_data' in self.data and 'X_test' in self.data['test_data']:\n",
    "                self.data['X_test'] = self.data['test_data']['X_test']\n",
    "            else:\n",
    "                display(Markdown(\"> **警告**: 缺少测试特征数据，仅显示目标值预测\"))\n",
    "\n",
    "        X_test = self.data.get('X_test', None)\n",
    "        y_test = self.data['y_test']\n",
    "        predictions = self.data['predictions']\n",
    "        model_names = list(predictions.keys())\n",
    "\n",
    "        # 设置随机种子\n",
    "        if random_seed is not None:\n",
    "            np.random.seed(random_seed)\n",
    "\n",
    "        # 随机选择样本\n",
    "        n_samples = len(y_test)\n",
    "        if sample_size > n_samples:\n",
    "            sample_size = n_samples\n",
    "            display(Markdown(f\"> **注意**: 样本数量不足，将显示全部 {n_samples} 个样本\"))\n",
    "\n",
    "        sample_indices = np.random.choice(n_samples, sample_size, replace=False)\n",
    "\n",
    "        # 创建图表，增加宽度为图例腾出空间\n",
    "        fig, axes = plt.subplots(sample_size, 1, figsize=(14, 4 * sample_size))\n",
    "        if sample_size == 1:\n",
    "            axes = [axes]\n",
    "\n",
    "        for i, idx in enumerate(sample_indices):\n",
    "            ax = axes[i]\n",
    "\n",
    "            # 获取真实值\n",
    "            true_value = y_test[idx]\n",
    "\n",
    "            # 获取所有模型的预测值\n",
    "            pred_values = {name: pred[idx] for name, pred in predictions.items()}\n",
    "\n",
    "            # 绘制柱状图\n",
    "            models = ['真实值'] + list(pred_values.keys())\n",
    "            values = [true_value] + list(pred_values.values())\n",
    "\n",
    "            # 设置不同颜色，真实值用蓝色，预测值用其他颜色\n",
    "            colors = ['#1f77b4'] + ['#%06x' % (i*30000 + 0x808080) for i in range(len(pred_values))]\n",
    "\n",
    "            ax.bar(models, values, color=colors)\n",
    "\n",
    "            # 在柱子上方显示数值\n",
    "            for j, value in enumerate(values):\n",
    "                ax.text(j, value + 0.02 * max(values), f'{value:.4f}', ha='center', fontproperties=self.font_set)\n",
    "\n",
    "            # 设置标题和标签\n",
    "            ax.set_title(f'样本 {idx} 的预测结果对比', fontproperties=self.font_set)\n",
    "            ax.set_ylabel('值', fontproperties=self.font_set)\n",
    "            ax.grid(axis='y', linestyle='--', alpha=0.7)\n",
    "\n",
    "            # 设置y轴范围，使真实值和预测值都能显示完整\n",
    "            min_val = min(values) - 0.1 * (max(values) - min(values))\n",
    "            max_val = max(values) + 0.1 * (max(values) - min(values))\n",
    "            ax.set_ylim(min_val, max_val)\n",
    "\n",
    "        plt.tight_layout()\n",
    "        plt.subplots_adjust(right=0.85)  # 调整右侧边距\n",
    "        plt.show()    \n",
    "        \n",
    "    def plot_error_metrics(self):\n",
    "        \"\"\"绘制各模型的误差指标柱状图\"\"\"\n",
    "        if not self.metadata['data_loaded'] or 'model_performance' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少模型性能数据\"))\n",
    "            return\n",
    "            \n",
    "        perf_df = self.data['model_performance']\n",
    "        \n",
    "        # 检查必要的列\n",
    "        if '模型' not in perf_df.columns:\n",
    "            print(\"模型性能数据缺少'模型'列\")\n",
    "            return\n",
    "            \n",
    "        model_names = perf_df['模型'].tolist()\n",
    "        \n",
    "        # 查找MAE和RMSE列\n",
    "        mae_col = None\n",
    "        rmse_col = None\n",
    "        \n",
    "        for col in perf_df.columns:\n",
    "            if 'MAE' in col.upper():\n",
    "                mae_col = col\n",
    "            if 'RMSE' in col.upper():\n",
    "                rmse_col = col\n",
    "                \n",
    "        if not mae_col or not rmse_col:\n",
    "            print(\"未找到MAE或RMSE列\")\n",
    "            return\n",
    "            \n",
    "        fig, ax = plt.subplots(figsize=(12, 8))\n",
    "        \n",
    "        # 准备数据\n",
    "        metrics_data = perf_df[[mae_col, rmse_col]].values.T\n",
    "        \n",
    "        # 设置柱状图参数\n",
    "        x = np.arange(len(model_names))\n",
    "        width = 0.35\n",
    "        \n",
    "        # 绘制柱状图\n",
    "        bars1 = ax.bar(x - width/2, metrics_data[0], width, label='MAE', color='#4a7ab7')\n",
    "        bars2 = ax.bar(x + width/2, metrics_data[1], width, label='RMSE', color='#e66101')\n",
    "        \n",
    "        # 添加数值标签\n",
    "        for bars in [bars1, bars2]:\n",
    "            for bar in bars:\n",
    "                height = bar.get_height()\n",
    "                ax.text(bar.get_x() + bar.get_width()/2., height,\n",
    "                       f'{height:.3f}', ha='center', va='bottom', fontsize=9)\n",
    "                       \n",
    "        ax.set_xlabel('模型', fontproperties=self.font_set)\n",
    "        ax.set_ylabel('误差值', fontproperties=self.font_set)\n",
    "        ax.set_title('不同算法的误差指标对比', fontproperties=self.font_set)\n",
    "        ax.set_xticks(x)\n",
    "        ax.set_xticklabels(model_names, rotation=45, ha='right')\n",
    "        ax.legend(prop=self.font_set)\n",
    "        ax.grid(True, axis='y', linestyle='--', alpha=0.7)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_scatter(self):\n",
    "        \"\"\"绘制各模型预测值与实际值的散点图\"\"\"\n",
    "        if not self.metadata['data_loaded'] or 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少预测结果数据\"))\n",
    "            return\n",
    "            \n",
    "        y_test = self.data['y_test']\n",
    "        predictions = self.data['predictions']\n",
    "        model_names = list(predictions.keys())\n",
    "        \n",
    "        n_models = len(model_names)\n",
    "        n_cols = 3\n",
    "        n_rows = int(np.ceil(n_models / n_cols))\n",
    "        \n",
    "        fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows))\n",
    "        if n_rows == 1:\n",
    "            axes = axes.reshape(1, -1)\n",
    "        \n",
    "        axes = axes.flatten()\n",
    "        \n",
    "        for i, (name, pred) in enumerate(predictions.items()):\n",
    "            ax = axes[i]\n",
    "            ax.scatter(y_test, pred, alpha=0.6, edgecolors='k', linewidth=0.5, s=30)\n",
    "            \n",
    "            # 绘制理想线 y=x\n",
    "            min_val = min(np.min(y_test), np.min(pred))\n",
    "            max_val = max(np.max(y_test), np.max(pred))\n",
    "            ax.plot([min_val, max_val], [min_val, max_val], 'r--', alpha=0.8, linewidth=2)\n",
    "            \n",
    "            # 计算R²\n",
    "            r2 = r2_score(y_test, pred)\n",
    "            ax.set_xlabel('实际值', fontproperties=self.font_set)\n",
    "            ax.set_ylabel('预测值', fontproperties=self.font_set)\n",
    "            ax.set_title(f'{name} (R²={r2:.3f})', fontproperties=self.font_set)\n",
    "            ax.grid(True, linestyle='--', alpha=0.5)\n",
    "            \n",
    "        # 隐藏多余的子图\n",
    "        for i in range(n_models, len(axes)):\n",
    "            axes[i].axis('off')\n",
    "            \n",
    "        plt.suptitle('各模型预测值与实际值散点图', fontproperties=self.font_set, fontsize=16)\n",
    "        plt.tight_layout(rect=[0, 0, 1, 0.96])  # 为suptitle留出空间\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_scatter_density(self):\n",
    "        \"\"\"绘制预测值与实际值的散点密度图\"\"\"\n",
    "        if not self.metadata['data_loaded'] or 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少预测结果数据\"))\n",
    "            return\n",
    "\n",
    "        y_test = self.data['y_test']\n",
    "        predictions = self.data['predictions']\n",
    "\n",
    "        # 创建图形\n",
    "        plt.figure(figsize=(14, 12))\n",
    "\n",
    "        # 创建2x2网格布局\n",
    "        gs = GridSpec(2, 2, figure=plt.gcf(), width_ratios=[3, 1], height_ratios=[1, 3])\n",
    "\n",
    "        # 1. 主图：散点图（使用不同颜色区分模型）\n",
    "        ax_main = plt.subplot(gs[1, 0])\n",
    "        colors = plt.cm.tab10.colors\n",
    "\n",
    "        # 绘制所有模型的实际值vs预测值\n",
    "        for i, (name, pred) in enumerate(predictions.items()):\n",
    "            r2 = r2_score(y_test, pred)\n",
    "            ax_main.scatter(y_test, pred, alpha=0.6, s=20, \n",
    "                           color=colors[i % len(colors)], \n",
    "                           label=f'{name} (R²={r2:.3f})')\n",
    "\n",
    "        # 绘制理想线 y=x\n",
    "        all_values = np.concatenate([y_test] + list(predictions.values()))\n",
    "        min_val, max_val = np.min(all_values), np.max(all_values)\n",
    "        ax_main.plot([min_val, max_val], [min_val, max_val], 'r--', alpha=0.8, linewidth=2)\n",
    "\n",
    "        ax_main.set_xlabel('实际值', fontproperties=self.font_set)\n",
    "        ax_main.set_ylabel('预测值', fontproperties=self.font_set)\n",
    "        ax_main.set_title('不同算法预测值与实际值分布', fontproperties=self.font_set)\n",
    "        ax_main.grid(True, linestyle='--', alpha=0.5)\n",
    "\n",
    "        # 2. 右侧：实际值密度图\n",
    "        ax_right = plt.subplot(gs[1, 1])\n",
    "        sns.kdeplot(y_test, ax=ax_right, color='black', fill=True, alpha=0.5)\n",
    "        ax_right.set_ylabel('密度', fontproperties=self.font_set)\n",
    "        ax_right.set_title('实际值密度', fontproperties=self.font_set)\n",
    "        ax_right.yaxis.tick_right()\n",
    "        ax_right.yaxis.set_label_position(\"right\")\n",
    "\n",
    "        # 3. 上方：预测值平均密度图\n",
    "        ax_top = plt.subplot(gs[0, 0])\n",
    "        all_preds = np.concatenate(list(predictions.values()))\n",
    "        sns.kdeplot(all_preds, ax=ax_top, color='gray', fill=True, alpha=0.5)\n",
    "        ax_top.set_xlabel('值', fontproperties=self.font_set)\n",
    "        ax_top.set_title('所有预测值平均密度', fontproperties=self.font_set)\n",
    "        ax_top.xaxis.set_tick_params(labelbottom=False)\n",
    "\n",
    "        # 4. 为每个模型添加单独的密度图（小图）\n",
    "        n_models = len(predictions)\n",
    "        if n_models <= 4:\n",
    "            ax_density = plt.subplot(gs[0, 1])\n",
    "            for i, (name, pred) in enumerate(predictions.items()):\n",
    "                # 绘制残差密度图\n",
    "                residuals = pred - y_test\n",
    "                sns.kdeplot(residuals, ax=ax_density, color=colors[i % len(colors)], \n",
    "                           label=name, fill=True, alpha=0.4)\n",
    "                ax_density.axvline(x=0, color='gray', linestyle='--', alpha=0.7)\n",
    "\n",
    "            ax_density.set_title('模型残差分布', fontproperties=self.font_set)\n",
    "            ax_density.set_xlabel('残差值', fontproperties=self.font_set)\n",
    "            ax_density.legend(prop=self.font_set)\n",
    "\n",
    "        # 优化图例位置\n",
    "        ax_main.legend(bbox_to_anchor=(0.95, 0.95), loc='upper left', \n",
    "                      prop=self.font_set, frameon=True, framealpha=0.9)\n",
    "\n",
    "        plt.tight_layout(rect=[0, 0, 0.95, 0.95])\n",
    "        plt.show()\n",
    "  \n",
    "    def plot_model_performance_synthesis(self):\n",
    "        \"\"\"绘制模型性能综合对比极坐标图（整合归一化与标准化视角）\"\"\"\n",
    "        # 数据有效性检查\n",
    "        if not self.metadata['data_loaded'] or 'model_performance' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少模型性能数据\"))\n",
    "            return\n",
    "\n",
    "        perf_df = self.data['model_performance']\n",
    "        if '模型' not in perf_df.columns:\n",
    "            display(Markdown(\"> **错误**: 模型性能数据缺少'模型'列\"))\n",
    "            return\n",
    "\n",
    "        # 提取模型名称与数值型指标\n",
    "        model_names = perf_df['模型'].tolist()\n",
    "        numeric_cols = [col for col in perf_df.columns \n",
    "                       if col != '模型' and pd.api.types.is_numeric_dtype(perf_df[col])]\n",
    "\n",
    "        if len(numeric_cols) < 3:\n",
    "            display(Markdown(f\"> **错误**: 需至少3个数值型指标，当前仅检测到{len(numeric_cols)}个\"))\n",
    "            return\n",
    "\n",
    "        # 指标分类（正向指标：越大越好；负向指标：越小越好）\n",
    "        positive_metrics = {'R²', '调整后R²', '解释方差', '交叉验证得分 (R²)'}\n",
    "        metric_types = ['正向' if col in positive_metrics else '负向' for col in numeric_cols]\n",
    "        metrics_data = perf_df[numeric_cols].values\n",
    "        num_metrics = len(numeric_cols)\n",
    "\n",
    "        # --------------------------\n",
    "        # 1. 相对最优归一化（Min-Max）\n",
    "        # --------------------------\n",
    "        # 计算指标极值\n",
    "        min_vals = metrics_data.min(axis=0)\n",
    "        max_vals = metrics_data.max(axis=0)\n",
    "\n",
    "        # 按指标类型归一化（映射至[0,1]区间）\n",
    "        minmax_norm = np.zeros_like(metrics_data)\n",
    "        for i, col in enumerate(numeric_cols):\n",
    "            col_vals = metrics_data[:, i]\n",
    "            val_range = max_vals[i] - min_vals[i]\n",
    "\n",
    "            if col in positive_metrics:\n",
    "                # 正向指标：(x - min)/(max - min)\n",
    "                minmax_norm[:, i] = (col_vals - min_vals[i]) / val_range if val_range != 0 else 1.0\n",
    "            else:\n",
    "                # 负向指标：(max - x)/(max - min)\n",
    "                minmax_norm[:, i] = (max_vals[i] - col_vals) / val_range if val_range != 0 else 1.0\n",
    "\n",
    "        # --------------------------\n",
    "        # 2. 相对平均标准化（Z-score）\n",
    "        # --------------------------\n",
    "        zscore_scaler = StandardScaler()\n",
    "        zscore_norm = zscore_scaler.fit_transform(metrics_data)\n",
    "\n",
    "        # 统一指标方向（负向指标取反，使正值表示优于平均）\n",
    "        for i, col in enumerate(numeric_cols):\n",
    "            if col not in positive_metrics:\n",
    "                zscore_norm[:, i] = -zscore_norm[:, i]\n",
    "\n",
    "        # 计算综合得分（PCA权重加权）\n",
    "        pca = PCA(n_components=1)\n",
    "        pca.fit(zscore_norm)\n",
    "        pca_weights = np.abs(pca.components_[0]) / np.sum(np.abs(pca.components_[0]))  # 归一化权重\n",
    "        composite_scores = np.sum(zscore_norm * pca_weights, axis=1)  # 综合得分\n",
    "\n",
    "        # --------------------------\n",
    "        # 极坐标角度设置（共享指标角度）\n",
    "        # --------------------------\n",
    "        angles = np.linspace(0, 2*np.pi, num_metrics, endpoint=False).tolist()\n",
    "        angles_closed = angles + angles[:1]  # 闭合图形\n",
    "\n",
    "        # --------------------------\n",
    "        # 绘图：双极坐标子图布局\n",
    "        # --------------------------\n",
    "        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8), subplot_kw=dict(polar=True))\n",
    "        colors = plt.cm.tab10.colors  # 模型颜色循环\n",
    "\n",
    "        # --------------------------\n",
    "        # 子图1：Min-Max归一化雷达图\n",
    "        # --------------------------\n",
    "        ax1.set_title(\"(a) 基于相对最优的归一化性能雷达图\", \n",
    "                      fontproperties=self.font_set, fontsize=14, pad=20)\n",
    "\n",
    "        # 绘制各模型轮廓\n",
    "        for i, (data, name) in enumerate(zip(minmax_norm, model_names)):\n",
    "            values = data.tolist() + data.tolist()[:1]  # 闭合数据\n",
    "            ax1.plot(angles_closed, values, linewidth=2, label=name if i==0 else \"\", \n",
    "                     color=colors[i % len(colors)], alpha=0.8)\n",
    "            ax1.fill(angles_closed, values, alpha=0.15, color=colors[i % len(colors)])\n",
    "\n",
    "        # 坐标轴设置\n",
    "        ax1.set_thetagrids(np.degrees(angles), numeric_cols, fontproperties=self.font_set)\n",
    "        ax1.set_ylim(0, 1.1)\n",
    "        ax1.set_rgrids([0.2, 0.4, 0.6, 0.8, 1.0], labels=[0.2, 0.4, 0.6, 0.8, 1.0], \n",
    "                       fontproperties=self.font_set)\n",
    "        ax1.grid(True, linestyle='--', alpha=0.6)\n",
    "\n",
    "        # --------------------------\n",
    "        # 子图2：Z-score标准化罗盘图\n",
    "        # --------------------------\n",
    "        ax2.set_title(\"(b) 基于相对平均的标准化性能罗盘图\", \n",
    "                      fontproperties=self.font_set, fontsize=14, pad=20)\n",
    "\n",
    "        # 绘制各模型轮廓\n",
    "        for i, (data, name, score) in enumerate(zip(zscore_norm, model_names, composite_scores)):\n",
    "            values = data.tolist() + data.tolist()[:1]  # 闭合数据\n",
    "            ax2.plot(angles_closed, values, linewidth=2, label=name, \n",
    "                     color=colors[i % len(colors)], alpha=0.8)\n",
    "            ax2.fill(angles_closed, values, alpha=0.1, color=colors[i % len(colors)])\n",
    "            # 标记综合得分位置\n",
    "            ax2.plot(angles[0], composite_scores[i], 'o', markersize=7, \n",
    "                     color=colors[i % len(colors)], alpha=0.9)\n",
    "\n",
    "        # 绘制平均性能参考线\n",
    "        mean_vals = np.mean(zscore_norm, axis=0).tolist() + np.mean(zscore_norm, axis=0).tolist()[:1]\n",
    "        ax2.plot(angles_closed, mean_vals, linewidth=3, linestyle='--', color='black', label='平均水平')\n",
    "\n",
    "        # 坐标轴设置\n",
    "        ax2.set_thetagrids(np.degrees(angles), numeric_cols, fontproperties=self.font_set)\n",
    "        ax2.set_ylim(-1.5, 1.5)\n",
    "        ax2.set_rgrids([-1.0, -0.5, 0, 0.5, 1.0], labels=[-1.0, -0.5, 0, 0.5, 1.0], \n",
    "                       fontproperties=self.font_set)\n",
    "        ax2.grid(True, linestyle='--', alpha=0.6)\n",
    "        # 添加径向参考线（辅助判断指标优劣）\n",
    "        for angle in angles:\n",
    "            ax2.plot([angle, angle], [-1.5, 1.5], 'k--', alpha=0.2)\n",
    "\n",
    "        # --------------------------\n",
    "        # 图例与注释（学术化说明）\n",
    "        # --------------------------\n",
    "        # 统一图例（放置于右侧）\n",
    "        lines, labels = ax2.get_legend_handles_labels()\n",
    "        fig.legend(\n",
    "            lines, \n",
    "            labels, \n",
    "            loc='center right', \n",
    "            bbox_to_anchor=(1.1, 0.75),\n",
    "            prop=self.font_set,  \n",
    "            title=\"模型\", \n",
    "            title_fontproperties=self.font_set  # 这个参数名称正确\n",
    "        )\n",
    "        # 底部方法说明（学术规范注释）\n",
    "#         method_note = (\n",
    "#             \"注：(a) 采用Min-Max归一化：正向指标映射为(x-min)/(max-min)，负向指标映射为(max-x)/(max-min)，取值范围[0,1]，值越大表示越接近最优水平；\\n\"\n",
    "#             \"(b) 采用Z-score标准化：正向指标保留原始标准化结果，负向指标取反，取值反映相对平均水平的偏离程度（正值优于平均，负值劣于平均）；\\n\"\n",
    "#             \"综合得分基于主成分分析（PCA）权重计算，权重由第一主成分载荷绝对值归一化得到，反映模型整体性能。\"\n",
    "#         )\n",
    "#         plt.figtext(0.5, 0.01, method_note, ha='center', fontproperties=self.font_set, \n",
    "#                     bbox=dict(facecolor='none', edgecolor='gray', pad=8.0), fontsize=10)\n",
    "\n",
    "#         plt.tight_layout(rect=[0, 0.05, 0.9, 1])  # 预留底部注释空间\n",
    "        plt.tight_layout()  # 预留底部注释空间\n",
    "        plt.show()\n",
    "        \n",
    "    def _plot_residual_analysis(self):\n",
    "        \"\"\"绘制残差分析\"\"\"\n",
    "        # 使用第一个模型的预测结果进行残差分析\n",
    "        if not self.data['predictions']:\n",
    "            return\n",
    "            \n",
    "        model_name = list(self.data['predictions'].keys())[0]\n",
    "        y_pred = self.data['predictions'][model_name]\n",
    "        y_true = self.data['y_test']\n",
    "        \n",
    "        residuals = y_true - y_pred\n",
    "        \n",
    "        plt.figure(figsize=(14, 5))\n",
    "        \n",
    "        # 残差分布\n",
    "        plt.subplot(1, 2, 1)\n",
    "        sns.histplot(residuals, kde=True)\n",
    "        plt.axvline(x=0, color='r', linestyle='--')\n",
    "        plt.title(f'{model_name} 残差分布', fontproperties=self.font_set)\n",
    "        plt.xlabel('残差', fontproperties=self.font_set)\n",
    "        plt.ylabel('频率', fontproperties=self.font_set)\n",
    "        plt.grid(alpha=0.3)\n",
    "        \n",
    "        # 残差 vs 预测值\n",
    "        plt.subplot(1, 2, 2)\n",
    "        plt.scatter(y_pred, residuals, alpha=0.5)\n",
    "        plt.axhline(y=0, color='r', linestyle='--')\n",
    "        plt.title(f'{model_name} 残差 vs 预测值', fontproperties=self.font_set)\n",
    "        plt.xlabel('预测值', fontproperties=self.font_set)\n",
    "        plt.ylabel('残差', fontproperties=self.font_set)\n",
    "        plt.grid(alpha=0.3)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    # ==================== 训练指标可视化 ====================\n",
    "    \n",
    "    def plot_training_metrics(self):\n",
    "        \"\"\"训练指标可视化\"\"\"\n",
    "        if 'training_metrics' not in self.data:\n",
    "            print(\"未找到训练指标数据\")\n",
    "            return\n",
    "            \n",
    "        # 绘制训练历史\n",
    "        for filename, data in self.data['training_metrics'].items():\n",
    "            if 'training_history' in filename and isinstance(data, list):\n",
    "                self._plot_training_history(pd.DataFrame(data))\n",
    "            elif isinstance(data, pd.DataFrame) and 'epoch' in data.columns:\n",
    "                self._plot_training_progress(data)\n",
    "                \n",
    "    def _plot_training_history(self, history_df):\n",
    "        \"\"\"绘制训练历史\"\"\"\n",
    "        plt.figure(figsize=(14, 6))\n",
    "        \n",
    "        # 绘制损失函数变化\n",
    "        if 'loss' in history_df.columns:\n",
    "            plt.subplot(1, 2, 1)\n",
    "            sns.lineplot(x='epoch', y='loss', data=history_df)\n",
    "            plt.title('训练损失函数变化', fontproperties=self.font_set)\n",
    "            plt.xlabel('训练轮次 (Epoch)', fontproperties=self.font_set)\n",
    "            plt.ylabel('损失值 (Loss)', fontproperties=self.font_set)\n",
    "            plt.grid(True, alpha=0.3)\n",
    "            \n",
    "        # 绘制学习率变化\n",
    "        if 'learning_rate' in history_df.columns:\n",
    "            plt.subplot(1, 2, 2)\n",
    "            sns.lineplot(x='epoch', y='learning_rate', data=history_df)\n",
    "            plt.title('学习率变化', fontproperties=self.font_set)\n",
    "            plt.xlabel('训练轮次 (Epoch)', fontproperties=self.font_set)\n",
    "            plt.ylabel('学习率 (Learning Rate)', fontproperties=self.font_set)\n",
    "            plt.grid(True, alpha=0.3)\n",
    "            plt.yscale('log')\n",
    "            \n",
    "            # 标记学习率下降点\n",
    "            lr_changes = history_df[history_df['learning_rate'].diff() < -0.0001]\n",
    "            for _, row in lr_changes.iterrows():\n",
    "                plt.axvline(x=row['epoch'], color='r', linestyle='--', alpha=0.7)\n",
    "                plt.text(row['epoch']+1, row['learning_rate']*1.5, \n",
    "                        f'LR下降', color='r', ha='left', va='bottom',\n",
    "                        fontproperties=self.font_set)\n",
    "            \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def _plot_training_progress(self, metrics_df):\n",
    "        \"\"\"绘制训练进度\"\"\"\n",
    "        # 绘制验证集指标\n",
    "        val_metrics = [col for col in metrics_df.columns if col.startswith('val_')]\n",
    "        \n",
    "        if val_metrics:\n",
    "            n_metrics = len(val_metrics)\n",
    "            fig, axes = plt.subplots(1, n_metrics, figsize=(5*n_metrics, 5))\n",
    "            if n_metrics == 1:\n",
    "                axes = [axes]\n",
    "                \n",
    "            for i, metric in enumerate(val_metrics):\n",
    "                sns.lineplot(x='epoch', y=metric, data=metrics_df, ax=axes[i])\n",
    "                axes[i].set_title(f'验证集 {metric.replace(\"val_\", \"\")} 变化',\n",
    "                                 fontproperties=self.font_set)\n",
    "                axes[i].set_xlabel('训练轮次', fontproperties=self.font_set)\n",
    "                axes[i].grid(True, alpha=0.3)\n",
    "                \n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    # ==================== 调优结果可视化 ====================\n",
    "    \n",
    "    def plot_tuning_results(self):\n",
    "        \"\"\"调优结果可视化\"\"\"\n",
    "        if 'tuning_details' in self.data:\n",
    "            self._plot_tuning_comparison()\n",
    "            self._plot_model_comparison()\n",
    "            \n",
    "        if 'tuning_results' in self.data:\n",
    "            for filename, data in self.data['tuning_results'].items():\n",
    "                if 'parameter_results' in filename and isinstance(data, pd.DataFrame):\n",
    "                    model_name = filename.split('_')[0]\n",
    "                    self._plot_parameter_effect(model_name, data)\n",
    "                    self.plot_hyperparameter_sensitivity(model_name)\n",
    "                    \n",
    "    def _plot_tuning_comparison(self):\n",
    "        \"\"\"绘制调优结果对比\"\"\"\n",
    "        if not isinstance(self.data['tuning_details'], list):\n",
    "            return\n",
    "            \n",
    "        successful_runs = [run for run in self.data['tuning_details'] \n",
    "                          if run.get('status') == 'success']\n",
    "        \n",
    "        if not successful_runs:\n",
    "            return\n",
    "            \n",
    "        plt.figure(figsize=(14, 6))\n",
    "        \n",
    "        models = [run['model_name'] for run in successful_runs]\n",
    "        scores = [run['best_score'] for run in successful_runs]\n",
    "        times = [run['training_time'] for run in successful_runs]\n",
    "        \n",
    "        # R²分数比较\n",
    "        plt.subplot(1, 2, 1)\n",
    "        sns.barplot(x=models, y=scores)\n",
    "        plt.title('各模型最佳交叉验证R²分数', fontproperties=self.font_set)\n",
    "        plt.ylabel('R²分数', fontproperties=self.font_set)\n",
    "        plt.xticks(rotation=45, ha='right')\n",
    "        plt.grid(axis='y', alpha=0.3)\n",
    "        \n",
    "        # 训练时间比较\n",
    "        plt.subplot(1, 2, 2)\n",
    "        sns.barplot(x=models, y=times)\n",
    "        plt.title('各模型训练时间', fontproperties=self.font_set)\n",
    "        plt.ylabel('训练时间 (秒)', fontproperties=self.font_set)\n",
    "        plt.xticks(rotation=45, ha='right')\n",
    "        plt.grid(axis='y', alpha=0.3)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # R²与训练时间关系\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        for model, score, time in zip(models, scores, times):\n",
    "            plt.scatter(time, score, s=100)\n",
    "            plt.text(time+0.1, score, model, fontsize=9, fontproperties=self.font_set)\n",
    "            \n",
    "        plt.xlabel('训练时间 (秒)', fontproperties=self.font_set)\n",
    "        plt.ylabel('R²分数', fontproperties=self.font_set)\n",
    "        plt.title('模型性能与训练时间的关系', fontproperties=self.font_set)\n",
    "        plt.grid(True, alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def _plot_model_comparison(self):\n",
    "        \"\"\"绘制各模型最佳R²性能比较\"\"\"\n",
    "        if 'tuning_results' not in self.data:\n",
    "            return\n",
    "            \n",
    "        # 收集所有模型的最佳性能\n",
    "        model_performance = []\n",
    "        \n",
    "        for filename, data in self.data['tuning_results'].items():\n",
    "            if 'parameter_results' in filename and isinstance(data, pd.DataFrame):\n",
    "                model_name = filename.split('_')[0]\n",
    "                if 'mean_r2' in data.columns:\n",
    "                    best_idx = data['mean_r2'].idxmax()\n",
    "                    best_r2 = data.loc[best_idx, 'mean_r2']\n",
    "                    model_performance.append({\n",
    "                        '模型': model_name,\n",
    "                        '最佳R²': best_r2\n",
    "                    })\n",
    "                    \n",
    "        if model_performance:\n",
    "            perf_df = pd.DataFrame(model_performance)\n",
    "            perf_df = perf_df.sort_values('最佳R²', ascending=False)\n",
    "            \n",
    "            plt.figure(figsize=(12, 8))\n",
    "            colors = plt.cm.viridis(np.linspace(0, 1, len(perf_df)))\n",
    "            bars = plt.bar(perf_df['模型'], perf_df['最佳R²'], color=colors)\n",
    "            \n",
    "            # 添加数值标签\n",
    "            for bar, value in zip(bars, perf_df['最佳R²']):\n",
    "                plt.text(bar.get_x() + bar.get_width()/2., bar.get_height() + 0.01,\n",
    "                        f'{value:.4f}', ha='center', va='bottom', fontsize=10)\n",
    "                        \n",
    "            plt.title('各模型最佳R²性能比较', fontproperties=self.font_set, fontsize=16)\n",
    "            plt.xlabel('模型', fontproperties=self.font_set)\n",
    "            plt.ylabel('最佳R²分数', fontproperties=self.font_set)\n",
    "            plt.xticks(rotation=45, ha='right')\n",
    "            plt.grid(True, axis='y', alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    def _plot_parameter_effect(self, model_name, param_df):\n",
    "        \"\"\"绘制超参数对模型性能的影响\"\"\"\n",
    "        if 'alpha' in param_df.columns and 'mean_r2' in param_df.columns:\n",
    "            plt.figure(figsize=(10, 6))\n",
    "            sns.lineplot(x='alpha', y='mean_r2', data=param_df)\n",
    "            plt.title(f'{model_name}中alpha参数对R²的影响', fontproperties=self.font_set)\n",
    "            plt.xlabel('alpha值', fontproperties=self.font_set)\n",
    "            plt.ylabel('平均R²分数', fontproperties=self.font_set)\n",
    "            plt.grid(True, alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "        if 'n_estimators' in param_df.columns and 'mean_r2' in param_df.columns:\n",
    "            plt.figure(figsize=(10, 6))\n",
    "            sns.lineplot(x='n_estimators', y='mean_r2', data=param_df)\n",
    "            plt.title(f'{model_name}中树的数量对R²的影响', fontproperties=self.font_set)\n",
    "            plt.xlabel('树的数量 (n_estimators)', fontproperties=self.font_set)\n",
    "            plt.ylabel('平均R²分数', fontproperties=self.font_set)\n",
    "            plt.grid(True, alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "        if 'max_depth' in param_df.columns and 'mean_r2' in param_df.columns:\n",
    "            plt.figure(figsize=(10, 6))\n",
    "            sns.lineplot(x='max_depth', y='mean_r2', data=param_df)\n",
    "            plt.title(f'{model_name}中最大深度对R²的影响', fontproperties=self.font_set)\n",
    "            plt.xlabel('最大深度 (max_depth)', fontproperties=self.font_set)\n",
    "            plt.ylabel('平均R²分数', fontproperties=self.font_set)\n",
    "            plt.grid(True, alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    def plot_hyperparameter_sensitivity(self, model_name):\n",
    "        \"\"\"绘制超参数敏感性分析\"\"\"\n",
    "        if 'tuning_results' not in self.data:\n",
    "            return\n",
    "            \n",
    "        # 查找对应的调优数据\n",
    "        param_df = None\n",
    "        for filename, data in self.data['tuning_results'].items():\n",
    "            if model_name in filename and isinstance(data, pd.DataFrame):\n",
    "                param_df = data\n",
    "                break\n",
    "                \n",
    "        if param_df is None or 'mean_r2' not in param_df.columns:\n",
    "            return\n",
    "            \n",
    "        # 识别数值型参数\n",
    "        numeric_params = []\n",
    "        for col in param_df.columns:\n",
    "            if col != 'mean_r2' and pd.api.types.is_numeric_dtype(param_df[col]):\n",
    "                if param_df[col].nunique() > 3:\n",
    "                    numeric_params.append(col)\n",
    "                    \n",
    "        if not numeric_params:\n",
    "            return\n",
    "            \n",
    "        # 选择前2个参数进行可视化\n",
    "        params_to_plot = numeric_params[:2]\n",
    "        \n",
    "        fig, axes = plt.subplots(1, len(params_to_plot), figsize=(15, 6))\n",
    "        if len(params_to_plot) == 1:\n",
    "            axes = [axes]\n",
    "            \n",
    "        for i, param in enumerate(params_to_plot):\n",
    "            ax = axes[i]\n",
    "            \n",
    "            # 对参数值排序\n",
    "            param_data = param_df[[param, 'mean_r2']].sort_values(param)\n",
    "            \n",
    "            # 绘制曲线\n",
    "            ax.plot(param_data[param], param_data['mean_r2'], 'bo-', alpha=0.7)\n",
    "            ax.set_title(f'{param} 敏感性', fontproperties=self.font_set)\n",
    "            ax.set_xlabel(param, fontproperties=self.font_set)\n",
    "            ax.set_ylabel('平均R²分数', fontproperties=self.font_set)\n",
    "            ax.grid(True, alpha=0.3)\n",
    "            \n",
    "            # 标记最佳值\n",
    "            best_idx = param_data['mean_r2'].idxmax()\n",
    "            best_value = param_data.loc[best_idx, param]\n",
    "            best_score = param_data.loc[best_idx, 'mean_r2']\n",
    "            ax.axvline(x=best_value, color='r', linestyle='--', alpha=0.7)\n",
    "            ax.text(best_value, ax.get_ylim()[0] + 0.05 * (ax.get_ylim()[1]-ax.get_ylim()[0]), \n",
    "                    f'最佳值: {best_value:.4f}\\nR²: {best_score:.4f}', \n",
    "                    color='red', fontproperties=self.font_set)\n",
    "                    \n",
    "        plt.suptitle(f'{model_name} 超参数敏感性分析', fontproperties=self.font_set)\n",
    "        plt.tight_layout(rect=[0, 0, 1, 0.95])\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_training_time_analysis(self):\n",
    "        \"\"\"绘制训练时间分析\"\"\"\n",
    "        if not self.metadata.get('data_loaded', False) or 'model_performance' not in self.data:\n",
    "            display(Markdown(\"> 错误: 数据未加载或缺少模型性能数据\"))\n",
    "            return\n",
    "            \n",
    "        perf_df = self.data['model_performance']\n",
    "        \n",
    "        # 查找训练时间列\n",
    "        time_col = None\n",
    "        for col in perf_df.columns:\n",
    "            if '训练时间' in col or 'training_time' in col.lower():\n",
    "                time_col = col\n",
    "                break\n",
    "                \n",
    "        if not time_col:\n",
    "            print(\"未找到训练时间数据\")\n",
    "            return\n",
    "            \n",
    "        # GPU加速模型列表\n",
    "        gpu_models = ['XGBoost', 'LightGBM', 'PyTorchNN', 'CatBoost', 'TensorFlow', '神经网络']\n",
    "        perf_df['GPU加速'] = perf_df['模型'].apply(lambda x: '是' if x in gpu_models else '否')\n",
    "        \n",
    "        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n",
    "        \n",
    "        # 训练时间分布\n",
    "        sns.boxplot(x='GPU加速', y=time_col, data=perf_df, ax=ax1)\n",
    "        ax1.set_title('GPU加速对训练时间的影响', fontproperties=self.font_set)\n",
    "        ax1.set_xlabel('是否使用GPU加速', fontproperties=self.font_set)\n",
    "        ax1.set_ylabel('训练时间 (秒)', fontproperties=self.font_set)\n",
    "        ax1.grid(axis='y', alpha=0.3)\n",
    "        \n",
    "        # 计算加速比\n",
    "        gpu_times = perf_df[perf_df['GPU加速'] == '是'][time_col]\n",
    "        cpu_times = perf_df[perf_df['GPU加速'] == '否'][time_col]\n",
    "        \n",
    "        if not gpu_times.empty and not cpu_times.empty:\n",
    "            avg_gpu_time = gpu_times.mean()\n",
    "            avg_cpu_time = cpu_times.mean()\n",
    "            speedup = avg_cpu_time / avg_gpu_time if avg_gpu_time > 0 else 0\n",
    "            \n",
    "            # 绘制平均时间对比\n",
    "            ax2.bar(['GPU加速', 'CPU'], [avg_gpu_time, avg_cpu_time], \n",
    "                   color=['royalblue', 'indianred'])\n",
    "            ax2.set_title(f'平均训练时间比较 (加速比: {speedup:.1f}x)', \n",
    "                         fontproperties=self.font_set)\n",
    "            ax2.set_ylabel('平均训练时间 (秒)', fontproperties=self.font_set)\n",
    "            \n",
    "            # 添加数值标签\n",
    "            for i, v in enumerate([avg_gpu_time, avg_cpu_time]):\n",
    "                ax2.text(i, v + max(avg_gpu_time, avg_cpu_time) * 0.02, \n",
    "                        f\"{v:.1f}s\", ha='center')\n",
    "                        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # 输出分析结果\n",
    "        if 'speedup' in locals():\n",
    "            display(Markdown(\"### 训练时间分析\"))\n",
    "            display(Markdown(\n",
    "                f\"- GPU加速模型平均训练时间: **{avg_gpu_time:.1f}** 秒\\n\"\n",
    "                f\"- 非GPU加速模型平均训练时间: **{avg_cpu_time:.1f}** 秒\\n\"\n",
    "                f\"- GPU加速带来 **{speedup:.1f}倍** 的速度提升\"\n",
    "            ))\n",
    "            \n",
    "    # ==================== 综合分析 ====================\n",
    "    \n",
    "    def generate_comprehensive_report(self):\n",
    "        \"\"\"生成综合分析报告\"\"\"\n",
    "        display(Markdown(\"# 机器学习模型综合分析报告\"))\n",
    "        \n",
    "        # 1. 数据概览\n",
    "        display(Markdown(\"## 1. 数据概览\"))\n",
    "        if 'test_data' in self.data and 'X_test' in self.data['test_data']:\n",
    "            X_test = self.data['test_data']['X_test']\n",
    "            if hasattr(X_test, 'shape'):\n",
    "                display(Markdown(f\"- 测试集样本数: **{X_test.shape[0]}**\"))\n",
    "                display(Markdown(f\"- 特征数: **{X_test.shape[1]}**\"))\n",
    "                \n",
    "        # 2. 模型性能总结\n",
    "        display(Markdown(\"## 2. 模型性能总结\"))\n",
    "        if 'model_performance' in self.data:\n",
    "            perf_df = self.data['model_performance']\n",
    "            \n",
    "            # 找到R²列\n",
    "            r2_col = None\n",
    "            for col in perf_df.columns:\n",
    "                if 'R²' in col or 'R2' in col or 'r2' in col.lower():\n",
    "                    r2_col = col\n",
    "                    break\n",
    "                    \n",
    "            if r2_col and '模型' in perf_df.columns:\n",
    "                best_model_idx = perf_df[r2_col].idxmax()\n",
    "                best_model = perf_df.loc[best_model_idx, '模型']\n",
    "                best_r2 = perf_df.loc[best_model_idx, r2_col]\n",
    "                \n",
    "                display(Markdown(f\"- 最佳模型: **{best_model}**\"))\n",
    "                display(Markdown(f\"- 最佳R²分数: **{best_r2:.4f}**\"))\n",
    "                \n",
    "                # 显示性能表格\n",
    "                display(Markdown(\"### 各模型性能指标\"))\n",
    "                display(perf_df)\n",
    "                \n",
    "        # 3. 关键发现\n",
    "        display(Markdown(\"## 3. 关键发现\"))\n",
    "        if 'predictions' in self.data and 'y_test' in self.data:\n",
    "            # 计算预测误差统计\n",
    "            for name, pred in self.data['predictions'].items():\n",
    "                mse = mean_squared_error(self.data['y_test'], pred)\n",
    "                mae = mean_absolute_error(self.data['y_test'], pred)\n",
    "                display(Markdown(f\"- {name}: MSE={mse:.4f}, MAE={mae:.4f}\"))\n",
    "                \n",
    "        # 4. 建议\n",
    "        display(Markdown(\"## 4. 建议\"))\n",
    "        display(Markdown(\n",
    "            \"- 考虑使用集成学习方法组合表现最好的几个模型\\n\"\n",
    "            \"- 进一步优化最佳模型的超参数\\n\"\n",
    "            \"- 收集更多数据以提高模型泛化能力\\n\"\n",
    "            \"- 考虑特征工程以提取更有信息量的特征\"\n",
    "        ))\n",
    "        \n",
    "    def plot_academic_report_key_metrics(self):\n",
    "        \"\"\"从学术报告中提取关键指标并绘制\"\"\"\n",
    "        if 'academic_report' not in self.data:\n",
    "            return\n",
    "            \n",
    "        report_content = self.data['academic_report']\n",
    "        \n",
    "        # 简单提取R²和训练时间等关键词\n",
    "        key_metrics = {}\n",
    "        for line in report_content.split('\\n'):\n",
    "            if 'R²' in line and '=' in line:\n",
    "                try:\n",
    "                    r2 = float(line.split('=')[-1].strip().split()[0])\n",
    "                    key_metrics['R²'] = r2\n",
    "                except:\n",
    "                    pass\n",
    "            if '训练时间' in line and '秒' in line:\n",
    "                try:\n",
    "                    time = float(line.split('(')[-1].split(')')[0])\n",
    "                    key_metrics['训练时间 (秒)'] = time\n",
    "                except:\n",
    "                    pass\n",
    "            if 'MAPE' in line and '=' in line:\n",
    "                try:\n",
    "                    mape = float(line.split('=')[-1].strip().split()[0])\n",
    "                    key_metrics['MAPE'] = mape\n",
    "                except:\n",
    "                    pass\n",
    "                    \n",
    "        if key_metrics:\n",
    "            plt.figure(figsize=(8, 6))\n",
    "            metrics = list(key_metrics.keys())\n",
    "            values = list(key_metrics.values())\n",
    "            bars = plt.bar(metrics, values, color=['#4a7ab7', '#e66101', '#fdb863'])\n",
    "            \n",
    "            # 添加数值标签\n",
    "            for bar, value in zip(bars, values):\n",
    "                plt.text(bar.get_x() + bar.get_width()/2., bar.get_height() + 0.01,\n",
    "                        f'{value:.2f}', ha='center', va='bottom')\n",
    "                        \n",
    "            plt.title('学术报告关键指标', fontproperties=self.font_set)\n",
    "            plt.ylabel('值', fontproperties=self.font_set)\n",
    "            plt.grid(axis='y', alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    def plot_multi_model_sensitivity(self):\n",
    "        \"\"\"\n",
    "        可视化多个模型的超参数敏感性分析结果\n",
    "        \"\"\"\n",
    "        # 修复元数据检查\n",
    "        if not self.metadata.get('sensitivity_analyzed', False):\n",
    "            # 如果尚未分析，尝试初始化\n",
    "            if 'tuning_results' in self.data:\n",
    "                self.metadata['sensitivity_analyzed'] = True\n",
    "                self.data['sensitivity_results'] = {}\n",
    "                for filename, data in self.data['tuning_results'].items():\n",
    "                    if 'parameter_results' in filename and isinstance(data, pd.DataFrame):\n",
    "                        model_name = filename.split('_')[0]\n",
    "                        self.data['sensitivity_results'][model_name] = data\n",
    "            else:\n",
    "                display(Markdown(\"> **错误**: 尚未进行超参数敏感性分析\"))\n",
    "                return\n",
    "\n",
    "        param_data_dict = self.data.get('sensitivity_results', {})\n",
    "        if not param_data_dict:\n",
    "            display(Markdown(\"> **错误**: 未找到超参数敏感性分析数据\"))\n",
    "            return\n",
    "\n",
    "        # 确定要显示的模型数量和参数数量\n",
    "        n_models = len(param_data_dict)\n",
    "        n_params = max(len([col for col in data.columns if col != 'mean_r2' and pd.api.types.is_numeric_dtype(data[col])]) \n",
    "                      for data in param_data_dict.values())\n",
    "\n",
    "        # 创建子图布局\n",
    "        fig, axes = plt.subplots(n_models, n_params, figsize=(5 * n_params, 4 * n_models))\n",
    "        if n_models == 1:\n",
    "            axes = [axes]\n",
    "        if n_params == 1:\n",
    "            axes = [[ax] for ax in axes]\n",
    "\n",
    "        # 遍历每个模型的敏感性分析结果\n",
    "        model_idx = 0\n",
    "        for model_name, param_data in param_data_dict.items():\n",
    "            param_names = [col for col in param_data.columns \n",
    "                          if col != 'mean_r2' and pd.api.types.is_numeric_dtype(param_data[col])]\n",
    "\n",
    "            # 遍历每个参数\n",
    "            for param_idx, param_name in enumerate(param_names):\n",
    "                if param_idx >= n_params:  # 只显示前n_params个参数\n",
    "                    continue\n",
    "                    \n",
    "                ax = axes[model_idx][param_idx]\n",
    "\n",
    "                # 获取参数值和对应的R²分数\n",
    "                param_values = param_data[param_name].tolist()\n",
    "                mean_r2 = param_data['mean_r2'].tolist()\n",
    "\n",
    "                # 找到最佳参数值\n",
    "                best_idx = param_data['mean_r2'].idxmax()\n",
    "                best_value = param_data.loc[best_idx, param_name]\n",
    "                best_score = param_data.loc[best_idx, 'mean_r2']\n",
    "\n",
    "                # 根据参数类型选择合适的图表类型\n",
    "                try:\n",
    "                    # 尝试将参数值转换为浮点数，如果成功则视为连续型参数\n",
    "                    float_values = [float(val) for val in param_values]\n",
    "                    is_numeric = True\n",
    "                except (ValueError, TypeError):\n",
    "                    # 否则视为分类参数\n",
    "                    is_numeric = False\n",
    "\n",
    "                if is_numeric:\n",
    "                    # 对于连续型参数，使用线图\n",
    "                    ax.plot(float_values, mean_r2, 'o-', linewidth=2, markersize=6)\n",
    "                    ax.set_xlabel(param_name, fontproperties=self.font_set)\n",
    "                else:\n",
    "                    # 对于分类参数，使用柱状图\n",
    "                    ax.bar(param_values, mean_r2, width=0.6)\n",
    "                    ax.set_xlabel(param_name, fontproperties=self.font_set)\n",
    "                    # 旋转x轴标签以便更好显示\n",
    "                    ax.tick_params(axis='x', rotation=45)\n",
    "\n",
    "                ax.set_ylabel('平均R²分数', fontproperties=self.font_set)\n",
    "                ax.set_title(f'{model_name} - {param_name}', fontproperties=self.font_set)\n",
    "                ax.grid(True, linestyle='--', alpha=0.7)\n",
    "\n",
    "                # 设置y轴范围，最小值设为0或当前最小值中的较小值\n",
    "                ax.set_ylim(bottom=min(0, min(mean_r2) - 0.05), top=1.05)\n",
    "\n",
    "                # 标记最佳参数值\n",
    "                ax.axvline(x=best_value, color='r', linestyle='--', alpha=0.7)\n",
    "\n",
    "                # 根据参数类型调整标注格式\n",
    "                if is_numeric:\n",
    "                    # 数值类型参数使用浮点数格式\n",
    "                    value_str = f'{best_value:.2f}'\n",
    "                else:\n",
    "                    # 分类类型参数直接使用原始值\n",
    "                    value_str = str(best_value)\n",
    "\n",
    "                ax.text(best_value, ax.get_ylim()[0] + 0.05 * (ax.get_ylim()[1]-ax.get_ylim()[0]), \n",
    "                        f'最佳: {value_str}\\nR²: {best_score:.4f}', \n",
    "                        color='red', fontproperties=self.font_set, fontsize=9, ha='center')\n",
    "\n",
    "            model_idx += 1\n",
    "\n",
    "        # 隐藏多余的子图\n",
    "        for i in range(model_idx, n_models):\n",
    "            for j in range(n_params):\n",
    "                axes[i][j].axis('off')\n",
    "\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_multi_model_prediction_comparison(self):\n",
    "        \"\"\"多模型预测值与真实值综合对比\"\"\"\n",
    "        if not self.metadata['data_loaded'] or 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            display(Markdown(\"> **错误**: 数据未加载或缺少预测结果数据\"))\n",
    "            return\n",
    "            \n",
    "        y_test = self.data['y_test']\n",
    "        predictions = self.data['predictions']\n",
    "        model_names = list(predictions.keys())\n",
    "        \n",
    "        if not model_names:\n",
    "            return\n",
    "            \n",
    "        # 创建组合图表\n",
    "        fig = plt.figure(figsize=(16, 10))\n",
    "        gs = GridSpec(2, 2, figure=fig)\n",
    "        \n",
    "        # 1. 预测值与真实值对比曲线\n",
    "        ax1 = fig.add_subplot(gs[0, :])\n",
    "        n_samples = min(100, len(y_test))\n",
    "        indices = np.arange(n_samples)\n",
    "        \n",
    "        ax1.plot(indices, y_test[:n_samples], '--*', label='真实值', linewidth=2, markersize=6)\n",
    "        \n",
    "        colors = plt.cm.tab10.colors\n",
    "        for i, (name, pred) in enumerate(predictions.items()):\n",
    "            ax1.plot(indices, pred[:n_samples], label=name, color=colors[i % len(colors)], \n",
    "                    linewidth=1.5, alpha=0.8)\n",
    "            \n",
    "        ax1.set_xlabel('样本索引', fontproperties=self.font_set)\n",
    "        ax1.set_ylabel('值', fontproperties=self.font_set)\n",
    "        ax1.set_title('模型预测值与真实值对比 (前100个样本)', fontproperties=self.font_set)\n",
    "        ax1.legend(prop=self.font_set, bbox_to_anchor=(1.05, 1), loc='upper left')\n",
    "        ax1.grid(True, linestyle='--', alpha=0.7)\n",
    "        \n",
    "        # 2. 残差分析\n",
    "        ax2 = fig.add_subplot(gs[1, 0])\n",
    "        for i, (name, pred) in enumerate(predictions.items()):\n",
    "            residuals = y_test - pred\n",
    "            sns.kdeplot(residuals, ax=ax2, color=colors[i % len(colors)], \n",
    "                       label=name, fill=True, alpha=0.2)\n",
    "            \n",
    "        ax2.axvline(x=0, color='black', linestyle='--', alpha=0.7)\n",
    "        ax2.set_xlabel('残差值', fontproperties=self.font_set)\n",
    "        ax2.set_ylabel('密度', fontproperties=self.font_set)\n",
    "        ax2.set_title('模型残差分布', fontproperties=self.font_set)\n",
    "        ax2.legend(prop=self.font_set)\n",
    "        ax2.grid(True, linestyle='--', alpha=0.7)\n",
    "        \n",
    "        # 3. 误差指标对比\n",
    "        ax3 = fig.add_subplot(gs[1, 1])\n",
    "        metrics = []\n",
    "        \n",
    "        for name, pred in predictions.items():\n",
    "            r2 = r2_score(y_test, pred)\n",
    "            rmse = np.sqrt(mean_squared_error(y_test, pred))\n",
    "            mae = mean_absolute_error(y_test, pred)\n",
    "            \n",
    "            metrics.append({\n",
    "                '模型': name,\n",
    "                'R²': r2,\n",
    "                'RMSE': rmse,\n",
    "                'MAE': mae\n",
    "            })\n",
    "            \n",
    "        metrics_df = pd.DataFrame(metrics)\n",
    "        \n",
    "        x = np.arange(len(model_names))\n",
    "        width = 0.25\n",
    "        \n",
    "        for i, metric in enumerate(['R²', 'RMSE', 'MAE']):\n",
    "            pos = x + width * (i - 1)\n",
    "            ax3.bar(pos, metrics_df[metric], width, label=metric)\n",
    "            \n",
    "        ax3.set_xlabel('模型', fontproperties=self.font_set)\n",
    "        ax3.set_ylabel('指标值', fontproperties=self.font_set)\n",
    "        ax3.set_title('模型误差指标对比', fontproperties=self.font_set)\n",
    "        ax3.set_xticks(x)\n",
    "        ax3.set_xticklabels(model_names, rotation=45, ha='right')\n",
    "        ax3.legend(prop=self.font_set)\n",
    "        ax3.grid(True, axis='y', linestyle='--', alpha=0.7)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.subplots_adjust(right=0.85)  # 为图例腾出空间\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_feature_importance_comparison(self):\n",
    "        \"\"\"比较不同模型的特征重要性\"\"\"\n",
    "        if 'data_exploration' not in self.data or 'feature_importance.csv' not in self.data['data_exploration']:\n",
    "            print(\"未找到特征重要性数据\")\n",
    "            return\n",
    "            \n",
    "        importance_df = self.data['data_exploration']['feature_importance.csv']\n",
    "        \n",
    "        # 确保数据格式正确\n",
    "        if 'feature' not in importance_df.columns or 'importance' not in importance_df.columns:\n",
    "            print(\"特征重要性数据格式不正确\")\n",
    "            return\n",
    "            \n",
    "        # 获取前10个重要特征\n",
    "        top_features = importance_df.nlargest(10, 'importance')\n",
    "        \n",
    "        plt.figure(figsize=(12, 8))\n",
    "        sns.barplot(x='importance', y='feature', data=top_features, palette='viridis')\n",
    "        plt.title('特征重要性排名 (Top 10)', fontproperties=self.font_set)\n",
    "        plt.xlabel('重要性', fontproperties=self.font_set)\n",
    "        plt.ylabel('特征', fontproperties=self.font_set)\n",
    "        plt.grid(axis='x', alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # 绘制特征重要性分布\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.histplot(importance_df['importance'], kde=True)\n",
    "        plt.title('特征重要性分布', fontproperties=self.font_set)\n",
    "        plt.xlabel('重要性', fontproperties=self.font_set)\n",
    "        plt.ylabel('频率', fontproperties=self.font_set)\n",
    "        plt.grid(alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_correlation_heatmap(self):\n",
    "        \"\"\"绘制特征相关性热图\"\"\"\n",
    "        if 'data_exploration' not in self.data or 'correlation.json' not in self.data['data_exploration']:\n",
    "            print(\"未找到相关性数据\")\n",
    "            return\n",
    "            \n",
    "        corr_data = self.data['data_exploration']['correlation.json']\n",
    "        \n",
    "        if 'matrix' not in corr_data:\n",
    "            print(\"相关性数据格式不正确\")\n",
    "            return\n",
    "            \n",
    "        corr_matrix = pd.DataFrame(corr_data['matrix'])\n",
    "        \n",
    "        # 为了可视化，只显示前20个特征\n",
    "        if len(corr_matrix.columns) > 20:\n",
    "            corr_matrix = corr_matrix.iloc[:20, :20]\n",
    "            \n",
    "        plt.figure(figsize=(12, 10))\n",
    "        mask = np.triu(np.ones_like(corr_matrix, dtype=bool))\n",
    "        cmap = sns.diverging_palette(230, 20, as_cmap=True)\n",
    "        \n",
    "        sns.heatmap(corr_matrix, mask=mask, cmap=cmap, vmax=1.0, vmin=-1.0,\n",
    "                   center=0, square=True, linewidths=.5, cbar_kws={\"shrink\": .5},\n",
    "                   annot=True, fmt=\".2f\", annot_kws={\"fontproperties\": self.font_set})\n",
    "                   \n",
    "        plt.title('特征相关性热图', fontproperties=self.font_set)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_prediction_distribution(self):\n",
    "        \"\"\"绘制预测值与真实值的分布对比\"\"\"\n",
    "        if 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            print(\"未找到预测数据或真实值\")\n",
    "            return\n",
    "            \n",
    "        y_test = self.data['y_test']\n",
    "        \n",
    "        plt.figure(figsize=(12, 8))\n",
    "        \n",
    "        # 绘制真实值分布\n",
    "        sns.histplot(y_test, kde=True, label='真实值', color='blue', alpha=0.5)\n",
    "        \n",
    "        # 绘制各模型预测值分布\n",
    "        for name, pred in self.data['predictions'].items():\n",
    "            sns.histplot(pred, kde=True, label=name, alpha=0.3)\n",
    "            \n",
    "        plt.title('预测值与真实值分布对比', fontproperties=self.font_set)\n",
    "        plt.xlabel('值', fontproperties=self.font_set)\n",
    "        plt.ylabel('频率', fontproperties=self.font_set)\n",
    "        plt.legend(prop=self.font_set)\n",
    "        plt.grid(alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_learning_curve(self):\n",
    "        \"\"\"绘制学习曲线\"\"\"\n",
    "        if 'training_metrics' not in self.data:\n",
    "            print(\"未找到训练指标数据\")\n",
    "            return\n",
    "            \n",
    "        # 查找学习曲线数据\n",
    "        learning_curve_data = None\n",
    "        for filename, data in self.data['training_metrics'].items():\n",
    "            if 'learning_curve' in filename.lower() and isinstance(data, pd.DataFrame):\n",
    "                learning_curve_data = data\n",
    "                break \n",
    "                \n",
    "        if learning_curve_data is None:\n",
    "            print(\"未找到学习曲线数据\")\n",
    "            return\n",
    "            \n",
    "        plt.figure(figsize=(12, 8))\n",
    "        \n",
    "        # 绘制训练集和验证集得分\n",
    "        if 'train_score_mean' in learning_curve_data.columns and 'test_score_mean' in learning_curve_data.columns:\n",
    "            plt.plot(learning_curve_data['train_sizes_abs'], learning_curve_data['train_score_mean'], \n",
    "                    'o-', color='blue', label='训练集')\n",
    "            plt.fill_between(learning_curve_data['train_sizes_abs'],\n",
    "                            learning_curve_data['train_score_mean'] - learning_curve_data['train_score_std'],\n",
    "                            learning_curve_data['train_score_mean'] + learning_curve_data['train_score_std'],\n",
    "                            alpha=0.1, color='blue')\n",
    "            \n",
    "            plt.plot(learning_curve_data['train_sizes_abs'], learning_curve_data['test_score_mean'], \n",
    "                    'o-', color='red', label='验证集')\n",
    "            plt.fill_between(learning_curve_data['train_sizes_abs'],\n",
    "                            learning_curve_data['test_score_mean'] - learning_curve_data['test_score_std'],\n",
    "                            learning_curve_data['test_score_mean'] + learning_curve_data['test_score_std'],\n",
    "                            alpha=0.1, color='red')\n",
    "            \n",
    "            plt.xlabel('训练样本数', fontproperties=self.font_set)\n",
    "            plt.ylabel('得分 (R²)', fontproperties=self.font_set)\n",
    "            plt.title('学习曲线', fontproperties=self.font_set)\n",
    "            plt.legend(prop=self.font_set)\n",
    "            plt.grid(alpha=0.3)\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "            \n",
    "    def plot_prediction_vs_actual_by_group(self, group_column=None):\n",
    "        \"\"\"按分组绘制预测值与真实值对比\"\"\"\n",
    "        if 'test_data' not in self.data or 'predictions' not in self.data:\n",
    "            print(\"未找到测试数据或预测数据\")\n",
    "            return\n",
    "            \n",
    "        # 如果未指定分组列，尝试从测试数据中查找合适的列\n",
    "        if group_column is None:\n",
    "            test_data = self.data['test_data']\n",
    "            if isinstance(test_data, dict) and 'X_test' in test_data and hasattr(test_data['X_test'], 'columns'):\n",
    "                # 查找可能的分类列\n",
    "                for col in test_data['X_test'].columns:\n",
    "                    if test_data['X_test'][col].nunique() < 10:\n",
    "                        group_column = col\n",
    "                        break\n",
    "                        \n",
    "        if group_column is None:\n",
    "            print(\"未找到合适的分组列\")\n",
    "            return\n",
    "            \n",
    "        # 提取分组数据\n",
    "        test_data = self.data['test_data']\n",
    "        if isinstance(test_data, dict) and 'X_test' in test_data:\n",
    "            X_test = test_data['X_test']\n",
    "            if group_column in X_test.columns:\n",
    "                groups = X_test[group_column].unique()\n",
    "                n_groups = len(groups)\n",
    "                \n",
    "                if n_groups > 5:  # 如果分组太多，只显示前5个\n",
    "                    groups = groups[:5]\n",
    "                    n_groups = 5\n",
    "                    \n",
    "                y_test = self.data['y_test']\n",
    "                \n",
    "                # 选择第一个模型进行分析\n",
    "                model_name = list(self.data['predictions'].keys())[0]\n",
    "                y_pred = self.data['predictions'][model_name]\n",
    "                \n",
    "                plt.figure(figsize=(15, 8))\n",
    "                \n",
    "                for i, group in enumerate(groups):\n",
    "                    group_indices = X_test[X_test[group_column] == group].index\n",
    "                    \n",
    "                    if len(group_indices) > 0:\n",
    "                        plt.subplot(1, n_groups, i+1)\n",
    "                        plt.scatter(y_test[group_indices], y_pred[group_indices], alpha=0.6)\n",
    "                        \n",
    "                        # 绘制理想线\n",
    "                        min_val = min(y_test[group_indices].min(), y_pred[group_indices].min())\n",
    "                        max_val = max(y_test[group_indices].max(), y_pred[group_indices].max())\n",
    "                        plt.plot([min_val, max_val], [min_val, max_val], 'r--')\n",
    "                        \n",
    "                        # 计算该组的R²\n",
    "                        group_r2 = r2_score(y_test[group_indices], y_pred[group_indices])\n",
    "                        \n",
    "                        plt.title(f'{group_column}: {group} (R²={group_r2:.3f})', fontproperties=self.font_set)\n",
    "                        plt.xlabel('真实值', fontproperties=self.font_set)\n",
    "                        plt.ylabel('预测值', fontproperties=self.font_set)\n",
    "                        plt.grid(alpha=0.3)\n",
    "                        \n",
    "                plt.tight_layout()\n",
    "                plt.show()\n",
    "                \n",
    "    def plot_permutation_importance(self):\n",
    "        \"\"\"绘制置换特征重要性\"\"\"\n",
    "        if 'data_exploration' not in self.data or 'permutation_importance.csv' not in self.data['data_exploration']:\n",
    "            print(\"未找到置换特征重要性数据\")\n",
    "            return\n",
    "            \n",
    "        perm_imp_df = self.data['data_exploration']['permutation_importance.csv']\n",
    "        \n",
    "        if 'feature' not in perm_imp_df.columns or 'importance_mean' not in perm_imp_df.columns:\n",
    "            print(\"置换特征重要性数据格式不正确\")\n",
    "            return\n",
    "            \n",
    "        # 获取前10个重要特征\n",
    "        top_features = perm_imp_df.nlargest(10, 'importance_mean')\n",
    "        \n",
    "        plt.figure(figsize=(12, 8))\n",
    "        sns.barplot(x='importance_mean', y='feature', data=top_features, palette='viridis')\n",
    "        \n",
    "        # 添加误差线\n",
    "        plt.errorbar(x=top_features['importance_mean'], y=top_features['feature'],\n",
    "                    xerr=top_features['importance_std'], fmt='none', ecolor='black',\n",
    "                    capsize=5)\n",
    "                    \n",
    "        plt.title('置换特征重要性排名 (Top 10)', fontproperties=self.font_set)\n",
    "        plt.xlabel('平均重要性', fontproperties=self.font_set)\n",
    "        plt.ylabel('特征', fontproperties=self.font_set)\n",
    "        plt.grid(axis='x', alpha=0.3)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_residual_analysis_by_feature(self, feature_name=None):\n",
    "        \"\"\"按特征绘制残差分析\"\"\"\n",
    "        if 'test_data' not in self.data or 'predictions' not in self.data:\n",
    "            print(\"未找到测试数据或预测数据\")\n",
    "            return\n",
    "            \n",
    "        # 如果未指定特征，尝试从测试数据中查找合适的特征\n",
    "        if feature_name is None:\n",
    "            test_data = self.data['test_data']\n",
    "            if isinstance(test_data, dict) and 'X_test' in test_data and hasattr(test_data['X_test'], 'columns'):\n",
    "                # 查找第一个数值型列\n",
    "                for col in test_data['X_test'].columns:\n",
    "                    if pd.api.types.is_numeric_dtype(test_data['X_test'][col]):\n",
    "                        feature_name = col\n",
    "                        break\n",
    "                        \n",
    "        if feature_name is None:\n",
    "            print(\"未找到合适的数值型特征\")\n",
    "            return\n",
    "            \n",
    "        # 提取特征数据\n",
    "        test_data = self.data['test_data']\n",
    "        if isinstance(test_data, dict) and 'X_test' in test_data:\n",
    "            X_test = test_data['X_test']\n",
    "            if feature_name in X_test.columns:\n",
    "                # 选择第一个模型进行分析\n",
    "                model_name = list(self.data['predictions'].keys())[0]\n",
    "                y_pred = self.data['predictions'][model_name]\n",
    "                y_test = self.data['y_test']\n",
    "                \n",
    "                # 计算残差\n",
    "                residuals = y_test - y_pred\n",
    "                \n",
    "                plt.figure(figsize=(15, 6))\n",
    "                \n",
    "                # 残差 vs 特征值\n",
    "                plt.subplot(1, 2, 1)\n",
    "                plt.scatter(X_test[feature_name], residuals, alpha=0.6)\n",
    "                plt.axhline(y=0, color='r', linestyle='--')\n",
    "                plt.title(f'残差 vs {feature_name}', fontproperties=self.font_set)\n",
    "                plt.xlabel(feature_name, fontproperties=self.font_set)\n",
    "                plt.ylabel('残差', fontproperties=self.font_set)\n",
    "                plt.grid(alpha=0.3)\n",
    "                \n",
    "                # 残差分布\n",
    "                plt.subplot(1, 2, 2)\n",
    "                sns.histplot(residuals, kde=True)\n",
    "                plt.axvline(x=0, color='r', linestyle='--')\n",
    "                plt.title('残差分布', fontproperties=self.font_set)\n",
    "                plt.xlabel('残差', fontproperties=self.font_set)\n",
    "                plt.ylabel('频率', fontproperties=self.font_set)\n",
    "                plt.grid(alpha=0.3)\n",
    "                \n",
    "                plt.tight_layout()\n",
    "                plt.show()\n",
    "                \n",
    "    def plot_actual_vs_predicted_quantiles(self):\n",
    "        \"\"\"按分位数绘制真实值与预测值对比\"\"\"\n",
    "        if 'y_test' not in self.data or 'predictions' not in self.data:\n",
    "            print(\"未找到预测数据或真实值\")\n",
    "            return\n",
    "            \n",
    "        y_test = self.data['y_test']\n",
    "        \n",
    "        # 计算分位数\n",
    "        quantiles = np.linspace(0, 1, 11)  # 0, 0.1, 0.2, ..., 1.0\n",
    "        test_quantiles = np.quantile(y_test, quantiles)\n",
    "        \n",
    "        plt.figure(figsize=(12, 8))\n",
    "        \n",
    "        # 绘制真实值分位数\n",
    "        plt.plot(quantiles, test_quantiles, 'o-', label='真实值', linewidth=2, color='blue')\n",
    "        \n",
    "        # 绘制各模型预测值分位数\n",
    "        for name, pred in self.data['predictions'].items():\n",
    "            pred_quantiles = np.quantile(pred, quantiles)\n",
    "            plt.plot(quantiles, pred_quantiles, 'o-', label=name, alpha=0.7)\n",
    "            \n",
    "        plt.title('真实值与预测值的分位数对比', fontproperties=self.font_set)\n",
    "        plt.xlabel('分位数', fontproperties=self.font_set)\n",
    "        plt.ylabel('值', fontproperties=self.font_set)\n",
    "        plt.grid(alpha=0.3)\n",
    "        plt.legend(prop=self.font_set)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "    def run_full_analysis(self):\n",
    "        \"\"\"运行完整分析流程\"\"\"\n",
    "        print(\"开始执行完整分析...\")\n",
    "        \n",
    "        # 加载数据\n",
    "        self.load_all_data()\n",
    "        \n",
    "        # 数据探索可视化\n",
    "        print(\"\\n生成数据探索可视化...\")\n",
    "        self.plot_data_exploration()\n",
    "        \n",
    "        # 模型评估可视化\n",
    "        print(\"\\n生成模型评估可视化...\")\n",
    "        self.plot_model_evaluation()\n",
    "        \n",
    "        # 训练指标可视化\n",
    "        print(\"\\n生成训练指标可视化...\")\n",
    "        self.plot_training_metrics()\n",
    "        \n",
    "        # 调优结果可视化\n",
    "        print(\"\\n生成调优结果可视化...\")\n",
    "        self.plot_tuning_results()\n",
    "        \n",
    "        # 综合分析\n",
    "        print(\"\\n生成综合分析...\")\n",
    "        self.generate_comprehensive_report()\n",
    "        \n",
    "        # 额外分析\n",
    "        print(\"\\n生成额外分析...\")\n",
    "        self.plot_feature_importance_comparison()\n",
    "        self.plot_correlation_heatmap()\n",
    "        self.plot_prediction_distribution()\n",
    "        self.plot_learning_curve()\n",
    "        self.plot_actual_vs_predicted_quantiles()\n",
    "        \n",
    "        print(\"\\n完整分析完成！\")\n",
    "\n",
    "def main(base_dir=None):\n",
    "    \"\"\"\n",
    "    单个目录的分析主函数\n",
    "    \"\"\"\n",
    "\n",
    "    visualizer = MLVisualizationSystem(base_dir)\n",
    "    visualizer.run_full_analysis()\n",
    "\n",
    "def process_multiple_directories(directories):\n",
    "    \"\"\"\n",
    "    批量处理多个目录\n",
    "    \"\"\"\n",
    "    for directory in directories:\n",
    "        print(f\"\\n{'='*50}\")\n",
    "        print(f\"开始处理目录: {directory}\")\n",
    "        print(f\"{'='*50}\")\n",
    "        visualizer = MLVisualizationSystem(directory)\n",
    "        visualizer.run_full_analysis()\n",
    "        print(f\"\\n完成目录 {directory} 的分析\")\n",
    "        print(f\"{'='*50}\\n\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b73ae7a6",
   "metadata": {},
   "source": [
    "### 运行"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5f7d46fd",
   "metadata": {},
   "outputs": [],
   "source": [
    "### # 运行部分（已存在于您的代码中）\n",
    "if __name__ == \"__main__\":\n",
    "    # 选择运行单个目录还是多个目录\n",
    "    run_mode = \"multiple\"  # 可以改为 \"single\" 或 \"multiple\"\n",
    "    \n",
    "    if run_mode == \"single\":\n",
    "        main()  # 运行单个目录\n",
    "    elif run_mode == \"multiple\":\n",
    "        # 定义要处理的多个目录\n",
    "        directories_to_process = [\n",
    "#             r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\DFT完成\",\n",
    "#             r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\DFS完成\",\n",
    "#             r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\DFB完成\",\n",
    "#             r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data0_auto_P完成\",           \n",
    "#             r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data1_auto_P完成\",\n",
    "            r\"R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data2_auto_P完成\"\n",
    "        ]\n",
    "        \n",
    "        # 执行批量处理\n",
    "        process_multiple_directories(directories_to_process)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bae69935",
   "metadata": {},
   "source": [
    "## 预测模型的应用"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3e233775",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import joblib\n",
    "import os\n",
    "import pyDOE2\n",
    "import gc\n",
    "import json\n",
    "import time\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "from joblib import Parallel, delayed\n",
    "\n",
    "# 使用拉丁超立方采样生成实验设计（优化内存）\n",
    "def generate_lhs(features, samples=1000):\n",
    "    n_features = len(features)\n",
    "    start_time = time.time()  # 记录总开始时间\n",
    "    \n",
    "    # 分块生成LHS设计\n",
    "    chunk_size = min(50000, samples)\n",
    "    chunks = []\n",
    "    remaining = samples\n",
    "    total_chunks = (samples + chunk_size - 1) // chunk_size  # 总块数（向上取整）\n",
    "    chunk_idx = 0  # 当前块索引\n",
    "    \n",
    "    print(f\"📊 开始生成LHS样本：总样本={samples}，分块大小={chunk_size}，总块数={total_chunks}\")\n",
    "    \n",
    "    while remaining > 0:\n",
    "        chunk_start = time.time()  # 记录当前块开始时间\n",
    "        current_chunk = min(chunk_size, remaining)\n",
    "        \n",
    "        # 生成当前块的LHS设计\n",
    "        lhs_design = pyDOE2.lhs(n_features, samples=current_chunk, criterion='maximin')\n",
    "        chunks.append(lhs_design)\n",
    "        \n",
    "        # 计算进度\n",
    "        chunk_idx += 1\n",
    "        generated = samples - remaining + current_chunk  # 已生成样本数\n",
    "        progress = (generated / samples) * 100  # 进度百分比\n",
    "        chunk_time = time.time() - chunk_start  # 当前块耗时\n",
    "        avg_time_per_chunk = (time.time() - start_time) / chunk_idx  # 平均每块耗时\n",
    "        remaining_chunks = total_chunks - chunk_idx  # 剩余块数\n",
    "        estimated_remaining = remaining_chunks * avg_time_per_chunk  # 估计剩余时间（秒）\n",
    "        \n",
    "        # 打印进度（格式化输出，更易读）\n",
    "        print(f\"  ✅ 块 {chunk_idx}/{total_chunks} 完成 | \"\n",
    "              f\"已生成 {generated}/{samples} ({progress:.1f}%) | \"\n",
    "              f\"本块耗时 {chunk_time:.2f}秒 | \"\n",
    "              f\"估计剩余 {estimated_remaining:.2f}秒\")\n",
    "        \n",
    "        remaining -= current_chunk\n",
    "    \n",
    "    # 合并块（添加合并进度提示）\n",
    "    print(f\"\\n🔗 开始合并{total_chunks}个块（总样本{samples}）...\")\n",
    "    merge_start = time.time()\n",
    "    lhs_design = np.vstack(chunks)\n",
    "    merge_time = time.time() - merge_start\n",
    "    print(f\"  ✅ 块合并完成 | 耗时 {merge_time:.2f}秒 | 合并后形状 {lhs_design.shape}\")\n",
    "    \n",
    "    # 映射到实际范围（添加映射进度提示）\n",
    "    print(\"\\n📏 开始将LHS值映射到实际特征范围...\")\n",
    "    map_start = time.time()\n",
    "    df = pd.DataFrame(lhs_design, columns=features.keys())\n",
    "    \n",
    "    for idx, (param, (min_val, max_val)) in enumerate(features.items()):\n",
    "        # 打印当前处理的特征及进度\n",
    "        feature_progress = (idx + 1) / len(features) * 100\n",
    "        print(f\"  处理特征 {idx + 1}/{len(features)} ({feature_progress:.1f}%)：{param}\")\n",
    "        \n",
    "        if isinstance(min_val, int) and isinstance(max_val, int):\n",
    "            levels = np.linspace(min_val, max_val, num=9, dtype=np.int32)\n",
    "            df[param] = (df[param] * 9).astype(np.int32).clip(0, 8)\n",
    "            df[param] = levels[df[param]]\n",
    "        else:\n",
    "            df[param] = df[param].astype(np.float32)\n",
    "            df[param] = df[param] * (max_val - min_val) + min_val\n",
    "    \n",
    "    map_time = time.time() - map_start\n",
    "    print(f\"  ✅ 特征映射完成 | 耗时 {map_time:.2f}秒\")\n",
    "    \n",
    "    # 总耗时统计\n",
    "    total_time = time.time() - start_time\n",
    "    print(f\"\\n✅ 所有样本生成完成 | 总耗时 {total_time:.2f}秒 | 最终数据形状 {df.shape}\")\n",
    "    \n",
    "    return df\n",
    "\n",
    "# 修改特征工程函数，增加是否生成EigenValue特征的控制参数\n",
    "def optimized_feature_engineering(df, uses_eigenvalue_as_feature=False):\n",
    "    print(f\"🔍 特征工程输入形状: {df.shape}\")\n",
    "    input_rows = df.shape[0]  # 记录输入行数\n",
    "    \n",
    "    # 重置索引，确保索引是连续的整数（0,1,2...）\n",
    "    df = df.reset_index(drop=True)\n",
    "    \n",
    "    # 只复制必要的列，减少内存占用\n",
    "    df_fe = df[list(df.columns)].copy()\n",
    "    \n",
    "    # 确定需要处理的特征列（排除EigenValue如果它是目标变量）\n",
    "    process_columns = df.columns.tolist()\n",
    "    if not uses_eigenvalue_as_feature and 'EigenValue' in process_columns:\n",
    "        process_columns.remove('EigenValue')  # 目标变量不生成衍生特征\n",
    "    \n",
    "    # 1. 平方项\n",
    "    for col in process_columns:\n",
    "        df_fe[f\"{col}_sq\"] = np.square(df[col].values)\n",
    "    \n",
    "    # 2. 平方根项 - 改进处理：对负值取绝对值后开平方\n",
    "    for col in process_columns:\n",
    "        df_fe[f\"{col}_sqrt\"] = np.sqrt(np.abs(df[col].values))\n",
    "    \n",
    "    # 3. 对数项 - 改进处理：使用 log(1 + |x|) 处理所有数值\n",
    "    for col in process_columns:\n",
    "        df_fe[f\"{col}_log\"] = np.log1p(np.abs(df[col].values))\n",
    "    \n",
    "    # 4. 交互项（只处理需要的特征）\n",
    "    interaction_pairs = [\n",
    "        ('B', 'cf1f'), ('B', 'cf2f'), ('B', 'axialratio'), ('B', 'H'),\n",
    "        ('cf1f', 'cf2f'), ('cf1f', 'axialratio'), ('cf1f', 'H'),\n",
    "        ('cf2f', 'axialratio'), ('cf2f', 'H'),\n",
    "        ('axialratio', 'H')\n",
    "    ]\n",
    "    \n",
    "    # 过滤交互项中包含EigenValue且不需要它作为特征的情况\n",
    "    if not uses_eigenvalue_as_feature:\n",
    "        interaction_pairs = [\n",
    "            (f1, f2) for f1, f2 in interaction_pairs \n",
    "            if f1 != 'EigenValue' and f2 != 'EigenValue'\n",
    "        ]\n",
    "    \n",
    "    # 预分配内存\n",
    "    num_rows = df.shape[0]\n",
    "    interaction_data = np.empty((num_rows, len(interaction_pairs) * 2), dtype=np.float32)\n",
    "    interaction_names = []\n",
    "    \n",
    "    # 填充交互数据\n",
    "    for idx, (feat1, feat2) in enumerate(interaction_pairs):\n",
    "        if feat1 in df.columns and feat2 in df.columns:\n",
    "            # 乘法项\n",
    "            col_idx = idx * 2\n",
    "            interaction_data[:, col_idx] = df[feat1].values * df[feat2].values\n",
    "            interaction_names.append(f'{feat1}_x_{feat2}')\n",
    "            \n",
    "            # 除法项\n",
    "            col_idx += 1\n",
    "            denominator = df[feat2].values + 1e-10\n",
    "            interaction_data[:, col_idx] = df[feat1].values / denominator\n",
    "            interaction_names.append(f'{feat1}_div_{feat2}')\n",
    "    \n",
    "    # 创建交互项DataFrame，并合并\n",
    "    interaction_df = pd.DataFrame(interaction_data, columns=interaction_names)\n",
    "    interaction_df = interaction_df.reset_index(drop=True)\n",
    "    df_fe = pd.concat([df_fe.reset_index(drop=True), interaction_df], axis=1)\n",
    "    \n",
    "    # 校验行数\n",
    "    assert df_fe.shape[0] == input_rows, f\"行数异常：输入{input_rows}行，合并后{df_fe.shape[0]}行\"\n",
    "    \n",
    "    # 清理临时变量\n",
    "    del interaction_data, interaction_df\n",
    "    gc.collect()\n",
    "    \n",
    "    # 处理异常值\n",
    "    df_fe.replace([np.inf, -np.inf], np.nan, inplace=True)\n",
    "    df_fe.fillna(0.0, inplace=True)\n",
    "    \n",
    "    # 优化数据类型\n",
    "    for col in df_fe.select_dtypes(include=['float64']):\n",
    "        df_fe[col] = df_fe[col].astype(np.float32)\n",
    "    \n",
    "    print(f\"✅ 特征工程输出形状: {df_fe.shape}\")\n",
    "    return df_fe\n",
    "\n",
    "# 特征对齐函数（内存优化），增加了打印对齐前后差异的功能\n",
    "def align_features(processed_features, model_features):\n",
    "    print(f\"🔧 开始特征对齐...\")\n",
    "    print(f\"对齐前特征数量: {processed_features.shape[1]}\")\n",
    "    \n",
    "    # 创建特征矩阵的副本\n",
    "    aligned_features = processed_features.copy()\n",
    "\n",
    "    # 补充缺失特征\n",
    "    missing_features = []\n",
    "    for feat in model_features:\n",
    "        if feat not in aligned_features.columns:\n",
    "            aligned_features[feat] = 0.0\n",
    "            missing_features.append(feat)\n",
    "            \n",
    "    # 只保留需要的特征\n",
    "    aligned_features = aligned_features[model_features]\n",
    "\n",
    "    # 处理异常值\n",
    "    aligned_features.replace([np.inf, -np.inf], np.nan, inplace=True)\n",
    "    aligned_features.fillna(0.0, inplace=True)\n",
    "    \n",
    "    print(f\"✅ 特征对齐完成!\")\n",
    "    print(f\"对齐后特征数量: {aligned_features.shape[1]}\")\n",
    "    \n",
    "    # 打印特征差异\n",
    "    print(\"\\n📊 特征对齐前后差异分析:\")\n",
    "    print(f\"  - 补充的缺失特征: {missing_features}\")\n",
    "    print(f\"  - 移除的多余特征: {list(set(processed_features.columns) - set(model_features))}\")\n",
    "    \n",
    "    return aligned_features\n",
    "\n",
    "# 新增：处理单个数据块的函数（用于并行计算）\n",
    "def process_chunk(chunk, model_path, model_features, uses_eigenvalue_as_feature):\n",
    "    \"\"\"\n",
    "    处理单个数据块：特征工程、特征对齐、预测\n",
    "    \"\"\"\n",
    "    # 加载模型（每个进程独立加载）\n",
    "    model = joblib.load(model_path)\n",
    "    \n",
    "    # 特征工程\n",
    "    df_fe_chunk = optimized_feature_engineering(\n",
    "        chunk, \n",
    "        uses_eigenvalue_as_feature=uses_eigenvalue_as_feature\n",
    "    )\n",
    "    \n",
    "    # 特征对齐\n",
    "    df_aligned_chunk = align_features(df_fe_chunk, model_features)\n",
    "    \n",
    "    # 预测\n",
    "    predictions = model.predict(df_aligned_chunk)\n",
    "    \n",
    "    # 处理多维输出\n",
    "    if predictions.ndim > 1:\n",
    "        predictions = predictions[:, 0]\n",
    "    \n",
    "    # 创建结果DataFrame\n",
    "    result_chunk = chunk.copy()\n",
    "    result_chunk[\"predicted_value\"] = predictions\n",
    "    \n",
    "    # 清理内存\n",
    "    del model, df_fe_chunk, df_aligned_chunk\n",
    "    gc.collect()\n",
    "    \n",
    "    return result_chunk\n",
    "\n",
    "# 修改process_folder函数，增加并行处理\n",
    "def process_folder(\n",
    "    folder_path: str,\n",
    "    model_name: str,\n",
    "    data_path: str,\n",
    "    target_feature: str = \"EigenValue\",\n",
    "    output_file: str = \"prediction_results.csv\",\n",
    "    samples: int = 200000,\n",
    "    chunk_size: int = 50000,\n",
    "    feature_ranges: dict = None,\n",
    "    uses_eigenvalue_as_feature: bool = False,\n",
    "    n_jobs: int = -1  # 新增：并行工作数，-1表示使用所有CPU核心\n",
    ") -> None:\n",
    "    print(f\"\\n==== 处理文件夹: {folder_path} ====\")\n",
    "    start_time = time.time()\n",
    "    \n",
    "    # 创建过程参数存储目录\n",
    "    process_dir = Path(folder_path) / \"process_parameters\"\n",
    "    process_dir.mkdir(exist_ok=True)\n",
    "    \n",
    "    # 使用传入的特征范围（替代原固定features）\n",
    "    features = feature_ranges\n",
    "    if not features:\n",
    "        print(\"❌ 未指定特征范围，终止处理\")\n",
    "        return\n",
    "    \n",
    "    # 保存当前配置的特征范围（方便后续核对）\n",
    "    with open(process_dir / \"feature_ranges.json\", \"w\") as f:\n",
    "        json.dump(features, f, indent=4)\n",
    "    \n",
    "    # 路径构建\n",
    "    model_path = os.path.join(folder_path, model_name)\n",
    "    output_path = os.path.join(folder_path, output_file)\n",
    "    \n",
    "    # 1. 生成实验数据（分块保存）\n",
    "    print(f\"⏳ 生成 {samples} 个实验组合...\")\n",
    "    df = generate_lhs(features, samples=samples)\n",
    "    \n",
    "    # 保存原始设计点\n",
    "    df.to_parquet(process_dir / \"raw_design_points.parquet\", index=False)\n",
    "    print(f\"💾 原始设计点已保存至: {process_dir/'raw_design_points.parquet'}\")\n",
    "    \n",
    "    # 2. 获取模型特征列表（不需要加载完整模型）\n",
    "    model_features = None\n",
    "    try:\n",
    "        # 只加载模型的特征名，避免加载整个模型\n",
    "        model = joblib.load(model_path)\n",
    "        model_features = model.feature_names_\n",
    "        del model\n",
    "        gc.collect()\n",
    "        print(\"✅ 从模型中获取特征列表\")\n",
    "    except:\n",
    "        print(f\"⚠️ 模型未保存特征名，尝试从数据文件获取: {data_path}\")\n",
    "        if not os.path.exists(data_path):\n",
    "            print(f\"❌ data_after_fe.csv不存在: {data_path}\")\n",
    "            return\n",
    "        \n",
    "        train_df = pd.read_csv(data_path, nrows=0)\n",
    "        model_features = [col for col in train_df.columns if col != target_feature]\n",
    "        print(f\"✅ 从数据文件获取特征列表（{len(model_features)} 个特征）\")\n",
    "    \n",
    "    # 保存特征列表\n",
    "    with open(process_dir / \"model_features.txt\", \"w\") as f:\n",
    "        f.write(\"\\n\".join(model_features))\n",
    "    \n",
    "    # 3. 准备数据块\n",
    "    chunks = []\n",
    "    for i in range(0, samples, chunk_size):\n",
    "        chunk_end = min(i + chunk_size, samples)\n",
    "        chunks.append(df.iloc[i:chunk_end].copy())\n",
    "    \n",
    "    print(f\"📦 数据分割为 {len(chunks)} 个块进行并行处理\")\n",
    "    \n",
    "    # 4. 并行处理\n",
    "    print(f\"🚀 启动并行处理 (n_jobs={n_jobs})...\")\n",
    "    parallel_start = time.time()\n",
    "    \n",
    "    # 使用joblib并行处理\n",
    "    results = Parallel(n_jobs=n_jobs, verbose=10)(\n",
    "        delayed(process_chunk)(\n",
    "            chunk, \n",
    "            model_path, \n",
    "            model_features, \n",
    "            uses_eigenvalue_as_feature\n",
    "        ) for chunk in chunks\n",
    "    )\n",
    "    \n",
    "    parallel_time = time.time() - parallel_start\n",
    "    print(f\"✅ 并行处理完成! 耗时: {parallel_time:.2f}秒\")\n",
    "    \n",
    "    # 5. 合并结果\n",
    "    print(\"⏳ 合并结果...\")\n",
    "    result_df = pd.concat(results, axis=0, ignore_index=True)\n",
    "    \n",
    "    # 保存结果\n",
    "    result_df.to_csv(output_path, index=False)\n",
    "    print(f\"📊 结果已保存至: {output_path}\")\n",
    "    \n",
    "    # 保存处理时间\n",
    "    process_time = time.time() - start_time\n",
    "    with open(process_dir / \"processing_time.txt\", \"w\") as f:\n",
    "        f.write(f\"总处理时间: {process_time:.2f}秒\\n\")\n",
    "        f.write(f\"并行处理时间: {parallel_time:.2f}秒\\n\")\n",
    "        f.write(f\"样本数量: {samples}\\n\")\n",
    "        f.write(f\"块大小: {chunk_size}\\n\")\n",
    "        f.write(f\"并行工作数: {n_jobs}\\n\")\n",
    "    \n",
    "    print(f\"✅ 处理完成! 总耗时: {process_time:.2f}秒\")\n",
    "\n",
    "# 修改main函数，添加n_jobs参数\n",
    "def main():\n",
    "    base_dir = r\"R:\\Jupyterdemo\\phdcode\\MODELtype\"\n",
    "    samples_num = 10000000\n",
    "    # 定义通用特征范围\n",
    "    base_features = {\n",
    "        'B': (1, 400),\n",
    "        'cf1f': (0, 2),\n",
    "        'cf2f': (0, 2),\n",
    "        'axialratio': (0, 1),\n",
    "        'H': (1, 3000),\n",
    "        'L': (1000, 15000),\n",
    "        'n': (1, 9),\n",
    "        'T1': (1, 200),\n",
    "        'T2': (1, 200),\n",
    "        'Imperfectfactor': (0.002, 0.2),\n",
    "        'yfss': (355, 690),\n",
    "        'sfricn': (0.1, 0.8),  \n",
    "        'F': (1, 9),\n",
    "        'pbol': (8000, 280000),\n",
    "        'EigenValue': (1, 100000000000)\n",
    "    }\n",
    "    \n",
    "    configs = [\n",
    "        # 前三个任务：预测EigenValue，不将其作为特征\n",
    "#         {\n",
    "#             \"folder\": os.path.join(base_dir, \"DFT完成\", \"retrained_models\"),\n",
    "#             \"model\": \"GradientBoosting_model.pkl\",\n",
    "#             \"data\": os.path.join(base_dir, \"DFT完成\", \"data_versions\", \"data_after_fe.csv\"),\n",
    "#             \"target\": \"EigenValue\",\n",
    "#             \"output\": os.path.join(base_dir, \"DFT完成\", \"预测\", \"prediction_results_DFT.csv\"),\n",
    "#             \"samples\": samples_num,\n",
    "#             \"feature_ranges\": {k: v for k, v in base_features.items() if k not in ['sfricn', 'F', 'pbol', 'EigenValue']},\n",
    "#             \"uses_eigenvalue_as_feature\": False,\n",
    "#             \"n_jobs\": 4  # 指定并行度\n",
    "#         },\n",
    "#         {\n",
    "#             \"folder\": os.path.join(base_dir, \"DFS完成\", \"retrained_models\"),\n",
    "#             \"model\": \"LightGBM_model.pkl\",\n",
    "#             \"data\": os.path.join(base_dir, \"DFS完成\", \"data_versions\", \"data_after_fe.csv\"),\n",
    "#             \"target\": \"EigenValue\",\n",
    "#             \"output\": os.path.join(base_dir, \"DFS完成\", \"预测\", \"prediction_results_DFS.csv\"),\n",
    "#             \"samples\": samples_num,\n",
    "#             \"feature_ranges\": {k: v for k, v in base_features.items() if k not in ['F', 'pbol', 'EigenValue']},\n",
    "#             \"uses_eigenvalue_as_feature\": False,\n",
    "#             \"n_jobs\": 4\n",
    "#         },\n",
    "#         {\n",
    "#             \"folder\": os.path.join(base_dir, \"DFB完成\", \"retrained_models\"),\n",
    "#             \"model\": \"GradientBoosting_model.pkl\",\n",
    "#             \"data\": os.path.join(base_dir, \"DFB完成\", \"data_versions\", \"data_after_fe.csv\"),\n",
    "#             \"target\": \"EigenValue\",\n",
    "#             \"output\": os.path.join(base_dir, \"DFB完成\", \"预测\", \"prediction_results_DFB.csv\"),\n",
    "#             \"samples\": samples_num,\n",
    "#             \"feature_ranges\": {k: v for k, v in base_features.items() if k not in ['EigenValue']},\n",
    "#             \"uses_eigenvalue_as_feature\": False,\n",
    "#             \"n_jobs\": 4\n",
    "#         },\n",
    "        # 后三个任务：预测Pucf12f，将EigenValue作为特征        \n",
    "        {\n",
    "            \"folder\": os.path.join(base_dir, \"data0_auto_P完成\", \"retrained_models\"),\n",
    "            \"model\": \"XGBoost_model.pkl\",\n",
    "            \"data\": os.path.join(base_dir, \"data0_auto_P完成\", \"data_versions\", \"data_after_fe.csv\"),\n",
    "            \"target\": \"Pucf12f\",\n",
    "            \"output\": os.path.join(base_dir, \"data0_auto_P完成\", \"预测\", \"prediction_results_data0_auto_P.csv\"),\n",
    "            \"samples\": samples_num,\n",
    "            \"feature_ranges\": {k: v for k, v in base_features.items() if k not in ['sfricn', 'F', 'pbol']},\n",
    "            \"uses_eigenvalue_as_feature\": False,\n",
    "            \"n_jobs\": 4\n",
    "        }\n",
    "\n",
    "#         ,\n",
    "#         {\n",
    "#             \"folder\": os.path.join(base_dir, \"data1_auto_P完成\", \"retrained_models\"),\n",
    "#             \"model\": \"GradientBoosting_model.pkl\",\n",
    "#             \"data\": os.path.join(base_dir, \"data1_auto_P完成\", \"data_versions\", \"data_after_fe.csv\"),\n",
    "#             \"target\": \"Pucf12f\",\n",
    "#             \"output\": os.path.join(base_dir, \"data1_auto_P完成\", \"预测\", \"prediction_results_data1_auto_P.csv\"),\n",
    "#             \"samples\": samples_num,\n",
    "#             \"feature_ranges\": {k: v for k, v in base_features.items() if k not in [ 'F', 'pbol']},\n",
    "#             \"uses_eigenvalue_as_feature\": True,\n",
    "#             \"n_jobs\": 4\n",
    "#         },\n",
    "#         {\n",
    "#             \"folder\": os.path.join(base_dir, \"data2_auto_P完成\", \"retrained_models\"),\n",
    "#             \"model\": \"GradientBoosting_model.pkl\",\n",
    "#             \"data\": os.path.join(base_dir, \"data2_auto_P完成\", \"data_versions\", \"data_after_fe.csv\"),\n",
    "#             \"target\": \"Pucf12f\",\n",
    "#             \"output\": os.path.join(base_dir, \"data2_auto_P完成\", \"预测\", \"prediction_results_data2_auto_P.csv\"),\n",
    "#             \"samples\": samples_num,\n",
    "#             \"feature_ranges\": base_features.copy(),\n",
    "#             \"uses_eigenvalue_as_feature\": True,\n",
    "#             \"n_jobs\": 4\n",
    "#         }\n",
    "    ]\n",
    "    \n",
    "    # 遍历处理时传入特征范围和EigenValue使用标识\n",
    "    for config in configs:\n",
    "        output_dir = os.path.dirname(config[\"output\"])\n",
    "        os.makedirs(output_dir, exist_ok=True)\n",
    "\n",
    "        process_folder(\n",
    "            folder_path=config[\"folder\"],\n",
    "            model_name=config[\"model\"],\n",
    "            data_path=config[\"data\"],\n",
    "            target_feature=config[\"target\"],\n",
    "            output_file=os.path.basename(config[\"output\"]),\n",
    "            samples=config[\"samples\"],\n",
    "            chunk_size=50000,\n",
    "            feature_ranges=config[\"feature_ranges\"],\n",
    "            uses_eigenvalue_as_feature=config[\"uses_eigenvalue_as_feature\"],\n",
    "            n_jobs=config.get(\"n_jobs\", -1)  # 传递并行度参数\n",
    "        )\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Windows系统多进程需要加上这句（避免递归创建进程）\n",
    "    import multiprocessing\n",
    "    multiprocessing.set_start_method('spawn')\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4dbf71bf",
   "metadata": {},
   "source": [
    "# 采用Autogluon（可用）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12274e30",
   "metadata": {},
   "source": [
    "### 单参数预测"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0c1b1001",
   "metadata": {},
   "source": [
    "#### 训练集与模型训练"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "91686cce",
   "metadata": {},
   "source": [
    "##### 有可能出现的One-hot编码的行数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3cb503d8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# # data=df_all_dic[df_all_dic['type']==1]\n",
    "# data=df_alltype\n",
    "# import pandas as pd\n",
    "# from sklearn.preprocessing import OneHotEncoder\n",
    "\n",
    "# # cols = ['cf1f', 'cf2f', 'axialratio', 'type', 'Imperfectfactor', 'yfss', 'pbol', 'sfricn', 'meshsz']\n",
    "# cols = ['H', 'B', 'T1', 'T2', 'L', 'n', 'type']\n",
    "# def get_actual_combinations_and_onehot(df):\n",
    "#     # 检查缺失值\n",
    "#     print(\"各列缺失值情况：\")\n",
    "#     print(df[cols].isnull().sum())\n",
    "#     # 检查数据类型\n",
    "#     print(\"\\n各列数据类型：\")\n",
    "#     print(df[cols].dtypes)\n",
    "#     # 处理缺失值，这里简单地删除包含缺失值的行\n",
    "#     df = df.dropna(subset=cols)\n",
    "#     # 提取实际存在的组合（去重）\n",
    "#     combinations_df = df[cols].drop_duplicates()\n",
    "#     print(\"\\n实际存在的特征组合：\")\n",
    "#     print(combinations_df)\n",
    "#     print(\"\\n共有 {} 种实际组合\".format(len(combinations_df)))\n",
    "\n",
    "#     # 统计每种组合下的数据量\n",
    "#     combination_counts = df.groupby(cols).size().reset_index(name='数据量')\n",
    "#     print(\"\\n每种组合情况下对应的数据量：\")\n",
    "#     print(combination_counts)\n",
    "\n",
    "#     # 初始化 OneHotEncoder\n",
    "#     encoder = OneHotEncoder(sparse_output=False)\n",
    "#     encoded_data = encoder.fit_transform(combinations_df)\n",
    "\n",
    "#     # 获取编码后的列名\n",
    "#     encoded_columns = encoder.get_feature_names_out(cols)\n",
    "#     encoded_df = pd.DataFrame(encoded_data, columns=encoded_columns)\n",
    "\n",
    "#     print(\"\\n独热编码后实际存在的特征组合：\")\n",
    "#     display(encoded_df)\n",
    "\n",
    "\n",
    "# # 使用示例\n",
    "# get_actual_combinations_and_onehot(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7fcad65e",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# import pandas as pd\n",
    "# import numpy as np\n",
    "# import random\n",
    "# import torch\n",
    "# from autogluon.tabular import TabularPredictor\n",
    "# import os\n",
    "# from sklearn.preprocessing import RobustScaler, QuantileTransformer, OneHotEncoder\n",
    "# from sklearn.compose import ColumnTransformer\n",
    "# from sklearn.pipeline import Pipeline\n",
    "# import xgboost as xgb\n",
    "# import lightgbm as lgb\n",
    "\n",
    "\n",
    "# # ============================== 全局配置与工具函数 ==============================\n",
    "# # 随机种子设置（确保实验可复现）\n",
    "# def set_seed(seed: int = 42):\n",
    "#     \"\"\"\n",
    "#     统一设置随机种子，保证结果可复现\n",
    "#     参数:\n",
    "#         seed: 随机种子值（默认42）\n",
    "#     \"\"\"\n",
    "#     random.seed(seed)\n",
    "#     np.random.seed(seed)\n",
    "#     torch.manual_seed(seed)\n",
    "#     if torch.cuda.is_available():\n",
    "#         torch.cuda.manual_seed_all(seed)  # 确保CUDA操作的随机性一致\n",
    "#     xgb.set_config(verbosity=0)  # 关闭XGBoost不必要的日志输出\n",
    "#     os.environ['PYTHONHASHSEED'] = str(seed)  # 固定Python哈希种子\n",
    "#     print(f\"[INFO] 全局随机种子已设置为 {seed}\")\n",
    "\n",
    "\n",
    "# # ============================== 数据预处理模块 ==============================\n",
    "# def preprocess_data(\n",
    "#     data: pd.DataFrame, \n",
    "#     target_feature: str, \n",
    "#     transform_target: bool = True\n",
    "# ) -> tuple[pd.DataFrame, callable]:\n",
    "#     \"\"\"\n",
    "#     数据预处理核心函数（新增异常值比例统计）\n",
    "#     \"\"\"\n",
    "#     print(f\"\\n{'='*80}\")\n",
    "#     print(f\"[PREPROCESS] 开始处理数据，目标特征：{target_feature}\")\n",
    "#     print(f\"    原始数据维度：{data.shape}（样本数={data.shape[0]}, 特征数={data.shape[1]-1}）\")\n",
    "    \n",
    "#     # 分离特征与目标变量\n",
    "#     X = data.drop(columns=[target_feature]).copy()\n",
    "#     y = data[target_feature].copy()\n",
    "    \n",
    "#     # ====================== 严格清洗目标变量 ======================\n",
    "#     # 检测非有限值（NaN/Inf/-Inf）和负数（假设目标变量应为正数）\n",
    "#     valid_y_mask = np.isfinite(y) & (y >= 0)  # 可根据业务调整阈值（如y > 0）\n",
    "#     invalid_y_count = (~valid_y_mask).sum()\n",
    "    \n",
    "#     if invalid_y_count > 0:\n",
    "#         print(f\"[CRITICAL] 目标变量存在 {invalid_y_count} 个无效值（非有限值或负数），占比 {invalid_y_count / len(y):.2%}\")\n",
    "#         X = X[valid_y_mask].reset_index(drop=True)\n",
    "#         y = y[valid_y_mask].reset_index(drop=True)\n",
    "#         print(f\"    [CLEAN] 已删除无效样本，剩余样本数：{len(y)}（原样本数：{len(data)}）\")\n",
    "#     else:\n",
    "#         print(\"[INFO] 目标变量全部有效，无需清洗\")\n",
    "    \n",
    "#     total_samples = X.shape[0]\n",
    "\n",
    "#     # ====================== 新增：目标变量非有限值清洗 ======================\n",
    "#     # 检测目标变量中的非有限值（NaN、Inf、-Inf）\n",
    "#     invalid_y_mask = ~np.isfinite(y)\n",
    "#     invalid_count = invalid_y_mask.sum()\n",
    "    \n",
    "#     if invalid_count > 0:\n",
    "#         print(f\"[WARNING] 目标变量存在 {invalid_count} 个非有限值（NaN/Inf/-Inf），占比 {invalid_count / total_samples * 100:.2f}%\")\n",
    "#         # 方案1：删除含非有限值的样本（推荐，适用于小批量异常）\n",
    "#         X_clean = X[~invalid_y_mask].reset_index(drop=True)\n",
    "#         y_clean = y[~invalid_y_mask].reset_index(drop=True)\n",
    "#         print(f\"    [CLEAN] 已删除 {invalid_count} 条异常样本，剩余样本数：{len(y_clean)}\")\n",
    "#     else:\n",
    "#         X_clean = X.copy()\n",
    "#         y_clean = y.copy()\n",
    "#         print(\"[INFO] 目标变量无异常值，无需清洗\")\n",
    "#     # ======================================================================\n",
    "# # ====================== 异常值检测与处理 ======================\n",
    "#     numeric_features = X_clean.select_dtypes(include=np.number).columns.tolist()\n",
    "#     if not numeric_features:\n",
    "#         print(\"[提示] 无数值特征，跳过异常值处理\")\n",
    "#         processed_data = pd.concat([X_clean, y_clean.rename(target_feature)], axis=1)\n",
    "#         return processed_data, lambda y: y\n",
    "    \n",
    "#     # （原异常值检测与处理代码保持不变，仅需将原X替换为X_clean）\n",
    "#     X_original_num = X_clean[numeric_features].copy()  # 注意：改为清洗后的X_clean\n",
    "#     y_original = y_clean.copy()  # 注意：改为清洗后的y_clean\n",
    "#     # 检测inf/-inf和极大值，并统计数量\n",
    "#     X_clean = X[numeric_features].copy()\n",
    "#     max_float64 = np.finfo(np.float64).max\n",
    "#     total_outliers = 0  # 全局总异常值数\n",
    "#     total_data_points = total_samples * len(numeric_features)  # 总数据点数（样本×特征）\n",
    "#     # 初始化异常值统计字典（新增异常值样本存储）\n",
    "#     outlier_stats = {\n",
    "#         \"特征名\": [],\n",
    "#         \"inf/-inf数量\": [],\n",
    "#         \"极大值数量\": [],\n",
    "#         \"总异常值数量\": [],\n",
    "#         \"异常值比例(%)\": [],\n",
    "#         \"异常值样本\": []  # 新增：存储每个特征的异常值样本（前5条）\n",
    "#     }\n",
    "#     feature_outliers = {}  # 存储每个特征的完整异常值（带目标变量）\n",
    "    \n",
    "#     max_float64 = np.finfo(np.float64).max\n",
    "#     total_outliers = 0\n",
    "    \n",
    "#     for col in numeric_features:\n",
    "#         # 检测异常值掩码（inf/-inf 或 极大值）\n",
    "#         is_inf = X_original_num[col].isin([np.inf, -np.inf])\n",
    "#         is_extreme = X_original_num[col].abs() > max_float64 * 0.9\n",
    "#         is_outlier = is_inf | is_extreme\n",
    "        \n",
    "#         # 提取异常值样本（带目标变量）\n",
    "#         outliers = X_original_num[is_outlier].copy()\n",
    "#         outliers[target_feature] = y_original[is_outlier].values  # 添加目标值\n",
    "#         feature_outliers[col] = outliers.reset_index(drop=True)\n",
    "        \n",
    "#         # 统计数量\n",
    "#         inf_count = is_inf.sum()\n",
    "#         extreme_count = is_extreme.sum()\n",
    "#         col_outliers = is_outlier.sum()\n",
    "        \n",
    "#         # 记录统计（新增：保存前5条异常值样本预览）\n",
    "#         outlier_stats[\"特征名\"].append(col)\n",
    "#         outlier_stats[\"inf/-inf数量\"].append(inf_count)\n",
    "#         outlier_stats[\"极大值数量\"].append(extreme_count)\n",
    "#         outlier_stats[\"总异常值数量\"].append(col_outliers)\n",
    "#         outlier_stats[\"异常值比例(%)\"].append(round(col_outliers / total_samples * 100, 2))\n",
    "#         outlier_stats[\"异常值样本\"].append(\n",
    "#             feature_outliers[col].head().to_string(index=False) if not outliers.empty else \"无\"\n",
    "#         )  # 仅保存前5条预览\n",
    "        \n",
    "#         total_outliers += col_outliers\n",
    "\n",
    "#     # 计算整体异常值比例\n",
    "#     overall_ratio = round(total_outliers / total_data_points * 100, 2)\n",
    "    \n",
    "#     # 输出异常值统计报告\n",
    "#     print(\"\\n\" + \"=\"*60)\n",
    "#     print(\"[异常值统计报告]\")\n",
    "#     print(f\"  总样本数: {total_samples} | 数值特征数: {len(numeric_features)} | 总数据点数: {total_data_points}\")\n",
    "#     print(f\"  全局总异常值数: {total_outliers} | 全局异常值比例: {overall_ratio}%\")\n",
    "#     display(pd.DataFrame(outlier_stats).to_string(index=False))  # 打印特征级统计表格\n",
    "#     display(\"=\"*60 + \"\\n\")\n",
    "    \n",
    "#     # 新增：打印每个特征的异常值详情（前5条）\n",
    "#     print(\"\\n[异常值详情（每个特征前5条样本）]\")\n",
    "#     for col in numeric_features:\n",
    "#         outliers = feature_outliers[col]\n",
    "#         if not outliers.empty:\n",
    "#             print(f\"\\n特征 {col}（异常值数量：{len(outliers)}）:\")\n",
    "#             print(\"    特征值 | 目标变量值\")\n",
    "#             print(outliers[col].astype(str) + \" | \" + outliers[target_feature].astype(str))\n",
    "#         else:\n",
    "#             print(f\"\\n特征 {col}：无异常值\")\n",
    "#     # 处理异常值（替换为NaN后填充中位数）\n",
    "#     X_clean = X_clean.replace([np.inf, -np.inf], np.nan)\n",
    "#     X_clean = X_clean.mask(X_clean.abs() > max_float64 * 0.9, np.nan)  # 极大值标记为NaN\n",
    "#     fill_values = X_clean.median()  # 用中位数填充（鲁棒性强）\n",
    "#     X_clean = X_clean.fillna(fill_values)\n",
    "#     X[numeric_features] = X_clean\n",
    "#     # ====================================================================\n",
    "    \n",
    "#     # 目标变量变换（保持原逻辑）\n",
    "#     if transform_target:\n",
    "#         y_transformed = np.log1p(y)\n",
    "#         inverse_transform = lambda y: np.expm1(y)\n",
    "#         print(f\"    [TARGET] 对目标变量应用log1p变换（处理后均值={y_transformed.mean():.4f}）\")\n",
    "#     else:\n",
    "#         y_transformed = y\n",
    "#         inverse_transform = lambda y: y\n",
    "#         print(f\"    [TARGET] 目标变量未变换（原始均值={y.mean():.4f}）\")\n",
    "    \n",
    "#     # 特征分类（保持原逻辑）\n",
    "#     numeric_features = X.select_dtypes(include=np.number).columns.tolist()\n",
    "#     cat_features = X.select_dtypes(exclude=np.number).columns.tolist()\n",
    "#     print(f\"    [FEATURES] 数值特征（{len(numeric_features)}）: {numeric_features[:5]}...（仅展示前5个）\")\n",
    "#     print(f\"               类别特征（{len(cat_features)}）: {cat_features}\")\n",
    "    \n",
    "#     # 特征处理管道（保持原逻辑）\n",
    "#     numeric_transformer = Pipeline(steps=[\n",
    "#         ('robust_scaler', RobustScaler()),\n",
    "#         ('quantile_transform', QuantileTransformer(\n",
    "#             n_quantiles=100, \n",
    "#             output_distribution='normal', \n",
    "#             random_state=42\n",
    "#         ))\n",
    "#     ])\n",
    "#     cat_transformer = OneHotEncoder(handle_unknown='ignore', sparse_output=False, dtype=np.float32)\n",
    "#     preprocessor = ColumnTransformer(\n",
    "#         transformers=[\n",
    "#             ('num', numeric_transformer, numeric_features),\n",
    "#             ('cat', cat_transformer, cat_features)\n",
    "#         ],\n",
    "#         verbose_feature_names_out=False\n",
    "#     )\n",
    "    \n",
    "#     # 执行变换（保持原逻辑）\n",
    "#     X_processed = preprocessor.fit_transform(X)\n",
    "#     encoded_cat_cols = cat_transformer.get_feature_names_out(cat_features) if cat_features else []\n",
    "#     full_feature_names = numeric_features + list(encoded_cat_cols)\n",
    "#     X_processed = pd.DataFrame(X_processed, columns=full_feature_names)\n",
    "#     processed_data = pd.concat([X_processed, y_transfpreprocess_dataormed.rename(target_feature)], axis=1)\n",
    "#     print(f\"    [OUTPUT] 预处理后数据维度：{processed_data.shape}（特征数={processed_data.shape[1]-1}）\")\n",
    "#     print(f\"{'='*80}\\n\")\n",
    "    \n",
    "#     return processed_data, inverse_transform\n",
    "\n",
    "# # ============================== 数据保存模块 ==============================\n",
    "# def save_processed_dataset(\n",
    "#     data: pd.DataFrame, \n",
    "#     data_type: str, \n",
    "#     target_feature: str, \n",
    "#     save_folder: str,\n",
    "#     file_format: str = 'csv'  # 新增参数：支持 'csv' 或 'excel'\n",
    "# ):\n",
    "#     \"\"\"\n",
    "#      保存预处理后的数据到指定路径（支持CSV/Excel格式）\n",
    "#     \"\"\"\n",
    "#     os.makedirs(save_folder, exist_ok=True)\n",
    "#     if file_format == 'csv':\n",
    "#         file_path = os.path.join(save_folder, f\"{data_type}_processed.csv\")\n",
    "#         data.to_csv(file_path, index=False)\n",
    "#     elif file_format == 'excel':\n",
    "#         file_path = os.path.join(save_folder, f\"{data_type}_processed.xlsx\")\n",
    "#         # 需安装openpyxl库：pip install openpyxl\n",
    "#         data.to_excel(file_path, index=False, engine='openpyxl')\n",
    "#     else:\n",
    "#         raise ValueError(f\"不支持的文件格式：{file_format}，请选择 'csv' 或 'excel'\")\n",
    "#     print(f\"[SAVE] {data_type.upper()} 集已保存至 {file_path}（样本数={data.shape[0]}）\")\n",
    "\n",
    "# # ============================== 模型训练与评估模块 ==============================\n",
    "# def run_regression_experiment(\n",
    "#     train_data: pd.DataFrame,\n",
    "#     val_data: pd.DataFrame,\n",
    "#     test_data: pd.DataFrame,\n",
    "#     target_feature: str,\n",
    "#     model_save_dir: str = \"ag_regression_models\",\n",
    "#     num_gpus: int = 1,\n",
    "#     transform_target: bool = True\n",
    "# ):\n",
    "#     \"\"\"\n",
    "#     完整回归实验流程，包含：\n",
    "#     1. 数据预处理与保存\n",
    "#     2. 自动化模型训练（超参数搜索+模型集成）\n",
    "#     3. 多尺度评估指标计算\n",
    "#     4. 模型性能排行榜输出\n",
    "    \n",
    "#     参数:\n",
    "#         train_data/val_data/test_data: 训练/验证/测试数据集\n",
    "#         target_feature: 目标变量列名\n",
    "#         model_save_dir: 模型与中间结果保存目录\n",
    "#         num_gpus: 使用的GPU数量（默认1）\n",
    "#         transform_target: 是否对目标变量进行对数变换（默认True）\n",
    "#     \"\"\"\n",
    "#     # 初始化全局配置\n",
    "#     set_seed(seed=42)  # 固定随机种子（论文可复现性关键）\n",
    "    \n",
    "#     # ====================== 阶段1：数据预处理 ======================\n",
    "#     print(f\"\\n{'='*100}\")\n",
    "#     print(f\"[EXPERIMENT START] 回归预测实验启动，目标特征：{target_feature}\")\n",
    "#     print(f\"    模型保存路径：{model_save_dir}\")\n",
    "#     print(f\"    GPU资源：{num_gpus} 张\")\n",
    "#     print(f\"{'='*100}\\n\")\n",
    "    \n",
    "#     # 预处理数据集\n",
    "#     train_processed, train_inverse = preprocess_data(train_data, target_feature, transform_target)\n",
    "#     val_processed, _ = preprocess_data(val_data, target_feature, transform_target)\n",
    "#     test_processed, test_inverse = preprocess_data(test_data, target_feature, transform_target)\n",
    "    \n",
    "#     # 合并训练集与验证集（AutoGluon自动划分训练/验证子集）\n",
    "#     combined_data = pd.concat([train_processed, val_processed])\n",
    "#     val_ratio = len(val_processed) / len(combined_data) if len(combined_data) > 0 else 0.2\n",
    "#     print(f\"    [DATA MERGE] 合并后训练集+验证集样本数：{len(combined_data)}（验证集占比{val_ratio:.2%}）\")\n",
    "    \n",
    "#     # 保存中间数据（论文可追溯性）\n",
    "#     data_save_path = os.path.join(model_save_dir, \"processed_data\")\n",
    "#     save_processed_dataset(train_processed, \"train\", target_feature, data_save_path)\n",
    "#     save_processed_dataset(val_processed, \"val\", target_feature, data_save_path)\n",
    "#     save_processed_dataset(test_processed, \"test\", target_feature, data_save_path)\n",
    "    \n",
    "#     # ====================== 阶段2：自动化模型训练 ======================\n",
    "#     # 超参数搜索空间（完整保留用户定义，修正拼写错误）\n",
    "#     hyperparameter_space = {\n",
    "#         \"XGB\": {  # XGBoost配置（支持GPU加速）\n",
    "#             \"n_estimators\": (500, 3000),         # 树数量（范围搜索）\n",
    "#             \"learning_rate\": (0.001, 0.2, 'log'), # 学习率（对数尺度搜索）\n",
    "#             \"max_depth\": (6, 12),                # 树深度\n",
    "#             \"subsample\": (0.6, 1.0),             # 行采样率\n",
    "#             \"colsample_bytree\": (0.6, 1.0),      # 列采样率\n",
    "#             \"gamma\": (0, 1.0),                   # 叶子节点分裂最小损失增益\n",
    "#             \"reg_alpha\": (0, 2.0),               # L1正则化\n",
    "#             \"reg_lambda\": (0, 2.0),              # L2正则化（修正拼写错误）\n",
    "#             \"tree_method\": \"hist\",  # CPU版本\n",
    "#             \"early_stopping_rounds\": 50          # 早停轮数\n",
    "#         },\n",
    "#         \"GBM\": {  # LightGBM配置（GPU版本）\n",
    "#             \"n_estimators\": (500, 3000),\n",
    "#             \"learning_rate\": (0.001, 0.2, 'log'),\n",
    "#             \"num_leaves\": (30, 1000),            # 叶子节点数\n",
    "#             \"subsample\": (0.6, 1.0),\n",
    "#             \"colsample_bytree\": (0.6, 1.0),\n",
    "#             \"reg_alpha\": (0, 2.0),\n",
    "#             \"reg_lambda\": (0, 2.0),\n",
    "#             \"device\": \"cpu\",  # CPU版本\n",
    "#             \"early_stopping_rounds\": 50\n",
    "#         },\n",
    "#         \"CAT\": {  # CatBoost配置（GPU版本）\n",
    "#             \"iterations\": (1000, 4000),          # 迭代次数\n",
    "#             \"learning_rate\": (0.001, 0.2, 'log'),\n",
    "#             \"depth\": (6, 12),\n",
    "#             \"l2_leaf_reg\": (1e-3, 20),           # 叶子节点L2正则化\n",
    "#             \"grow_policy\": ['SymmetricTree', 'Depthwise'],  # 树生长策略\n",
    "#             \"task_type\": \"GPU\",                  # GPU任务类型\n",
    "#             \"early_stopping_rounds\": 50\n",
    "#         },\n",
    "#         \"RF\": {  # 随机森林配置（并行优化）\n",
    "#             \"n_estimators\": (500, 2000),\n",
    "#             \"max_depth\": (10, 40),\n",
    "#             \"min_samples_split\": (2, 20),        # 节点分裂最小样本数\n",
    "#             \"max_features\": ['sqrt', 'log2', 0.8],  # 特征选择策略\n",
    "#             \"n_jobs\": -1                         # 使用所有CPU核心\n",
    "#         },\n",
    "#         \"NN_TORCH\": {  # 神经网络配置（PyTorch实现）\n",
    "#             \"num_epochs\": (200, 800),            # 训练轮数\n",
    "#             \"batch_size\": [512, 1024, 2048],     # 批量大小\n",
    "#             \"learning_rate\": (1e-5, 0.1, 'log'),\n",
    "#             \"dropout_prob\": (0.1, 0.7),          #  dropout率\n",
    "#             \"hidden_layer_sizes\": [              # 隐藏层结构\n",
    "#                 (1024, 512, 256), \n",
    "#                 (512, 512, 256), \n",
    "#                 (256, 256, 128), \n",
    "#                 (1024, 1024)\n",
    "#             ],\n",
    "#             \"batch_norm\": True,                  # 批量归一化\n",
    "#             \"optimizer\": ['adamw', 'sgd', 'rmsprop'],  # 优化器\n",
    "#             \"device\": \"cuda\" if num_gpus > 0 else \"cpu\"  # 设备类型\n",
    "#         },\n",
    "#         \"TabNet\": {  # TabNet配置（稀疏特征选择）\n",
    "#             \"n_steps\": (3, 8),                   # 注意力步骤数\n",
    "#             \"gamma\": (1.0, 3.0),                 # 放松因子\n",
    "#             \"n_shared\": (2, 6),                  # 共享特征维度\n",
    "#             \"lambda_sparse\": (1e-6, 1e-2, 'log'),# 稀疏正则化\n",
    "#             \"optimizer_lr\": (1e-4, 0.1, 'log'),\n",
    "#             \"mask_type\": ['entmax', 'sparsemax', 'sparse_logistic']  # 掩码类型\n",
    "#         },\n",
    "#         \"stack\": {  # 模型融合配置（Stacking）\n",
    "#             \"num_stack_levels\": (2, 3),          # 融合层数\n",
    "#             \"meta_model\": ['XGB', 'GBM', 'CAT', 'NN_TORCH']  # 元模型类型\n",
    "#         }\n",
    "#     }\n",
    "    \n",
    "#     # 初始化AutoGluon预测器\n",
    "#     print(f\"\\n    [MODEL INIT] 初始化TabularPredictor，评估指标：RMSE\")\n",
    "#     predictor = TabularPredictor(\n",
    "#         label=target_feature,\n",
    "#         problem_type=\"regression\",\n",
    "#         eval_metric=\"rmse\",\n",
    "#         path=model_save_dir\n",
    "#     )\n",
    "    \n",
    "#     # 模型训练（超参数搜索+集成）\n",
    "#     print(f\"    [TRAINING START] 超参数搜索策略：Optuna（{hyperparameter_space['XGB']['n_estimators'][1]}次试验）\")\n",
    "#     predictor.fit(\n",
    "#         train_data=combined_data,\n",
    "#         holdout_frac=val_ratio,\n",
    "#         hyperparameters=hyperparameter_space,\n",
    "#         presets=\"best_quality\",  # 使用最高质量预设（包括交叉验证和集成）\n",
    "#         included_model_types=\"all\",  # 包含所有支持的模型类型\n",
    "#         hyperparameter_tune_kwargs={\n",
    "#             \"search_strategy\": \"optuna\",        # 优化搜索策略\n",
    "#             \"num_trials\": 1000,                 # 试验次数（论文中可调整）\n",
    "#             \"scheduler\": \"fifo\",                # 先进先出调度\n",
    "#             \"pruner\": \"hyperband\"               # 早停剪枝策略\n",
    "#         },\n",
    "#         num_bag_folds=5,                   # 5折袋外集成（提升泛化性）\n",
    "#         verbosity=2,                       # 日志详细度（避免冗余输出）\n",
    "#         num_cpus=16,                       # 使用CPU核心数\n",
    "#         num_gpus=num_gpus                  # GPU资源分配\n",
    "#     )\n",
    "#     print(f\"    [TRAINING FINISH] 训练完成，最佳模型保存至 {model_save_dir}\")\n",
    "    \n",
    "#     # ====================== 阶段3：测试集评估 ======================\n",
    "#     # 预测并转换回原始尺度\n",
    "#     print(f\"\\n    [EVALUATION START] 测试集样本数：{len(test_processed)}\")\n",
    "#     y_pred_transformed = predictor.predict(test_processed)\n",
    "#     y_pred_original = test_inverse(y_pred_transformed)\n",
    "#     y_true_original = test_data[target_feature].values\n",
    "    \n",
    "#     # 计算评估指标（变换后/原始尺度）\n",
    "#     transformed_metrics = predictor.evaluate(test_processed, metrics=[\"rmse\", \"r2\", \"mae\"])\n",
    "#     rmsle_original = np.sqrt(np.mean((y_pred_transformed - test_processed[target_feature].values) ** 2))\n",
    "    \n",
    "#     # 输出预测结果（论文实验结果部分直接引用）\n",
    "#     print(f\"\\n{'='*50} 预测结果示例 {'='*50}\")\n",
    "#     print(f\"    原始尺度预测值（前5条）: \\n{np.round(y_pred_original[:5], 2)}\")\n",
    "#     print(f\"    原始尺度真实值（前5条）: \\n{np.round(y_true_original[:5], 2)}\")\n",
    "#     print(f\"    预测值范围: [{y_pred_original.min():.2f}, {y_pred_original.max():.2f}]\")\n",
    "#     print(f\"    真实值范围: [{y_true_original.min():.2f}, {y_true_original.max():.2f}]\")\n",
    "    \n",
    "#     # 输出评估指标（核心结果，建议写入论文表格）\n",
    "#     print(f\"\\n{'='*50} 评估指标 {'='*50}\")\n",
    "#     print(f\"    [变换后尺度（log1p）]\")\n",
    "#     print(f\"        RMSE: {transformed_metrics['rmse']:.4f} | R²: {transformed_metrics['r2']:.4f} | MAE: {transformed_metrics['mae']:.4f}\")\n",
    "#     print(f\"    [原始尺度]\")\n",
    "#     print(f\"        RMSLE（等价变换后RMSE）: {rmsle_original:.4f}\")  # RMSLE与变换后RMSE数学等价\n",
    "    \n",
    "#     # 输出模型排行榜（论文中模型比较部分）\n",
    "#     leaderboard = predictor.leaderboard(\n",
    "#         combined_data,\n",
    "#         extra_metrics=[\"rmse\", \"r2\", \"mae\", \"mse\"],\n",
    "#         rank_by=\"rmse\"  # 按验证集RMSE排序\n",
    "#     )\n",
    "#     print(f\"\\n{'='*50} 模型性能排行榜（前5名） {'='*50}\")\n",
    "#     print(leaderboard.head(5).to_string(index=False))  # 去除索引列，便于论文表格转换\n",
    "    \n",
    "#     # 保存最佳模型（后续预测或部署使用）\n",
    "#     predictor.save()\n",
    "#     print(f\"    [MODEL SAVED] 最佳模型已保存，可通过TabularPredictor.load('{model_save_dir}')加载\")\n",
    "    \n",
    "#     print(f\"\\n{'='*100}\")\n",
    "#     print(f\"[EXPERIMENT FINISH] 回归预测实验完成，完整结果已记录至 {model_save_dir}\")\n",
    "#     print(f\"{'='*100}\\n\")\n",
    "\n",
    "# import pandas as pd\n",
    "# from sklearn.preprocessing import OneHotEncoder\n",
    "\n",
    "# def analyze_and_encode_combinations(df: pd.DataFrame, feature_cols: list):\n",
    "#     \"\"\"\n",
    "#     分析特征组合并进行独热编码（论文级详细版本）\n",
    "    \n",
    "#     参数:\n",
    "#         df: 输入数据集（包含目标特征和待编码的特征列）\n",
    "#         feature_cols: 待分析和编码的特征列名列表（如 ['H', 'B', 'T1', 'T2', 'L', 'n', 'type']）\n",
    "    \n",
    "#     输出:\n",
    "#         combinations_df: 去重后的唯一特征组合DataFrame\n",
    "#         encoded_df: 独热编码后的特征组合DataFrame\n",
    "#         combination_counts: 每种组合对应的数据量统计\n",
    "#     \"\"\"\n",
    "#     # ====================== 步骤1：数据质量检查 ======================\n",
    "#     print(\"=\"*60)\n",
    "#     print(\"[数据质量检查]\")\n",
    "#     # 缺失值统计（论文中需说明处理方式）\n",
    "#     missing_values = df[feature_cols].isnull().sum()\n",
    "#     print(f\"1. 各特征缺失值数量（总样本数：{len(df)}）:\")\n",
    "#     print(missing_values.to_string())  # 转换为字符串避免截断\n",
    "    \n",
    "#     # 数据类型检查（确保无非法类型，如字符串混入数值列）\n",
    "#     dtypes = df[feature_cols].dtypes\n",
    "#     print(f\"\\n2. 各特征数据类型:\")\n",
    "#     print(dtypes.to_string())\n",
    "    \n",
    "#     # 缺失值处理（论文中需说明：删除含缺失值的行）\n",
    "#     df_clean = df.dropna(subset=feature_cols).copy()\n",
    "#     if len(df_clean) < len(df):\n",
    "#         print(f\"\\n警告：删除 {len(df)-len(df_clean)} 条含缺失值的样本（剩余 {len(df_clean)} 条）\")\n",
    "#     else:\n",
    "#         print(\"\\n提示：数据无缺失值，无需删除样本\")\n",
    "    \n",
    "#     # ====================== 步骤2：提取唯一特征组合 ======================\n",
    "#     print(\"\\n\" + \"=\"*60)\n",
    "#     print(\"[特征组合分析]\")\n",
    "#     # 去重提取唯一组合（论文中需说明：仅保留不同特征值的唯一组合）\n",
    "#     combinations_df = df_clean[feature_cols].drop_duplicates()\n",
    "#     print(f\"1. 实际存在的唯一特征组合数量：{len(combinations_df)}\")\n",
    "#     print(\"   部分组合示例（前5条）:\")\n",
    "#     print(combinations_df.head().to_string(index=False))  # 输出前5条避免冗长\n",
    "    \n",
    "#     # 统计每种组合的数据量（论文中需分析数据分布均衡性）\n",
    "#     combination_counts = df_clean.groupby(feature_cols).size().reset_index(name='数据量')\n",
    "#     print(f\"\\n2. 每种组合对应的数据量（按数据量降序排列）:\")\n",
    "#     print(combination_counts.sort_values('数据量', ascending=False).head().to_string(index=False))  # 输出前5多的组合\n",
    "    \n",
    "#     # 检查是否存在数据量过少的组合（论文中需说明对小样本组合的处理）\n",
    "#     min_count = combination_counts['数据量'].min()\n",
    "#     if min_count < 5:\n",
    "#         print(f\"\\n警告：存在数据量仅 {min_count} 的组合（可能影响模型泛化性）\")\n",
    "    \n",
    "#     # ====================== 步骤3：独热编码 ======================\n",
    "#     print(\"\\n\" + \"=\"*60)\n",
    "#     print(\"[独热编码实现]\")\n",
    "#     # 初始化编码器（论文中需说明：使用独热编码处理特征组合）\n",
    "#     encoder = OneHotEncoder(\n",
    "#         sparse_output=False,  # 输出密集矩阵（便于可视化和后续处理）\n",
    "#         handle_unknown='ignore'  # 测试集出现新组合时编码为全0（鲁棒性关键）\n",
    "#     )\n",
    "    \n",
    "#     # 执行编码（论文中需说明：每个唯一组合对应一个二进制向量）\n",
    "#     encoded_data = encoder.fit_transform(combinations_df)\n",
    "#     encoded_columns = encoder.get_feature_names_out(feature_cols)  # 生成带原始列名的编码列（如 H_100, B_200）\n",
    "#     encoded_df = pd.DataFrame(encoded_data, columns=encoded_columns)\n",
    "    \n",
    "#     print(f\"1. 编码后特征数量：{encoded_df.shape[1]}（原特征数：{len(feature_cols)}）\")\n",
    "#     print(\"   编码后组合示例（前5条）:\")\n",
    "#     display(encoded_df.head().astype(int).to_string(index=False))  # 转换为整数更易读\n",
    "    \n",
    "#     # 验证编码唯一性（确保每个组合编码唯一）\n",
    "#     unique_encoded = encoded_df.drop_duplicates().shape[0]\n",
    "#     if unique_encoded == len(combinations_df):\n",
    "#         print(\"\\n验证：所有组合编码唯一，无冲突\")\n",
    "#     else:\n",
    "#         print(f\"\\n警告：存在 {len(combinations_df)-unique_encoded} 个编码冲突（需检查特征值）\")\n",
    "    \n",
    "#     return combinations_df, encoded_df, combination_counts\n",
    "\n",
    "\n",
    "# # ====================== 使用示例 ======================\n",
    "# if __name__ == \"__main__\":\n",
    "#     # 假设 df_alltype 是你的数据集（需替换为实际数据）\n",
    "#     # data = df_alltype  # 取消注释使用实际数据\n",
    "#     feature_columns = ['H', 'B', 'T1', 'T2', 'L', 'n', 'type']  # 待分析的特征列\n",
    "    \n",
    "#     # 执行分析与编码\n",
    "#     unique_combinations, encoded_combinations, combination_stats = analyze_and_encode_combinations(data, feature_columns)\n",
    "    \n",
    "#     # 保存结果（论文中需保存中间数据）\n",
    "#     unique_combinations.to_csv(\"unique_feature_combinations.csv\", index=False)\n",
    "#     encoded_combinations.to_csv(\"onehot_encoded_combinations.csv\", index=False)\n",
    "#     combination_stats.to_csv(\"combination_data_counts.csv\", index=False)\n",
    "#     print(\"\\n[结果保存] 唯一组合、编码结果、数据量统计已保存为CSV文件\")\n",
    "# # ============================== 实验执行入口 ==============================\n",
    "# if __name__ == \"__main__\":\n",
    "#     # 论文实验配置（需替换为实际数据）\n",
    "#     TARGET_FEATURE = \"Pucf12f\"  # 目标变量名称\n",
    "#     MODEL_SAVE_DIR = \"ag_regression_models\"  # 模型保存目录\n",
    "#     NUM_GPUS = 1  # 使用GPU数量（0表示仅CPU）\n",
    "    \n",
    "#     # 数据加载（示例，需用户根据实际路径修改）\n",
    "#     # train_data = pd.read_csv(\"path/to/train.csv\")\n",
    "#     # val_data = pd.read_csv(\"path/to/val.csv\")\n",
    "#     # test_data = pd.read_csv(\"path/to/test.csv\")\n",
    "    \n",
    "#     # 假设数据已加载为ag_train/ag_val/ag_test（用户需自行替换）\n",
    "#     run_regression_experiment(\n",
    "#         train_data=ag_train,\n",
    "#         val_data=ag_val,\n",
    "#         test_data=ag_test,\n",
    "#         target_feature=TARGET_FEATURE,\n",
    "#         model_save_dir=MODEL_SAVE_DIR,\n",
    "#         num_gpus=NUM_GPUS\n",
    "#     )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9e159c03",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# # --------------------------\n",
    "# # 预测测试集\n",
    "# test_predictions = predictor.predict(test_data)\n",
    "# print(f\"\\n测试集预测结果（前5条）：\\n{test_predictions[:5]}\")\n",
    "\n",
    "# # 评估 R² 分数\n",
    "# test_score = predictor.evaluate(test_data, metrics=[\"r2\"])\n",
    "# print(f\"测试集 R² 分数：{test_score['r2']:.4f}\")\n",
    "# preprocess_data\n",
    "# # 查看所有模型性能排名（按验证集排序）\n",
    "# leaderboard = predictor.leaderboard(\n",
    "#     val_data,  # 使用验证集评估模型\n",
    "#     extra_metrics=[\"r2\", \"mae\", \"mse\"],  # 额外评估指标\n",
    "#     rank_by=\"r2\"  # 按 R² 排序（降序）\n",
    "# )\n",
    "# print(\"\\n各模型性能排名（按 R² 降序）：\")\n",
    "# print(leaderboard)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "543e5f2a",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "67bc8466",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ae44d80",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import shap\n",
    "import joblib\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "# 设置中文字体\n",
    "plt.rcParams['font.sans-serif'] = ['SimHei']\n",
    "plt.rcParams['axes.unicode_minus'] = False\n",
    "\n",
    "class SHAPAnalyzer:\n",
    "    def __init__(self, model, data, features, target):\n",
    "        \"\"\"\n",
    "        SHAP分析器初始化\n",
    "        \n",
    "        参数:\n",
    "        model: 训练好的模型\n",
    "        data: 数据DataFrame\n",
    "        features: 特征列表\n",
    "        target: 目标变量名\n",
    "        \"\"\"\n",
    "        self.model = model\n",
    "        self.data = data\n",
    "        self.features = features\n",
    "        self.target = target\n",
    "        self.X = data[features]\n",
    "        self.y = data[target]\n",
    "        self.explainer = None\n",
    "        self.shap_values = None\n",
    "        \n",
    "    def create_explainer(self):\n",
    "        \"\"\"创建SHAP解释器\"\"\"\n",
    "        # 根据模型类型选择合适的解释器\n",
    "        model_type = type(self.model).__name__\n",
    "        \n",
    "        if 'Tree' in model_type or 'Forest' in model_type or 'XGB' in model_type or 'LGBM' in model_type:\n",
    "            # 树模型使用TreeExplainer\n",
    "            self.explainer = shap.TreeExplainer(self.model)\n",
    "        elif 'Linear' in model_type or 'Ridge' in model_type or 'Lasso' in model_type:\n",
    "            # 线性模型使用LinearExplainer\n",
    "            self.explainer = shap.LinearExplainer(self.model, self.X)\n",
    "        else:\n",
    "            # 其他模型使用KernelExplainer（较慢）\n",
    "            # 使用数据的一个小样本作为背景数据\n",
    "            background = shap.sample(self.X, 100)\n",
    "            self.explainer = shap.KernelExplainer(self.model.predict, background)\n",
    "            \n",
    "        print(f\"创建了{type(self.explainer).__name__}解释器\")\n",
    "        \n",
    "    def calculate_shap_values(self, sample_size=None):\n",
    "        \"\"\"计算SHAP值\"\"\"\n",
    "        if sample_size:\n",
    "            X_sample = self.X.sample(n=sample_size, random_state=42)\n",
    "        else:\n",
    "            X_sample = self.X\n",
    "            \n",
    "        self.shap_values = self.explainer.shap_values(X_sample)\n",
    "        \n",
    "        # 如果是多输出模型，选择第一个输出\n",
    "        if isinstance(self.shap_values, list):\n",
    "            self.shap_values = self.shap_values[0]\n",
    "            \n",
    "        print(f\"计算了{len(X_sample)}个样本的SHAP值\")\n",
    "        return X_sample\n",
    "        \n",
    "    def plot_summary(self, plot_type='both'):\n",
    "        \"\"\"绘制SHAP摘要图\"\"\"\n",
    "        plt.figure(figsize=(12, 8))\n",
    "        \n",
    "        if plot_type == 'bar' or plot_type == 'both':\n",
    "            # 条形图 - 显示特征重要性\n",
    "            plt.subplot(1, 2 if plot_type == 'both' else 1, 1)\n",
    "            shap.summary_plot(self.shap_values, self.X, plot_type=\"bar\", show=False)\n",
    "            plt.title(\"特征重要性 (|SHAP值|平均值)\", fontsize=14)\n",
    "            \n",
    "        if plot_type == 'dot' or plot_type == 'both':\n",
    "            # 点图 - 显示特征影响\n",
    "            plt.subplot(1, 2 if plot_type == 'both' else 1, 2 if plot_type == 'both' else 1)\n",
    "            shap.summary_plot(self.shap_values, self.X, show=False)\n",
    "            plt.title(\"特征影响分布\", fontsize=14)\n",
    "            \n",
    "        plt.tight_layout()\n",
    "        plt.savefig('shap_summary.png', dpi=300, bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_dependence(self, feature, interaction_feature=None):\n",
    "        \"\"\"绘制依赖图\"\"\"\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        \n",
    "        if interaction_feature:\n",
    "            shap.dependence_plot(feature, self.shap_values, self.X, \n",
    "                               interaction_index=interaction_feature, show=False)\n",
    "            plt.title(f\"{feature} 的SHAP依赖图 (与 {interaction_feature} 交互)\", fontsize=14)\n",
    "        else:\n",
    "            shap.dependence_plot(feature, self.shap_values, self.X, show=False)\n",
    "            plt.title(f\"{feature} 的SHAP依赖图\", fontsize=14)\n",
    "            \n",
    "        plt.xlabel(f\"{feature} 值\", fontsize=12)\n",
    "        plt.ylabel(f\"SHAP值 (对{self.target}的影响)\", fontsize=12)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(f'shap_dependence_{feature}.png', dpi=300, bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_waterfall(self, instance_idx=0):\n",
    "        \"\"\"绘制瀑布图 - 解释单个预测\"\"\"\n",
    "        # 创建Explanation对象\n",
    "        shap_explanation = shap.Explanation(values=self.shap_values[instance_idx],\n",
    "                                           base_values=self.explainer.expected_value,\n",
    "                                           data=self.X.iloc[instance_idx],\n",
    "                                           feature_names=self.features)\n",
    "        \n",
    "        plt.figure(figsize=(12, 8))\n",
    "        shap.waterfall_plot(shap_explanation, show=False)\n",
    "        \n",
    "        actual_value = self.y.iloc[instance_idx]\n",
    "        pred_value = self.model.predict(self.X.iloc[instance_idx:instance_idx+1])[0]\n",
    "        \n",
    "        plt.title(f\"样本 {instance_idx} 的预测解释\\n实际值: {actual_value:.3f}, 预测值: {pred_value:.3f}\", \n",
    "                 fontsize=14)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(f'shap_waterfall_sample_{instance_idx}.png', dpi=300, bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_force(self, instance_idx=0):\n",
    "        \"\"\"绘制力图 - 另一种单个预测解释\"\"\"\n",
    "        # 使用matplotlib后端\n",
    "        shap.force_plot(self.explainer.expected_value, \n",
    "                       self.shap_values[instance_idx],\n",
    "                       self.X.iloc[instance_idx],\n",
    "                       feature_names=self.features,\n",
    "                       matplotlib=True,\n",
    "                       show=False)\n",
    "        \n",
    "        plt.title(f\"样本 {instance_idx} 的力图解释\", fontsize=14)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(f'shap_force_sample_{instance_idx}.png', dpi=300, bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_interaction_values(self):\n",
    "        \"\"\"绘制特征交互图\"\"\"\n",
    "        # 计算交互SHAP值（注意：这可能很慢）\n",
    "        shap_interaction_values = self.explainer.shap_interaction_values(self.X.sample(100))\n",
    "        \n",
    "        # 计算主效应和交互效应\n",
    "        main_effects = np.abs(shap_interaction_values).diagonal(axis1=1, axis2=2).mean(0)\n",
    "        interaction_effects = np.abs(shap_interaction_values).sum(2).mean(0) - main_effects\n",
    "        \n",
    "        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 8))\n",
    "        \n",
    "        # 主效应图\n",
    "        y_pos = np.arange(len(self.features))\n",
    "        ax1.barh(y_pos, main_effects)\n",
    "        ax1.set_yticks(y_pos)\n",
    "        ax1.set_yticklabels(self.features)\n",
    "        ax1.set_xlabel('平均|SHAP|值')\n",
    "        ax1.set_title('特征主效应', fontsize=14)\n",
    "        \n",
    "        # 交互效应热力图\n",
    "        sns.heatmap(interaction_effects, xticklabels=self.features, \n",
    "                   yticklabels=self.features, annot=True, fmt='.3f',\n",
    "                   cmap='YlOrRd', ax=ax2)\n",
    "        ax2.set_title('特征交互效应', fontsize=14)\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.savefig('shap_interactions.png', dpi=300, bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "    def plot_all_dependence(self):\n",
    "        \"\"\"为所有特征绘制依赖图\"\"\"\n",
    "        n_features = len(self.features)\n",
    "        n_cols = 3\n",
    "        n_rows = (n_features + n_cols - 1) // n_cols\n",
    "        \n",
    "        fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, 6*n_rows))\n",
    "        axes = axes.flatten()\n",
    "        \n",
    "        for i, feature in enumerate(self.features):\n",
    "            ax = axes[i]\n",
    "            \n",
    "            # 获取特征索引\n",
    "            feature_idx = self.X.columns.get_loc(feature)\n",
    "            \n",
    "            # 手动创建依赖图\n",
    "            ax.scatter(self.X[feature], self.shap_values[:, feature_idx], \n",
    "                      alpha=0.5, s=20, edgecolors='k', linewidth=0.5)\n",
    "            \n",
    "            # 添加平滑曲线\n",
    "            from scipy.ndimage import gaussian_filter1d\n",
    "            sorted_idx = np.argsort(self.X[feature].values)\n",
    "            smoothed_shap = gaussian_filter1d(self.shap_values[sorted_idx, feature_idx], sigma=5)\n",
    "            ax.plot(self.X[feature].values[sorted_idx], smoothed_shap, 'r-', linewidth=2)\n",
    "            \n",
    "            ax.set_xlabel(feature, fontsize=12)\n",
    "            ax.set_ylabel(f'SHAP值', fontsize=12)\n",
    "            ax.set_title(f'{feature} 的SHAP依赖性', fontsize=14)\n",
    "            ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)\n",
    "            \n",
    "        # 隐藏多余的子图\n",
    "        for i in range(len(self.features), len(axes)):\n",
    "            axes[i].set_visible(False)\n",
    "            \n",
    "        plt.tight_layout()\n",
    "        plt.savefig('shap_all_dependence.png', dpi=300, bbox_inches='tight')\n",
    "        plt.show()\n",
    "        \n",
    "    def generate_shap_report(self):\n",
    "        \"\"\"生成SHAP分析报告\"\"\"\n",
    "        print(\"=\"*60)\n",
    "        print(\"SHAP特征解释分析报告\")\n",
    "        print(\"=\"*60)\n",
    "        \n",
    "        # 计算特征重要性\n",
    "        shap_importance = np.abs(self.shap_values).mean(0)\n",
    "        importance_df = pd.DataFrame({\n",
    "            '特征': self.features,\n",
    "            'SHAP重要性': shap_importance\n",
    "        }).sort_values('SHAP重要性', ascending=False)\n",
    "        \n",
    "        print(\"\\n1. 基于SHAP值的特征重要性排序:\")\n",
    "        print(importance_df.to_string(index=False))\n",
    "        \n",
    "        # 计算正负影响\n",
    "        print(\"\\n2. 特征的正负影响分析:\")\n",
    "        for i, feature in enumerate(self.features):\n",
    "            positive_impact = (self.shap_values[:, i] > 0).sum() / len(self.shap_values) * 100\n",
    "            negative_impact = (self.shap_values[:, i] < 0).sum() / len(self.shap_values) * 100\n",
    "            print(f\"{feature}:\")\n",
    "            print(f\"  - 正向影响样本占比: {positive_impact:.1f}%\")\n",
    "            print(f\"  - 负向影响样本占比: {negative_impact:.1f}%\")\n",
    "            print(f\"  - 平均SHAP值: {self.shap_values[:, i].mean():.4f}\")\n",
    "            \n",
    "        # 找出最重要的交互特征对\n",
    "        print(\"\\n3. 重要特征交互分析:\")\n",
    "        print(\"（基于相关性分析，建议进一步研究以下特征对的交互效应）\")\n",
    "        \n",
    "        # 计算SHAP值之间的相关性来识别潜在的交互\n",
    "        shap_corr = pd.DataFrame(self.shap_values, columns=self.features).corr()\n",
    "        \n",
    "        # 找出相关性最高的特征对（排除自身）\n",
    "        high_corr_pairs = []\n",
    "        for i in range(len(self.features)):\n",
    "            for j in range(i+1, len(self.features)):\n",
    "                corr_value = abs(shap_corr.iloc[i, j])\n",
    "                if corr_value > 0.3:  # 相关性阈值\n",
    "                    high_corr_pairs.append((self.features[i], self.features[j], corr_value))\n",
    "        \n",
    "        high_corr_pairs.sort(key=lambda x: x[2], reverse=True)\n",
    "        for feat1, feat2, corr in high_corr_pairs[:5]:\n",
    "            print(f\"  - {feat1} 与 {feat2}: 相关性 = {corr:.3f}\")\n",
    "\n",
    "# 使用示例\n",
    "if __name__ == \"__main__\":\n",
    "    # 加载模型和数据\n",
    "    model_path = r\"R:\\NAS_DRIVE\\OneDrive\\experimentclarify\\phdcode\\MODELtype\\data2_auto_P完成\\retrained_models\"\n",
    "    \n",
    "    # 需要先加载模型和数据\n",
    "    # model = joblib.load(os.path.join(model_path, \"your_model.pkl\"))\n",
    "    # data = pd.read_csv(\"your_data.csv\")\n",
    "    \n",
    "    features = ['B', 'cf1f', 'cf2f', 'axialratio', 'H', 'L', 'n', 'T1', 'T2', 'Imperfectfactor', 'yfss']\n",
    "    target = 'EigenValue'\n",
    "    \n",
    "    # 创建SHAP分析器\n",
    "    # analyzer = SHAPAnalyzer(model, data, features, target)\n",
    "    \n",
    "    # 执行SHAP分析\n",
    "    # analyzer.create_explainer()\n",
    "    # analyzer.calculate_shap_values()\n",
    "    \n",
    "    # 生成各种SHAP图表\n",
    "    # analyzer.plot_summary('both')\n",
    "    # analyzer.plot_all_dependence()\n",
    "    # analyzer.plot_waterfall(0)  # 解释第一个样本\n",
    "    # analyzer.plot_force(0)\n",
    "    # analyzer.generate_shap_report()\n",
    "    \n",
    "    # 为特定特征绘制依赖图\n",
    "    # for feature in ['axialratio', 'H', 'L']:  # 选择几个重要特征\n",
    "    #     analyzer.plot_dependence(feature)\n",
    "    \n",
    "    print(\"\\nSHAP分析使用说明:\")\n",
    "    print(\"1. 安装SHAP库: pip install shap\")\n",
    "    print(\"2. 加载您的模型和数据\")\n",
    "    print(\"3. 创建SHAPAnalyzer实例\")\n",
    "    print(\"4. 运行各种分析方法\")\n",
    "    print(\"5. 所有图表将保存为高分辨率PNG文件\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4df8d2a9",
   "metadata": {},
   "source": [
    "#### 读取模型"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8e5858db",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.311Z"
    }
   },
   "outputs": [],
   "source": [
    "# save_path = r'R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\AutoModel\\agModels-predict-Pu'\n",
    "# save_path = r'R:\\Jupyterdemo\\phdcode\\autogluon_type_feature_output'  \n",
    "\n",
    "# predictor  = TabularPredictor.load(save_path) #将训练好模型载入"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1b99c453",
   "metadata": {},
   "source": [
    "#### 模型评估"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "88921920",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 获取特定模型的训练历史\n",
    "model_names = predictor_data0_eigen.model_names()\n",
    "for model in model_names:\n",
    "    try:\n",
    "        history = predictor_data0_eigen.get_model_best_history(model)\n",
    "        print(f\"\\n模型: {model}\")\n",
    "        for epoch, metrics in history.items():\n",
    "            if \"valid_rmse\" in metrics:\n",
    "                print(f\"Epoch {epoch}: RMSE = {metrics['valid_rmse']}\")\n",
    "    except:\n",
    "        pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c21a312a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 仅适用于支持学习曲线的模型（如NeuralNetFastAI）\n",
    "try:\n",
    "    nn_model = predictor_data0_eigen.model_names(\"NeuralNetFastAI\")[0]\n",
    "    predictor_data0_eigen.plot_learning_curve(nn_model)\n",
    "    plt.show()\n",
    "except:\n",
    "    print(\"模型不支持学习曲线绘制\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "830fdfe3",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.metrics import mean_squared_error\n",
    "\n",
    "# 加载测试数据\n",
    "test_data = TabularDataset(\"data0_test.csv\")\n",
    "\n",
    "# 获取真实值和预测值\n",
    "y_true = test_data[\"EigenValue\"]\n",
    "y_pred = predictor_data0_eigen.predict(test_data)\n",
    "\n",
    "# 手动计算RMSE\n",
    "rmse = mean_squared_error(y_true, y_pred, squared=False)\n",
    "print(f\"手动计算的RMSE: {rmse}\")\n",
    "\n",
    "# 对比AutoGluon的评估结果\n",
    "leaderboard = predictor_data0_eigen.leaderboard(test_data, silent=True)\n",
    "print(leaderboard)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "20550b4d",
   "metadata": {},
   "source": [
    "##### 模型排行榜"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1fc419fb",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.330Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "leaderboard0=predictor_data0_eigen.leaderboard(data0_test, silent=True)#输出排⾏榜\n",
    "# leaderboard1=predictor_data1_eigen.leaderboard(data1_test, silent=True)#输出排⾏榜\n",
    "# leaderboard2=predictor_data2_eigen.leaderboard(data2_test, silent=True)#输出排⾏榜\n",
    "# dispalay(leaderboard0)\n",
    "# dispalay(leaderboard1)\n",
    "# dispalay(leaderboard2)\n",
    "# print(predictor.leaderboard(extra_info=True, silent=True))#输出拓展的每个算法运⾏数据的排⾏榜\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "80a502e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "leaderboard0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "af8eb4a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "leaderboard1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2e72615d",
   "metadata": {},
   "outputs": [],
   "source": [
    "leaderboard2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "187871b8",
   "metadata": {},
   "outputs": [],
   "source": [
    "leaderboard=pd.read_excel(r'R:\\NAS_DRIVE\\SynologyDrive\\OneDrive\\experimentclarify\\phdcode\\leaderboard.xlsx')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6b93bc6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "display(leaderboard)\n",
    "# leaderboard.to_excel('leaderboard.xlsx')\n",
    "leaderboard.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9e97430b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "from scipy import stats\n",
    "from sklearn.linear_model import LinearRegression\n",
    "import pandas as pd\n",
    "\n",
    "# ==================== 学术图表规范配置 ====================\n",
    "# 设置 matplotlib 的字体和其他参数，以满足学术图表规范\n",
    "plt.rcParams.update({\n",
    "    'font.family': 'serif',\n",
    "    'font.serif': ['Times New Roman'],\n",
    "    'font.size': 11,\n",
    "    'axes.titlesize': 12,\n",
    "    'axes.labelsize': 11,\n",
    "    'pdf.fonttype': 42,\n",
    "    'ps.fonttype': 42\n",
    "})\n",
    "\n",
    "# ==================== 数据预处理（动态提取家族） ====================\n",
    "def preprocess_data(df):\n",
    "    \"\"\"\n",
    "    动态识别所有出现的模型家族，并对数据进行预处理。\n",
    "    包括转换层级标签、区分模型类型、提取模型家族、转换时间单位和解析随机种子。\n",
    "\n",
    "    参数:\n",
    "    df (pandas.DataFrame): 输入的原始数据\n",
    "\n",
    "    返回:\n",
    "    pandas.DataFrame: 预处理后的数据\n",
    "    \"\"\"\n",
    "    print(\"开始数据预处理...\")\n",
    "    # 转换 stack_level 列的值为字符串格式，前面添加 'L'，例如 1 转换为 'L1'\n",
    "    df['stack_level'] = 'L' + df['stack_level'].astype(str)\n",
    "    print(\"已完成 stack_level 列的转换。\")\n",
    "\n",
    "    # 区分模型类型，根据模型名称中是否包含 'Ensemble' 来判断是集成模型还是基础模型\n",
    "    df['Model Type'] = df['model'].apply(\n",
    "        lambda x: 'Ensemble' if 'Ensemble' in x else 'Base Model'\n",
    "    )\n",
    "    print(\"已完成模型类型的区分。\")\n",
    "\n",
    "    # 动态提取模型家族（基于常见家族关键词匹配，支持扩展）\n",
    "    # 定义常见模型家族及其对应的正则表达式模式\n",
    "    common_families = {\n",
    "        'CatBoost': r'CatBoost',\n",
    "        'LightGBM': r'LightGBM',\n",
    "        'XGBoost': r'XGBoost',\n",
    "        'RandomForest': r'RandomForest',\n",
    "        'KNeighbors': r'KNeighbors'\n",
    "    }\n",
    "\n",
    "    def extract_family(model_name):\n",
    "        \"\"\"\n",
    "        根据模型名称提取模型家族。\n",
    "\n",
    "        参数:\n",
    "        model_name (str): 模型名称\n",
    "\n",
    "        返回:\n",
    "        str: 模型家族名称\n",
    "        \"\"\"\n",
    "        for family, pattern in common_families.items():\n",
    "            if pd.notna(pd.Series(model_name).str.match(pattern).iloc[0]):\n",
    "                return family\n",
    "        return model_name  # 保留未匹配的原始名称作为家族\n",
    "\n",
    "    df['Family'] = df['model'].apply(extract_family)\n",
    "    print(\"已完成模型家族的提取。\")\n",
    "\n",
    "    # 转换时间单位，将 fit_time_marginal 和 pred_time_test_marginal 列的值从秒转换为分钟\n",
    "    time_columns = ['fit_time_marginal', 'pred_time_test_marginal']\n",
    "    df[time_columns] = df[time_columns] / 60\n",
    "    print(\"已完成时间单位的转换。\")\n",
    "\n",
    "    # 解析随机种子，从模型名称中提取 _r 后面的数字作为随机种子\n",
    "    df['Random Seed'] = df['model'].str.extract(r'_r(\\d+)', expand=False)\\\n",
    "                                   .fillna(0).astype(int)\n",
    "    print(\"已完成随机种子的解析。\")\n",
    "\n",
    "    # 按 stack_level 和 score_test 列排序数据，stack_level 升序，score_test 降序\n",
    "    sorted_df = df.sort_values(['stack_level', 'score_test'], ascending=[True, False])\n",
    "    print(\"数据已按 stack_level 和 score_test 排序。\")\n",
    "    print(\"数据预处理完成。\")\n",
    "    return sorted_df\n",
    "\n",
    "# ==================== 核心图表绘制函数 ====================\n",
    "def plot_stack_level_performance(df):\n",
    "    \"\"\"\n",
    "    绘制按 stack_level 分组的模型性能对比条形图。\n",
    "\n",
    "    参数:\n",
    "    df (pandas.DataFrame): 预处理后的数据\n",
    "    \"\"\"\n",
    "    print(\"开始绘制按 stack_level 分组的模型性能对比图...\")\n",
    "    plt.figure(figsize=(14, 8))\n",
    "    # 绘制条形图，x 轴为 score_test，y 轴为 model，按 stack_level 分组着色\n",
    "    ax = sns.barplot(\n",
    "        x='score_test', y='model', hue='stack_level',\n",
    "        data=df, palette='viridis', dodge=False, edgecolor='white'\n",
    "    )\n",
    "\n",
    "    # 找到最高的 score_test 值\n",
    "    best_score = df['score_test'].max()\n",
    "    # 绘制垂直虚线标记最高分\n",
    "    ax.axvline(best_score, color='#ff4747', linestyle='--', linewidth=1)\n",
    "    # 在图上标注最高分\n",
    "    ax.text(best_score + 0.002, 0.5,\n",
    "            f\"Best: {best_score:.4f}\", color='#ff4747', va='center', fontsize=10)\n",
    "\n",
    "    plt.xlabel('R² Score (Test Set)', fontsize=12, fontproperties=font_set)\n",
    "    plt.ylabel('', fontproperties=font_set)\n",
    "    plt.title('A. Model Performance by Stack Level', loc='left', weight='bold')\n",
    "    # 设置图例位置\n",
    "    plt.legend(title='Stack Level', bbox_to_anchor=(1, 1), frameon=False)\n",
    "    plt.tight_layout()\n",
    "    # 保存图表为 PDF 文件\n",
    "    plt.savefig('stack_level_performance.pdf', dpi=300)\n",
    "    plt.close()\n",
    "    print(\"按 stack_level 分组的模型性能对比图已保存为 stack_level_performance.pdf。\")\n",
    "\n",
    "def plot_family_performance(df):\n",
    "    \"\"\"\n",
    "    绘制不同模型家族的性能分布小提琴图和散点图。\n",
    "\n",
    "    参数:\n",
    "    df (pandas.DataFrame): 预处理后的数据\n",
    "    \"\"\"\n",
    "    print(\"开始绘制不同模型家族的性能分布对比图...\")\n",
    "    plt.figure(figsize=(12, 6))\n",
    "    # 动态获取家族顺序，按出现频率排序\n",
    "    family_order = df['Family'].value_counts().index.tolist()\n",
    "    # 绘制小提琴图，展示不同模型家族的 score_test 分布\n",
    "    sns.violinplot(\n",
    "        x='Family', y='score_test', data=df,\n",
    "        inner='quartile', palette='Set3', order=family_order\n",
    "    )\n",
    "    # 绘制散点图，展示每个模型的 score_test 值\n",
    "    sns.swarmplot(\n",
    "        x='Family', y='score_test', data=df,\n",
    "        color='black', size=3, alpha=0.8\n",
    "    )\n",
    "\n",
    "    # 绘制水平虚线标记 score_test 的中位数\n",
    "    plt.axhline(df['score_test'].median(), color='red', linestyle='--', alpha=0.7)\n",
    "    plt.xlabel('Algorithm Family', fontsize=12)\n",
    "    plt.ylabel('Test R² Score', fontsize=12)\n",
    "    plt.xticks(rotation=45, ha='right')\n",
    "    plt.title('C. Algorithm Family Performance Distribution', loc='left', weight='bold')\n",
    "    # 显示图表\n",
    "    plt.show()\n",
    "    print(\"不同模型家族的性能分布对比图已显示。\")\n",
    "\n",
    "# ==================== 执行流程 ====================\n",
    "if __name__ == \"__main__\":\n",
    "    # 加载用户提供的 leaderboard 数据\n",
    "    \n",
    "    # 对数据进行预处理\n",
    "    processed_df = preprocess_data(leaderboard)\n",
    "    # 绘制按 stack_level 分组的模型性能对比图\n",
    "    plot_stack_level_performance(processed_df)\n",
    "    # 绘制不同模型家族的性能分布对比图\n",
    "    plot_family_performance(processed_df)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0d6cfd64",
   "metadata": {},
   "source": [
    "#### 可解释性"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c5ac28e",
   "metadata": {},
   "source": [
    "##### 输出各特征重要性"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7310b36c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 获取最佳模型名称\n",
    "best_model = predictor_data0_eigen.model_best  # 注意没有括号！\n",
    "print(\"Best Model:\", best_model)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "abc47042",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.340Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# 计算测试集上的特征重要性\n",
    "# 为了更好地理解我们训练有素的预测器，我们可以估计每个特征的整体重要性(计算测试集上的特征重要性)：\n",
    "feature_importance=predictor_data0_eigen.feature_importance(data=test_data, model=None, features=None, feature_stage='original', \n",
    " subsample_size=None,time_limit=None, num_shuffle_sets=None, \n",
    " include_confidence_band=True, confidence_level=0.99, silent=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7861398d",
   "metadata": {},
   "outputs": [],
   "source": [
    "feature_importance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3ceab2b7",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.360Z"
    }
   },
   "outputs": [],
   "source": [
    "print(\"AutoGluon infers problem type is: \", predictor_data0_eigen.problem_type)\n",
    "print(\"AutoGluon identified the following types of features:\")\n",
    "print(predictor_data0_eigen.feature_metadata)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a5aedbc1",
   "metadata": {},
   "source": [
    "#### 结果可视化"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6d9d8730",
   "metadata": {},
   "outputs": [],
   "source": [
    "leaderboard.to_excel('leaderboard.xlsx')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4644192",
   "metadata": {},
   "outputs": [],
   "source": [
    "best_model_name = leaderboard['model'][0]  # 获取最佳模型的名字\n",
    "print(f\"Best model name: {best_model_name}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8615ad1b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 打印leaderboard的所有列名\n",
    "print(\"Leaderboard列名:\", leaderboard.columns.tolist())\n",
    "\n",
    "# 示例输出（新版本AutoGluon）：\n",
    "# ['model', 'score_val', 'score_test', 'pred_time_val', 'fit_time', ...]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b13f953b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from matplotlib.font_manager import FontProperties\n",
    "\n",
    "# 为了确保中文字体能正确显示，请替换为你的系统中存在的中文字体路径或字体名\n",
    "font = FontProperties(fname=r\"C:/Windows/Fonts/simhei.ttf\", size=14)  # 示例：fname可以是类似'/usr/share/fonts/truetype/arphic/ukai.ttc'的路径\n",
    "# font = FontProperties(fname=r\"C:/Windows/Fonts/simhei.ttf\", size=textsize)\n",
    "class DummyPredictor:\n",
    "    def feature_importance(self, data):\n",
    "        features = data.columns if isinstance(data, pd.DataFrame) else [f'Feature_{i}' for i in range(len(data[0]))]\n",
    "        importances = [i * 0.1 for i in range(len(features))]\n",
    "        return pd.Series(importances, index=features)\n",
    "\n",
    "# 创建示例数据（这里你需要替换为实际的数据）\n",
    "\n",
    "# train_data = TabularDataset(train_df)\n",
    "# val_data = TabularDataset(val_df)\n",
    "# test_data = TabularDataset(test_df)\n",
    "\n",
    "# predictor = DummyPredictor()\n",
    "feature_importance = predictor.feature_importance(test_data)\n",
    "feature_importance = feature_importance.sort_values(ascending=True)\n",
    "\n",
    "sns.set_style(\"whitegrid\")\n",
    "plt.figure(figsize=(10, 6))\n",
    "\n",
    "ax = feature_importance.plot(kind='barh', \n",
    "                             color=sns.color_palette(\"viridis\", len(feature_importance)))\n",
    "\n",
    "for p in ax.patches:\n",
    "    ax.annotate(format(p.get_width(), '.2f'), \n",
    "                (p.get_width(), p.get_y() + p.get_height() / 2.), \n",
    "                ha = 'left', va = 'center', \n",
    "                xytext = (5, 0), \n",
    "                textcoords = 'offset points')\n",
    "\n",
    "# 设置字体为支持中文的字体\n",
    "ax.set_xlabel('重要性得分', fontproperties=font)  \n",
    "ax.set_ylabel('特征', fontproperties=font)        \n",
    "# ax.set_title('特征重要性', fontproperties=font)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21a9730d",
   "metadata": {},
   "outputs": [],
   "source": [
    "feature_importance\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8553d7ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 使用 y_test 作为 y_true\n",
    "y_true = y_test\n",
    "# 使用模型对测试集进行预测\n",
    "y_pred = predictor.predict(test_data)\n",
    "print(f\"y_true 类型: {type(y_atrue)}, 内容示例: {y_true[:5]}\")\n",
    "print(f\"y_pred 类型: {type(y_pred)}, 内容示例: {y_pred[:5]}\")\n",
    "y_true.to_excel('y_true.xlsx')\n",
    "y_pred.to_excel('y_pred.xlsx')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a0b2dfa3",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 确保y_true和y_pred索引对齐（关键！）\n",
    "y_true = test_df['Pucf12f']  # 从原始数据提取真实值\n",
    "y_pred = predictor.predict(X_test)  # 从模型获取预测值\n",
    "\n",
    "# 计算对角线范围\n",
    "min_val = min(y_true.min(), y_pred.min())\n",
    "max_val = max(y_true.max(), y_pred.max())\n",
    "\n",
    "# 绘制散点图\n",
    "plt.figure(figsize=(10, 8))\n",
    "plt.scatter(y_true, y_pred, alpha=0.6, color='royalblue')\n",
    "\n",
    "# 添加对角线参考线\n",
    "plt.plot([min_val, max_val], [min_val, max_val], 'r--', linewidth=2)\n",
    "\n",
    "# 格式化坐标轴\n",
    "plt.xlim(min_val, max_val)\n",
    "plt.ylim(min_val, max_val)\n",
    "plt.xlabel('True Values', fontsize=14)\n",
    "plt.ylabel('Predicted Values', fontsize=14)\n",
    "plt.title('True vs Predicted Values', fontsize=16)\n",
    "\n",
    "# 添加统计信息（可选）\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "mse = mean_squared_error(y_true, y_pred)\n",
    "r2 = r2_score(y_true, y_pred)\n",
    "plt.text(0.95, 0.05, f'MSE: {mse:.2f}\\nR²: {r2:.2f}',\n",
    "         transform=plt.gca().transAxes,\n",
    "         bbox=dict(facecolor='white', alpha=0.8),\n",
    "         ha='right', va='bottom', fontsize=12)\n",
    "\n",
    "plt.grid(True, linestyle='--', alpha=0.7)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ac6ee82d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from sklearn.calibration import calibration_curve\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 示例数据\n",
    "# y_true = np.array(['positive', 'negative', 'positive', 'negative'])\n",
    "# y_pred = np.array([0.8, 0.2, 0.9, 0.1])\n",
    "\n",
    "# 明确指定正类标签\n",
    "prob_true, prob_pred = calibration_curve(y_true, y_pred, pos_label='positive', n_bins=10)\n",
    "\n",
    "plt.figure(figsize=(10, 8))\n",
    "plt.plot(prob_pred, prob_true, marker='o', label='Model')\n",
    "plt.xlabel('Predicted probability')\n",
    "plt.ylabel('True probability')\n",
    "plt.title('Calibration Curve')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86b4518f",
   "metadata": {},
   "source": [
    "### 准确率、模型参数、FLOPs 收敛"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cc75abc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from autogluon.tabular import TabularPredictor\n",
    "import pandas as pd\n",
    "\n",
    "# 初始化指标字典\n",
    "metrics = {\n",
    "    'R2': [],\n",
    "    'Params': [],\n",
    "    'FLOPs': [],\n",
    "    'Models': []\n",
    "}\n",
    "\n",
    "# 假设 save_path 是保存模型的地方\n",
    "save_path = 'agModels-predictClass'  # 自定义路径\n",
    "\n",
    "# 创建或加载预测器\n",
    "predictor = TabularPredictor.load(save_path)\n",
    "\n",
    "# 使用 model_names 属性获取所有训练好的模型名称\n",
    "for model_name in predictor.model_names:\n",
    "    try:\n",
    "        # 获取模型对象\n",
    "        model_info = predictor.get_model_info(model_name)\n",
    "        \n",
    "        # 收集 R² 分数\n",
    "        r2_score = model_info['score_val']\n",
    "        metrics['R2'].append(r2_score)\n",
    "        metrics['Models'].append(model_name)\n",
    "        \n",
    "        # 对于非深度学习模型，参数数量和FLOPs通常不适用\n",
    "        # 如果是深度学习模型，这里可以添加额外逻辑来计算这些值\n",
    "        # 下面是一个示例框架，但实际实现取决于您的具体需求\n",
    "        \n",
    "        # 示例：如果模型是PyTorch模型，则可以尝试如下方式计算参数数量和FLOPs\n",
    "        # 注意：这只是一个概念性的例子，AutoGluon 不直接提供对底层模型的访问\n",
    "        if 'pytorch' in model_name.lower():\n",
    "            from torchsummary import summary\n",
    "            \n",
    "            # 假设您有一个方法可以从AutoGluon模型提取出PyTorch模型\n",
    "            pytorch_model = extract_pytorch_model(predictor, model_name)  # 需要实现这个函数\n",
    "            \n",
    "            input_size = (3, 224, 224)  # 根据您的模型调整输入尺寸\n",
    "            summary(pytorch_model, input_size=input_size)\n",
    "            \n",
    "            # 这里您可以提取参数数量和FLOPs，并将其添加到metrics中\n",
    "            # 参数数量和FLOPs的提取依赖于具体的实现细节\n",
    "            # params = ...\n",
    "            # flops = ...\n",
    "            # metrics['Params'].append(params)\n",
    "            # metrics['FLOPs'].append(flops)\n",
    "        else:\n",
    "            metrics['Params'].append(None)\n",
    "            metrics['FLOPs'].append(None)\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"处理模型 {model_name} 时发生错误: {e}\")\n",
    "\n",
    "# 绘制收敛图\n",
    "plt.figure(figsize=(15, 5))\n",
    "\n",
    "# 准备绘图数据\n",
    "df_metrics = pd.DataFrame(metrics)\n",
    "\n",
    "# 绘制 R² 分数收敛图\n",
    "plt.subplot(1, 3, 1)\n",
    "sns.barplot(x='Models', y='R2', data=df_metrics)\n",
    "plt.title('Convergence of Accuracy (R²)')\n",
    "plt.xticks(rotation=45)\n",
    "plt.grid(True)\n",
    "\n",
    "# 如果有参数数量和FLOPs的数据，也可以绘制相应的图表\n",
    "if any(df_metrics['Params']):\n",
    "    plt.subplot(1, 3, 2)\n",
    "    sns.barplot(x='Models', y='Params', data=df_metrics)\n",
    "    plt.title('Convergence of Parameters')\n",
    "    plt.xticks(rotation=45)\n",
    "    plt.grid(True)\n",
    "\n",
    "if any(df_metrics['FLOPs']):\n",
    "    plt.subplot(1, 3, 3)\n",
    "    sns.barplot(x='Models', y='FLOPs', data=df_metrics)\n",
    "    plt.title('Convergence of FLOPs')\n",
    "    plt.xticks(rotation=45)\n",
    "    plt.grid(True)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "313559c7",
   "metadata": {},
   "source": [
    "#### 预测"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef59a32d",
   "metadata": {},
   "outputs": [],
   "source": [
    "predictor.problem_type # 查看预测类型，即回归还是分类\n",
    "predictor.feature_metadata # 数据标签列的数据类型\n",
    "predictor.features() # 特征\n",
    "predictor.get_model_best() # 输出表现最好的模型\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "28b9acbc",
   "metadata": {},
   "source": [
    "### 多参数预测"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0433e210",
   "metadata": {},
   "source": [
    "#### 导入包"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3daa82e0",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.387Z"
    }
   },
   "outputs": [],
   "source": [
    "from autogluon.tabular import TabularDataset, TabularPredictor\n",
    "from autogluon.common.utils.utils import setup_outputdir\n",
    "from autogluon.core.utils.loaders import load_pkl\n",
    "from autogluon.core.utils.savers import save_pkl\n",
    "import os.path\n",
    "\n",
    "class MultilabelPredictor:\n",
    "    \"\"\" Tabular Predictor for predicting multiple columns in table.\n",
    "        Creates multiple TabularPredictor objects which you can also use individually.\n",
    "        You can access the TabularPredictor for a particular label via: `multilabel_predictor.get_predictor(label_i)`\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        labels : List[str]\n",
    "            The ith element of this list is the column (i.e. `label`) predicted by the ith TabularPredictor stored in this object.\n",
    "        path : str, default = None\n",
    "            Path to directory where models and intermediate outputs should be saved.\n",
    "            If unspecified, a time-stamped folder called \"AutogluonModels/ag-[TIMESTAMP]\" will be created in the working directory to store all models.\n",
    "            Note: To call `fit()` twice and save all results of each fit, you must specify different `path` locations or don't specify `path` at all.\n",
    "            Otherwise files from first `fit()` will be overwritten by second `fit()`.\n",
    "            Caution: when predicting many labels, this directory may grow large as it needs to store many TabularPredictors.\n",
    "        problem_types : List[str], default = None\n",
    "            The ith element is the `problem_type` for the ith TabularPredictor stored in this object.\n",
    "        eval_metrics : List[str], default = None\n",
    "            The ith element is the `eval_metric` for the ith TabularPredictor stored in this object.\n",
    "        consider_labels_correlation : bool, default = True\n",
    "            Whether the predictions of multiple labels should account for label correlations or predict each label independently of the others.\n",
    "            If True, the ordering of `labels` may affect resulting accuracy as each label is predicted conditional on the previous labels appearing earlier in this list (i.e. in an auto-regressive fashion).\n",
    "            Set to False if during inference you may want to individually use just the ith TabularPredictor without predicting all the other labels.\n",
    "        kwargs :\n",
    "            Arguments passed into the initialization of each TabularPredictor.\n",
    "\n",
    "    \"\"\"\n",
    "\n",
    "    multi_predictor_file = 'multilabel_predictor.pkl'\n",
    "\n",
    "    def __init__(self, labels, path=None, problem_types=None, eval_metrics=None, consider_labels_correlation=True, **kwargs):\n",
    "        if len(labels) < 2:\n",
    "            raise ValueError(\"MultilabelPredictor is only intended for predicting MULTIPLE labels (columns), use TabularPredictor for predicting one label (column).\")\n",
    "        if (problem_types is not None) and (len(problem_types) != len(labels)):\n",
    "            raise ValueError(\"If provided, `problem_types` must have same length as `labels`\")\n",
    "        if (eval_metrics is not None) and (len(eval_metrics) != len(labels)):\n",
    "            raise ValueError(\"If provided, `eval_metrics` must have same length as `labels`\")\n",
    "        self.path = setup_outputdir(path, warn_if_exist=False)\n",
    "        self.labels = labels\n",
    "        self.consider_labels_correlation = consider_labels_correlation\n",
    "        self.predictors = {}  # key = label, value = TabularPredictor or str path to the TabularPredictor for this label\n",
    "        if eval_metrics is None:\n",
    "            self.eval_metrics = {}\n",
    "        else:\n",
    "            self.eval_metrics = {labels[i] : eval_metrics[i] for i in range(len(labels))}\n",
    "        problem_type = None\n",
    "        eval_metric = None\n",
    "        for i in range(len(labels)):\n",
    "            label = labels[i]\n",
    "            path_i = os.path.join(self.path, \"Predictor_\" + str(label))\n",
    "            if problem_types is not None:\n",
    "                problem_type = problem_types[i]\n",
    "            if eval_metrics is not None:\n",
    "                eval_metric = eval_metrics[i]\n",
    "            self.predictors[label] = TabularPredictor(label=label, problem_type=problem_type, eval_metric=eval_metric, path=path_i, **kwargs)\n",
    "\n",
    "    def fit(self, train_data, tuning_data=None, **kwargs):\n",
    "        \"\"\" Fits a separate TabularPredictor to predict each of the labels.\n",
    "\n",
    "            Parameters\n",
    "            ----------\n",
    "            train_data, tuning_data : str or pd.DataFrame\n",
    "                See documentation for `TabularPredictor.fit()`.\n",
    "            kwargs :\n",
    "                Arguments passed into the `fit()` call for each TabularPredictor.\n",
    "        \"\"\"\n",
    "        if isinstance(train_data, str):\n",
    "            train_data = TabularDataset(train_data)\n",
    "        if tuning_data is not None and isinstance(tuning_data, str):\n",
    "            tuning_data = TabularDataset(tuning_data)\n",
    "        train_data_og = train_data.copy()\n",
    "        if tuning_data is not None:\n",
    "            tuning_data_og = tuning_data.copy()\n",
    "        else:\n",
    "            tuning_data_og = None\n",
    "        save_metrics = len(self.eval_metrics) == 0\n",
    "        for i in range(len(self.labels)):\n",
    "            label = self.labels[i]\n",
    "            predictor = self.get_predictor(label)\n",
    "            if not self.consider_labels_correlation:\n",
    "                labels_to_drop = [l for l in self.labels if l != label]\n",
    "            else:\n",
    "                labels_to_drop = [self.labels[j] for j in range(i+1, len(self.labels))]\n",
    "            train_data = train_data_og.drop(labels_to_drop, axis=1)\n",
    "            if tuning_data is not None:\n",
    "                tuning_data = tuning_data_og.drop(labels_to_drop, axis=1)\n",
    "            print(f\"Fitting TabularPredictor for label: {label} ...\")\n",
    "            predictor.fit(train_data=train_data, tuning_data=tuning_data, **kwargs)\n",
    "            self.predictors[label] = predictor.path\n",
    "            if save_metrics:\n",
    "                self.eval_metrics[label] = predictor.eval_metric\n",
    "        self.save()\n",
    "\n",
    "    def predict(self, data, **kwargs):\n",
    "        \"\"\" Returns DataFrame with label columns containing predictions for each label.\n",
    "\n",
    "            Parameters\n",
    "            ----------\n",
    "            data : str or autogluon.tabular.TabularDataset or pd.DataFrame\n",
    "                Data to make predictions for. If label columns are present in this data, they will be ignored. See documentation for `TabularPredictor.predict()`.\n",
    "            kwargs :\n",
    "                Arguments passed into the predict() call for each TabularPredictor.\n",
    "        \"\"\"\n",
    "        return self._predict(data, as_proba=False, **kwargs)\n",
    "\n",
    "    def predict_proba(self, data, **kwargs):\n",
    "        \"\"\" Returns dict where each key is a label and the corresponding value is the `predict_proba()` output for just that label.\n",
    "\n",
    "            Parameters\n",
    "            ----------\n",
    "            data : str or autogluon.tabular.TabularDataset or pd.DataFrame\n",
    "                Data to make predictions for. See documentation for `TabularPredictor.predict()` and `TabularPredictor.predict_proba()`.\n",
    "            kwargs :\n",
    "                Arguments passed into the `predict_proba()` call for each TabularPredictor (also passed into a `predict()` call).\n",
    "        \"\"\"\n",
    "        return self._predict(data, as_proba=True, **kwargs)\n",
    "\n",
    "    def evaluate(self, data, **kwargs):\n",
    "        \"\"\" Returns dict where each key is a label and the corresponding value is the `evaluate()` output for just that label.\n",
    "\n",
    "            Parameters\n",
    "            ----------\n",
    "            data : str or autogluon.tabular.TabularDataset or pd.DataFrame\n",
    "                Data to evalate predictions of all labels for, must contain all labels as columns. See documentation for `TabularPredictor.evaluate()`.\n",
    "            kwargs :\n",
    "                Arguments passed into the `evaluate()` call for each TabularPredictor (also passed into the `predict()` call).\n",
    "        \"\"\"\n",
    "        data = self._get_data(data)\n",
    "        eval_dict = {}\n",
    "        for label in self.labels:\n",
    "            print(f\"Evaluating TabularPredictor for label: {label} ...\")\n",
    "            predictor = self.get_predictor(label)\n",
    "            eval_dict[label] = predictor.evaluate(data, **kwargs)\n",
    "            if self.consider_labels_correlation:\n",
    "                data[label] = predictor.predict(data, **kwargs)\n",
    "        return eval_dict\n",
    "\n",
    "    def save(self):\n",
    "        \"\"\" Save MultilabelPredictor to disk. \"\"\"\n",
    "        for label in self.labels:\n",
    "            if not isinstance(self.predictors[label], str):\n",
    "                self.predictors[label] = self.predictors[label].path\n",
    "        save_pkl.save(path=os.path.join(self.path, self.multi_predictor_file), object=self)\n",
    "        print(f\"MultilabelPredictor saved to disk. Load with: MultilabelPredictor.load('{self.path}')\")\n",
    "\n",
    "    @classmethod\n",
    "    def load(cls, path):\n",
    "        \"\"\" Load MultilabelPredictor from disk `path` previously specified when creating this MultilabelPredictor. \"\"\"\n",
    "        path = os.path.expanduser(path)\n",
    "        return load_pkl.load(path=os.path.join(path, cls.multi_predictor_file))\n",
    "\n",
    "    def get_predictor(self, label):\n",
    "        \"\"\" Returns TabularPredictor which is used to predict this label. \"\"\"\n",
    "        predictor = self.predictors[label]\n",
    "        if isinstance(predictor, str):\n",
    "            return TabularPredictor.load(path=predictor)\n",
    "        return predictor\n",
    "\n",
    "    def _get_data(self, data):\n",
    "        if isinstance(data, str):\n",
    "            return TabularDataset(data)\n",
    "        return data.copy()\n",
    "\n",
    "    def _predict(self, data, as_proba=False, **kwargs):\n",
    "        data = self._get_data(data)\n",
    "        if as_proba:\n",
    "            predproba_dict = {}\n",
    "        for label in self.labels:\n",
    "            print(f\"Predicting with TabularPredictor for label: {label} ...\")\n",
    "            predictor = self.get_predictor(label)\n",
    "            if as_proba:\n",
    "                predproba_dict[label] = predictor.predict_proba(data, as_multiclass=True, **kwargs)\n",
    "            data[label] = predictor.predict(data, **kwargs)\n",
    "        if not as_proba:\n",
    "            return data[self.labels]\n",
    "        else:\n",
    "            return predproba_dict"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "412d11b8",
   "metadata": {},
   "source": [
    "#### 训练"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4bc34399",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.407Z"
    }
   },
   "outputs": [],
   "source": [
    "train_data = train_data\n",
    "train_data = train_data.sample(n=len(train_data), random_state=42)\n",
    "print('数据总数',len(train_data))\n",
    "train_data.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0be01511",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.417Z"
    }
   },
   "outputs": [],
   "source": [
    "labels =y_name0_autogluon # which columns to predict based on the others\n",
    "eval_metrics = ['mean_absolute_error' for _ in y_name0_autogluon]  # metrics used to evaluate predictions for each label (optional)\n",
    "save_path = 'agModels-predictEducationClass-columns'  # specifies folder to store trained models (optional)\n",
    "# time_limit = 30000  # how many seconds to train the TabularPredictor for each label, set much larger in your applications!\n",
    "problem_types = ['regression' for _ in y_name0_autogluon]# type of each prediction problem (optional)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb19d485",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.426Z"
    }
   },
   "outputs": [],
   "source": [
    "multi_predictor = MultilabelPredictor(labels=labels, problem_types=problem_types, \n",
    "                                      eval_metrics=eval_metrics, path=save_path)\n",
    "\n",
    "multi_predictor.fit(train_data,num_gpus='auto',presets='best_quality')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "88ef9b98",
   "metadata": {},
   "outputs": [],
   "source": [
    "MultilabelPredictor saved to disk. Load with: MultilabelPredictor.load('R:\\Jupyterdemo\\phdcode\\agModels-predictEducationClass-columns')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cc733daf",
   "metadata": {},
   "source": [
    "#### 推理和评估"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "52364bb5",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.437Z"
    }
   },
   "outputs": [],
   "source": [
    "test_data = test_data\n",
    "test_data = test_data.sample(n=len(test_data), random_state=0)\n",
    "test_data_nolab = test_data.drop(columns=labels)  # unnecessary, just to demonstrate we're not cheating here\n",
    "test_data_nolab.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b2aa4bb3",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.457Z"
    }
   },
   "outputs": [],
   "source": [
    "evaluations = multi_predictor.evaluate(test_data)\n",
    "print(evaluations)\n",
    "print(\"Evaluated using metrics:\", multi_predictor.eval_metrics)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b1dec95b",
   "metadata": {},
   "source": [
    "#### 通过模型预测一列"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e7b628e8",
   "metadata": {},
   "outputs": [],
   "source": [
    "display(predictor_class)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "429c336a",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.467Z"
    }
   },
   "outputs": [],
   "source": [
    "label='Bcf3f'\n",
    "predictor_class = multi_predictor.get_predictor(label)\n",
    "predictor_class.leaderboard()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ddb25ee",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.476Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "predictor_class.fit_summary(show_plot=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9a8fedd3",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.485Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "predictor_class.feature_importance(test_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "277a4ee1",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_data_nolab"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f090b11",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# test_data=TabularDataset(test_df)\n",
    "# predictor_class = multi_predictor.predict('Bcf3f')\n",
    "\n",
    "predictions = multi_predictor.predict(test_data_nolab)\n",
    "print(\"Predictions:  \\n\", predictions)\n",
    "\n",
    "# plt.figure(figsize=(10, 6))\n",
    "# plt.plot(test_data['Bcf3f'], label='Actual')\n",
    "# plt.plot(predictor_class, label='Predicted')\n",
    "# plt.legend()\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d74dd52e",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 获取训练日志\n",
    "training_log = multi_predictor.fit_summary()\n",
    "\n",
    "# 假设训练日志中包含每个 epoch 的损失值\n",
    "# 通常训练日志可能包含 'epoch' 和 'loss' 等列\n",
    "train_loss = training_log['loss'].tolist()\n",
    "epochs = training_log['epoch'].tolist()\n",
    "\n",
    "# 创建图表\n",
    "plt.figure(figsize=(10, 6))\n",
    "\n",
    "# 绘制训练损失\n",
    "plt.plot(epochs, train_loss, 'b-o', label='Training Loss')\n",
    "\n",
    "# 添加标题和标签\n",
    "plt.title('Training Loss Over Epochs')\n",
    "plt.xlabel('Epochs')\n",
    "plt.ylabel('Loss')\n",
    "\n",
    "# 添加图例和网格\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "# 显示图表\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91a53441",
   "metadata": {},
   "outputs": [],
   "source": [
    "# predictions\n",
    "plt.figure(figsize=(10, 6))\n",
    "# plt.plot(test_data['Pucf2f'], label='Actual')\n",
    "# plt.plot(predictions['Pucf2f'], label='Predicted')\n",
    "# plt.legend()\n",
    "# plt.show()\n",
    "\n",
    "# 实际值与预测值对比图\n",
    "# 以样本序号作为横坐标\n",
    "x = range(len(test_data))\n",
    "\n",
    "# 绘制实际值\n",
    "plt.plot(x, test_data['Pucf2f'], label='Actual', color='blue')\n",
    "# 绘制预测值\n",
    "plt.plot(x,predictions['Pucf2f'], label='Predicted', color='red', linestyle='--')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79f66492",
   "metadata": {},
   "source": [
    "## 采用NNI(多种搜索）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "342a360f",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-08-25T04:24:12.534423Z",
     "start_time": "2022-08-25T04:24:12.527405Z"
    }
   },
   "source": [
    "### 步骤一：准备模型"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4016b489",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.496Z"
    }
   },
   "outputs": [],
   "source": [
    "{\n",
    "    \"dropout_rate\":{\"_type\":\"uniform\",\"_value\":[0.5, 0.9]},\n",
    "    \"conv_size\":{\"_type\":\"choice\",\"_value\":[2,3,5,7]},\n",
    "    \"hidden_size\":{\"_type\":\"choice\",\"_value\":[124, 512, 1024]},\n",
    "    \"batch_size\": {\"_type\":\"choice\", \"_value\": [1, 4, 8, 16, 32]},\n",
    "    \"learning_rate\":{\"_type\":\"choice\",\"_value\":[0.0001, 0.001, 0.01, 0.1]}\n",
    "}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "acc2f2b7",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2022-10-12T12:02:55.095Z"
    }
   },
   "source": [
    "### 步骤二：定义搜索空间"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3c808061",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.506Z"
    }
   },
   "outputs": [],
   "source": [
    "# {\"_type\": \"choice\", \"_value\": options}\n",
    "# # dropout_rate\":{\"_type\":\"uniform\",\"_value\":[0.5, 0.9]}的结果为0.5或者0.9\n",
    "\n",
    "# {\"_type\": \"uniform\", \"_value\": [low, high]}\n",
    "\n",
    "# # 变量是 low 和 high 之间均匀分布的值。\n",
    "# # 当优化时，此变量值会在两侧区间内。\n",
    "\n",
    "# {\"_type\": \"quniform\", \"_value\": [low, high, q]}\n",
    "# # 从low开始到high结束，步长为q。\n",
    "# # 比如{\"_type\": \"quniform\", \"_value\": [0, 10, 2]}的结果为0,2,4,6,8,10\n",
    "\n",
    "# {\"_type\": \"normal\", \"_value\": [mu, sigma]}\n",
    "# # 变量值为实数，且为正态分布，均值为 mu，标准方差为 sigma。 优化时，此变量不受约束。\n",
    "\n",
    "# {\"_type\": \"randint\", \"_value\": [lower, upper]}\n",
    "# # 从 lower (包含) 到 upper (不包含) 中选择一个随机整数。\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3d7020ff",
   "metadata": {},
   "source": [
    "### 步骤三：配置实验¶"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "425292e2",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.517Z"
    }
   },
   "outputs": [],
   "source": [
    "# NI 使用“实验”来管理超参调优，“实验配置”定义了如何训练模型、如何遍历搜索空间。\n",
    "# 在本教程中我们使用 local 模式的实验，这意味着实验只在本机运行，不使用任何特别的训练平台。\n",
    "from nni.experiment import Experiment\n",
    "experiment = Experiment('local')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d1d8eab0",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.526Z"
    }
   },
   "outputs": [],
   "source": [
    "# 配置 trial¶\n",
    "# 在 NNI 中评估一组超参的过程被称为一个“trial”（试验），上面的模型代码被称为“trial 代码”。\n",
    "experiment.config.trial_command = 'python model.py'\n",
    "experiment.config.trial_code_directory = '.'\n",
    "# 如果 trial_code_directory 是一个相对路径，它被认为相对于当前的工作目录。 \n",
    "# 如果您想在其他路径下运行本文件 main.py ，您可以将代码目录设置为 Path(__file__).parent 。 \n",
    "# (__file__ 只能在 py 文件中使用，不能在 Jupyter Notebook 中使用)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f984171",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.536Z"
    }
   },
   "outputs": [],
   "source": [
    "# 配置搜索空间\n",
    "experiment.config.search_space = search_space"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "59e00bc6",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.545Z"
    }
   },
   "outputs": [],
   "source": [
    "# 配置调优算法\n",
    "# 此处我们使用 TPE 算法 。\n",
    "experiment.config.tuner.name = 'TPE'\n",
    "experiment.config.tuner.class_args['optimize_mode'] = 'maximize'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6a3ca278",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.554Z"
    }
   },
   "outputs": [],
   "source": [
    "# 配置运行多少 trial¶\n",
    "# 本教程中我们总共尝试10组超参，并且每次并行地评估2组超参。\n",
    "experiment.config.max_trial_number = 10\n",
    "experiment.config.trial_concurrency = 2\n",
    "# 您也可以设置 max_experiment_duration = '1h' 来限制运行时间。\n",
    "# 如果 max_trial_number 和 max_experiment_duration 都没有设置，实验将会一直运行，直到您按下 Ctrl-C。\n",
    "# 此处将 max_trial_number 设置为10是为了让教程能够较快地运行结束， \n",
    "# 在实际使用中应该设为更大的数值，TPE 算法在默认参数下需要评估20组超参才会完成初始化。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f93e56a",
   "metadata": {},
   "source": [
    "### 步骤四：运行实验¶"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e57805c0",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.564Z"
    }
   },
   "outputs": [],
   "source": [
    "# 现在实验已经配置完成了，您可以指定一个端口来运行它，教程中我们使用8080端口。\n",
    "\n",
    "# 您可以通过网页控制台查看实验状态： http://localhost:8080.\n",
    "experiment.run(8080)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a5913e2",
   "metadata": {},
   "source": [
    "### 实验结束之后"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5feda71d",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.575Z"
    }
   },
   "outputs": [],
   "source": [
    "# 您只需要等待函数返回就可以正常结束实验，以下内容为可选项。\n",
    "# 如果您使用的是普通 Python 而不是 Jupyter Notebook， \n",
    "# 您可以在代码末尾加上一行 input() 或者 signal.pause() 来避免 Python 解释器自动退出， 这样您就能继续使用网页控制台。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21b29af5",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.584Z"
    }
   },
   "outputs": [],
   "source": [
    "# input('Press enter to quit')\n",
    "experiment.stop()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "83e93359",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.594Z"
    }
   },
   "outputs": [],
   "source": [
    "import nni\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.datasets import load_digits\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.svm import SVC\n",
    "import logging\n",
    "\n",
    "LOG = logging.getLogger('sklearn_classification')\n",
    "\n",
    "\n",
    "def load_data():\n",
    "    '''Load dataset, use 20newsgroups dataset'''\n",
    "    digits = load_digits()\n",
    "    X_train, X_test, y_train, y_test = train_test_split(\n",
    "        digits.data, digits.target, random_state=99, test_size=0.25)\n",
    "\n",
    "    ss = StandardScaler()\n",
    "    X_train = ss.fit_transform(X_train)\n",
    "    X_test = ss.transform(X_test)\n",
    "\n",
    "    return X_train, X_test, y_train, y_test\n",
    "\n",
    "\n",
    "def get_default_parameters():\n",
    "    '''get default parameters'''\n",
    "    params = {\n",
    "        'C': 1.0,\n",
    "        'kernel': 'linear',\n",
    "        'degree': 3,\n",
    "        'gamma': 0.01,\n",
    "        'coef0': 0.01\n",
    "    }\n",
    "    return params\n",
    "\n",
    "\n",
    "def get_model(PARAMS):  # 加载模型\n",
    "    '''Get model according to parameters'''\n",
    "    model = SVC()\n",
    "    model.C = PARAMS.get('C')\n",
    "    model.kernel = PARAMS.get('kernel')\n",
    "    model.degree = PARAMS.get('degree')\n",
    "    model.gamma = PARAMS.get('gamma')\n",
    "    model.coef0 = PARAMS.get('coef0')\n",
    "    return model\n",
    "\n",
    "\n",
    "def run(X_train, X_test, y_train, y_test, model):\n",
    "    '''Train model and predict result'''\n",
    "    model.fit(X_train, y_train)\n",
    "    score = model.score(X_test, y_test)\n",
    "    LOG.debug('score: %s', score)\n",
    "    nni.report_final_result(score)  # 灵魂代码：nni根据这个值判定模型的好坏\n",
    "\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    X_train, X_test, y_train, y_test = load_data()\n",
    "    try:\n",
    "        # get parameters from tuner\n",
    "        RECEIVED_PARAMS = nni.get_next_parameter()  # 这里是使用nni得到参数\n",
    "        LOG.debug(RECEIVED_PARAMS)\n",
    "        PARAMS = get_default_parameters()  # 使用一个默认参数\n",
    "        PARAMS.update(RECEIVED_PARAMS)  # 将默认参数更新为新的参数\n",
    "        LOG.debug(PARAMS)\n",
    "        model = get_model(PARAMS)  # 用这个参数训练模型\n",
    "        run(X_train, X_test, y_train, y_test, model)  # 得到结果\n",
    "    except Exception as exception:\n",
    "        LOG.exception(exception)\n",
    "        raise\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d2043956",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.603Z"
    }
   },
   "outputs": [],
   "source": [
    "nnictl create --config config.yml -p 12388 --debug\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7f6578a0",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.612Z"
    }
   },
   "outputs": [],
   "source": [
    "nnictl create --config config.yml -p 8957"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9fad8b45",
   "metadata": {},
   "source": [
    "## 采用TPOT(基于树的管道优化工具)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b9578fa0",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.623Z"
    }
   },
   "outputs": [],
   "source": [
    "# check tpot version\n",
    "import tpot\n",
    "print('tpot: %s' % tpot.__version__)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d7f36599",
   "metadata": {},
   "source": [
    "### 数据准备-建模"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7659798c",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.634Z"
    }
   },
   "outputs": [],
   "source": [
    "from tpot import TPOTRegressor\n",
    "from sklearn.datasets import load_boston\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "housing = load_boston()\n",
    "X_train, X_test, y_train, y_test = train_test_split(housing.data, housing.target,\n",
    "                                                    train_size=0.75, test_size=0.25, random_state=42)\n",
    "\n",
    "tpot = TPOTRegressor(generations=5, population_size=50, verbosity=2, random_state=42)\n",
    "tpot.fit(X_train, y_train)\n",
    "print(tpot.score(X_test, y_test))\n",
    "tpot.export('tpot_boston_pipeline.py')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7aaf6c9c",
   "metadata": {},
   "source": [
    "### 使用 TPOT-NN 的神经网络分类器"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f1668dea",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.645Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.ensemble import ExtraTreesRegressor\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.pipeline import make_pipeline\n",
    "from sklearn.preprocessing import PolynomialFeatures\n",
    "from tpot.export_utils import set_param_recursive\n",
    "\n",
    "# NOTE: Make sure that the outcome column is labeled 'target' in the data file\n",
    "tpot_data = pd.read_csv('PATH/TO/DATA/FILE', sep='COLUMN_SEPARATOR', dtype=np.float64)\n",
    "features = tpot_data.drop('target', axis=1)\n",
    "training_features, testing_features, training_target, testing_target = \\\n",
    "            train_test_split(features, tpot_data['target'], random_state=42)\n",
    "\n",
    "# Average CV score on the training set was: -10.812040755234403\n",
    "exported_pipeline = make_pipeline(\n",
    "    PolynomialFeatures(degree=2, include_bias=False, interaction_only=False),\n",
    "    ExtraTreesRegressor(bootstrap=False, max_features=0.5, min_samples_leaf=2, min_samples_split=3, n_estimators=100)\n",
    ")\n",
    "# Fix random state for all the steps in exported pipeline\n",
    "set_param_recursive(exported_pipeline.steps, 'random_state', 42)\n",
    "\n",
    "exported_pipeline.fit(training_features, training_target)\n",
    "results = exported_pipeline.predict(testing_features)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "787a3c35",
   "metadata": {},
   "source": [
    "### 使用 TPOT-NN 的神经网络分类器"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cbcc0ec1",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.655Z"
    }
   },
   "outputs": [],
   "source": [
    "from tpot import TPOTClassifier\n",
    "from sklearn.datasets import make_blobs\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "X, y = make_blobs(n_samples=100, centers=2, n_features=3, random_state=42)\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.75, test_size=0.25)\n",
    "\n",
    "clf = TPOTClassifier(config_dict='TPOT NN', template='Selector-Transformer-PytorchLRClassifier',\n",
    "                     verbosity=2, population_size=10, generations=10)\n",
    "clf.fit(X_train, y_train)\n",
    "print(clf.score(X_test, y_test))\n",
    "clf.export('tpot_nn_demo_pipeline.py')\n",
    "# 这个例子有点琐碎，但它应该会导致接近 100% 的分类准确率。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f256228",
   "metadata": {},
   "source": [
    "## Model_Search(Google)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f6ca6bee",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.666Z"
    },
    "code_folding": []
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    " \n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    " \n",
    "# !ls\n",
    " \n",
    "# LICENSE          WORKSPACE        [34mmodel_search[m[m\n",
    "# README.md        default.csv      requirements.txt\n",
    " \n",
    "## 该文件下载自：https://archive.ics.uci.edu/ml/machine-learning-databases/00350/default%20of%20credit%20card%20clients.xls\n",
    "data=data0_auto\n",
    "data=data.rename({'default payment next month':'default'}, axis=1)\n",
    "data.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2b391200",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.675Z"
    }
   },
   "outputs": [],
   "source": [
    "categorical=['SEX','EDUCATION','MARRIAGE']\n",
    "numeric=['PAY_0','PAY_2','PAY_3','PAY_4','PAY_5','PAY_6']\n",
    " \n",
    "data_final=pd.get_dummies(data=data[categorical], columns=['SEX','EDUCATION','MARRIAGE'])\n",
    "data_final.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7f734e61",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.685Z"
    }
   },
   "outputs": [],
   "source": [
    "data_default=pd.concat([data['default'], data_final, data[numeric]],  axis=1)\n",
    "data_default.to_csv('default.csv',sep = ',', index = False, header = None)\n",
    "data_default.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ba7a176",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.694Z"
    }
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    " \n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    " \n",
    "import model_search\n",
    "from model_search import constants\n",
    "from model_search import single_trainer\n",
    "from model_search.data import csv_data \n",
    " \n",
    "%matplotlib inline \n",
    "\n",
    "trainer = single_trainer.SingleTrainer(\n",
    "    data=csv_data.Provider(label_index=0, logits_dimension=2, record_defaults=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], filename=\"default.csv\"),\n",
    "    spec='./model_search/configs/dnn_config.pbtxt')\n",
    " \n",
    "!mkdir tmp\n",
    "!mkdir ./tmp/run_example\n",
    " \n",
    "import sys\n",
    "from absl import app\n",
    " \n",
    "# Addresses `UnrecognizedFlagError: Unknown command line flag 'f'`\n",
    "sys.argv = sys.argv[:1]\n",
    " \n",
    "# `app.run` calls `sys.exit`\n",
    "try:\n",
    "    app.run(lambda argv: None)\n",
    "except:\n",
    "    pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2c224c01",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.704Z"
    }
   },
   "outputs": [],
   "source": [
    "import model_search\n",
    "from model_search import constants\n",
    "from model_search import single_trainer\n",
    "from model_search.data import csv_data\n",
    "\n",
    "trainer = single_trainer.SingleTrainer(\n",
    "    data=csv_data.Provider(\n",
    "        label_index=0,\n",
    "        logits_dimension=2,\n",
    "        record_defaults=[0, 0, 0, 0],\n",
    "        filename=\"model_search/data/testdata/csv_random_data.csv\"),\n",
    "    spec=constants.DEFAULT_DNN)\n",
    "\n",
    "trainer.try_models(\n",
    "    number_models=200,\n",
    "    train_steps=1000,\n",
    "    eval_steps=100,\n",
    "    root_dir=\"/tmp/run_example\",\n",
    "    batch_size=32,\n",
    "    experiment_name=\"example\",\n",
    "    experiment_owner=\"model_search_user\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "81479f31",
   "metadata": {},
   "source": [
    "## 采用H2O（JAVA编程远程使用的）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5bed6cb6",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.714Z"
    }
   },
   "outputs": [],
   "source": [
    "import h2o\n",
    "h2o.init()\n",
    "# h2o.shutdown()第一行主要判读H2O是否被启动；\n",
    "h2o.init(threads = -1, maxmemsize = '4g')\n",
    "import h2o\n",
    "h2o.init()\n",
    "h2o.demo(\"glm\")\n",
    "import h2o\n",
    "h2o.init()\n",
    "\n",
    "datasets = '/Users/zhangpeng/Desktop/h2o/datasets/iris_wheader.csv'\n",
    "data = h2o.import_file(datasets)\n",
    "\n",
    "y = 'class'\n",
    "x = ['sepal_len','sepal_wid','petal_len','petal_wid']\n",
    "train, test = data.split_frame([0.8])\n",
    "\n",
    "m = h2o.estimators.deeplearning.H2ODeepLearningEstimator()\n",
    "m.train(x, y, train)\n",
    "p = m.predict(test)\n",
    "m.confusion_matrix(train)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de236ad2",
   "metadata": {},
   "source": [
    "## 自编机器学习模型"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "33c95f8d",
   "metadata": {},
   "source": [
    "### 一、库依赖与模型分组"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72b91aa8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 01_必要库安装提示（若缺失）\n",
    "try:\n",
    "    import xgboost as xgb\n",
    "    import lightgbm as lgb\n",
    "    import catboost as cb\n",
    "except ImportError:\n",
    "    print(\"警告：未安装XGBoost/LightGBM/CatBoost，相关模型将无法运行！\")\n",
    "    print(\"安装命令：pip install xgboost lightgbm catboost\")\n",
    "\n",
    "# 02_模型分组导入（按类别组织）\n",
    "# 线性回归模型\n",
    "from sklearn.linear_model import (\n",
    "    LinearRegression, Ridge, Lasso, ElasticNet, BayesianRidge\n",
    ")\n",
    "\n",
    "# 非线性回归模型\n",
    "from sklearn.svm import SVR\n",
    "from sklearn.kernel_ridge import KernelRidge\n",
    "from sklearn.neighbors import KNeighborsRegressor\n",
    "from sklearn.nadarseq import NadarayaWatson\n",
    "\n",
    "# 树模型\n",
    "from sklearn.tree import DecisionTreeRegressor\n",
    "from sklearn.ensemble import (\n",
    "    RandomForestRegressor, AdaBoostRegressor, GradientBoostingRegressor\n",
    ")\n",
    "from xgboost import XGBRegressor\n",
    "from lightgbm import LGBMRegressor\n",
    "from catboost import CatBoostRegressor\n",
    "\n",
    "# 神经网络\n",
    "from sklearn.neural_network import MLPRegressor\n",
    "# 注：CNN/RNN需数据为图像/序列格式，此处仅示例MLP，其他需自定义数据格式\n",
    "\n",
    "# 概率与其他模型\n",
    "from sklearn.gaussian_process import GaussianProcessRegressor\n",
    "from sklearn.linear_model import QuantileRegressor, HuberRegressor, RANSACRegressor\n",
    "from sklearn.cross_decomposition import PLSRegression, PCA\n",
    "from sklearn.preprocessing import PolynomialFeatures"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "58dd571f",
   "metadata": {},
   "source": [
    "### 二、配置中心（支持全模型列表）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ee283f8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 03_配置参数（模型开关与参数）\n",
    "class Config:\n",
    "    MODELS_TO_RUN = [  # 可自由勾选运行的模型（按类别分组）\n",
    "        # 线性回归\n",
    "        \"LinearRegression\", \"Ridge\", \"Lasso\", \"ElasticNet\", \"BayesianRidge\",\n",
    "        \n",
    "        # 非线性回归\n",
    "        \"PolynomialRegression\", \"SVR\", \"KernelRidge\", \"KNN\", \"NadarayaWatson\",\n",
    "        \n",
    "        # 树模型\n",
    "        \"DecisionTree\", \"RandomForest\", \"GradientBoosting\", \"AdaBoost\",\n",
    "        \"XGBoost\", \"LightGBM\", \"CatBoost\",\n",
    "        \n",
    "        # 神经网络\n",
    "        \"MLP\",  # \"CNN\", \"RNN\" 需自定义数据加载方式\n",
    "        \n",
    "        # 概率与其他\n",
    "        \"GaussianProcess\", \"QuantileRegression\", \"HuberRegression\", \"PLSRegression\"\n",
    "    ]\n",
    "    \n",
    "    # 通用参数\n",
    "    RANDOM_SEED = 42\n",
    "    TEST_SIZE = 0.2\n",
    "    POLY_DEGREE = 2  # 多项式阶数（仅影响线性模型）\n",
    "    IS_MULTI_FEATURE = True  # 特征类型开关"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0bbc649c",
   "metadata": {},
   "source": [
    "### 04_模型构建函数（根据名称生成流水线）"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5bd0927e",
   "metadata": {},
   "source": [
    "# 04_模型构建函数（根据名称生成流水线）\n",
    "def create_model(model_name: str) -> object:\n",
    "    \"\"\"根据模型名称返回预处理+模型流水线\"\"\"\n",
    "    if model_name in [\"LinearRegression\", \"Ridge\", \"Lasso\", \"ElasticNet\", \"BayesianRidge\"]:\n",
    "        # 线性模型流水线：归一化 + 多项式特征 + 模型\n",
    "        return make_pipeline(\n",
    "            MinMaxScaler(),\n",
    "            PolynomialFeatures(degree=Config.POLY_DEGREE),\n",
    "            {\n",
    "                \"LinearRegression\": LinearRegression(),\n",
    "                \"Ridge\": Ridge(alpha=0.5),\n",
    "                \"Lasso\": Lasso(alpha=0.1),\n",
    "                \"ElasticNet\": ElasticNet(alpha=0.1, l1_ratio=0.5),  # l1_ratio控制弹性网络混合比例\n",
    "                \"BayesianRidge\": BayesianRidge()\n",
    "            }[model_name]\n",
    "        )\n",
    "    \n",
    "    elif model_name == \"PolynomialRegression\":\n",
    "        # 多项式回归本质是线性回归+多项式特征（单独处理）\n",
    "        return make_pipeline(\n",
    "            MinMaxScaler(),\n",
    "            PolynomialFeatures(degree=3),\n",
    "            LinearRegression()\n",
    "        )\n",
    "    \n",
    "    elif model_name in [\"SVR\", \"KernelRidge\"]:\n",
    "        # SVM相关模型流水线：归一化 + 模型（核函数默认rbf）\n",
    "        return make_pipeline(\n",
    "            MinMaxScaler(),\n",
    "            {\n",
    "                \"SVR\": SVR(C=1.0),\n",
    "                \"KernelRidge\": KernelRidge(kernel=\"rbf\")\n",
    "            }[model_name]\n",
    "        )\n",
    "    \n",
    "    elif model_name == \"KNN\":\n",
    "        return make_pipeline(MinMaxScaler(), KNeighborsRegressor(n_neighbors=5))\n",
    "    \n",
    "    elif model_name == \"NadarayaWatson\":\n",
    "        return make_pipeline(MinMaxScaler(), NadarayaWatson(kernel=\"gaussian\"))\n",
    "    \n",
    "    # 树模型（无需多项式特征，仅归一化）\n",
    "    elif model_name in [\"DecisionTree\", \"RandomForest\", \"GradientBoosting\", \"AdaBoost\"]:\n",
    "        return make_pipeline(\n",
    "            MinMaxScaler(),\n",
    "            {\n",
    "                \"DecisionTree\": DecisionTreeRegressor(random_state=Config.RANDOM_SEED),\n",
    "                \"RandomForest\": RandomForestRegressor(n_estimators=100, random_state=Config.RANDOM_SEED),\n",
    "                \"GradientBoosting\": GradientBoostingRegressor(n_estimators=100, random_state=Config.RANDOM_SEED),\n",
    "                \"AdaBoost\": AdaBoostRegressor(n_estimators=50, random_state=Config.RANDOM_SEED)\n",
    "            }[model_name]\n",
    "        )\n",
    "    \n",
    "    # 进阶树模型（需安装对应库）\n",
    "    elif model_name in [\"XGBoost\", \"LightGBM\", \"CatBoost\"]:\n",
    "        return make_pipeline(\n",
    "            MinMaxScaler(),\n",
    "            {\n",
    "                \"XGBoost\": xgb.XGBRegressor(objective=\"reg:squarederror\", n_estimators=100, random_state=Config.RANDOM_SEED),\n",
    "                \"LightGBM\": lgb.LGBMRegressor(n_estimators=100, random_state=Config.RANDOM_SEED),\n",
    "                \"CatBoost\": cb.CatBoostRegressor(iterations=100, random_state=Config.RANDOM_SEED, verbose=0)\n",
    "            }[model_name]\n",
    "        )\n",
    "    \n",
    "    # 神经网络\n",
    "    elif model_name == \"MLP\":\n",
    "        return make_pipeline(\n",
    "            MinMaxScaler(),\n",
    "            MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, random_state=Config.RANDOM_SEED)\n",
    "        )\n",
    "    \n",
    "    # 概率与其他模型\n",
    "    elif model_name == \"GaussianProcess\":\n",
    "        return make_pipeline(MinMaxScaler(), GaussianProcessRegressor())\n",
    "    \n",
    "    elif model_name == \"QuantileRegression\":\n",
    "        return make_pipeline(MinMaxScaler(), QuantileRegressor(quantile=0.5))  # 分位数回归示例\n",
    "    \n",
    "    elif model_name == \"HuberRegression\":\n",
    "        return make_pipeline(MinMaxScaler(), HuberRegressor())\n",
    "    \n",
    "    elif model_name == \"PLSRegression\":\n",
    "        return make_pipeline(MinMaxScaler(), PLSRegression(n_components=5))  # PLS回归示例\n",
    "    \n",
    "    else:\n",
    "        raise ValueError(f\"不支持的模型: {model_name}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9bf23eae",
   "metadata": {},
   "source": [
    "### 四、主运行流程（支持全模型遍历）"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5193e7eb",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 05_主函数（批量运行配置中的模型）\n",
    "def main(df: pd.DataFrame):\n",
    "    x, y = load_data(df)\n",
    "    x_train, x_test, y_train, y_test = split_data(x, y)\n",
    "    \n",
    "    for model_name in Config.MODELS_TO_RUN:\n",
    "        try:\n",
    "            print(f\"\\n===== 运行模型: {model_name} ======\")\n",
    "            pipeline = create_model(model_name)\n",
    "            pipeline.fit(x_train, y_train.ravel())\n",
    "            \n",
    "            # 评估\n",
    "            metrics = evaluate_model(pipeline, x_test, y_test)\n",
    "            print(\"评估指标:\")\n",
    "            for k, v in metrics.items():\n",
    "                print(f\"  {k}: {v:.3f}\")\n",
    "            \n",
    "            # 特征重要性（仅树模型）\n",
    "            if \"Tree\" in model_name or \"Forest\" in model_name or \"Boost\" in model_name:\n",
    "                estimator = pipeline[-1]  # 取最后一个模型对象\n",
    "                if hasattr(estimator, \"feature_importances_\"):\n",
    "                    plot_feature_importance(estimator, feature_names=Config.MULTI_FEATURES if Config.IS_MULTI_FEATURE else [Config.SINGLE_FEATURE])\n",
    "            \n",
    "            # 一元特征可视化（仅线性模型）\n",
    "            if not Config.IS_MULTI_FEATURE and \"Linear\" in model_name:\n",
    "                y_pred = pipeline.predict(x_test)\n",
    "                plot_prediction(x_test, y_test, y_pred, feature_name=Config.SINGLE_FEATURE)\n",
    "                \n",
    "        except Exception as e:\n",
    "            print(f\"模型 {model_name} 运行失败: {str(e)}\")\n",
    "            continue"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9bfafe40",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 假设df为已加载的DataFrame（含特征和目标变量）\n",
    "if __name__ == \"__main__\":\n",
    "    import pandas as pd\n",
    "    df = pd.read_csv(\"your_data.csv\")  # 替换为实际数据路径\n",
    "    main(df)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "07e05794",
   "metadata": {},
   "source": [
    "# 符号回归"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "04cffbff",
   "metadata": {},
   "source": [
    "## gplearn框架"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ed4c681c",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-09-18T07:28:46.272588Z",
     "start_time": "2023-09-18T07:28:46.224824Z"
    }
   },
   "outputs": [],
   "source": [
    "from gplearn.genetic import SymbolicRegressor\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.tree import DecisionTreeRegressor\n",
    "from sklearn.utils.random import check_random_state\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import graphviz\n",
    "import sympy "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "65df8710",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from gplearn.genetic import SymbolicRegressor\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import r2_score, mean_absolute_error\n",
    "from sympy import symbols, simplify, Eq, Add, Mul, Pow\n",
    "import warnings\n",
    "\n",
    "# ================== 数据准备 ==================\n",
    "# 假设 df 已加载并预处理\n",
    "x_core = ['H', 'B']               # 核心自变量\n",
    "x_adjust = ['yfss', 'Imperfectfactor', 'sfricn', 'pbol', 'F']  # 调整参数\n",
    "x_category = ['n']                 # 分类参数\n",
    "target = 'Bcf12f'                  # 目标参数\n",
    "\n",
    "# 数据清洗\n",
    "df_clean = df.dropna(subset=x_core + [target] + x_category)\n",
    "\n",
    "# 分类参数预处理（示例：n取值为1-5）\n",
    "df_clean['n'] = df_clean['n'].astype(int).clip(1, 5)  # 确保n为整数且在1-5之间\n",
    "\n",
    "# 分割数据集\n",
    "train_df, test_df = train_test_split(df_clean, test_size=0.3, random_state=42)\n",
    "\n",
    "# ================== 阶段1：核心模型（H和B） ==================\n",
    "def train_core_model(data):\n",
    "    \"\"\"训练仅使用H和B的核心模型\"\"\"\n",
    "    X_core = data[x_core]\n",
    "    y = data[target]\n",
    "    \n",
    "    # 约束函数集以反映工程关系（如H/B、H*B等）\n",
    "    function_set_core = ['add', 'sub', 'mul', 'div', 'sqrt', 'square']\n",
    "    \n",
    "    # 配置符号回归（强化物理约束）\n",
    "    est_core = SymbolicRegressor(\n",
    "        population_size=5000,\n",
    "        generations=50,\n",
    "        function_set=function_set_core,\n",
    "        parsimony_coefficient=0.001,  # 允许稍复杂的物理公式\n",
    "        feature_names=x_core,\n",
    "        stopping_criteria=0.01,       # 早停阈值\n",
    "        random_state=42,\n",
    "        metric='neg_mean_absolute_error',\n",
    "        n_jobs=-1\n",
    "    )\n",
    "    \n",
    "    est_core.fit(X_core, y)\n",
    "    return est_core\n",
    "\n",
    "# 分n类别训练核心模型（每个n单独建模）\n",
    "core_models = {}\n",
    "for n_val in range(1, 6):\n",
    "    train_subset = train_df[train_df['n'] == n_val]\n",
    "    if len(train_subset) > 10:  # 确保足够样本量\n",
    "        core_models[n_val] = train_core_model(train_subset)\n",
    "        print(f\"=== n={n_val} 核心模型公式 ===\")\n",
    "        print(core_models[n_val]._program)\n",
    "\n",
    "# ================== 阶段2：全局修正模型 ==================\n",
    "# 生成核心模型的预测值作为基础\n",
    "def get_core_prediction(X):\n",
    "    \"\"\"根据n值选择对应的核心模型预测\"\"\"\n",
    "    y_pred = np.zeros(len(X))\n",
    "    for n_val in core_models.keys():\n",
    "        mask = X['n'] == n_val\n",
    "        if mask.any():\n",
    "            X_subset = X.loc[mask, x_core]\n",
    "            y_pred[mask] = core_models[n_val].predict(X_subset)\n",
    "    return y_pred\n",
    "\n",
    "# 计算残差（目标值 - 核心模型预测）\n",
    "train_df['core_pred'] = get_core_prediction(train_df)\n",
    "train_df['residual'] = train_df[target] - train_df['core_pred']\n",
    "\n",
    "# 训练残差修正模型（使用调整参数）\n",
    "est_adjust = SymbolicRegressor(\n",
    "    population_size=2000,\n",
    "    generations=30,\n",
    "    function_set=['add', 'sub', 'mul', 'div', 'neg'],  # 简单修正项\n",
    "    feature_names=x_adjust,\n",
    "    parsimony_coefficient=0.1,  # 强制简化\n",
    "    random_state=42\n",
    ")\n",
    "\n",
    "est_adjust.fit(train_df[x_adjust], train_df['residual'])\n",
    "\n",
    "# ================== 完整预测公式 ==================\n",
    "def predict_Bcf12f(X):\n",
    "    \"\"\"分层预测：核心模型 + 修正项\"\"\"\n",
    "    y_core = get_core_prediction(X)\n",
    "    y_adjust = est_adjust.predict(X[x_adjust])\n",
    "    return y_core + y_adjust\n",
    "\n",
    "# ================== 物理验证 ==================\n",
    "def check_dimensional_homogeneity(program_str, H_dim, B_dim, target_dim):\n",
    "    \"\"\"\n",
    "    检查量纲齐次性（示例假设H和B为长度量纲，目标为无量纲）\n",
    "    需根据实际物理量纲定义\n",
    "    \"\"\"\n",
    "    H, B = symbols('H B')\n",
    "    expr = simplify(program_str)\n",
    "    \n",
    "    # 计算表达式的量纲\n",
    "    expr_dim = expr.subs({H: H_dim, B: B_dim})\n",
    "    \n",
    "    # 检查是否与目标量纲一致\n",
    "    return expr_dim == target_dim\n",
    "\n",
    "# 示例：假设H和B为长度[m]，目标无量纲\n",
    "for n_val, model in core_models.items():\n",
    "    program_str = str(model._program).replace('sub', '-').replace('mul', '*').replace('div', '/')\n",
    "    is_valid = check_dimensional_homogeneity(program_str, H_dim='L', B_dim='L', target_dim=1)\n",
    "    print(f\"n={n_val} 核心模型量纲{'有效' if is_valid else '无效'}\")\n",
    "\n",
    "# ================== 评估 ==================\n",
    "# 测试集预测\n",
    "test_df['pred'] = predict_Bcf12f(test_df)\n",
    "\n",
    "# 性能指标\n",
    "r2 = r2_score(test_df[target], test_df['pred'])\n",
    "mae = mean_absolute_error(test_df[target], test_df['pred'])\n",
    "print(f\"\\n=== 最终模型性能 ===\")\n",
    "print(f\"R²: {r2:.3f}\")\n",
    "print(f\"MAE: {mae:.3f}\")\n",
    "\n",
    "# 可视化核心公式与修正项贡献\n",
    "plt.figure(figsize=(10, 4))\n",
    "plt.subplot(121)\n",
    "plt.scatter(test_df['core_pred'], test_df[target], alpha=0.6)\n",
    "plt.plot([0, test_df[target].max()], [0, test_df[target].max()], 'r--')\n",
    "plt.xlabel('核心模型预测值')\n",
    "plt.ylabel('真实值')\n",
    "\n",
    "plt.subplot(122)\n",
    "plt.hist(test_df['pred'] - test_df[target], bins=30)\n",
    "plt.xlabel('修正项贡献')\n",
    "plt.ylabel('频率')\n",
    "plt.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "88b7793f",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6278bda7",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.753Z"
    }
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from sklearn.model_selection import train_test_split\n",
    "from autogluon.tabular import TabularDataset, TabularPredictor\n",
    "\n",
    "def process_data(data, x_columns, y_columns):\n",
    "    \"\"\"\n",
    "    处理数据的函数，包括空值填充和筛选行操作。\n",
    "    :param data: 原始DataFrame\n",
    "    :param x_columns: 自变量列名列表\n",
    "    :param y_columns: 因变量列名列表\n",
    "    :return: 处理后的DataFrame\n",
    "    \"\"\"\n",
    "    # 当F列为空时填充为0\n",
    "    if 'F' in data.columns:\n",
    "        data['F'] = data['F'].fillna(0)\n",
    "    \n",
    "    data[y_columns] = data[y_columns].fillna(0)\n",
    "    data = data[x_columns + y_columns]\n",
    "    condition = (data[y_columns] != 0).any(axis=1)\n",
    "    data = data[condition]\n",
    "    return data\n",
    "\n",
    "# 假设 dfdelpara 已经定义\n",
    "df = dfdelpara.copy()\n",
    "df = df[~((df['Pucf1f'] < 1) & (df['Pucf2f'] < 1))]\n",
    "\n",
    "x_name_autogluon = ['H', 'B', 'T1', 'T2', 'L', 'n', 'yfss', 'Imperfectfactor', 'type',\n",
    "                    'cf1f', 'cf2f', 'cf3f','meshsz','sfricn', 'pbol', 'F','Bcf12f']\n",
    "y_name_autogluon = ['Pucf12f']\n",
    "\n",
    "# 使用更新后的process_data函数\n",
    "data_autogluon = process_data(df, x_name_autogluon, y_name_autogluon)\n",
    "\n",
    "train_df, test_df = train_test_split(data_autogluon, test_size=0.3, random_state=42)\n",
    "val_df, test_df = train_test_split(test_df, test_size=0.5, random_state=42)\n",
    "\n",
    "# 分离特征和目标变量\n",
    "X_train = train_df[x_name_autogluon]\n",
    "y_train = train_df[y_name_autogluon]\n",
    "X_val = val_df[x_name_autogluon]\n",
    "y_val = val_df[y_name_autogluon]\n",
    "X_test = test_df[x_name_autogluon]\n",
    "y_test = test_df[y_name_autogluon]\n",
    "\n",
    "print(f\"训总数据大小: {len(df)}\")\n",
    "print(f\"训练集特征大小: {len(X_train)}\")\n",
    "print(f\"训练集特征\")\n",
    "display(X_train)\n",
    "print(f\"训练集目标大小: {len(y_train)}\")\n",
    "print(f\"训练集目标\")\n",
    "display(y_train)\n",
    "print(f\"验证集特征大小: {len(X_val)}\")\n",
    "print(f\"验证集目标大小: {len(y_val)}\")\n",
    "print(f\"测试集特征大小: {len(X_test)}\")\n",
    "print(f\"测试集目标大小: {len(y_test)}\")\n",
    "\n",
    "train_data = TabularDataset(train_df)\n",
    "val_data = TabularDataset(val_df)\n",
    "test_data = TabularDataset(test_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "000a76f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# 假设 X_train 是 DataFrame\n",
    "print(X_train.isnull().sum())\n",
    "\n",
    "# 假设 X_train 是一个 DataFrame\n",
    "X_train_cleaned = X_train.dropna(subset=['Bcf12f'])\n",
    "y_train_cleaned = y_train[X_train.index.isin(X_train_cleaned.index)]\n",
    "X_train=X_train_cleaned\n",
    "y_train=y_train_cleaned"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e627337d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 分离特征和目标变量\n",
    "# X_train = train_df[x_name_autogluon]\n",
    "# y_train = train_df[y_name_autogluon]\n",
    "# X_val = val_df[x_name_autogluon]\n",
    "# y_val = val_df[y_name_autogluon]\n",
    "X_test_cleaned = X_test.dropna(subset=['Bcf12f'])\n",
    "y_test_cleaned = y_test[X_test.index.isin(X_test_cleaned.index)]\n",
    "X_test = X_test_cleaned\n",
    "y_test = y_test_cleaned\n",
    "print(X_test.isnull().sum())\n",
    "print(y_test.isnull().sum())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd4846f1",
   "metadata": {},
   "source": [
    "### 拟合采用的计算方法"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ee0d4e82",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.763Z"
    }
   },
   "outputs": [],
   "source": [
    "function_set=['add','sub','mul','div','sqrt','neg','inv']\n",
    "# function_set=['add','sub','mul','div','sqrt','log','abs','neg','inv','max','min','sin' ,'cos','tan']\n",
    "  #function_set = ('add', 'sub', 'mul', 'div', gp_tanh, 'sqrt', 'log', 'abs', 'neg', 'inv','max', 'min', 'tan', 'cos', 'sin'),"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e2ecf95b",
   "metadata": {},
   "source": [
    "### 拟合"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e255c49f",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.773Z"
    }
   },
   "outputs": [],
   "source": [
    "# est_gp_optimized = SymbolicRegressor(\n",
    "#     population_size=15000,\n",
    "#     tournament_size=1000,\n",
    "#     generations=30,\n",
    "#     stopping_criteria=0.01,  # 允许提前停止\n",
    "#     p_crossover=0.7,\n",
    "#     p_subtree_mutation=0.15,  # 增加变异探索\n",
    "#     p_point_mutation=0.05,\n",
    "#     function_set = function_set,  # 扩展函数集\n",
    "#     parsimony_coefficient=0.03,  # 强制简化公式\n",
    "#     feature_names=x_name_autogluon,  # 包含衍生特征\n",
    "#     metric='mean absolute error',\n",
    "#     random_state=42\n",
    "# )\n",
    "est_gp = SymbolicRegressor(\n",
    "    # 种群与进化参数\n",
    "    population_size=30000,          # 增大种群规模以探索更多可能解\n",
    "    generations=100,                # 增加进化代数至100代\n",
    "    tournament_size=500,            # 减小锦标赛规模以提高选择压力（更严格筛选）\n",
    "    stopping_criteria=0.0,          # 禁用提前停止，强制跑满所有代际\n",
    "    \n",
    "    # 遗传操作概率\n",
    "    p_crossover=0.5,                # 适度降低交叉概率，平衡探索与利用\n",
    "    p_subtree_mutation=0.3,         # 大幅增加子树变异概率\n",
    "    p_hoist_mutation=0.1,           # 提升Hoist变异概率（修剪冗余结构）\n",
    "    p_point_mutation=0.1,           # 提高点变异概率以增强局部搜索\n",
    "    \n",
    "    # 复杂度控制\n",
    "    parsimony_coefficient=0.001,    # 降低复杂度惩罚，允许复杂公式\n",
    "    max_samples=1.0,                # 使用全部样本训练\n",
    "    \n",
    "    # 函数与特征配置\n",
    "    function_set=function_set,\n",
    "    feature_names=x_name_autogluon,  # 使用增强后的特征（见下文）\n",
    "    \n",
    "    # 训练策略\n",
    "    warm_start=True,                # 启用热启动以便手动干预\n",
    "    n_jobs=-1,                      # 使用全部CPU核心\n",
    "    verbose=2,                      # 输出详细日志\n",
    "    random_state=42,\n",
    "    metric='mean absolute error'    # 或使用 'mse' 以匹配最终评估指标\n",
    ")\n",
    "est_gp.fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eef0382e",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.785Z"
    }
   },
   "outputs": [],
   "source": [
    "n=850\n",
    "\n",
    "class TimeoutException(Exception):\n",
    "    pass\n",
    "\n",
    "def timeout_handler(signum, frame):\n",
    "    raise TimeoutException\n",
    "\n",
    "signal.signal(signal.SIGALRM, timeout_handler)\n",
    "\n",
    "\n",
    "signal.alarm(n)   # seconds  \n",
    "try:\n",
    "    est_gp.fit(train, y)\n",
    "\n",
    "except TimeoutException:\n",
    "    #with open('gp_model.pkl', 'wb') as f: # uncomment to save model\n",
    "        #pickle.dump(est_gp, f)\n",
    "    print('function terminated')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "76448b63",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.795Z"
    }
   },
   "outputs": [],
   "source": [
    "print(\"This model was pretrained for {} generations\".format(est_gp.run_details_['generation'][-1]))\n",
    "est_gp.set_params(generations=est_gp.run_details_['generation'][-1]+1) #train for 1 more generation\n",
    "est_gp.fit(train, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5e7ac4b7",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.804Z"
    }
   },
   "outputs": [],
   "source": [
    "print(\"This model was pretrained for {} generations\".format(est_gp.run_details_['generation'][-1]))\n",
    "est_gp.set_params(generations=est_gp.run_details_['generation'][-1]+1) #train for 1 more generation\n",
    "est_gp.fit(train, y)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e82eb53e",
   "metadata": {},
   "source": [
    "### 将公式转化为可视形式"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a770f2f3",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.814Z"
    }
   },
   "outputs": [],
   "source": [
    "from sympy import sympify\n",
    "\n",
    "# 假设 est_gp 是你训练好的 SymbolicRegressor 模型\n",
    "# 获取最优解的字符串表达式\n",
    "optimal_program_str = str(est_gp._program)\n",
    "\n",
    "# 打印原始字符串表达式查看\n",
    "print('最优解字符串表达式:\\n', optimal_program_str)\n",
    "\n",
    "# 自定义 locals 字典，用于 sympy.sympify 转换\n",
    "converter = {\n",
    "    'add': lambda x, y: x + y,\n",
    "    'sub': lambda x, y: x - y,\n",
    "    'mul': lambda x, y: x*y,\n",
    "    'div': lambda x, y: x/y,\n",
    "    'sqrt': lambda x: x**0.5,\n",
    "    'log': lambda x: sympify('log')(x),\n",
    "    'abs': lambda x: abs(x),\n",
    "    'neg': lambda x: -x,\n",
    "    'inv': lambda x: 1/x,\n",
    "    'max': lambda x, y: max(x, y),\n",
    "    'min': lambda x, y: min(x, y),\n",
    "    'sin': lambda x: sympify('sin')(x),\n",
    "    'cos': lambda x: sympify('cos')(x),\n",
    "    'pow': lambda x, y: x**y,\n",
    "}\n",
    "\n",
    "# 使用 sympify 将字符串表达式转换为 SymPy 表达式\n",
    "try:\n",
    "    sympy_expr = sympify(optimal_program_str, locals=converter)\n",
    "    print('SymPy 表达式:\\n', sympy_expr)\n",
    "except Exception as e:\n",
    "    print(\"转换过程中出现错误:\", e)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "614f50ac",
   "metadata": {},
   "source": [
    "### 公式树形图"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b214ae0e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "os.environ[\"PATH\"] += os.pathsep + 'C:/Program Files/Graphviz-12.2.1-win64/bin'  # 替换为实际安装路径"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5da8a14",
   "metadata": {},
   "outputs": [],
   "source": [
    "pip install graphviz"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5217677",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "from graphviz import Source\n",
    "dot_data = est_gp._program.export_graphviz()\n",
    "graph = Source(dot_data)\n",
    "graph"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ddb548d5",
   "metadata": {},
   "source": [
    "### 预测"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "24ac7b04",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(X_train.isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b957d44",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.844Z"
    }
   },
   "outputs": [],
   "source": [
    "import time\n",
    "import numpy as np\n",
    "from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error\n",
    "\n",
    "def evaluate_model(model, X_test, y_test):\n",
    "    \"\"\"\n",
    "    综合评估模型性能，包含时间测量和多指标输出\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # 计时（更高精度，重复多次减少波动）\n",
    "        n_runs = 5  # 重复预测次数\n",
    "        predict_times = []\n",
    "        for _ in range(n_runs):\n",
    "            t_start = time.perf_counter()  # 使用高精度计时器\n",
    "            y_pred = model.predict(X_test)\n",
    "            t_end = time.perf_counter()\n",
    "            predict_times.append(t_end - t_start)\n",
    "        \n",
    "        avg_time = np.mean(predict_times)\n",
    "        std_time = np.std(predict_times)\n",
    "        print(f'预测时间: {avg_time:.4f} ± {std_time:.4f} 秒 (n={n_runs})')\n",
    "        \n",
    "        # 计算多指标\n",
    "        r2 = r2_score(y_test, y_pred)\n",
    "        mae = mean_absolute_error(y_test, y_pred)\n",
    "        mse = mean_squared_error(y_test, y_pred)\n",
    "        \n",
    "#         # 物理合理性检查（示例：稳定系数应在[0,1]区间）\n",
    "#         if np.any(y_pred < 0) or np.any(y_pred > 1.0):\n",
    "#             print(\"警告：预测值超出合理范围！\")\n",
    "        \n",
    "        return {\n",
    "            'R2': r2,\n",
    "            'MAE': mae,\n",
    "            'MSE': mse,\n",
    "            '预测值': y_pred\n",
    "        }\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"评估失败: {str(e)}\")\n",
    "        return None\n",
    "\n",
    "# 执行评估\n",
    "metrics = evaluate_model(est_gp, X_test, y_test)\n",
    "if metrics:\n",
    "    print(\"=== 符号回归性能 ===\")\n",
    "    print(f\"R²: {metrics['R2']:.4f}\")\n",
    "    print(f\"MAE: {metrics['MAE']:.4f}\")\n",
    "    print(f\"MSE: {metrics['MSE']:.4f}\")\n",
    "\n",
    "    # 对比基准模型（如线性回归）\n",
    "    from sklearn.linear_model import LinearRegression\n",
    "    lin_reg = LinearRegression().fit(X_train, y_train)\n",
    "    metrics_lin = evaluate_model(lin_reg, X_test, y_test)\n",
    "    if metrics_lin:\n",
    "        print(\"\\n=== 线性回归对比 ===\")\n",
    "        print(f\"R²: {metrics_lin['R2']:.4f} (Δ={metrics['R2'] - metrics_lin['R2']:.2f})\")\n",
    "        print(f\"MAE: {metrics_lin['MAE']:.4f} (Δ={metrics['MAE'] - metrics_lin['MAE']:.2f})\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "811d3678",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.853Z"
    }
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics import mean_absolute_error\n",
    "\n",
    "y = y_test.copy()\n",
    "# 对y进行排序（如果需要）\n",
    "y = y.sort_index()\n",
    "\n",
    "# plt.figure(figsize=(20, 30))\n",
    "# 第一个子图：LightGBM vs 实际值\n",
    "# plt.subplot(5, 1, 1)\n",
    "plt.plot(y, color='g', label='y_train')\n",
    "plt.plot(y_gpl, color='b', label='lgb')\n",
    "plt.legend(loc=(0.7, 0.8))\n",
    "plt.ylim((0,17))\n",
    "# plt.title('MAE: {:.2f}'.format(mean_absolute_error(y, prelgb1['TTF'].values)))\n",
    "plt.xticks([])\n",
    "plt.show()\n",
    "\n",
    "# # 第二个子图：GPlearn vs 实际值\n",
    "# plt.subplot(5, 1, 2)\n",
    "# plt.plot(y, color='g', label='y_train')\n",
    "# plt.plot(y_gp, color='b', label='Gplearn')\n",
    "# plt.legend(loc=(0.7, 0.8))\n",
    "# plt.ylim((0,17))\n",
    "# plt.title('MAE: {:.2f}'.format(mean_absolute_error(y, y_gp)))\n",
    "# plt.xticks([])\n",
    "\n",
    "# # 第三个子图：XGBoost vs 实际值\n",
    "# plt.subplot(5, 1, 3)\n",
    "# plt.plot(y, color='g', label='y_train')\n",
    "# plt.plot(prexgb01['TTF'].values, color='b', label='xgb')\n",
    "# plt.legend(loc=(0.7, 0.8))\n",
    "# plt.title('MAE: {:.2f}'.format(mean_absolute_error(y, prexgb01['TTF'].values)))\n",
    "# plt.ylim((0,17))\n",
    "# plt.xticks([])\n",
    "\n",
    "# # 第四个子图：LightGBM + GPlearn 平均值 vs 实际值\n",
    "# plt.subplot(5, 1, 4)\n",
    "# combined_pred_lgb_gp = (prelgb1['TTF'].values + y_gp) / 2\n",
    "# plt.plot(y, color='g', label='y_train')\n",
    "# plt.plot(combined_pred_lgb_gp, color='b', label='lgb+gp')\n",
    "# plt.legend(loc=(0.7, 0.8))\n",
    "# plt.title('MAE: {:.2f}'.format(mean_absolute_error(y, combined_pred_lgb_gp)))\n",
    "# plt.ylim((0,17))\n",
    "# plt.xticks([])\n",
    "\n",
    "# # 第五个子图：LightGBM + GPlearn + XGBoost 平均值 vs 实际值\n",
    "# plt.subplot(5, 1, 5)\n",
    "# combined_pred_all = (prelgb1['TTF'].values + y_gp + prexgb01['TTF'].values) / 3\n",
    "# plt.plot(y, color='g', label='y_train')\n",
    "# plt.plot(combined_pred_all, color='b', label='lgb+gp+xgb')\n",
    "# plt.legend(loc=(0.7, 0.8))\n",
    "# plt.title('MAE: {:.2f}'.format(mean_absolute_error(y, combined_pred_all)))\n",
    "# plt.ylim((0,17))\n",
    "# plt.suptitle('Predictions vs Actual');\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "af13c746",
   "metadata": {},
   "source": [
    "## PySR框架"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4d9e530d",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.864Z"
    }
   },
   "outputs": [],
   "source": [
    "from julia import Julia\n",
    "\n",
    "julia = Julia(compiled_modules=False)\n",
    "from julia import Main\n",
    "from julia.tools import redirect_output_streams\n",
    "\n",
    "redirect_output_streams()\n",
    "import numpy as np\n",
    "import pysr\n",
    "pysr.install()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4a70528",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.874Z"
    }
   },
   "outputs": [],
   "source": [
    "import sympy\n",
    "import numpy as np\n",
    "from matplotlib import pyplot as plt\n",
    "from pysr import PySRRegressor\n",
    "import torch\n",
    "from torch import nn, optim\n",
    "from torch.nn import functional as F\n",
    "from torch.utils.data import DataLoader, TensorDataset\n",
    "from sklearn.model_selection import train_test_split\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8c863732",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.884Z"
    }
   },
   "outputs": [],
   "source": [
    "# Dataset\n",
    "np.random.seed(0)\n",
    "X = 2 * np.random.randn(100, 5)\n",
    "y = 2.5382 * np.cos(X[:, 3]) + X[:, 0] ** 2 - 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "29fe24e3",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.894Z"
    }
   },
   "outputs": [],
   "source": [
    "\n",
    "default_pysr_params = dict(\n",
    "    populations=30,\n",
    "    procs=4,\n",
    "    model_selection=\"best\",\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "78ae423f",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.905Z"
    }
   },
   "outputs": [],
   "source": [
    "# Learn equations\n",
    "model = PySRRegressor(\n",
    "    niterations=30,\n",
    "    binary_operators=[\"plus\", \"mult\"],\n",
    "    unary_operators=[\"cos\", \"exp\", \"sin\"],\n",
    "    **default_pysr_params\n",
    ")\n",
    "\n",
    "model.fit(X, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f13b9f5",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.920Z"
    }
   },
   "outputs": [],
   "source": [
    "# 打印模型\n",
    "model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9d804a4d",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.930Z"
    }
   },
   "outputs": [],
   "source": [
    "# 最佳模型展示\n",
    "model.sympy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0e42146b",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.940Z"
    }
   },
   "outputs": [],
   "source": [
    "# 第二个模型展示\n",
    "model.sympy(2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d2f283f2",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.949Z"
    }
   },
   "outputs": [],
   "source": [
    "#输出为LaTeX格式\n",
    "model.latex()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "145ed0dc",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.958Z"
    }
   },
   "outputs": [],
   "source": [
    "# 最佳模型和第二个模型对于预测值的MSE均方误差\n",
    "ypredict = model.predict(X)\n",
    "ypredict_simpler = model.predict(X, 2)\n",
    "\n",
    "print(\"Default selection MSE:\", np.power(ypredict - y, 2).mean())\n",
    "print(\"Manual selection MSE for index 2:\", np.power(ypredict_simpler - y, 2).mean())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4fd7e31",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.967Z"
    }
   },
   "outputs": [],
   "source": [
    "\n",
    "np.random.seed(0)\n",
    "N = 3000\n",
    "upper_sigma = 5\n",
    "X = 2 * np.random.rand(N, 5)\n",
    "sigma = np.random.rand(N) * (5 - 0.1) + 0.1\n",
    "eps = sigma * np.random.randn(N)\n",
    "y = 5 * np.cos(3.5 * X[:, 0]) - 1.3 + eps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9087378a",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.976Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.scatter(X[:, 0], y, alpha=0.2)\n",
    "plt.xlabel(\"$x_0$\")\n",
    "plt.ylabel(\"$y$\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0aa54950",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.986Z"
    }
   },
   "outputs": [],
   "source": [
    "weights = 1 / sigma ** 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bcb290e4",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:04.995Z"
    }
   },
   "outputs": [],
   "source": [
    "weights[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ae25d487",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:05.004Z"
    }
   },
   "outputs": [],
   "source": [
    "model = PySRRegressor(\n",
    "    loss=\"myloss(x, y, w) = w * abs(x - y)\",  # Custom loss function with weights.\n",
    "    niterations=20,\n",
    "    populations=20,  # Use more populations\n",
    "    binary_operators=[\"plus\", \"mult\"],\n",
    "    unary_operators=[\"cos\"],\n",
    ")\n",
    "model.fit(X, y, weights=weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4d8d07d",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:05.014Z"
    }
   },
   "outputs": [],
   "source": [
    "model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66d684df",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:05.023Z"
    }
   },
   "outputs": [],
   "source": [
    "best_idx = model.equations_.query(\n",
    "    f\"loss < {2 * model.equations_.loss.min()}\"\n",
    ").score.idxmax()\n",
    "model.sympy(best_idx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70ba0dcc",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:05.032Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.scatter(X[:, 0], y, alpha=0.1)\n",
    "y_prediction = model.predict(X, index=best_idx)\n",
    "plt.scatter(X[:, 0], y_prediction)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42424824",
   "metadata": {
    "ExecuteTime": {
     "start_time": "2023-07-04T14:49:05.042Z"
    }
   },
   "outputs": [],
   "source": [
    "###### np.random.seed(0)\n",
    "N = 100000\n",
    "Nt = 100\n",
    "X = 6 * np.random.rand(N, Nt, 5) - 3\n",
    "y_i = X[..., 0] ** 2 + 6 * np.cos(2 * X[..., 2])\n",
    "y = np.sum(y_i, axis=1) / y_i.shape[1]\n",
    "z = y**2\n",
    "X.shape, y.shape\n",
    "hidden = 128\n",
    "total_steps = 50000\n",
    "\n",
    "\n",
    "def mlp(size_in, size_out, act=nn.ReLU):\n",
    "    return nn.Sequential(\n",
    "        nn.Linear(size_in, hidden),\n",
    "        act(),\n",
    "        nn.Linear(hidden, hidden),\n",
    "        act(),\n",
    "        nn.Linear(hidden, hidden),\n",
    "        act(),\n",
    "        nn.Linear(hidden, size_out),\n",
    "    )\n",
    "\n",
    "\n",
    "class SumNet(pl.LightningModule):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "\n",
    "    ########################################################\n",
    "    # The same inductive bias as above!\n",
    "        self.g = mlp(5, 1)\n",
    "        self.f = mlp(1, 1)\n",
    "\n",
    "    def forward(self, x):\n",
    "        y_i = self.g(x)[:, :, 0]\n",
    "        y = torch.sum(y_i, dim=1, keepdim=True) / y_i.shape[1]\n",
    "        z = self.f(y)\n",
    "        return z[:, 0]\n",
    "\n",
    "    ########################################################\n",
    "\n",
    "    # PyTorch Lightning bookkeeping:\n",
    "    def training_step(self, batch, batch_idx):\n",
    "        x, z = batch\n",
    "        predicted_z = self(x)\n",
    "        loss = F.mse_loss(predicted_z, z)\n",
    "        return loss\n",
    "\n",
    "    def validation_step(self, batch, batch_idx):\n",
    "        return self.training_step(batch, batch_idx)\n",
    "\n",
    "    def configure_optimizers(self):\n",
    "        self.trainer.reset_train_dataloader()\n",
    "\n",
    "        optimizer = torch.optim.Adam(self.parameters(), lr=self.max_lr)\n",
    "        scheduler = {\n",
    "            \"scheduler\": torch.optim.lr_scheduler.OneCycleLR(\n",
    "                optimizer,\n",
    "                max_lr=self.max_lr,\n",
    "                total_steps=self.total_steps,\n",
    "                final_div_factor=1e4,\n",
    "            ),\n",
    "            \"interval\": \"step\",\n",
    "        }\n",
    "        return [optimizer], [scheduler]\n",
    "Xt = torch.tensor(X).float()\n",
    "zt = torch.tensor(z).float()\n",
    "X_train, X_test, z_train, z_test = train_test_split(Xt, zt, random_state=0)\n",
    "train_set = TensorDataset(X_train, z_train)\n",
    "train = DataLoader(train_set, batch_size=128, num_workers=2)\n",
    "test_set = TensorDataset(X_test, z_test)\n",
    "test = DataLoader(test_set, batch_size=256, num_workers=2)\n",
    "pl.seed_everything(0)\n",
    "model = SumNet()\n",
    "model.total_steps = total_steps\n",
    "model.max_lr = 1e-2\n",
    "trainer = pl.Trainer(max_steps=total_steps, gpus=1, benchmark=True)\n",
    "trainer.fit(model, train_dataloaders=train, val_dataloaders=test)\n",
    "np.random.seed(0)\n",
    "idx = np.random.randint(0, 10000, size=1000)\n",
    "\n",
    "X_for_pysr = Xt[idx]\n",
    "y_i_for_pysr = model.g(X_for_pysr)[:, :, 0]\n",
    "y_for_pysr = torch.sum(y_i_for_pysr, dim=1) / y_i_for_pysr.shape[1]\n",
    "z_for_pysr = zt[idx]  # Use true values.\n",
    "\n",
    "X_for_pysr.shape, y_i_for_pysr.shape\n",
    "np.random.seed(1)\n",
    "tmpX = X_for_pysr.detach().numpy().reshape(-1, 5)\n",
    "tmpy = y_i_for_pysr.detach().numpy().reshape(-1)\n",
    "idx2 = np.random.randint(0, tmpy.shape[0], size=3000)\n",
    "\n",
    "model = PySRRegressor(\n",
    "    niterations=20,\n",
    "    binary_operators=[\"plus\", \"sub\", \"mult\"],\n",
    "    unary_operators=[\"cos\", \"square\", \"neg\"],\n",
    ")\n",
    "model.fit(X=tmpX[idx2], y=tmpy[idx2])\n",
    "\n",
    "model"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  },
  "notify_time": "0",
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {
    "height": "739px",
    "left": "73px",
    "top": "111.125px",
    "width": "306px"
   },
   "toc_section_display": true,
   "toc_window_display": true
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "0867b4392ea24b3d96cb789459e64923": {
      "model_module": "@jupyter-widgets/output",
      "model_module_version": "1.0.0",
      "model_name": "OutputModel",
      "state": {
       "layout": "IPY_MODEL_c41c74f281d8427c86eba6ee950edd05",
       "outputs": [
        {
         "data": {
          "image/png": "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\n",
          "text/plain": "<PIL.TiffImagePlugin.TiffImageFile image mode=P size=910x729>"
         },
         "metadata": {},
         "output_type": "display_data"
        }
       ]
      }
     },
     "189b855dae494614ab7a055c1a12e101": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "29174d673da64d04ba5cde9f05194281": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "62395848cd6249df97e5307c856a1ef8": {
      "model_module": "jupyter-matplotlib",
      "model_module_version": "^0.11",
      "model_name": "ToolbarModel",
      "state": {
       "_model_module_version": "^0.11",
       "_view_module_version": "^0.11",
       "collapsed": true,
       "layout": "IPY_MODEL_6cb13f8064704c439fd04681166ff696",
       "orientation": "vertical",
       "toolitems": [
        [
         "Home",
         "Reset original view",
         "home",
         "home"
        ],
        [
         "Back",
         "Back to previous view",
         "arrow-left",
         "back"
        ],
        [
         "Forward",
         "Forward to next view",
         "arrow-right",
         "forward"
        ],
        [
         "Pan",
         "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect",
         "arrows",
         "pan"
        ],
        [
         "Zoom",
         "Zoom to rectangle\nx/y fixes axis",
         "square-o",
         "zoom"
        ],
        [
         "Download",
         "Download plot",
         "floppy-o",
         "save_figure"
        ]
       ]
      }
     },
     "63edc33265d749dc836596ca799ee9ff": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "6cb13f8064704c439fd04681166ff696": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "7d12debc6b364142993a55ba94f88056": {
      "model_module": "jupyter-matplotlib",
      "model_module_version": "^0.11",
      "model_name": "ToolbarModel",
      "state": {
       "_model_module_version": "^0.11",
       "_view_module_version": "^0.11",
       "collapsed": true,
       "layout": "IPY_MODEL_63edc33265d749dc836596ca799ee9ff",
       "orientation": "vertical",
       "toolitems": [
        [
         "Home",
         "Reset original view",
         "home",
         "home"
        ],
        [
         "Back",
         "Back to previous view",
         "arrow-left",
         "back"
        ],
        [
         "Forward",
         "Forward to next view",
         "arrow-right",
         "forward"
        ],
        [
         "Pan",
         "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect",
         "arrows",
         "pan"
        ],
        [
         "Zoom",
         "Zoom to rectangle\nx/y fixes axis",
         "square-o",
         "zoom"
        ],
        [
         "Download",
         "Download plot",
         "floppy-o",
         "save_figure"
        ]
       ]
      }
     },
     "8661de7021f843ee802d77bc43575d09": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "b41b0457b21b4fbfb981fff78a9df0c3": {
      "model_module": "@jupyter-widgets/output",
      "model_module_version": "1.0.0",
      "model_name": "OutputModel",
      "state": {
       "layout": "IPY_MODEL_189b855dae494614ab7a055c1a12e101"
      }
     },
     "c41c74f281d8427c86eba6ee950edd05": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "d80fbae1f9dd401ebcc4db5fcee0329d": {
      "model_module": "jupyter-matplotlib",
      "model_module_version": "^0.11",
      "model_name": "MPLCanvasModel",
      "state": {
       "_data_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8AAAALQCAYAAABfdxm0AAAAAXNSR0IArs4c6QAAIABJREFUeF7snQd4VEXbhp8kJISWgHRBagi9NxEpIoogivAJiCIgIoIKiF1AQFAs/B8iTREUGyggXUBQpAnSixBaEkroRWJCS0j7vznrZnMg2TmbLeecPc9clxeSnfK+9zsZ5tlpARkZGRlgIgESIAESIAESIAESIAESIAESIAE/JxBAAeznEaZ7JEACJEACJEACJEACJEACJEACCgEKYHYEEiABEiABEiABEiABEiABEiABSxCgALZEmOkkCZAACZAACZAACZAACZAACZAABTD7AAmQAAmQAAmQAAmQAAmQAAmQgCUIUABbIsx0kgRIgARIgARIgARIgARIgARIgAKYfYAESIAESIAESIAESIAESIAESMASBCiALRFmOkkCJEACJEACJEACJEACJEACJEABzD5AAiRAAiRAAiRAAiRAAiRAAiRgCQIUwJYIM50kARIgARIgARIgARIgARIgARKgAGYfIAESIAESIAESIAESIAESIAESsAQBCmBLhJlOkgAJkAAJkAAJkAAJkAAJkAAJUACzD5AACZAACZAACZAACZAACZAACViCAAWwJcJMJ0mABEiABEiABEiABEiABEiABCiA2QdIgARIgARIgARIgARIgARIgAQsQYAC2BJhppMkQAIkQAIkQAIkQAIkQAIkQAIUwOwDJEACJEACJEACJEACJEACJEACliBAAWyJMNNJEiABEiABEiABEiABEiABEiABCmD2ARIgARIgARIgARIgARIgARIgAUsQoAC2RJjpJAmQAAmQAAmQAAmQAAmQAAmQAAUw+wAJkAAJkAAJkAAJkAAJkAAJkIAlCFAAWyLMdJIESIAESIAESIAESIAESIAESIACmH2ABEiABEiABEiABEiABEiABEjAEgQogC0RZjpJAiRAAiRAAiRAAiRAAiRAAiRAAcw+QAIkQAIkQAIkQAIkQAIkQAIkYAkCFMCWCDOdJAESIAESIAESIAESIAESIAESoABmHyABEiABEiABEiABEiABEiABErAEAQpgS4SZTpIACZAACZAACZAACZAACZAACVAAsw+QAAmQAAmQAAmQAAmQAAmQAAlYggAFsCXCTCdJgARIgARIgARIgARIgARIgAQogNkHSIAESIAESIAESIAESIAESIAELEGAAtgSYaaTJEACJEACJEACJEACJEACJEACFMDsAyRAAiRAAiRAAiRAAiRAAiRAApYgQAFsiTDTSRIgARIgARIgARIgARIgARIgAQpg9gESIAESIAESIAESIAESIAESIAFLEKAAtkSY6SQJkAAJkAAJkAAJkAAJkAAJkAAFMPsACZAACZAACZAACZAACZAACZCAJQhQAFsizHSSBEiABEiABEiABEiABEiABEiAAph9gARIgARIgARIgARIgARIgARIwBIEKIAtEWY6SQIkQAIkQAIkQAIkQAIkQAIkQAHMPkACJEACJEACJEACJEACJEACJGAJAhTAlggznSQBEiABEiABEiABEiABEiABEqAAZh8gARIgARIgARIgARIgARIgARKwBAEKYEuEmU6SAAmQAAmQAAmQAAmQAAmQAAlQALMPkAAJkAAJkAAJkAAJkAAJkAAJWIIABbAlwkwnSYAESIAESIAESIAESIAESIAEKIDZB0iABEiABEiABEiABEiABEiABCxBgALYEmGmkyRAAiRAAiRAAiRAAiRAAiRAAhTA7AMkQAIkQAIkQAIkQAIkQAIkQAKWIEABbIkw00kSIAESIAESIAESIAESIAESIAEKYPYBEiABEiABEiABEiABEiABEiABSxCgALZEmOkkCZAACZAACZAACZAACZAACZAABTD7AAmQAAmQAAmQAAmQAAmQAAmQgCUIUABbIsx0kgRIgARIgARIgARIgARIgARIgAKYfYAESIAESIAESIAESIAESIAESMASBCiALRFmOkkCJEACJEACJEACJEACJEACJEABzD5AAiRAAiRAAiRAAiRAAiRAAiRgCQIUwJYIM50kARIgARIgARIgARIgARIgARKgAGYfIAESIAESIAESIAESIAESIAESsAQBCmBLhJlOkgAJkAAJkAAJkAAJkAAJkAAJUACzD5AACZAACZAACZAACZAACZAACViCAAWwJcJMJ0mABEiABEiABEiABEiABEiABCiA2QdIgARIgARIgARIgARIgARIgAQsQYAC2BJhppMkQAIkQAIkQAIkQAIkQAIkQAIUwOwDJEACJEACJEACJEACJEACJEACliBAAWyJMNNJEiABEiABEiABEiABEiABEiABCmD2ARIgARIgARIgARIgARIgARIgAUsQoAC2RJjpJAmQAAmQAAmQAAmQAAmQAAmQAAUw+wAJkAAJkAAJkAAJkAAJkAAJkIAlCFAAWyLMdJIESIAESIAESIAESIAESIAESIACmH2ABEiABEiABEiABEiABEiABEjAEgQogC0RZjpJAiRAAiRAAiRAAiRAAiRAAiRAAcw+QAIkQAIkQAIkQAIkQAIkQAIkYAkCFMCWCDOdJAESIAESIAESIAESIAESIAESoABmHyABEiABEiABEiABEiABEiABErAEAQpgS4SZTpIACZAACZAACZAACZAACZAACVAAsw+QAAmQAAmQAAmQAAmQAAmQAAlYggAFsCXCTCdJgARIgARIgARIgARIgARIgAQogNkHSIAESIAESIAESIAESIAESIAELEGAAtgSYaaTJEACJEACJEACJEACJEACJEACFMAG6QMDBw7EypUrcfz48dssatmyJTZu3Kj6+bp169CqVSuDWE8zSIAESIAESIAESIAESIAESMD4BCiADRCj2bNno2fPnihfvvxtAnjTpk3o0qULihQpkmlp5cqVsXz5cgNYThNIgARIgARIgARIgARIgARIwDwEKIB1jlVUVBReeuklJCUl4ezZs7cJ4I4dO+LDDz9ErVq1dLaUzZMACZAACZAACZAACZAACZCAuQlQAOsYvytXrqBDhw6YM2cOnn76aUX8Zt0CvWfPHvTr1w8rVqxAiRIldLSUTZMACZAACZAACZAACZAACZCA+QlQAOsYwx49euC5555DmzZt0Lp169sEcLdu3TB//nzFwmbNmuGNN97AY489pqPFbJoESIAESIAESIAESIAESIAEzEuAAlin2E2cOBE3b95URK1ItwpgsSV68ODBOHfuHMQ54MuXLyv5+vbtixkzZiAwMFBqealSpXDx4kUEBwdnm1ecJWYiARIgARIgARIgARIgATMTiIuLQ4ECBZR5c3bp0UcfRWxsrGFcFHPwpUuXGsYeqxlCAaxDxDdv3owpU6YoW5/tKbsVYPtnaWlpmDlzJt58800kJCRgxIgRGDt2rNTyQoUK4dq1awgJCaEAltJiBhLwPYGMjAxcunRJabhYsWIICAjwvRFskQRIwOcETiWeQmJyYma7gQGBiLijCo7GBCE11WFOgQJA+fI+N48NGphAcvIZpKb+k2lhQEAQ8uWLgPhTmuLigKtX1dlEBxMdzeRJiFux4COOF2aX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RdiwvuYu4ZMACZAACZAACUSOAAVw5FhzJhIgARIgARsQQJmgBg0ayOTJk6VDhw5BrRj3ZREejbJAxob7xQgz9vZYUJOwMwmQAAmQAAmQQLYJUABnGx2fSAIkQAIkkBsJaNmhBw0apO75BtNQEgj3l8eOHauSTWmlnXAXGKHPKL1UrFixYIZkXxIgARIgARIggRASoAAOIUwORQIkQAIkED0CuH+LMj9mGmriGpNE4XmoeYsSSOfPn1dZjZHkCTV1zbbLly+rTNbwHiOjMzI+I0EXMkjDM+wtAZW3sZHZ2qz3+cEHH3SXOzK7TvYjARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacS+H+5YxOW8ZOtuAAAAABJRU5ErkJggg==",
       "_figure_label": "Figure 1",
       "_model_module_version": "^0.11",
       "_size": [
        640,
        480
       ],
       "_view_module_version": "^0.11",
       "layout": "IPY_MODEL_29174d673da64d04ba5cde9f05194281",
       "toolbar": "IPY_MODEL_62395848cd6249df97e5307c856a1ef8",
       "toolbar_position": "left"
      }
     },
     "e423edb07c1b4f9daafde69a51fb0d72": {
      "model_module": "jupyter-matplotlib",
      "model_module_version": "^0.11",
      "model_name": "MPLCanvasModel",
      "state": {
       "_data_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8AAAALQCAYAAABfdxm0AAAAAXNSR0IArs4c6QAAIABJREFUeF7snQd4VEXbhp8kJISWgHRBagi9NxEpIoogivAJiCIgIoIKiF1AQFAs/B8iTREUGyggXUBQpAnSixBaEkroRWJCS0j7vznrZnMg2TmbLeecPc9clxeSnfK+9zsZ5tlpARkZGRlgIgESIAESIAESIAESIAESIAESIAE/JxBAAeznEaZ7JEACJEACJEACJEACJEACJEACCgEKYHYEEiABEiABEiABEiABEiABEiABSxCgALZEmOkkCZAACZAACZAACZAACZAACZAABTD7AAmQAAmQAAmQAAmQAAmQAAmQgCUIUABbIsx0kgRIgARIgARIgARIgARIgARIgAKYfYAESIAESIAESIAESIAESIAESMASBCiALRFmOkkCJEACJEACJEACJEACJEACJEABzD5AAiRAAiRAAiRAAiRAAiRAAiRgCQIUwJYIM50kARIgARIgARIgARIgARIgARKgAGYfIAESIAESIAESIAESIAESIAESsAQBCmBLhJlOkgAJkAAJkAAJkAAJkAAJkAAJUACzD5AACZAACZAACZAACZAACZAACViCAAWwJcJMJ0mABEiABEiABEiABEiABEiABCiA2QdIgARIgARIgARIgARIgARIgAQsQYAC2BJhppMkQAIkQAIkQAIkQAIkQAIkQAIUwOwDJEACJEACJEACJEACJEACJEACliBAAWyJMNNJEiABEiABEiABEiABEiABEiABCmD2ARIgARIgARIgARIgARIgARIgAUsQoAC2RJjpJAmQAAmQAAmQAAmQAAmQAAmQAAUw+wAJkAAJkAAJkAAJkAAJkAAJkIAlCFAAWyLMdJIESIAESIAESIAESIAESIAESIACmH2ABEiABEiABEiABEiABEiABEjAEgQogC0RZjpJAiRAAiRAAiRAAiRAAiRAAiRAAcw+QAIkQAIkQAIkQAIkQAIkQAIkYAkCFMCWCDOdJAESIAESIAESIAESIAESIAESoABmHyABEiABEiABEiABEiABEiABErAEAQpgS4SZTpIACZAACZAACZAACZAACZAACVAAsw+QAAmQAAmQAAmQAAmQAAmQAAlYggAFsCXCTCdJgARIgARIgARIgARIgARIgAQogNkHSIAESIAESIAESIAESIAESIAELEGAAtgSYaaTJEACJEACJEACJEACJEACJEACFMDsAyRAAiRAAiRAAiRAAiRAAiRAApYgQAFsiTDTSRIgARIgARIgARIgARIgARIgAQpg9gESIAESIAESIAESIAESIAESIAFLEKAAtkSY6SQJkAAJkAAJkAAJkAAJkAAJkAAFMPsACZAACZAACZAACZAACZAACZCAJQhQAFsizHSSBEiABEiABEiABEiABEiABEiAAph9gARIgARIgARIgARIgARIgARIwBIEKIAtEWY6SQIkQAIkQAIkQAIkQAIkQAIkQAHMPkACJEACJEACJEACJEACJEACJGAJAhTAlggznSQBEiABEiABEiABEiABEiABEqAAZh8gARIgARIgARIgARIgARIgARKwBAEKYEuEmU6SAAmQAAmQAAmQAAmQAAmQAAlQALMPkAAJkAAJkAAJkAAJkAAJkAAJWIIABbAlwkwnSYAESIAESIAESIAESIAESIAEKIDZB0iABEiABEiABEiABEiABEiABCxBgALYEmGmkyRAAiRAAiRAAiRAAiRAAiRAAhTA7AMkQAIkQAIkQAIkQAIkQAIkQAKWIEABbIkw00kSIAESIAESIAESIAESIAESIAEKYPYBEiABEiABEiABEiABEiABEiABSxCgALZEmOkkCZAACZAACZAACZAACZAACZAABTD7AAmQAAmQAAmQAAmQAAmQAAmQgCUIUABbIsx0kgRIgARIgARIgARIgARIgARIgAKYfYAESIAESIAESIAESIAESIAESMASBCiALRFmOkkCJEACJEACJEACJEACJEACJEABzD5AAiRAAiRAAiRAAiRAAiRAAiRgCQIUwJYIM50kARIgARIgARIgARIgARIgARKgAGYfIAESIAESIAESIAESIAESIAESsAQBCmBLhJlOkgAJkAAJkAAJkAAJkAAJkAAJUACzD5AACZAACZAACZAACZAACZAACViCAAWwJcJMJ0mABEiABEiABEiABEiABEiABCiA2QdIgARIgARIgARIgARIgARIgAQsQYAC2BJhppMkQAIkQAIkQAIkQAIkQAIkQAIUwOwDJEACJEACJEACJEACJEACJEACliBAAWyJMNNJEiABEiABEiABEiABEiABEiABCmD2ARIgARIgARIgARIgARIgARIgAUsQoAC2RJjpJAmQAAmQAAmQAAmQAAmQAAmQAAUw+wAJkAAJkAAJkAAJkAAJkAAJkIAlCFAAWyLMdJIESIAESIAESIAESIAESIAESIACmH2ABEiABEiABEiABEiABEiABEjAEgQogC0RZjpJAiRAAiRAAiRAAiRAAiRAAiRAAcw+QAIkQAIkQAIkQAIkQAIkQAIkYAkCFMCWCDOdJAESIAESIAESIAESIAESIAESoABmHyABEiABEiABEiABEiABEiABErAEAQpgS4SZTpIACZAACZAACZAACZAACZAACVAAsw+QAAmQAAmQAAmQAAmQAAmQAAlYggAFsCXCTCdJgARIgARIgARIgARIgARIgAQogNkHSIAESIAESIAESIAESIAESIAELEGAAtgSYaaTJEACJEACJEACJEACJEACJEACFMAG6QMDBw7EypUrcfz48dssatmyJTZu3Kj6+bp169CqVSuDWE8zSIAESIAESIAESIAESIAESMD4BCiADRCj2bNno2fPnihfvvxtAnjTpk3o0qULihQpkmlp5cqVsXz5cgNYThNIgARIgARIgARIgARIgARIwDwEKIB1jlVUVBReeuklJCUl4ezZs7cJ4I4dO+LDDz9ErVq1dLaUzZMACZAACZAACZAACZAACZCAuQlQAOsYvytXrqBDhw6YM2cOnn76aUX8Zt0CvWfPHvTr1w8rVqxAiRIldLSUTZMACZAACZAACZAACZAACZCA+QlQAOsYwx49euC5555DmzZt0Lp169sEcLdu3TB//nzFwmbNmuGNN97AY489pqPFbJoESIAESIAESIAESIAESIAEzEuAAlin2E2cOBE3b95URK1ItwpgsSV68ODBOHfuHMQ54MuXLyv5+vbtixkzZiAwMFBqealSpXDx4kUEBwdnm1ecJWYiARIgARIgARIgARIgATMTiIuLQ4ECBZR5c3bp0UcfRWxsrGFcFHPwpUuXGsYeqxlCAaxDxDdv3owpU6YoW5/tKbsVYPtnaWlpmDlzJt58800kJCRgxIgRGDt2rNTyQoUK4dq1awgJCaEAltJiBhLwPYGMjAxcunRJabhYsWIICAjwvRFskQRIwOcETiWeQmJyYma7gQGBiLijCo7GBCE11WFOgQJA+fI+N48NGphAcvIZpKb+k2lhQEAQ8uWLgPhTmuLigKtX1dlEBxMdzeRJiFux4COOF2aX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RdiwvuYu4ZMACZAACZAACUSOAAVw5FhzJhIgARIgARsQQJmgBg0ayOTJk6VDhw5BrRj3ZREejbJAxob7xQgz9vZYUJOwMwmQAAmQAAmQQLYJUABnGx2fSAIkQAIkkBsJaNmhBw0apO75BtNQEgj3l8eOHauSTWmlnXAXGKHPKL1UrFixYIZkXxIgARIgARIggRASoAAOIUwORQIkQAIkED0CuH+LMj9mGmriGpNE4XmoeYsSSOfPn1dZjZHkCTV1zbbLly+rTNbwHiOjMzI+I0EXMkjDM+wtAZW3sZHZ2qz3+cEHH3SXOzK7TvYjARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacSoAB2quW5bxIgARIgARIgARIgARIgARJwGAEKYIcZnNslARIgARIgARIgARIgARIgAacS+H+5YxOW8ZOtuAAAAABJRU5ErkJggg==",
       "_figure_label": "Figure 2",
       "_model_module_version": "^0.11",
       "_size": [
        640,
        480
       ],
       "_view_module_version": "^0.11",
       "layout": "IPY_MODEL_8661de7021f843ee802d77bc43575d09",
       "toolbar": "IPY_MODEL_7d12debc6b364142993a55ba94f88056",
       "toolbar_position": "left"
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
